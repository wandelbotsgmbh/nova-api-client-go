// Package v2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package v2

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AbbControllerKind.
const (
	AbbControllerKindAbbController AbbControllerKind = "AbbController"
)

// Defines values for Behavior.
const (
	BEHAVIORAUTOMATIC                       Behavior = "BEHAVIOR_AUTOMATIC"
	BEHAVIORAUTOMATICNOTCOMPLYWITHCYCLETIME Behavior = "BEHAVIOR_AUTOMATIC_NOT_COMPLY_WITH_CYCLETIME"
	BEHAVIOREXTERNALSOURCE                  Behavior = "BEHAVIOR_EXTERNAL_SOURCE"
)

// Defines values for BooleanValueValueType.
const (
	BooleanValueValueTypeBoolean BooleanValueValueType = "boolean"
)

// Defines values for BoxBoxType.
const (
	FULL   BoxBoxType = "FULL"
	HOLLOW BoxBoxType = "HOLLOW"
)

// Defines values for BusIOProfinetBusType.
const (
	Profinet BusIOProfinetBusType = "profinet"
)

// Defines values for BusIOProfinetVirtualBusType.
const (
	VirtualProfinet BusIOProfinetVirtualBusType = "virtual_profinet"
)

// Defines values for BusIOsStateEnum.
const (
	BUSIOSSTATECONNECTED    BusIOsStateEnum = "BUS_IOS_STATE_CONNECTED"
	BUSIOSSTATEDISCONNECTED BusIOsStateEnum = "BUS_IOS_STATE_DISCONNECTED"
	BUSIOSSTATEINITIALIZING BusIOsStateEnum = "BUS_IOS_STATE_INITIALIZING"
	BUSIOSSTATEUNKNOWN      BusIOsStateEnum = "BUS_IOS_STATE_UNKNOWN"
)

// Defines values for Comparator.
const (
	COMPARATOREQUALS       Comparator = "COMPARATOR_EQUALS"
	COMPARATORGREATER      Comparator = "COMPARATOR_GREATER"
	COMPARATORGREATEREQUAL Comparator = "COMPARATOR_GREATER_EQUAL"
	COMPARATORLESS         Comparator = "COMPARATOR_LESS"
	COMPARATORLESSEQUAL    Comparator = "COMPARATOR_LESS_EQUAL"
	COMPARATORNOTEQUALS    Comparator = "COMPARATOR_NOT_EQUALS"
)

// Defines values for ConfigurationArchiveStatusCreatingStatus.
const (
	Creating ConfigurationArchiveStatusCreatingStatus = "creating"
)

// Defines values for ConfigurationArchiveStatusErrorStatus.
const (
	ConfigurationArchiveStatusErrorStatusError ConfigurationArchiveStatusErrorStatus = "error"
)

// Defines values for ConfigurationArchiveStatusSuccessStatus.
const (
	Success ConfigurationArchiveStatusSuccessStatus = "success"
)

// Defines values for Direction.
const (
	DIRECTIONBACKWARD Direction = "DIRECTION_BACKWARD"
	DIRECTIONFORWARD  Direction = "DIRECTION_FORWARD"
)

// Defines values for FanucControllerKind.
const (
	FanucControllerKindFanucController FanucControllerKind = "FanucController"
)

// Defines values for FloatValueValueType.
const (
	FloatValueValueTypeFloat FloatValueValueType = "float"
)

// Defines values for IOBooleanValueValueType.
const (
	IOBooleanValueValueTypeBoolean IOBooleanValueValueType = "boolean"
)

// Defines values for IODirection.
const (
	IOTYPEINPUT  IODirection = "IO_TYPE_INPUT"
	IOTYPEOUTPUT IODirection = "IO_TYPE_OUTPUT"
)

// Defines values for IOFloatValueValueType.
const (
	IOFloatValueValueTypeFloat IOFloatValueValueType = "float"
)

// Defines values for IOIntegerValueValueType.
const (
	IOIntegerValueValueTypeInteger IOIntegerValueValueType = "integer"
)

// Defines values for IOValueType.
const (
	IOVALUEANALOGFLOAT   IOValueType = "IO_VALUE_ANALOG_FLOAT"
	IOVALUEANALOGINTEGER IOValueType = "IO_VALUE_ANALOG_INTEGER"
	IOVALUEBOOLEAN       IOValueType = "IO_VALUE_BOOLEAN"
)

// Defines values for InitializeJoggingRequestMessageType.
const (
	InitializeJoggingRequestMessageTypeInitializeJoggingRequest InitializeJoggingRequestMessageType = "InitializeJoggingRequest"
)

// Defines values for InitializeJoggingResponseKind.
const (
	InitializeJoggingResponseKindINITIALIZERECEIVED InitializeJoggingResponseKind = "INITIALIZE_RECEIVED"
)

// Defines values for InitializeMovementRequestMessageType.
const (
	InitializeMovementRequestMessageTypeInitializeMovementRequest InitializeMovementRequestMessageType = "InitializeMovementRequest"
)

// Defines values for InitializeMovementResponseKind.
const (
	InitializeMovementResponseKindINITIALIZERECEIVED InitializeMovementResponseKind = "INITIALIZE_RECEIVED"
)

// Defines values for IntegerValueValueType.
const (
	IntegerValueValueTypeInteger IntegerValueValueType = "integer"
)

// Defines values for JoggingDetailsKind.
const (
	JOGGING JoggingDetailsKind = "JOGGING"
)

// Defines values for JoggingPausedByUserKind.
const (
	JoggingPausedByUserKindPAUSEDBYUSER JoggingPausedByUserKind = "PAUSED_BY_USER"
)

// Defines values for JoggingPausedNearCollisionKind.
const (
	PAUSEDNEARCOLLISION JoggingPausedNearCollisionKind = "PAUSED_NEAR_COLLISION"
)

// Defines values for JoggingPausedNearJointLimitKind.
const (
	PAUSEDNEARJOINTLIMIT JoggingPausedNearJointLimitKind = "PAUSED_NEAR_JOINT_LIMIT"
)

// Defines values for JoggingPausedOnIOKind.
const (
	JoggingPausedOnIOKindPAUSEDONIO JoggingPausedOnIOKind = "PAUSED_ON_IO"
)

// Defines values for JoggingRunningKind.
const (
	JoggingRunningKindRUNNING JoggingRunningKind = "RUNNING"
)

// Defines values for JointVelocityRequestMessageType.
const (
	JointVelocityRequestMessageTypeJointVelocityRequest JointVelocityRequestMessageType = "JointVelocityRequest"
)

// Defines values for JointVelocityResponseKind.
const (
	JOINTVELOCITYRECEIVED JointVelocityResponseKind = "JOINT_VELOCITY_RECEIVED"
)

// Defines values for KukaControllerKind.
const (
	KukaControllerKindKukaController KukaControllerKind = "KukaController"
)

// Defines values for LicenseStatusEnum.
const (
	EXPIRED         LicenseStatusEnum = "EXPIRED"
	GRACEPERIODOVER LicenseStatusEnum = "GRACE_PERIOD_OVER"
	NOTFOUND        LicenseStatusEnum = "NOT_FOUND"
	OK              LicenseStatusEnum = "OK"
	SUSPENDED       LicenseStatusEnum = "SUSPENDED"
)

// Defines values for Manufacturer.
const (
	Abb             Manufacturer = "abb"
	Fanuc           Manufacturer = "fanuc"
	Kuka            Manufacturer = "kuka"
	Universalrobots Manufacturer = "universalrobots"
	Yaskawa         Manufacturer = "yaskawa"
)

// Defines values for MovementErrorResponseKind.
const (
	MOTIONERROR MovementErrorResponseKind = "MOTION_ERROR"
)

// Defines values for OperatingState.
const (
	ACTIVE   OperatingState = "ACTIVE"
	INACTIVE OperatingState = "INACTIVE"
)

// Defines values for OperationMode.
const (
	OPERATIONMODEAUTO         OperationMode = "OPERATION_MODE_AUTO"
	OPERATIONMODEDISCONNECTED OperationMode = "OPERATION_MODE_DISCONNECTED"
	OPERATIONMODEMANUAL       OperationMode = "OPERATION_MODE_MANUAL"
	OPERATIONMODEMANUALT1     OperationMode = "OPERATION_MODE_MANUAL_T1"
	OPERATIONMODEMANUALT2     OperationMode = "OPERATION_MODE_MANUAL_T2"
	OPERATIONMODENOCONTROLLER OperationMode = "OPERATION_MODE_NO_CONTROLLER"
	OPERATIONMODEPENDING      OperationMode = "OPERATION_MODE_PENDING"
	OPERATIONMODEPOWERON      OperationMode = "OPERATION_MODE_POWER_ON"
	OPERATIONMODERECOVERY     OperationMode = "OPERATION_MODE_RECOVERY"
	OPERATIONMODEUNKNOWN      OperationMode = "OPERATION_MODE_UNKNOWN"
)

// Defines values for OrientationType.
const (
	EULERANGLESEXTRINSICXYX OrientationType = "EULER_ANGLES_EXTRINSIC_XYX"
	EULERANGLESEXTRINSICXYZ OrientationType = "EULER_ANGLES_EXTRINSIC_XYZ"
	EULERANGLESEXTRINSICXZX OrientationType = "EULER_ANGLES_EXTRINSIC_XZX"
	EULERANGLESEXTRINSICXZY OrientationType = "EULER_ANGLES_EXTRINSIC_XZY"
	EULERANGLESEXTRINSICYXY OrientationType = "EULER_ANGLES_EXTRINSIC_YXY"
	EULERANGLESEXTRINSICYXZ OrientationType = "EULER_ANGLES_EXTRINSIC_YXZ"
	EULERANGLESEXTRINSICYZX OrientationType = "EULER_ANGLES_EXTRINSIC_YZX"
	EULERANGLESEXTRINSICYZY OrientationType = "EULER_ANGLES_EXTRINSIC_YZY"
	EULERANGLESEXTRINSICZXY OrientationType = "EULER_ANGLES_EXTRINSIC_ZXY"
	EULERANGLESEXTRINSICZXZ OrientationType = "EULER_ANGLES_EXTRINSIC_ZXZ"
	EULERANGLESEXTRINSICZYX OrientationType = "EULER_ANGLES_EXTRINSIC_ZYX"
	EULERANGLESEXTRINSICZYZ OrientationType = "EULER_ANGLES_EXTRINSIC_ZYZ"
	EULERANGLESINTRINSICXYX OrientationType = "EULER_ANGLES_INTRINSIC_XYX"
	EULERANGLESINTRINSICXYZ OrientationType = "EULER_ANGLES_INTRINSIC_XYZ"
	EULERANGLESINTRINSICXZX OrientationType = "EULER_ANGLES_INTRINSIC_XZX"
	EULERANGLESINTRINSICXZY OrientationType = "EULER_ANGLES_INTRINSIC_XZY"
	EULERANGLESINTRINSICYXY OrientationType = "EULER_ANGLES_INTRINSIC_YXY"
	EULERANGLESINTRINSICYXZ OrientationType = "EULER_ANGLES_INTRINSIC_YXZ"
	EULERANGLESINTRINSICYZX OrientationType = "EULER_ANGLES_INTRINSIC_YZX"
	EULERANGLESINTRINSICYZY OrientationType = "EULER_ANGLES_INTRINSIC_YZY"
	EULERANGLESINTRINSICZXY OrientationType = "EULER_ANGLES_INTRINSIC_ZXY"
	EULERANGLESINTRINSICZXZ OrientationType = "EULER_ANGLES_INTRINSIC_ZXZ"
	EULERANGLESINTRINSICZYX OrientationType = "EULER_ANGLES_INTRINSIC_ZYX"
	EULERANGLESINTRINSICZYZ OrientationType = "EULER_ANGLES_INTRINSIC_ZYZ"
	QUATERNION              OrientationType = "QUATERNION"
	ROTATIONVECTOR          OrientationType = "ROTATION_VECTOR"
)

// Defines values for PauseJoggingRequestMessageType.
const (
	PauseJoggingRequestMessageTypePauseJoggingRequest PauseJoggingRequestMessageType = "PauseJoggingRequest"
)

// Defines values for PauseJoggingResponseKind.
const (
	PauseJoggingResponseKindPAUSERECEIVED PauseJoggingResponseKind = "PAUSE_RECEIVED"
)

// Defines values for PauseMovementRequestMessageType.
const (
	PauseMovementRequestMessageTypePauseMovementRequest PauseMovementRequestMessageType = "PauseMovementRequest"
)

// Defines values for PauseMovementResponseKind.
const (
	PauseMovementResponseKindPAUSERECEIVED PauseMovementResponseKind = "PAUSE_RECEIVED"
)

// Defines values for PlaybackSpeedRequestMessageType.
const (
	PlaybackSpeedRequestMessageTypePlaybackSpeedRequest PlaybackSpeedRequestMessageType = "PlaybackSpeedRequest"
)

// Defines values for PlaybackSpeedResponseKind.
const (
	PLAYBACKSPEEDRECEIVED PlaybackSpeedResponseKind = "PLAYBACK_SPEED_RECEIVED"
)

// Defines values for ProfinetIODirection.
const (
	PROFINETIODIRECTIONINOUT  ProfinetIODirection = "PROFINET_IO_DIRECTION_INOUT"
	PROFINETIODIRECTIONINPUT  ProfinetIODirection = "PROFINET_IO_DIRECTION_INPUT"
	PROFINETIODIRECTIONOUTPUT ProfinetIODirection = "PROFINET_IO_DIRECTION_OUTPUT"
)

// Defines values for ProfinetIOTypeEnum.
const (
	PROFINETIOTYPEBOOL    ProfinetIOTypeEnum = "PROFINET_IO_TYPE_BOOL"
	PROFINETIOTYPEDINT    ProfinetIOTypeEnum = "PROFINET_IO_TYPE_DINT"
	PROFINETIOTYPEINT     ProfinetIOTypeEnum = "PROFINET_IO_TYPE_INT"
	PROFINETIOTYPELREAL   ProfinetIOTypeEnum = "PROFINET_IO_TYPE_LREAL"
	PROFINETIOTYPEREAL    ProfinetIOTypeEnum = "PROFINET_IO_TYPE_REAL"
	PROFINETIOTYPESINT    ProfinetIOTypeEnum = "PROFINET_IO_TYPE_SINT"
	PROFINETIOTYPEUDINT   ProfinetIOTypeEnum = "PROFINET_IO_TYPE_UDINT"
	PROFINETIOTYPEUINT    ProfinetIOTypeEnum = "PROFINET_IO_TYPE_UINT"
	PROFINETIOTYPEUNKNOWN ProfinetIOTypeEnum = "PROFINET_IO_TYPE_UNKNOWN"
	PROFINETIOTYPEUSINT   ProfinetIOTypeEnum = "PROFINET_IO_TYPE_USINT"
)

// Defines values for ReleaseChannel.
const (
	Next   ReleaseChannel = "next"
	Stable ReleaseChannel = "stable"
)

// Defines values for RobotSystemMode.
const (
	MODECONTROL                 RobotSystemMode = "MODE_CONTROL"
	MODECONTROLLERNOTCONFIGURED RobotSystemMode = "MODE_CONTROLLER_NOT_CONFIGURED"
	MODEFREEDRIVE               RobotSystemMode = "MODE_FREE_DRIVE"
	MODEINITIALIZING            RobotSystemMode = "MODE_INITIALIZING"
	MODEMONITOR                 RobotSystemMode = "MODE_MONITOR"
)

// Defines values for SafetyStateType.
const (
	SAFETYSTATECONFIRMSAFETY       SafetyStateType = "SAFETY_STATE_CONFIRM_SAFETY"
	SAFETYSTATEDEVICEEMERGENCYSTOP SafetyStateType = "SAFETY_STATE_DEVICE_EMERGENCY_STOP"
	SAFETYSTATEFAULT               SafetyStateType = "SAFETY_STATE_FAULT"
	SAFETYSTATEMASTERING           SafetyStateType = "SAFETY_STATE_MASTERING"
	SAFETYSTATENORMAL              SafetyStateType = "SAFETY_STATE_NORMAL"
	SAFETYSTATEOPERATORSAFETY      SafetyStateType = "SAFETY_STATE_OPERATOR_SAFETY"
	SAFETYSTATEPROTECTIVESTOP      SafetyStateType = "SAFETY_STATE_PROTECTIVE_STOP"
	SAFETYSTATERECOVERY            SafetyStateType = "SAFETY_STATE_RECOVERY"
	SAFETYSTATEREDUCED             SafetyStateType = "SAFETY_STATE_REDUCED"
	SAFETYSTATEROBOTEMERGENCYSTOP  SafetyStateType = "SAFETY_STATE_ROBOT_EMERGENCY_STOP"
	SAFETYSTATESTOP                SafetyStateType = "SAFETY_STATE_STOP"
	SAFETYSTATESTOP0               SafetyStateType = "SAFETY_STATE_STOP_0"
	SAFETYSTATESTOP1               SafetyStateType = "SAFETY_STATE_STOP_1"
	SAFETYSTATESTOP2               SafetyStateType = "SAFETY_STATE_STOP_2"
	SAFETYSTATEUNKNOWN             SafetyStateType = "SAFETY_STATE_UNKNOWN"
	SAFETYSTATEVIOLATION           SafetyStateType = "SAFETY_STATE_VIOLATION"
)

// Defines values for ServiceGroup.
const (
	ServiceGroupApp             ServiceGroup = "App"
	ServiceGroupCellService     ServiceGroup = "CellService"
	ServiceGroupRobotController ServiceGroup = "RobotController"
	ServiceGroupSystemService   ServiceGroup = "SystemService"
)

// Defines values for ServiceStatusPhase.
const (
	ServiceStatusPhaseCompleted         ServiceStatusPhase = "Completed"
	ServiceStatusPhaseContainerCreating ServiceStatusPhase = "ContainerCreating"
	ServiceStatusPhaseCrashLoopBackOff  ServiceStatusPhase = "CrashLoopBackOff"
	ServiceStatusPhaseError             ServiceStatusPhase = "Error"
	ServiceStatusPhaseEvicted           ServiceStatusPhase = "Evicted"
	ServiceStatusPhaseImagePullBackOff  ServiceStatusPhase = "ImagePullBackOff"
	ServiceStatusPhaseInitialized       ServiceStatusPhase = "Initialized"
	ServiceStatusPhaseNoReady           ServiceStatusPhase = "NoReady"
	ServiceStatusPhaseOOMKilled         ServiceStatusPhase = "OOMKilled"
	ServiceStatusPhasePending           ServiceStatusPhase = "Pending"
	ServiceStatusPhasePodInitializing   ServiceStatusPhase = "PodInitializing"
	ServiceStatusPhaseRunning           ServiceStatusPhase = "Running"
	ServiceStatusPhaseTerminating       ServiceStatusPhase = "Terminating"
	ServiceStatusPhaseUnknown           ServiceStatusPhase = "Unknown"
)

// Defines values for ServiceStatusSeverity.
const (
	ERROR   ServiceStatusSeverity = "ERROR"
	INFO    ServiceStatusSeverity = "INFO"
	WARNING ServiceStatusSeverity = "WARNING"
)

// Defines values for SettableRobotSystemMode.
const (
	ROBOTSYSTEMMODECONTROL SettableRobotSystemMode = "ROBOT_SYSTEM_MODE_CONTROL"
	ROBOTSYSTEMMODEMONITOR SettableRobotSystemMode = "ROBOT_SYSTEM_MODE_MONITOR"
)

// Defines values for SingularityTypeEnum.
const (
	ELBOW    SingularityTypeEnum = "ELBOW"
	SHOULDER SingularityTypeEnum = "SHOULDER"
	WRIST    SingularityTypeEnum = "WRIST"
)

// Defines values for StartMovementRequestMessageType.
const (
	StartMovementRequestMessageTypeStartMovementRequest StartMovementRequestMessageType = "StartMovementRequest"
)

// Defines values for StartMovementResponseKind.
const (
	STARTRECEIVED StartMovementResponseKind = "START_RECEIVED"
)

// Defines values for TcpVelocityRequestMessageType.
const (
	TcpVelocityRequestMessageTypeTcpVelocityRequest TcpVelocityRequestMessageType = "TcpVelocityRequest"
)

// Defines values for TcpVelocityResponseKind.
const (
	TCPVELOCITYRECEIVED TcpVelocityResponseKind = "TCP_VELOCITY_RECEIVED"
)

// Defines values for TrajectoryDataMessageType.
const (
	TrajectoryDataMessageTypeTrajectoryData TrajectoryDataMessageType = "TrajectoryData"
)

// Defines values for TrajectoryDetailsKind.
const (
	TRAJECTORY TrajectoryDetailsKind = "TRAJECTORY"
)

// Defines values for TrajectoryEndedKind.
const (
	ENDOFTRAJECTORY TrajectoryEndedKind = "END_OF_TRAJECTORY"
)

// Defines values for TrajectoryPausedByUserKind.
const (
	TrajectoryPausedByUserKindPAUSEDBYUSER TrajectoryPausedByUserKind = "PAUSED_BY_USER"
)

// Defines values for TrajectoryPausedOnIOKind.
const (
	TrajectoryPausedOnIOKindPAUSEDONIO TrajectoryPausedOnIOKind = "PAUSED_ON_IO"
)

// Defines values for TrajectoryRunningKind.
const (
	TrajectoryRunningKindRUNNING TrajectoryRunningKind = "RUNNING"
)

// Defines values for TrajectoryWaitForIOKind.
const (
	WAITFORIO TrajectoryWaitForIOKind = "WAIT_FOR_IO"
)

// Defines values for UnitType.
const (
	UNITAMPERE      UnitType = "UNIT_AMPERE"
	UNITCELSIUS     UnitType = "UNIT_CELSIUS"
	UNITHERTZ       UnitType = "UNIT_HERTZ"
	UNITKELVIN      UnitType = "UNIT_KELVIN"
	UNITKILOGRAM    UnitType = "UNIT_KILOGRAM"
	UNITMETER       UnitType = "UNIT_METER"
	UNITNEWTON      UnitType = "UNIT_NEWTON"
	UNITNEWTONMETER UnitType = "UNIT_NEWTON_METER"
	UNITNONE        UnitType = "UNIT_NONE"
	UNITVOLT        UnitType = "UNIT_VOLT"
)

// Defines values for UniversalrobotsControllerKind.
const (
	UniversalrobotsControllerKindUniversalrobotsController UniversalrobotsControllerKind = "UniversalrobotsController"
)

// Defines values for VirtualControllerKind.
const (
	VirtualControllerKindVirtualController VirtualControllerKind = "VirtualController"
)

// Defines values for VirtualControllerTypes.
const (
	AbbIrb101003715       VirtualControllerTypes = "abb-irb1010_037_15"
	AbbIrb110004754       VirtualControllerTypes = "abb-irb1100_0475_4"
	AbbIrb11000584        VirtualControllerTypes = "abb-irb1100_058_4"
	AbbIrb12007           VirtualControllerTypes = "abb-irb1200_7"
	AbbIrb13000911        VirtualControllerTypes = "abb-irb1300_09_11"
	AbbIrb130011510       VirtualControllerTypes = "abb-irb1300_115_10"
	AbbIrb13001412        VirtualControllerTypes = "abb-irb1300_14_12"
	AbbIrb1300147         VirtualControllerTypes = "abb-irb1300_14_7"
	AbbIrb16001210        VirtualControllerTypes = "abb-irb1600_12_10"
	AbbIrb1600126         VirtualControllerTypes = "abb-irb1600_12_6"
	AbbIrb160014510       VirtualControllerTypes = "abb-irb1600_145_10"
	AbbIrb16001456        VirtualControllerTypes = "abb-irb1600_145_6"
	AbbIrb260016512       VirtualControllerTypes = "abb-irb2600_165_12"
	AbbIrb260016520       VirtualControllerTypes = "abb-irb2600_165_20"
	AbbIrb260018512       VirtualControllerTypes = "abb-irb2600_185_12"
	AbbIrb2600ID18515     VirtualControllerTypes = "abb-irb2600ID_185_15"
	AbbIrb2600ID2008      VirtualControllerTypes = "abb-irb2600ID_200_8"
	AbbIrb460020545       VirtualControllerTypes = "abb-irb4600_205_45"
	AbbIrb460020560       VirtualControllerTypes = "abb-irb4600_205_60"
	AbbIrb460025020       VirtualControllerTypes = "abb-irb4600_250_20"
	AbbIrb460025540       VirtualControllerTypes = "abb-irb4600_255_40"
	FanucArcMate100iD     VirtualControllerTypes = "fanuc-arc_mate_100iD"
	FanucArcMate100iD16S  VirtualControllerTypes = "fanuc-arc_mate_100iD16S"
	FanucArcMate120iD     VirtualControllerTypes = "fanuc-arc_mate_120iD"
	FanucArcMate120iD12L  VirtualControllerTypes = "fanuc-arc_mate_120iD12L"
	FanucArcMate120iD35   VirtualControllerTypes = "fanuc-arc_mate_120iD35"
	FanucCr35ib           VirtualControllerTypes = "fanuc-cr35ib"
	FanucCr7ia            VirtualControllerTypes = "fanuc-cr7ia"
	FanucCr7ial           VirtualControllerTypes = "fanuc-cr7ial"
	FanucCrx10ia          VirtualControllerTypes = "fanuc-crx10ia"
	FanucCrx10ial         VirtualControllerTypes = "fanuc-crx10ial"
	FanucCrx20ial         VirtualControllerTypes = "fanuc-crx20ial"
	FanucCrx25ia          VirtualControllerTypes = "fanuc-crx25ia"
	FanucCrx30ia          VirtualControllerTypes = "fanuc-crx30ia"
	FanucCrx5ia           VirtualControllerTypes = "fanuc-crx5ia"
	FanucLrMate200iD      VirtualControllerTypes = "fanuc-lr_mate_200iD"
	FanucLrMate200iD4S    VirtualControllerTypes = "fanuc-lr_mate_200iD4S"
	FanucLrMate200iD7L    VirtualControllerTypes = "fanuc-lr_mate_200iD7L"
	FanucM10iD12          VirtualControllerTypes = "fanuc-m10iD12"
	FanucM10iD16S         VirtualControllerTypes = "fanuc-m10iD16S"
	FanucM20iD25          VirtualControllerTypes = "fanuc-m20iD25"
	FanucM20iD35          VirtualControllerTypes = "fanuc-m20iD35"
	FanucM710iC20L        VirtualControllerTypes = "fanuc-m710iC20L"
	FanucM900iB280L       VirtualControllerTypes = "fanuc-m900iB280L"
	FanucM900iB360E       VirtualControllerTypes = "fanuc-m900iB360E"
	FanucR2000ic125l      VirtualControllerTypes = "fanuc-r2000ic125l"
	FanucR2000ic210f      VirtualControllerTypes = "fanuc-r2000ic210f"
	KukaKr10R1100         VirtualControllerTypes = "kuka-kr10_r1100"
	KukaKr10R11002        VirtualControllerTypes = "kuka-kr10_r1100_2"
	KukaKr10R900          VirtualControllerTypes = "kuka-kr10_r900"
	KukaKr10R9002         VirtualControllerTypes = "kuka-kr10_r900_2"
	KukaKr120R27002       VirtualControllerTypes = "kuka-kr120_r2700_2"
	KukaKr12R18102        VirtualControllerTypes = "kuka-kr12_r1810_2"
	KukaKr150R2           VirtualControllerTypes = "kuka-kr150_r2"
	KukaKr16R16102        VirtualControllerTypes = "kuka-kr16_r1610_2"
	KukaKr16R20102        VirtualControllerTypes = "kuka-kr16_r2010_2"
	KukaKr20R1810         VirtualControllerTypes = "kuka-kr20_r1810"
	KukaKr20R18102        VirtualControllerTypes = "kuka-kr20_r1810_2"
	KukaKr210R27002       VirtualControllerTypes = "kuka-kr210_r2700_2"
	KukaKr210R31002       VirtualControllerTypes = "kuka-kr210_r3100_2"
	KukaKr210R33002       VirtualControllerTypes = "kuka-kr210_r3300_2"
	KukaKr240R2700        VirtualControllerTypes = "kuka-kr240_r2700"
	KukaKr250R27002       VirtualControllerTypes = "kuka-kr250_r2700_2"
	KukaKr30R2100         VirtualControllerTypes = "kuka-kr30_r2100"
	KukaKr30R3            VirtualControllerTypes = "kuka-kr30_r3"
	KukaKr360L2403        VirtualControllerTypes = "kuka-kr360_l240_3"
	KukaKr3R540           VirtualControllerTypes = "kuka-kr3_r540"
	KukaKr4R600           VirtualControllerTypes = "kuka-kr4_r600"
	KukaKr500L3403        VirtualControllerTypes = "kuka-kr500_l340_3"
	KukaKr50R2500         VirtualControllerTypes = "kuka-kr50_r2500"
	KukaKr6R1820          VirtualControllerTypes = "kuka-kr6_r1820"
	KukaKr6R7002          VirtualControllerTypes = "kuka-kr6_r700_2"
	KukaKr6R700Sixx       VirtualControllerTypes = "kuka-kr6_r700_sixx"
	KukaKr6R900           VirtualControllerTypes = "kuka-kr6_r900"
	KukaKr6R9002          VirtualControllerTypes = "kuka-kr6_r900_2"
	KukaLbrIisy11R1300    VirtualControllerTypes = "kuka-lbr_iisy_11_r1300"
	UniversalrobotsUr10cb VirtualControllerTypes = "universalrobots-ur10cb"
	UniversalrobotsUr10e  VirtualControllerTypes = "universalrobots-ur10e"
	UniversalrobotsUr16e  VirtualControllerTypes = "universalrobots-ur16e"
	UniversalrobotsUr20e  VirtualControllerTypes = "universalrobots-ur20e"
	UniversalrobotsUr3e   VirtualControllerTypes = "universalrobots-ur3e"
	UniversalrobotsUr5cb  VirtualControllerTypes = "universalrobots-ur5cb"
	UniversalrobotsUr5e   VirtualControllerTypes = "universalrobots-ur5e"
	YaskawaAr1440         VirtualControllerTypes = "yaskawa-ar1440"
	YaskawaAr1730         VirtualControllerTypes = "yaskawa-ar1730"
	YaskawaAr2010         VirtualControllerTypes = "yaskawa-ar2010"
	YaskawaAr3120         VirtualControllerTypes = "yaskawa-ar3120"
	YaskawaAr700          VirtualControllerTypes = "yaskawa-ar700"
	YaskawaAr900          VirtualControllerTypes = "yaskawa-ar900"
	YaskawaGp110          VirtualControllerTypes = "yaskawa-gp110"
	YaskawaGp12           VirtualControllerTypes = "yaskawa-gp12"
	YaskawaGp180          VirtualControllerTypes = "yaskawa-gp180"
	YaskawaGp180120       VirtualControllerTypes = "yaskawa-gp180-120"
	YaskawaGp20hl         VirtualControllerTypes = "yaskawa-gp20hl"
	YaskawaGp215          VirtualControllerTypes = "yaskawa-gp215"
	YaskawaGp225          VirtualControllerTypes = "yaskawa-gp225"
	YaskawaGp25           VirtualControllerTypes = "yaskawa-gp25"
	YaskawaGp250          VirtualControllerTypes = "yaskawa-gp250"
	YaskawaGp2512         VirtualControllerTypes = "yaskawa-gp25_12"
	YaskawaGp280          VirtualControllerTypes = "yaskawa-gp280"
	YaskawaGp35L          VirtualControllerTypes = "yaskawa-gp35L"
	YaskawaGp400          VirtualControllerTypes = "yaskawa-gp400"
	YaskawaGp50           VirtualControllerTypes = "yaskawa-gp50"
	YaskawaGp600          VirtualControllerTypes = "yaskawa-gp600"
	YaskawaGp7            VirtualControllerTypes = "yaskawa-gp7"
	YaskawaGp8            VirtualControllerTypes = "yaskawa-gp8"
	YaskawaGp88           VirtualControllerTypes = "yaskawa-gp88"
	YaskawaHc10dtp        VirtualControllerTypes = "yaskawa-hc10dtp"
	YaskawaHc20dtp        VirtualControllerTypes = "yaskawa-hc20dtp"
)

// Defines values for YaskawaControllerKind.
const (
	YaskawaControllerKindYaskawaController YaskawaControllerKind = "YaskawaController"
)

// AbbController The configuration of a physical ABB robot controller has to contain IP address.
// Additionally an EGM server configuration has to be specified in order to control the robot.
// Deploying the server is a functionality of this API.
type AbbController struct {
	ControllerIp string `json:"controller_ip"`

	// ControllerPort Default values: 80, 443. If custom value is set, field is required.
	ControllerPort int `json:"controller_port"`

	// EgmServer The EGM server runs inside of the cell, thus its IP must be in the same network as the 'controller_ip'
	EgmServer struct {
		Ip   string `json:"ip"`
		Port int    `json:"port"`
	} `json:"egm_server"`
	Kind AbbControllerKind `json:"kind,omitempty"`
}

// AbbControllerKind defines model for AbbController.Kind.
type AbbControllerKind string

// AddTrajectoryError defines model for AddTrajectoryError.
type AddTrajectoryError struct {
	Data *AddTrajectoryError_Data `json:"data,omitempty"`

	// Location The location of the error in the trajectory.
	Location *float64 `json:"location,omitempty"`
	Message  *string  `json:"message,omitempty"`
}

// AddTrajectoryError_Data defines model for AddTrajectoryError.Data.
type AddTrajectoryError_Data struct {
	union json.RawMessage
}

// AddTrajectoryRequest defines model for AddTrajectoryRequest.
type AddTrajectoryRequest struct {
	// MotionGroup Unique identifier of the motion group the trajectory is planned for.
	MotionGroup string `json:"motion_group"`

	// Tcp Unique identifier of the tool the trajectory is planned for.
	Tcp        *string         `json:"tcp,omitempty"`
	Trajectory JointTrajectory `json:"trajectory"`
}

// AddTrajectoryResponse The response signals if the trajectory is valid or faulty resulting in an executable, partially executable or not executable state.
// - valid trajectory: response contains only the unique identifier for the trajectory
// - trajectory has error on path: response contains the unique identifier for the trajectory and information about the failure. It is executable up to the point of failure.
// - trajectory has error at start or invalid data: response contains only information about the failure.
//
// To execute the trajectory use the unique identifier for calling [executeTrajectory](executeTrajectory).
// If you want to validate your trajectory before execution, execute it with a virtual motion group and check the state in the response stream of [executeTrajectory](executeTrajectory).
type AddTrajectoryResponse struct {
	Error *AddTrajectoryError `json:"error,omitempty"`

	// Trajectory The unique identifier of the trajectory. Use this identifier to execute the trajectory with the [executeTrajectory](executeTrajectory) endpoint.
	Trajectory *string `json:"trajectory,omitempty"`
}

// App An App is defined by a webserver, packed inside a container, serving a web-application.
type App struct {
	// AppIcon The path of the icon for the App (/$cell/$name/$app_icon).
	AppIcon string `json:"app_icon"`

	// ContainerImage A user provided, custom container image and the required credentials to pull it from a registry.
	ContainerImage ContainerImage `json:"container_image"`

	// DiagnosisPath Defines the URL path suffix used to provide an endpoint for diagnosis data collection.
	// The complete diagnosis check URL is constructed as `/$cell/$name/$diagnosis_path`.
	//
	// The endpoint is called when a diagnosis package is requested via the diagnosis API.
	// The endpoint needs to return the data within a zip file `application/zip` response.
	DiagnosisPath *string `json:"diagnosis_path,omitempty"`

	// Environment A list of environment variables with name and their value.
	// These can be used to configure the containerized application, and turn features on or off.
	Environment *ContainerEnvironment `json:"environment,omitempty"`

	// HealthPath Defines the URL path suffix used to check the application's health status. The complete health check URL
	// is constructed as `/$cell/$name/$health_path`. When the application is working as expected,
	// the endpoint returns an HTTP 200 status code.
	//
	// If not specified, the system will default to using the application icon path suffix
	// (the value of `app_icon`) as the health check endpoint, resulting in `/$cell/$name/$app_icon`.
	//
	// If the health check fails (no response or non-200 status code), the system will
	// automatically restart the application container to restore service.
	HealthPath *string `json:"health_path,omitempty"`

	// Name The name of the provided application.
	// The name must be unique within the cell and is used as a identifier for addressing the application in all API calls
	// , e.g. when updating the application.
	//
	// It also defines where the application is reachable (/$cell/$name).
	//
	// It must be a valid k8s label name as defined by [RFC 1035](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#rfc-1035-label-names).
	Name string `json:"name"`

	// Port The port the containerized webserver is listening on.
	Port *int `json:"port,omitempty"`

	// Resources Additional resources that the application requires.
	Resources *ContainerResources `json:"resources,omitempty"`

	// Storage The path and capacity of a volume that retains data across application restarts.
	// The maximal requestable capacity is 300Mi.
	// If you need more capacity consider using [storeObject](storeObject).
	Storage *ContainerStorage `json:"storage,omitempty"`
}

// Behavior ## BEHAVIOR_AUTOMATIC
// This is the default behavior.
// The motion groups of the controller take commanded joint configuration as actual joint state.
// Configures the compliance of the virtual robot with the normal ControllerState cycle time. If set, the virtual robot will act like a physical one, e.g. with a cycle time of 8ms to respond to a new joint state command.
// ## BEHAVIOR_AUTOMATIC_NOT_COMPLY_WITH_CYCLETIME
// Configures the compliance of the virtual robot with the normal ControllerState cycle time. If set, the robot will respond as fast as possible, limited only by software execution speed. Because of that the execution of a movement requires less time than with BEHAVIOR_AUTOMATIC.
// ## BEHAVIOR_EXTERNAL_SOURCE
// The external client is the only source of actual joint state changes.
// This mode is used to enable third party software indicating the current joint state via [externalJointsStream](externalJointsStream).
type Behavior string

// BinaryObject Any value encoded as a binary string.
type BinaryObject = openapi_types.File

// BlendingAuto defines model for BlendingAuto.
type BlendingAuto struct {
	BlendingName string `json:"blending_name"`

	// MinVelocityInPercent Auto-blending is used to keep a constant velocity when blending between two motion commands.
	// It changes the TCP path around the target point of the motion command.
	// The value represents the percentage of the original velocity.
	MinVelocityInPercent *uint32 `json:"min_velocity_in_percent,omitempty"`
}

// BlendingPosition defines model for BlendingPosition.
type BlendingPosition struct {
	BlendingName string `json:"blending_name"`

	// PositionZoneRadius Specifies the maximum radius in [mm] around the motion command's target point
	// where the TCP path can be altered to blend the motion command into the following one.
	// If auto-blending blends too much of the resulting trajectory, use position-blending to restrict the blending zone radius.
	PositionZoneRadius *float64 `json:"position_zone_radius,omitempty"`
}

// BooleanValue Value of a digital input/output.
type BooleanValue struct {
	Value     bool                  `json:"value"`
	ValueType BooleanValueValueType `json:"value_type,omitempty"`
}

// BooleanValueValueType defines model for BooleanValue.ValueType.
type BooleanValueValueType string

// Box Defines a cuboid shape centred around an origin.
//
// If a margin is applied to the box type full, it is added to all size values. The shape will keep its edges.
// The hollow box type consists of thin boxes that make up its walls.
// If a margin is applied to the box type hollow, its size values are reduced by the margin.
type Box struct {
	// BoxType The box type defines if the box is hollow or full.
	BoxType   BoxBoxType `json:"box_type"`
	ShapeType string     `json:"shape_type"`

	// SizeX The dimension in x-direction in [mm].
	SizeX float64 `json:"size_x"`

	// SizeY The dimension in y-direction in [mm].
	SizeY float64 `json:"size_y"`

	// SizeZ The dimension in z-direction in [mm].
	SizeZ float64 `json:"size_z"`
}

// BoxBoxType The box type defines if the box is hollow or full.
type BoxBoxType string

// BusIOProfinet PROFINET BUS Inputs/Outputs Service configuration.
type BusIOProfinet struct {
	BusType BusIOProfinetBusType `json:"bus_type,omitempty"`

	// ConfigFileContent Path to the configuration file.
	ConfigFileContent *string `json:"config_file_content,omitempty"`

	// DefaultRoute Default route configuration for the PROFINET service.
	// Will be removed before release by automatic default route configuration,
	// if possible.
	DefaultRoute struct {
		// Gateway Gateway for the default route.
		Gateway string `json:"gateway"`

		// Interface Interface for the default route.
		Interface string `json:"interface"`
	} `json:"default_route"`

	// Mac MAC address for the PROFINET port, should be get from another NOVA API endpoind?
	Mac           string                `json:"mac"`
	NetworkConfig *BusIOProfinetNetwork `json:"network_config,omitempty"`
}

// BusIOProfinetBusType defines model for BusIOProfinet.BusType.
type BusIOProfinetBusType string

// BusIOProfinetIpConfig Network configuration for the PROFINET device
type BusIOProfinetIpConfig struct {
	// Gateway Gateway for the PROFINET device
	Gateway string `json:"gateway"`

	// Ip IP address for the PROFINET device
	Ip string `json:"ip"`

	// Netmask Network mask for the PROFINET device.
	Netmask string `json:"netmask"`
}

// BusIOProfinetNetwork defines model for BusIOProfinetNetwork.
type BusIOProfinetNetwork struct {
	// DeviceName Name of the PROFINET device.
	DeviceName *string `json:"device_name,omitempty"`

	// IpConfig Network configuration for the PROFINET device
	IpConfig *BusIOProfinetIpConfig `json:"ip_config,omitempty"`

	// RemaXmlContent Content of the PROFINET REMA XML file.
	RemaXmlContent *string `json:"rema_xml_content,omitempty"`
}

// BusIOProfinetVirtual Virtual PROFINET BUS Inputs/Outputs Service configuration.
type BusIOProfinetVirtual struct {
	BusType BusIOProfinetVirtualBusType `json:"bus_type,omitempty"`
}

// BusIOProfinetVirtualBusType defines model for BusIOProfinetVirtual.BusType.
type BusIOProfinetVirtualBusType string

// BusIOType defines model for BusIOType.
type BusIOType struct {
	union json.RawMessage
}

// BusIOsState defines model for BusIOsState.
type BusIOsState struct {
	// Message A message providing additional information on the input/output, e.g. BUS service status, encountered errors.
	// May be empty if no additional information is available.
	Message *string `json:"message,omitempty"`

	// State Current state of the BUS input/output service.
	State BusIOsStateEnum `json:"state"`
}

// BusIOsStateEnum Current state of the BUS input/output service.
type BusIOsStateEnum string

// Capacity The amount of requested storage capacity.
type Capacity = string

// Capsule Defines a cylindrical shape with 2 semi-spheres on the top and bottom.
// Centred around origin, symmetric around z-axis.
type Capsule struct {
	// CylinderHeight The height of the inner cylinder in [mm].
	CylinderHeight float64 `json:"cylinder_height"`

	// Radius The radius of the cylinder and semi-spheres in [mm].
	Radius    float64 `json:"radius"`
	ShapeType string  `json:"shape_type"`
}

// CartesianLimits defines model for CartesianLimits.
type CartesianLimits struct {
	Acceleration            *float64 `json:"acceleration,omitempty"`
	OrientationAcceleration *float64 `json:"orientation_acceleration,omitempty"`
	OrientationVelocity     *float64 `json:"orientation_velocity,omitempty"`
	Velocity                *float64 `json:"velocity,omitempty"`
}

// Cell To create a robot cell, only a valid name is required.
// Once created, a robot cell provides access to the Wandelbots NOVA foundation services.
// The configuration can be customized, e.g. robot controllers, also within apps.
type Cell struct {
	Apps        *[]App             `json:"apps,omitempty"`
	Controllers *[]RobotController `json:"controllers,omitempty"`

	// Description A description of the cell.
	Description *CellDescription `json:"description,omitempty"`

	// Name A unique name for the cell used as an identifier for addressing the cell in all API calls.
	// It must be a valid k8s label name as defined by [RFC 1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-label-names).
	Name CellName `json:"name"`
}

// CellDescription A description of the cell.
type CellDescription = string

// CellName A unique name for the cell used as an identifier for addressing the cell in all API calls.
// It must be a valid k8s label name as defined by [RFC 1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-label-names).
type CellName = string

// Collider Defines a collider with a single shape.
//
// A collider is an object that is used for collision detection.
// It defines the `shape` that is attached with the offset of `pose` to a reference frame.
//
// Use colliders to:
// - Define the shape of a workpiece. The reference frame is the scene origin.
// - Define the shape of a link in a motion group. The reference frame is the link coordinate system.
// - Define the shape of a tool. The reference frame is the flange coordinate system.
type Collider struct {
	// Margin Increases the shape's size in all dimensions. Applied in [mm]. Can be used to keep a safe distance to the shape.
	Margin *float32 `json:"margin,omitempty"`

	// Pose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	Pose  *Pose          `json:"pose,omitempty"`
	Shape Collider_Shape `json:"shape"`
}

// Collider_Shape defines model for Collider.Shape.
type Collider_Shape struct {
	union json.RawMessage
}

// ColliderDictionary A collection of identifiable colliders.
type ColliderDictionary map[string]Collider

// Collision defines model for Collision.
type Collision struct {
	IdOfA     *string `json:"id_of_a,omitempty"`
	IdOfB     *string `json:"id_of_b,omitempty"`
	IdOfLayer *string `json:"id_of_layer,omitempty"`

	// NormalRootOnB A three-dimensional vector [x, y, z] with double precision.
	NormalRootOnB *Vector3d         `json:"normal_root_on_b,omitempty"`
	PositionOnA   *CollisionContact `json:"position_on_a,omitempty"`
	PositionOnB   *CollisionContact `json:"position_on_b,omitempty"`
}

// CollisionContact defines model for CollisionContact.
type CollisionContact struct {
	// Local A three-dimensional vector [x, y, z] with double precision.
	Local *Vector3d `json:"local,omitempty"`

	// Root A three-dimensional vector [x, y, z] with double precision.
	Root *Vector3d `json:"root,omitempty"`
}

// CollisionError defines model for CollisionError.
type CollisionError struct {
	Collision *FeedbackCollision `json:"collision,omitempty"`
}

// CollisionFreeAlgorithm Configuration for collision-free path planning algorithms.
// Different algorithms may have different parameters and behavior.
type CollisionFreeAlgorithm struct {
	union json.RawMessage
}

// CollisionSetup defines model for CollisionSetup.
type CollisionSetup struct {
	// Colliders A collection of identifiable colliders.
	Colliders *ColliderDictionary `json:"colliders,omitempty"`

	// LinkChain A link chain is a kinematic chain of links that is connected via joints.
	// A motion group can be used to control the motion of the joints in a link chain.
	//
	// A link is a group of colliders that is attached to the link reference frame.
	//
	// The reference frame of a link is obtained after applying all sets of Denavit-Hartenberg-parameters from base to (including) the link index.
	//
	// This means that the reference frame of the link is on the rotation axis of the next joint in the kinematic chain.
	// Example: For a motion group with 2 joints, the collider reference frame (CRF) for link 1 is on the rotation axis of joint 2. The chain looks like:
	// - Origin >> Mounting >> Base >> (CRF Base) Joint 0 >> Link 0 >> (CRF Link 0) Joint 1 >> Link 1 >> (CRF Link 1) Flange (CRF Tool) >> TCP
	//
	// Adjacent links in the kinematic chain of the motion group are not checked for mutual collision.
	LinkChain *LinkChain `json:"link_chain,omitempty"`

	// SelfCollisionDetection If true, self-collision detection is enabled for the motion group.
	//
	// Self-collision detection checks if links in the kinematic chain of the motion group collide with each other.
	// Adjacent links in the kinematic chain of the motion group are not checked for mutual collision.
	// The tool is treated like a link at the end of the kinematic chain. It is checked against all links except the last one.
	//
	// Default is true.
	SelfCollisionDetection *bool `json:"self_collision_detection,omitempty"`

	// Tool Defines the shape of a tool.
	//
	// A tool is a dictionary of colliders.
	//
	// All colliders that make up a tool are attached to the flange frame of the motion group.
	Tool *Tool `json:"tool,omitempty"`
}

// CollisionSetups Collision layers to be respected by the motion planner when planning for a single motion group.
// Each setup represents one layer, e.g. the safety zones and shapes or a fine grained tool and workpiece model.
// Layers are checked individually along the trajectory and independently of other layers.
//
// To respect the safety zones of the controller and check for collision:
// 1. Fetch the safety zones, link and tool shapes from the controller.
// 2. Add the fetched zones, links and tools to a layer.
// 3. Create other layers from your own 3D data as needed.
// 4. Plan trajectory.
// 5. The response highlights the layer in which a collision was detected by key.
type CollisionSetups map[string]CollisionSetup

// Comparator Comparator for the comparison of two values.
// The comparator is used to compare two values and return a boolean result.
// The default comparator is unknown.
type Comparator string

// ConfigurationArchive Binary data representing a configuration archive.
type ConfigurationArchive = openapi_types.File

// ConfigurationArchiveStatus Result of a backup operation.
type ConfigurationArchiveStatus struct {
	union json.RawMessage
}

// ConfigurationArchiveStatusCreating defines model for ConfigurationArchiveStatusCreating.
type ConfigurationArchiveStatusCreating struct {
	// Progress Current completion ratio (0 â€“ 1).
	Progress float32 `json:"progress"`

	// Status Backup is in progress.
	Status ConfigurationArchiveStatusCreatingStatus `json:"status"`
}

// ConfigurationArchiveStatusCreatingStatus Backup is in progress.
type ConfigurationArchiveStatusCreatingStatus string

// ConfigurationArchiveStatusError defines model for ConfigurationArchiveStatusError.
type ConfigurationArchiveStatusError struct {
	// Message Human-readable explanation of the failure.
	Message string                                `json:"message"`
	Status  ConfigurationArchiveStatusErrorStatus `json:"status"`
}

// ConfigurationArchiveStatusErrorStatus defines model for ConfigurationArchiveStatusError.Status.
type ConfigurationArchiveStatusErrorStatus string

// ConfigurationArchiveStatusSuccess defines model for ConfigurationArchiveStatusSuccess.
type ConfigurationArchiveStatusSuccess struct {
	// Status Backup successfully created.
	Status ConfigurationArchiveStatusSuccessStatus `json:"status"`
}

// ConfigurationArchiveStatusSuccessStatus Backup successfully created.
type ConfigurationArchiveStatusSuccessStatus string

// ConfigurationResource Configuration resource object.
type ConfigurationResource struct {
	// Children Array of configuration resources.
	Children *ConfigurationResourceArray `json:"children,omitempty"`

	// Id Identifier of a configuration resource.
	Id ConfigurationResourceId `json:"id"`

	// Name Human-readable name of the configuration resource.
	Name string `json:"name"`
}

// ConfigurationResourceArray Array of configuration resources.
type ConfigurationResourceArray = []ConfigurationResource

// ConfigurationResourceId Identifier of a configuration resource.
type ConfigurationResourceId = string

// ContainerEnvironment A list of environment variables with name and their value.
// These can be used to configure the containerized application, and turn features on or off.
type ContainerEnvironment = []struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// ContainerImage A user provided, custom container image and the required credentials to pull it from a registry.
type ContainerImage struct {
	// Credentials User provided credentials for creating a secret to pull an image from a registry.
	Credentials *ImageCredentials `json:"credentials,omitempty"`

	// Image The location of a container image in the form of `<registry>/<image>:<tag>`.
	Image string `json:"image"`

	// Secrets Known secrets for authentication with the container registry.
	Secrets *[]struct {
		Name string `json:"name"`
	} `json:"secrets,omitempty"`
}

// ContainerResources Additional resources that the application requires.
type ContainerResources struct {
	// IntelGpu Number of GPUs the application requires.
	IntelGpu *int `json:"intel_gpu,omitempty"`

	// MemoryLimit The maximum memory allocated to this application.
	MemoryLimit *string `json:"memory_limit,omitempty"`
}

// ContainerStorage The path and capacity of a volume that retains data across application restarts.
// The maximal requestable capacity is 300Mi.
// If you need more capacity consider using [storeObject](storeObject).
type ContainerStorage struct {
	// Capacity The amount of requested storage capacity.
	Capacity  Capacity `json:"capacity"`
	MountPath string   `json:"mount_path"`
}

// ControllerDescription The data type to describe a robot controller.
type ControllerDescription struct {
	ConnectedMotionGroups []string `json:"connected_motion_groups"`

	// SupportsControl Can this controller be controlled with NOVA (true) or is it only possible to read data (false).
	SupportsControl bool `json:"supports_control"`

	// SupportsFreedrive Can this controller be moved through freedrive (true), or not (false).
	SupportsFreedrive bool `json:"supports_freedrive"`

	// SupportsSafetyZones True if NOVA supports reading safety zone-, tool- and link-geometries for this motion group.
	// Safety zones are used to define areas where the robot should slow down or stop.
	// If false, NOVA can't guarantee that the executed motions respect safety zones defined on the controller.
	SupportsSafetyZones bool `json:"supports_safety_zones"`
}

// ConvexHull Defines a convex hull encapsulating a set of vertices.
type ConvexHull struct {
	ShapeType string `json:"shape_type"`

	// Vertices The list of encapsulated points.
	Vertices []Vector3d `json:"vertices"`
}

// CoordinateSystem defines model for CoordinateSystem.
type CoordinateSystem struct {
	// CoordinateSystem Unique identifier of the coordinate system.
	CoordinateSystem string `json:"coordinate_system"`

	// Name Human readable name of this coordinate system.
	Name *string `json:"name,omitempty"`

	// Orientation Describes an orientation in 3D space.
	// A tree-to-four-dimensional vector [x, y, z, w] with double precision.
	Orientation *Orientation `json:"orientation,omitempty"`

	// OrientationType The type of rotation description that is used to specify the orientation.
	//
	// **Rotation Vector notation**
	//
	// * The rotation is represented using an axis-angle representation:
	// > axis = Vector[0:2]
	// > angle = |axis| in [rad]
	// > axis.normalized * angle
	//
	// **Quaternion notation**
	//
	// * The rotation is represented using a unit quaternion: [x, y, z, w].
	// * The vector part [x, y, z] is the imaginary part of the quaternion, and the scalar part [w] is the real part.
	//
	// **Euler notation**
	//
	// * *extrinsic* fixed external reference system
	// * *intrinsic* reference system fixed to rotation body
	// > angles = Vector[0:2] in [rad].
	// * ZYX, ZXZ,...
	//   - mapping of the given angles values to the (either intrinsic
	//     or extrinsic) axes in the stated order.
	//  > Example ZYX: Z = Vector[0], Y = Vector[1], X = Vector[2].
	OrientationType *OrientationType `json:"orientation_type,omitempty"`

	// Position A three-dimensional vector [x, y, z] with double precision.
	Position *Vector3d `json:"position,omitempty"`

	// ReferenceCoordinateSystem The identifier of the reference coordinate system. Empty if world is used.
	ReferenceCoordinateSystem *string `json:"reference_coordinate_system,omitempty"`
}

// CoordinateSystemData defines model for CoordinateSystemData.
type CoordinateSystemData struct {
	// Name Human readable name of this coordinate system.
	Name *string `json:"name,omitempty"`

	// Orientation Describes an orientation in 3D space.
	// A tree-to-four-dimensional vector [x, y, z, w] with double precision.
	Orientation *Orientation `json:"orientation,omitempty"`

	// OrientationType The type of rotation description that is used to specify the orientation.
	//
	// **Rotation Vector notation**
	//
	// * The rotation is represented using an axis-angle representation:
	// > axis = Vector[0:2]
	// > angle = |axis| in [rad]
	// > axis.normalized * angle
	//
	// **Quaternion notation**
	//
	// * The rotation is represented using a unit quaternion: [x, y, z, w].
	// * The vector part [x, y, z] is the imaginary part of the quaternion, and the scalar part [w] is the real part.
	//
	// **Euler notation**
	//
	// * *extrinsic* fixed external reference system
	// * *intrinsic* reference system fixed to rotation body
	// > angles = Vector[0:2] in [rad].
	// * ZYX, ZXZ,...
	//   - mapping of the given angles values to the (either intrinsic
	//     or extrinsic) axes in the stated order.
	//  > Example ZYX: Z = Vector[0], Y = Vector[1], X = Vector[2].
	OrientationType *OrientationType `json:"orientation_type,omitempty"`

	// Position A three-dimensional vector [x, y, z] with double precision.
	Position *Vector3d `json:"position,omitempty"`

	// ReferenceCoordinateSystem The identifier of the reference coordinate system. Empty if world is used.
	ReferenceCoordinateSystem *string `json:"reference_coordinate_system,omitempty"`
}

// CubicSplineParameter defines model for CubicSplineParameter.
type CubicSplineParameter struct {
	PathParameter float64 `json:"path_parameter"`

	// Pose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	Pose Pose `json:"pose"`
}

// CycleTime defines model for CycleTime.
type CycleTime struct {
	// CycleTimeMs Cycle time of controller communication in [ms].
	CycleTimeMs uint32 `json:"cycle_time_ms"`
}

// Cylinder Defines a cylindrical shape.
// Centred around origin, symmetric around z-axis.
//
// If a margin is applied, it is added to radius and height. The shape will keep its edges.
type Cylinder struct {
	// Height The height of the cylinder in [mm].
	Height float64 `json:"height"`

	// Radius The radius of the cylinder in [mm].
	Radius    float64 `json:"radius"`
	ShapeType string  `json:"shape_type"`
}

// DHParameter A single set of DH parameters.
type DHParameter struct {
	// A Offset along x-axis in [mm].
	A *float64 `json:"a,omitempty"`

	// Alpha Angle about x-axis in [rad].
	Alpha *float64 `json:"alpha,omitempty"`

	// D Offset along z-axis in [mm].
	D *float64 `json:"d,omitempty"`

	// ReverseRotationDirection True, if rotation direction of joint is reversed.
	ReverseRotationDirection *bool `json:"reverse_rotation_direction,omitempty"`

	// Theta Angle about z-axis in [rad].
	Theta *float64 `json:"theta,omitempty"`
}

// Direction The direction in which the trajectory is executed. Default: Forward.
type Direction string

// DoubleArray defines model for DoubleArray.
type DoubleArray = []float64

// Error defines model for Error.
type Error struct {
	Code    *string `json:"code,omitempty"`
	Message string  `json:"message"`
}

// ErrorInvalidJointCount The provided joint data does not match the expected number of joints
// for this motion group.
type ErrorInvalidJointCount struct {
	ErrorFeedbackName string `json:"error_feedback_name"`

	// ExpectedJointCount The expected number of joints for this motion group.
	ExpectedJointCount int `json:"expected_joint_count"`

	// ProvidedJointCount The number of provided joints.
	ProvidedJointCount int `json:"provided_joint_count"`
}

// ErrorJointLimitExceeded A reference joint position (start or target) exceeds the configured joint limits.
type ErrorJointLimitExceeded struct {
	ErrorFeedbackName string `json:"error_feedback_name"`

	// JointIndex Index of the joint exceeding its limits (0-based).
	JointIndex    *uint32      `json:"joint_index,omitempty"`
	JointPosition *DoubleArray `json:"joint_position,omitempty"`
}

// ErrorJointPositionCollision A reference joint position (e.g. start or target joint position) results in collisions that prevent processing.
type ErrorJointPositionCollision struct {
	Collisions        *[]Collision `json:"collisions,omitempty"`
	ErrorFeedbackName string       `json:"error_feedback_name"`
	JointPosition     *DoubleArray `json:"joint_position,omitempty"`
}

// ErrorMaxIterationsExceeded The collision-free planning algorithm reached its maximum iteration limit
// without finding a valid path. Increase max_iterations or
// modify the start/target positions.
type ErrorMaxIterationsExceeded struct {
	ErrorFeedbackName string `json:"error_feedback_name"`

	// MaxIterations The maximum number of iterations that was reached.
	MaxIterations *int `json:"max_iterations,omitempty"`
}

// Execute Details about the state of the motion execution.
// The details are either for a jogging or a trajectory.
// If NOVA is not controlling this motion group at the moment, this field is omitted.
type Execute struct {
	Details *Execute_Details `json:"details,omitempty"`

	// JointPosition Commanded joint position of each joint in [rad]. This command was sent in the time step the corresponding state was received.
	JointPosition []float64 `json:"joint_position"`
}

// Execute_Details defines model for Execute.Details.
type Execute_Details struct {
	union json.RawMessage
}

// ExecuteJoggingResponse defines model for ExecuteJoggingResponse.
type ExecuteJoggingResponse struct {
	union json.RawMessage
}

// ExecuteTrajectoryResponse defines model for ExecuteTrajectoryResponse.
type ExecuteTrajectoryResponse struct {
	union json.RawMessage
}

// ExternalJointStreamDatapoint A datapoint inside external joint stream.
type ExternalJointStreamDatapoint struct {
	// MotionGroup The unique identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// Value Ensure to provide one value for each joint. See [getMotionGroups](getMotionGroups) for the number of joints.
	// Everything but positions is optional.
	Value MotionGroupJoints `json:"value"`
}

// ExternalJointStreamDatapoints defines model for ExternalJointStreamDatapoints.
type ExternalJointStreamDatapoints = []ExternalJointStreamDatapoint

// ExternalJointStreamRequest defines model for ExternalJointStreamRequest.
type ExternalJointStreamRequest struct {
	States ExternalJointStreamDatapoints `json:"states"`
}

// FanucController The configuration of a physical FANUC robot controller has to contain IP address of the controller.
type FanucController struct {
	ControllerIp string              `json:"controller_ip"`
	Kind         FanucControllerKind `json:"kind,omitempty"`
}

// FanucControllerKind defines model for FanucController.Kind.
type FanucControllerKind string

// FeedbackCollision defines model for FeedbackCollision.
type FeedbackCollision struct {
	Collisions        *[]Collision `json:"collisions,omitempty"`
	ErrorFeedbackName string       `json:"error_feedback_name"`
	JointPosition     *DoubleArray `json:"joint_position,omitempty"`

	// TcpPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TcpPose *Pose `json:"tcp_pose,omitempty"`
}

// FeedbackJointLimitExceeded This error is returned when a joint position limit is exceeded.
// The joint index denotes which joint is out of its limits, starting with 1 and followed by the full joint position.
type FeedbackJointLimitExceeded struct {
	ErrorFeedbackName string       `json:"error_feedback_name"`
	JointIndex        *uint32      `json:"joint_index,omitempty"`
	JointPosition     *DoubleArray `json:"joint_position,omitempty"`
}

// FeedbackOutOfWorkspace Requested TCP pose is outside of motion group's workspace.
type FeedbackOutOfWorkspace struct {
	ErrorFeedbackName string `json:"error_feedback_name"`

	// InvalidTcpPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	InvalidTcpPose *Pose `json:"invalid_tcp_pose,omitempty"`
}

// FeedbackSingularity A singularity is a point in the robot's workspace where the robot loses one or more degrees of freedom with regards to moving its TCP.
// This means the robot cannot move or rotate the TCP in a certain direction from this specific point.
//
// Use PTP motions if possible. They will almost never fail due to singularities (only if the target point is at a singularity).
//
// Alternatively change the robot TCP's path to avoid moving through this point or try to move the TCP through this point in a different direction.
type FeedbackSingularity struct {
	ErrorFeedbackName     string               `json:"error_feedback_name"`
	SingularJointPosition *DoubleArray         `json:"singular_joint_position,omitempty"`
	SingularityType       *SingularityTypeEnum `json:"singularity_type,omitempty"`
}

// Flag defines model for Flag.
type Flag struct {
	Active bool `json:"active"`
}

// FloatValue defines model for FloatValue.
type FloatValue struct {
	// Value Value of an analog input/output in floating number representation.
	Value     float64             `json:"value"`
	ValueType FloatValueValueType `json:"value_type,omitempty"`
}

// FloatValueValueType defines model for FloatValue.ValueType.
type FloatValueValueType string

// ForwardKinematics422Response defines model for ForwardKinematics422Response.
type ForwardKinematics422Response struct {
	Detail *[]ForwardKinematicsValidationError `json:"detail,omitempty"`
}

// ForwardKinematicsRequest defines model for ForwardKinematicsRequest.
type ForwardKinematicsRequest struct {
	// JointPositions List of joint positions [rad] for which TCP poses are computed.
	JointPositions []DoubleArray `json:"joint_positions"`

	// MotionGroupModel String identifiying the model of a motion group.
	MotionGroupModel MotionGroupModel `json:"motion_group_model"`

	// Mounting Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	Mounting *Pose `json:"mounting,omitempty"`

	// TcpOffset Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TcpOffset *Pose `json:"tcp_offset,omitempty"`
}

// ForwardKinematicsResponse defines model for ForwardKinematicsResponse.
type ForwardKinematicsResponse struct {
	// TcpPoses List of computed TCP poses corresponding to the input joint positions.
	TcpPoses []Pose `json:"tcp_poses"`
}

// ForwardKinematicsValidationError defines model for ForwardKinematicsValidationError.
type ForwardKinematicsValidationError struct {
	// Data The provided joint data does not match the expected number of joints
	// for this motion group.
	Data  *ErrorInvalidJointCount                     `json:"data,omitempty"`
	Input map[string]interface{}                      `json:"input"`
	Loc   []ForwardKinematicsValidationError_Loc_Item `json:"loc"`
	Msg   string                                      `json:"msg"`
	Type  string                                      `json:"type"`
}

// ForwardKinematicsValidationErrorLoc0 defines model for .
type ForwardKinematicsValidationErrorLoc0 = string

// ForwardKinematicsValidationErrorLoc1 defines model for .
type ForwardKinematicsValidationErrorLoc1 = int

// ForwardKinematicsValidationError_Loc_Item defines model for ForwardKinematicsValidationError.loc.Item.
type ForwardKinematicsValidationError_Loc_Item struct {
	union json.RawMessage
}

// GetTrajectoryResponse defines model for GetTrajectoryResponse.
type GetTrajectoryResponse struct {
	// MotionGroup Unique identifier of the motion group the trajectory is planned for.
	MotionGroup string `json:"motion_group"`

	// Tcp Unique identifier of the tool the trajectory is planned for.
	Tcp        string          `json:"tcp"`
	Trajectory JointTrajectory `json:"trajectory"`
}

// HTTPValidationError defines model for HTTPValidationError.
type HTTPValidationError struct {
	Detail *[]ValidationError `json:"detail,omitempty"`
}

// IOBooleanValue Input/Output boolean value representation.
type IOBooleanValue struct {
	// Io Unique identifier of the input/output.
	Io string `json:"io"`

	// Value Value of a digital input/output.
	Value     bool                    `json:"value"`
	ValueType IOBooleanValueValueType `json:"value_type,omitempty"`
}

// IOBooleanValueValueType defines model for IOBooleanValue.ValueType.
type IOBooleanValueValueType string

// IODescription defines model for IODescription.
type IODescription struct {
	// Direction Identifies the input/output type.
	Direction IODirection `json:"direction"`

	// Group Name of the input/output group. Customize it on the physical controller or in the virtual robot specification.
	Group *string `json:"group,omitempty"`

	// Io Unique identifier of the input/output.
	Io  string             `json:"io"`
	Max *IODescription_Max `json:"max,omitempty"`
	Min *IODescription_Min `json:"min,omitempty"`

	// Name Name of the input/output. Customize it on the physical controller or in the virtual robot specification.
	Name string `json:"name"`

	// Unit The unit of input/output value.
	Unit *UnitType `json:"unit,omitempty"`

	// ValueType Data type of the input/output.
	ValueType IOValueType `json:"value_type"`
}

// IODescription_Max defines model for IODescription.Max.
type IODescription_Max struct {
	union json.RawMessage
}

// IODescription_Min defines model for IODescription.Min.
type IODescription_Min struct {
	union json.RawMessage
}

// IODirection Identifies the input/output type.
type IODirection string

// IOFloatValue defines model for IOFloatValue.
type IOFloatValue struct {
	// Io Unique identifier of the input/output.
	Io string `json:"io"`

	// Value Value of an analog input/output in floating number representation.
	Value     float64               `json:"value"`
	ValueType IOFloatValueValueType `json:"value_type,omitempty"`
}

// IOFloatValueValueType defines model for IOFloatValue.ValueType.
type IOFloatValueValueType string

// IOIntegerValue defines model for IOIntegerValue.
type IOIntegerValue struct {
	// Io Unique identifier of the input/output.
	Io string `json:"io"`

	// Value Value of an input/output with integer representation.
	//
	// > The integral value is transmitted as a string to avoid precision loss during conversion to JSON.
	// > We recommend to use int64 in your implementation. If you want to interact with int64 in numbers,
	// > JS bigint libraries can help you to parse the string into an integral value.
	Value     string                  `json:"value"`
	ValueType IOIntegerValueValueType `json:"value_type,omitempty"`
}

// IOIntegerValueValueType defines model for IOIntegerValue.ValueType.
type IOIntegerValueValueType string

// IOValue defines model for IOValue.
type IOValue struct {
	union json.RawMessage
}

// IOValueType Data type of the input/output.
type IOValueType string

// ImageCredentials User provided credentials for creating a secret to pull an image from a registry.
type ImageCredentials struct {
	Password string `json:"password"`
	Registry string `json:"registry"`
	User     string `json:"user"`
}

// InconsitentTrajectorySize defines model for InconsitentTrajectorySize.
type InconsitentTrajectorySize struct {
	InconsistentTrajectorySize *struct {
		JointPositionSize *int32 `json:"joint_position_size,omitempty"`
		LocationsSize     *int32 `json:"locations_size,omitempty"`
		TimesSize         *int32 `json:"times_size,omitempty"`
	} `json:"inconsistent_trajectory_size,omitempty"`
}

// InitializeJoggingRequest Send this message to start jogging a motion group.
type InitializeJoggingRequest struct {
	// MessageType Type specifier for server, set automatically.
	MessageType *InitializeJoggingRequestMessageType `json:"message_type,omitempty"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// PauseOnIo Defines an input/output that is listened to during the movement. Execution pauses if the defined comparator evaluates to `true`.
	PauseOnIo *string `json:"pause_on_io,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the responses are transformed.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `json:"response_coordinate_system,omitempty"`

	// ResponseRate Update rate for the response message in milliseconds (ms).
	//
	// Recommendation: As Wandelbots NOVA updates states in the controller's step rate, use either the controller's step rate or a multiple of it.
	//                 Wandelbots NOVA will not interpolate the state but round it to the nearest step rate below the configured response rate.
	// Use [getOptimizerConfiguration](getOptimizerConfiguration) to get the controller's step rate.
	//
	// Minimal response rate is the step rate of the controller.
	ResponseRate *uint32 `json:"response_rate,omitempty"`

	// Tcp Identifier of the tool. Required for robots (all limits, including TCP limits, are respected at all times regardless of the motion). Not required for external axes.
	Tcp *string `json:"tcp,omitempty"`
}

// InitializeJoggingRequestMessageType Type specifier for server, set automatically.
type InitializeJoggingRequestMessageType string

// InitializeJoggingResponse Acknowledgment to an InitializeJoggingRequest.
type InitializeJoggingResponse struct {
	Kind InitializeJoggingResponseKind `json:"kind"`

	// Message Error message in case of invalid InitializeJoggingRequest.
	Message *string `json:"message,omitempty"`
}

// InitializeJoggingResponseKind defines model for InitializeJoggingResponse.Kind.
type InitializeJoggingResponseKind string

// InitializeMovementRequest Sets up connection by locking a trajectory for execution. The robot controller mode is set to control mode.
// ATTENTION: This request has to be sent before any StartMovementRequest is sent.
//
//	If initializing the movement was successful, no further movements can be initialized. To execute another trajectory, another connection has to be established.
type InitializeMovementRequest struct {
	// InitialLocation Location on trajectory where the execution will start.
	// The default value is the start (forward movement) or end (backward movement) of the trajectory.
	// If you want to start your movement from an arbitrary location, e.g. in combination with [streamMoveToTrajectoryViaJointPTP](streamMoveToTrajectoryViaJointPTP),
	// set the location by respecting the following format:
	// - The location is a scalar value that defines a position along a path, typically ranging from 0 to `n`,
	//   where `n` denotes the number of motion commands
	// - Each integer value of the location corresponds to a specific motion command,
	//   while non-integer values interpolate positions within the segments.
	// - The location is calculated from the joint path
	InitialLocation *float64 `json:"initial_location,omitempty"`

	// MessageType Type specifier for server, set automatically.
	MessageType *InitializeMovementRequestMessageType `json:"message_type,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the responses are transformed.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `json:"response_coordinate_system,omitempty"`

	// ResponseRate Update rate for the response message in milliseconds (ms). Default is 200 ms.
	// Recommendation: As Wandelbots NOVA updates states in the controller's step rate, use either the controller's step rate or a multiple of it.
	//                 Wandelbots NOVA will not interpolate the state but rather round it to the nearest step rate below the configured response rate.
	// Minimal response rate is the step rate of controller.
	ResponseRate *uint32 `json:"response_rate,omitempty"`

	// Trajectory The trajectory which should be executed and locked to the connection.
	Trajectory InitializeMovementRequest_Trajectory `json:"trajectory"`
}

// InitializeMovementRequestMessageType Type specifier for server, set automatically.
type InitializeMovementRequestMessageType string

// InitializeMovementRequest_Trajectory The trajectory which should be executed and locked to the connection.
type InitializeMovementRequest_Trajectory struct {
	union json.RawMessage
}

// InitializeMovementResponse Response for InitializeMovementRequest message.
type InitializeMovementResponse struct {
	AddTrajectoryError *AddTrajectoryError            `json:"add_trajectory_error,omitempty"`
	Kind               InitializeMovementResponseKind `json:"kind"`

	// Message Error message in case of invalid InitializeMovementRequest.
	Message *string `json:"message,omitempty"`
}

// InitializeMovementResponseKind defines model for InitializeMovementResponse.Kind.
type InitializeMovementResponseKind string

// IntegerValue Value of an input/output with integer representation.
//
// > The integral value is transmitted as a string to avoid precision loss during conversion to JSON.
// > We recommend to use int64 in your implementation. If you want to interact with int64 in numbers,
// > JS bigint libraries can help you to parse the string into an integral value.
type IntegerValue struct {
	Value     string                `json:"value"`
	ValueType IntegerValueValueType `json:"value_type,omitempty"`
}

// IntegerValueValueType defines model for IntegerValue.ValueType.
type IntegerValueValueType string

// InvalidDof defines model for InvalidDof.
type InvalidDof struct {
	InvalidDof *struct {
		// JointPosition The joint position that is out of its limits.
		JointPosition *[]float64 `json:"joint_position,omitempty"`

		// ValidDof The valid degrees of freedom for the motion group.
		ValidDof *int32 `json:"valid_dof,omitempty"`
	} `json:"invalid_dof,omitempty"`
}

// InverseKinematics422Response defines model for InverseKinematics422Response.
type InverseKinematics422Response struct {
	Detail *[]InverseKinematicsValidationError `json:"detail,omitempty"`
}

// InverseKinematicsRequest defines model for InverseKinematicsRequest.
type InverseKinematicsRequest struct {
	// CollisionSetups Collision layers to be respected by the motion planner when planning for a single motion group.
	// Each setup represents one layer, e.g. the safety zones and shapes or a fine grained tool and workpiece model.
	// Layers are checked individually along the trajectory and independently of other layers.
	//
	// To respect the safety zones of the controller and check for collision:
	// 1. Fetch the safety zones, link and tool shapes from the controller.
	// 2. Add the fetched zones, links and tools to a layer.
	// 3. Create other layers from your own 3D data as needed.
	// 4. Plan trajectory.
	// 5. The response highlights the layer in which a collision was detected by key.
	CollisionSetups *CollisionSetups `json:"collision_setups,omitempty"`

	// JointPositionLimits Joint position limits in [rad], indexed starting from base.
	JointPositionLimits *JointPositionLimits `json:"joint_position_limits,omitempty"`

	// MotionGroupModel String identifiying the model of a motion group.
	MotionGroupModel MotionGroupModel `json:"motion_group_model"`

	// Mounting Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	Mounting *Pose `json:"mounting,omitempty"`

	// TcpOffset Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TcpOffset *Pose `json:"tcp_offset,omitempty"`

	// TcpPoses List of TCP poses for which the inverse solutions are computed.
	TcpPoses []Pose `json:"tcp_poses"`
}

// InverseKinematicsResponse defines model for InverseKinematicsResponse.
type InverseKinematicsResponse struct {
	Joints [][]DoubleArray `json:"joints"`
}

// InverseKinematicsValidationError defines model for InverseKinematicsValidationError.
type InverseKinematicsValidationError struct {
	// Data Optional data further specifying the validation error.
	Data  *InverseKinematicsValidationError_Data      `json:"data,omitempty"`
	Input map[string]interface{}                      `json:"input"`
	Loc   []InverseKinematicsValidationError_Loc_Item `json:"loc"`
	Msg   string                                      `json:"msg"`
	Type  string                                      `json:"type"`
}

// InverseKinematicsValidationError_Data Optional data further specifying the validation error.
type InverseKinematicsValidationError_Data struct {
	union json.RawMessage
}

// InverseKinematicsValidationErrorLoc0 defines model for .
type InverseKinematicsValidationErrorLoc0 = string

// InverseKinematicsValidationErrorLoc1 defines model for .
type InverseKinematicsValidationErrorLoc1 = int

// InverseKinematicsValidationError_Loc_Item defines model for InverseKinematicsValidationError.loc.Item.
type InverseKinematicsValidationError_Loc_Item struct {
	union json.RawMessage
}

// JoggingDetails State of jogging execution.
// This state is sent during jogging movement, response-rate closest to the nearest multiple of controller step-rate but not exceeding the configured rate.
// The jogging state can be one of the following:
// - RUNNING: Jogging is active.
// - PAUSED_BY_USER: User has paused jogging.
// - PAUSED_NEAR_JOINT_LIMIT: Jogging was paused because a joint is is near its limit.
// - PAUSED_NEAR_COLLISION: Jogging was paused because the motion group neared a collision.
// - PAUSED_ON_IO: Jogging was paused because of an I/O event.
type JoggingDetails struct {
	Kind  JoggingDetailsKind   `json:"kind"`
	State JoggingDetails_State `json:"state"`
}

// JoggingDetailsKind defines model for JoggingDetails.Kind.
type JoggingDetailsKind string

// JoggingDetails_State defines model for JoggingDetails.State.
type JoggingDetails_State struct {
	union json.RawMessage
}

// JoggingPausedByUser User has paused jogging.
type JoggingPausedByUser struct {
	Kind JoggingPausedByUserKind `json:"kind"`
}

// JoggingPausedByUserKind defines model for JoggingPausedByUser.Kind.
type JoggingPausedByUserKind string

// JoggingPausedNearCollision Jogging was paused because the motion group neared a collision.
type JoggingPausedNearCollision struct {
	Description string                         `json:"description"`
	Kind        JoggingPausedNearCollisionKind `json:"kind"`
}

// JoggingPausedNearCollisionKind defines model for JoggingPausedNearCollision.Kind.
type JoggingPausedNearCollisionKind string

// JoggingPausedNearJointLimit Jogging was paused because a joint is near its limit.
type JoggingPausedNearJointLimit struct {
	JointIndices []uint32                        `json:"joint_indices"`
	Kind         JoggingPausedNearJointLimitKind `json:"kind"`
}

// JoggingPausedNearJointLimitKind defines model for JoggingPausedNearJointLimit.Kind.
type JoggingPausedNearJointLimitKind string

// JoggingPausedOnIO Jogging was paused because of an I/O event.
type JoggingPausedOnIO struct {
	Kind JoggingPausedOnIOKind `json:"kind"`
}

// JoggingPausedOnIOKind defines model for JoggingPausedOnIO.Kind.
type JoggingPausedOnIOKind string

// JoggingRunning Jogging is active.
type JoggingRunning struct {
	Kind JoggingRunningKind `json:"kind"`
}

// JoggingRunningKind defines model for JoggingRunning.Kind.
type JoggingRunningKind string

// JointLimitExceeded defines model for JointLimitExceeded.
type JointLimitExceeded struct {
	// JointLimitExceeded This error is returned when a joint position limit is exceeded.
	// The joint index denotes which joint is out of its limits, starting with 1 and followed by the full joint position.
	JointLimitExceeded *FeedbackJointLimitExceeded `json:"joint_limit_exceeded,omitempty"`
}

// JointLimits defines model for JointLimits.
type JointLimits struct {
	Acceleration *float64 `json:"acceleration,omitempty"`

	// Position The upper_limit must be greater then the lower_limit.
	Position *LimitRange `json:"position,omitempty"`
	Torque   *float64    `json:"torque,omitempty"`
	Velocity *float64    `json:"velocity,omitempty"`
}

// JointPositionLimits Joint position limits in [rad], indexed starting from base.
type JointPositionLimits = []LimitRange

// JointTrajectory defines model for JointTrajectory.
type JointTrajectory struct {
	// JointPositions List of joint positions [rad] for each sample.
	// The number of samples must match the number of timestamps provided in the times field.
	JointPositions []Joints `json:"joint_positions"`

	// Locations Location for each sample, scalar value defining a position along a path. Typical range: 0 to `n`, `n` denoting the number of motion commands.
	// Each integer value of the location corresponds to a specific motion command.
	// If provided, the number of samples must match the number of timestamps provided in the times field.
	Locations []float64 `json:"locations"`

	// Times Timestamp for each sample [s].
	Times []float64 `json:"times"`
}

// JointVelocityRequest Sets target joint velocities for jogging a motion group.
type JointVelocityRequest struct {
	// MessageType Type specifier for server, set automatically.
	MessageType *JointVelocityRequestMessageType `json:"message_type,omitempty"`

	// Velocity This structure describes a set of joint values (e.g. positions, currents, torques) of a motion group.
	//
	// Float precision is the default.
	Velocity Joints `json:"velocity"`
}

// JointVelocityRequestMessageType Type specifier for server, set automatically.
type JointVelocityRequestMessageType string

// JointVelocityResponse Acknowledgment to a JointVelocityRequest.
type JointVelocityResponse struct {
	Kind JointVelocityResponseKind `json:"kind"`

	// Message Error message in case of invalid JointVelocityRequest.
	Message *string `json:"message,omitempty"`
}

// JointVelocityResponseKind defines model for JointVelocityResponse.Kind.
type JointVelocityResponseKind string

// Joints This structure describes a set of joint values (e.g. positions, currents, torques) of a motion group.
//
// Float precision is the default.
type Joints = []float64

// Key Unique identifier describing to adress an object.
//
// Special characters, such as `;`, `/`, `?`, `:`, `@`, `=` and `&`, have to be URL encoded.
type Key = string

// KukaController The configuration of a physical KUKA robot controller has to contain an IP address.
// Additionally an RSI server configuration has to be specified in order to control the robot.
// Deploying the server is a functionality of this API.
type KukaController struct {
	ControllerIp   string             `json:"controller_ip"`
	ControllerPort int                `json:"controller_port"`
	Kind           KukaControllerKind `json:"kind,omitempty"`

	// RsiServer The RSI server runs inside of the cell.
	RsiServer struct {
		Ip   string `json:"ip"`
		Port int    `json:"port"`
	} `json:"rsi_server"`
}

// KukaControllerKind defines model for KukaController.Kind.
type KukaControllerKind string

// License defines model for License.
type License struct {
	// AllowedActivations Amount of times the license can be activated.
	AllowedActivations int `json:"allowed_activations"`

	// ConsumedActivations Amount of times the license was activated.
	ConsumedActivations int `json:"consumed_activations"`

	// FeatureFlags Features enabled by a license.
	FeatureFlags *[]string `json:"feature_flags,omitempty"`

	// FeatureLimitations Feature limitations of the license.
	FeatureLimitations *map[string]int `json:"feature_limitations,omitempty"`

	// GracePeriodExpiryDate End date of grace period, given if instance is not connected to internet.
	GracePeriodExpiryDate time.Time `json:"grace_period_expiry_date"`

	// LicenseExpiryDate Expiration date of the license.
	LicenseExpiryDate *openapi_types.Date `json:"license_expiry_date,omitempty"`

	// LicenseKey Identification key of the license.
	LicenseKey string `json:"license_key"`

	// OwnerEmail Mail address of the license owner.
	OwnerEmail openapi_types.Email `json:"owner_email"`

	// ProductName Name of the licensed product.
	ProductName string `json:"product_name"`

	// Status Status of the license.
	Status LicenseStatus `json:"status"`
}

// LicenseStatus Status of the license.
type LicenseStatus struct {
	Message string            `json:"message"`
	Status  LicenseStatusEnum `json:"status"`
}

// LicenseStatusEnum defines model for LicenseStatusEnum.
type LicenseStatusEnum string

// LimitConfig defines model for LimitConfig.
type LimitConfig struct {
	OperationLimits *OperationLimits `json:"operation_limits,omitempty"`
	PhysicalLimits  *LimitSet        `json:"physical_limits,omitempty"`
}

// LimitRange The upper_limit must be greater then the lower_limit.
type LimitRange struct {
	LowerLimit *float64 `json:"lower_limit,omitempty"`
	UpperLimit *float64 `json:"upper_limit,omitempty"`
}

// LimitSet defines model for LimitSet.
type LimitSet struct {
	Elbow  *CartesianLimits `json:"elbow,omitempty"`
	Flange *CartesianLimits `json:"flange,omitempty"`
	Joints *[]JointLimits   `json:"joints,omitempty"`
	Tcp    *CartesianLimits `json:"tcp,omitempty"`
}

// LimitsOverride If a limit is not set, the default value will be used.
type LimitsOverride struct {
	// JointAccelerationLimits Maximum joint acceleration in [rad/s^2] for each joint.
	// Either leave this field empty or set a value for each joint.
	JointAccelerationLimits *[]float64 `json:"joint_acceleration_limits,omitempty"`

	// JointVelocityLimits Maximum joint velocity in [rad/s] for each joint.
	// Either leave this field empty or set a value for each joint.
	JointVelocityLimits *[]float64 `json:"joint_velocity_limits,omitempty"`

	// TcpAccelerationLimit Maximum allowed TCP acceleration in [mm/s^2].
	TcpAccelerationLimit *float64 `json:"tcp_acceleration_limit,omitempty"`

	// TcpOrientationAccelerationLimit Maximum allowed TCP rotation acceleration in [rad/s^2].
	TcpOrientationAccelerationLimit *float64 `json:"tcp_orientation_acceleration_limit,omitempty"`

	// TcpOrientationVelocityLimit Maximum allowed TCP rotation velocity in [rad/s].
	TcpOrientationVelocityLimit *float64 `json:"tcp_orientation_velocity_limit,omitempty"`

	// TcpVelocityLimit Maximum allowed TCP velocity in [mm/s].
	TcpVelocityLimit *float64 `json:"tcp_velocity_limit,omitempty"`
}

// Link defines model for Link.
type Link map[string]Collider

// LinkChain A link chain is a kinematic chain of links that is connected via joints.
// A motion group can be used to control the motion of the joints in a link chain.
//
// A link is a group of colliders that is attached to the link reference frame.
//
// The reference frame of a link is obtained after applying all sets of Denavit-Hartenberg-parameters from base to (including) the link index.
//
// This means that the reference frame of the link is on the rotation axis of the next joint in the kinematic chain.
// Example: For a motion group with 2 joints, the collider reference frame (CRF) for link 1 is on the rotation axis of joint 2. The chain looks like:
// - Origin >> Mounting >> Base >> (CRF Base) Joint 0 >> Link 0 >> (CRF Link 0) Joint 1 >> Link 1 >> (CRF Link 1) Flange (CRF Tool) >> TCP
//
// Adjacent links in the kinematic chain of the motion group are not checked for mutual collision.
type LinkChain = []Link

// ListCoordinateSystemsResponse defines model for ListCoordinateSystemsResponse.
type ListCoordinateSystemsResponse = []CoordinateSystem

// ListIODescriptionsResponse defines model for ListIODescriptionsResponse.
type ListIODescriptionsResponse = []IODescription

// ListIOValuesResponse Array of input/output values.
type ListIOValuesResponse = []IOValue

// ListTrajectoriesResponse defines model for ListTrajectoriesResponse.
type ListTrajectoriesResponse struct {
	// Trajectories Identifiers of trajectories which are currently cached.
	// Use [addTrajectory](addTrajectory) to add a new trajectory. Adding trajectories is necessary to execute them.
	// Trajectories are removed if the corresponding motion group or controller disconnects.
	Trajectories *[]string `json:"trajectories,omitempty"`
}

// Manufacturer defines model for Manufacturer.
type Manufacturer string

// Metadata Additional metadata to add to the backup
type Metadata map[string]string

// MetadataObject A metadata object.
type MetadataObject map[string]string

// MidpointInsertionAlgorithm Midpoint insertion algorithm configuration for collision-free path planning.
// This algorithm iteratively inserts midpoints between the start and target joint position to find collision-free paths.
type MidpointInsertionAlgorithm struct {
	// AlgorithmName Algorithm discriminator.
	AlgorithmName string `json:"algorithm_name"`

	// MaxIterations Maximum number of iterations for the midpoint insertion algorithm.
	// Higher values increase likelyhood of success, but also computation time (linear).
	MaxIterations *int `json:"max_iterations,omitempty"`
}

// MotionCommand defines model for MotionCommand.
type MotionCommand struct {
	// Blending Blending alters the TCP path at the target point of a motion command
	// to ensure that the velocity does not drop to zero between two motion commands.
	Blending *MotionCommand_Blending `json:"blending,omitempty"`

	// LimitsOverride If a limit is not set, the default value will be used.
	LimitsOverride *LimitsOverride    `json:"limits_override,omitempty"`
	Path           MotionCommand_Path `json:"path"`
}

// MotionCommand_Blending Blending alters the TCP path at the target point of a motion command
// to ensure that the velocity does not drop to zero between two motion commands.
type MotionCommand_Blending struct {
	union json.RawMessage
}

// MotionCommand_Path defines model for MotionCommand.Path.
type MotionCommand_Path struct {
	union json.RawMessage
}

// MotionGroupDescription The configuration of a motion-group used for motion planning.
type MotionGroupDescription struct {
	// CycleTime [ms] cycle time of the motion group controller. A trajectory for this motion group should be computed to this resolution.
	CycleTime *uint32 `json:"cycle_time,omitempty"`

	// DhParameters The DH parameters describing the motion group geometry, starting from base.
	DhParameters *[]DHParameter `json:"dh_parameters,omitempty"`
	GlobalLimits LimitConfig    `json:"global_limits"`

	// MotionGroupModel String identifiying the model of a motion group.
	MotionGroupModel MotionGroupModel `json:"motion_group_model"`

	// Mounting Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	Mounting Pose `json:"mounting"`

	// Payloads Maps a payload name to its configuration. Key must be a payload identifier.
	// Values are payload objects.
	Payloads *map[string]Payload `json:"payloads,omitempty"`

	// SafetyLinkColliders The shape of the MotionGroups links to validate against safety zones.
	// Indexed along the kinematic chain, starting with a static base shape before first joint.
	SafetyLinkColliders *[]ColliderDictionary `json:"safety_link_colliders,omitempty"`

	// SafetyToolColliders Maps a TCP name to its tool collider. Key must be a TCP identifier.
	// Values are ColliderDictionaries that make up the shape of one tool to validate against safety zones.
	SafetyToolColliders *map[string]ColliderDictionary `json:"safety_tool_colliders,omitempty"`

	// SafetyZones A collection of identifiable colliders.
	SafetyZones *ColliderDictionary `json:"safety_zones,omitempty"`

	// Tcps Maps a TCP name to its offset relative to the flange coordinate system. Key must be a TCP identifier.
	// Values are TcpOffsets.
	Tcps map[string]TcpOffset `json:"tcps"`
}

// MotionGroupInfo defines model for MotionGroupInfo.
type MotionGroupInfo struct {
	// Dof The number of joints aka degrees of freedom in the motion group.
	Dof uint32 `json:"dof"`

	// MotionGroup The unique identifier of the motion group. Use it to refer to the motion group in other calls.
	MotionGroup string `json:"motion_group"`

	// Name The name of the motion group for display purposes.
	Name string `json:"name"`
}

// MotionGroupInfos defines model for MotionGroupInfos.
type MotionGroupInfos = []MotionGroupInfo

// MotionGroupJoints Ensure to provide one value for each joint. See [getMotionGroups](getMotionGroups) for the number of joints.
// Everything but positions is optional.
type MotionGroupJoints struct {
	// Accelerations The joint accelerations of the motion group.
	Accelerations *[]float64 `json:"accelerations,omitempty"`

	// Positions The joint positions of the motion group.
	Positions []float64 `json:"positions"`

	// Torques The joint torques of the motion group.
	Torques *[]float64 `json:"torques,omitempty"`

	// Velocities The joint velocities of the motion group.
	Velocities *[]float64 `json:"velocities,omitempty"`
}

// MotionGroupModel String identifiying the model of a motion group.
type MotionGroupModel = string

// MotionGroupSetup defines model for MotionGroupSetup.
type MotionGroupSetup struct {
	// CollisionSetups Collision layers to be respected by the motion planner when planning for a single motion group.
	// Each setup represents one layer, e.g. the safety zones and shapes or a fine grained tool and workpiece model.
	// Layers are checked individually along the trajectory and independently of other layers.
	//
	// To respect the safety zones of the controller and check for collision:
	// 1. Fetch the safety zones, link and tool shapes from the controller.
	// 2. Add the fetched zones, links and tools to a layer.
	// 3. Create other layers from your own 3D data as needed.
	// 4. Plan trajectory.
	// 5. The response highlights the layer in which a collision was detected by key.
	CollisionSetups *CollisionSetups `json:"collision_setups,omitempty"`

	// CycleTime [ms] cycle time of the motion group controller. A trajectory for this motion group should be computed to this resolution.
	CycleTime    uint32    `json:"cycle_time"`
	GlobalLimits *LimitSet `json:"global_limits,omitempty"`

	// MotionGroupModel String identifiying the model of a motion group.
	MotionGroupModel MotionGroupModel `json:"motion_group_model"`

	// Mounting Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	Mounting *Pose    `json:"mounting,omitempty"`
	Payload  *Payload `json:"payload,omitempty"`

	// TcpOffset Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TcpOffset *Pose `json:"tcp_offset,omitempty"`
}

// MotionGroupState Presents the current state of the motion group.
type MotionGroupState struct {
	// Controller Convenience: Identifier of the robot controller the motion group is attached to.
	Controller string `json:"controller"`

	// CoordinateSystem Unique identifier addressing the reference coordinate system of the cartesian data.
	// Might not be returned for positioners as some do not support TCPs, depending on the model.
	// Default: world coordinate system of corresponding controller.
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// Execute Details about the state of the motion execution.
	// The details are either for a jogging or a trajectory.
	// If NOVA is not controlling this motion group at the moment, this field is omitted.
	Execute *Execute `json:"execute,omitempty"`

	// FlangePose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	FlangePose *Pose `json:"flange_pose,omitempty"`

	// JointCurrent This structure describes a set of joint values (e.g. positions, currents, torques) of a motion group.
	//
	// Float precision is the default.
	JointCurrent *Joints `json:"joint_current,omitempty"`

	// JointLimitReached Indicates which joint of the motion group is in a limit.
	// If a joint is in its limit, only this joint can be moved. Movements that affect any other joints are not executed.
	JointLimitReached MotionGroupStateJointLimitReached `json:"joint_limit_reached"`

	// JointPosition This structure describes a set of joint values (e.g. positions, currents, torques) of a motion group.
	//
	// Float precision is the default.
	JointPosition Joints `json:"joint_position"`

	// JointTorque This structure describes a set of joint values (e.g. positions, currents, torques) of a motion group.
	//
	// Float precision is the default.
	JointTorque *Joints `json:"joint_torque,omitempty"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// Payload Unique identifier addressing the active payload.
	// Only fetchable via GET endpoint, not available in WebSocket.
	Payload *string `json:"payload,omitempty"`

	// SequenceNumber Sequence number of the controller state. It starts with 0 upon establishing the connection with a physical controller.
	// The sequence number is reset when the connection to the physical controller is closed and re-established.
	SequenceNumber uint32 `json:"sequence_number"`

	// Standstill Indicates whether the motion group is in standstill.
	// Convenience: Signals that NOVA treats measured joint velocities as 0.
	Standstill bool `json:"standstill"`

	// Tcp Unique identifier addressing the active TCP.
	// Might not be returned for positioners as some do not support TCPs, depending on the model.
	Tcp *string `json:"tcp,omitempty"`

	// TcpPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TcpPose *Pose `json:"tcp_pose,omitempty"`

	// Timestamp Timestamp for when data was received from the robot controller.
	Timestamp time.Time `json:"timestamp"`
}

// MotionGroupStateJointLimitReached Indicates which joint of the motion group is in a limit.
// If a joint is in its limit, only this joint can be moved. Movements that affect any other joints are not executed.
type MotionGroupStateJointLimitReached struct {
	// LimitReached If true, operational (soft) jointLimit is reached for specific joint.
	LimitReached []bool `json:"limit_reached"`
}

// MovementErrorResponse Error message in case an error occurs during movement execution.
type MovementErrorResponse struct {
	Kind MovementErrorResponseKind `json:"kind"`

	// Message Detailed error message describing the issue encountered during movement execution.
	Message string `json:"message"`
}

// MovementErrorResponseKind defines model for MovementErrorResponse.Kind.
type MovementErrorResponseKind string

// NameList A list of names
type NameList = []string

// NanValue defines model for NanValue.
type NanValue struct {
	// NanValue Requested joint position contains NaN values.
	NanValue *struct {
		// JointPosition The joint position that is out of its limits.
		JointPosition *[]float64 `json:"joint_position,omitempty"`
	} `json:"nan_value,omitempty"`
}

// OpMode Controllers have two operating modes: AUTOMATIC and MANUAL.
// MANUAL mode is mainly used for teaching a robot application.
// To ensure safe operation the velocity of the robot is limited to 250 mm/s.
// Running the finished application is done in AUTOMATIC operating mode without the limited velocity of the MANUAL mode.
type OpMode struct {
	// Mode Current operation mode of the configured robot controller.
	// Operation modes in which the attached motion groups can be moved are:
	// - OPERATION_MODE_MANUAL (if enabling switch is pressed)
	// - OPERATION_MODE_MANUAL_T1 (if enabling switch is pressed)
	// - OPERATION_MODE_MANUAL_T2 (if enabling switch is pressed)
	// - OPERATION_MODE_AUTO (without needing to press enabling switch)
	// All other modes are considered as non-operational.
	Mode OperationMode `json:"mode"`
}

// OperatingState The operating state.
type OperatingState string

// OperationLimits defines model for OperationLimits.
type OperationLimits struct {
	AutoLimits     *LimitSet `json:"auto_limits,omitempty"`
	ManualLimits   *LimitSet `json:"manual_limits,omitempty"`
	ManualT1Limits *LimitSet `json:"manual_t1_limits,omitempty"`
	ManualT2Limits *LimitSet `json:"manual_t2_limits,omitempty"`
}

// OperationMode Current operation mode of the configured robot controller.
// Operation modes in which the attached motion groups can be moved are:
// - OPERATION_MODE_MANUAL (if enabling switch is pressed)
// - OPERATION_MODE_MANUAL_T1 (if enabling switch is pressed)
// - OPERATION_MODE_MANUAL_T2 (if enabling switch is pressed)
// - OPERATION_MODE_AUTO (without needing to press enabling switch)
// All other modes are considered as non-operational.
type OperationMode string

// Orientation Describes an orientation in 3D space.
// A tree-to-four-dimensional vector [x, y, z, w] with double precision.
type Orientation = []float64

// OrientationType The type of rotation description that is used to specify the orientation.
//
// **Rotation Vector notation**
//
// * The rotation is represented using an axis-angle representation:
// > axis = Vector[0:2]
// > angle = |axis| in [rad]
// > axis.normalized * angle
//
// **Quaternion notation**
//
// * The rotation is represented using a unit quaternion: [x, y, z, w].
// * The vector part [x, y, z] is the imaginary part of the quaternion, and the scalar part [w] is the real part.
//
// **Euler notation**
//
// * *extrinsic* fixed external reference system
// * *intrinsic* reference system fixed to rotation body
// > angles = Vector[0:2] in [rad].
// * ZYX, ZXZ,...
//   - mapping of the given angles values to the (either intrinsic
//     or extrinsic) axes in the stated order.
//     > Example ZYX: Z = Vector[0], Y = Vector[1], X = Vector[2].
type OrientationType string

// PathCartesianPTP A cartesian point-to-point is representing a joint point-to-point motion from start point to the indicated target pose.
// The target pose is a joint point-to-point given in cartesian space. The target joint configuration will be calculated
// to be in the same kinematic configuration as the start point is. If that is not possible, planning will fail.
type PathCartesianPTP struct {
	PathDefinitionName string `json:"path_definition_name"`

	// TargetPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TargetPose Pose `json:"target_pose"`
}

// PathCircle A circular constructs a circle in translative space from 1) the start position which is provided via position, and 2) the indicated target position.
// The orientation is calculated via a [bezier spline](https://en.wikipedia.org/wiki/B%C3%A9zier_curve) from start orientation to the indicated target orientation.
// The via point defines the control point for the bezier spline.
// Therefore, the control point will not be hit directly.
type PathCircle struct {
	PathDefinitionName string `json:"path_definition_name"`

	// TargetPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TargetPose Pose `json:"target_pose"`

	// ViaPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	ViaPose Pose `json:"via_pose"`
}

// PathCubicSpline A [cubic spline](https://de.wikipedia.org/wiki/Spline-Interpolation) represents a cartesian cubic spline
// in translative and orientational space from start point to indicated target pose via control points.
type PathCubicSpline struct {
	Parameters         []CubicSplineParameter `json:"parameters"`
	PathDefinitionName string                 `json:"path_definition_name"`
}

// PathJointPTP A joint point-to-point represents a line in joint space. All joints will be moved synchronously.
type PathJointPTP struct {
	PathDefinitionName  string      `json:"path_definition_name"`
	TargetJointPosition DoubleArray `json:"target_joint_position"`
}

// PathLine A line represents a straight line from start position to indicated target position.
// The orientation is calculated via a quaternion [slerp](https://en.wikipedia.org/wiki/Slerp) from start orientation to indicated target orientation.
type PathLine struct {
	PathDefinitionName string `json:"path_definition_name"`

	// TargetPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TargetPose Pose `json:"target_pose"`
}

// PauseJoggingRequest Request to pause jogging. If successful, `execute` jogging state in [MotionGroupState](MotionGroupState.yaml) is set to `PAUSED_BY_USER`.
type PauseJoggingRequest struct {
	// MessageType Type specifier for server, set automatically.
	MessageType *PauseJoggingRequestMessageType `json:"message_type,omitempty"`
}

// PauseJoggingRequestMessageType Type specifier for server, set automatically.
type PauseJoggingRequestMessageType string

// PauseJoggingResponse Acknowledgment to a PauseJoggingRequest.
type PauseJoggingResponse struct {
	Kind PauseJoggingResponseKind `json:"kind"`

	// Message Error message in case of invalid PauseJoggingRequest.
	Message *string `json:"message,omitempty"`
}

// PauseJoggingResponseKind defines model for PauseJoggingResponse.Kind.
type PauseJoggingResponseKind string

// PauseMovementRequest Request to pause the movement execution. Movement pauses as soon as a [Standstill](Standstill.yaml) is sent back to the client.
// Resume movement with StartMovementRequest.
type PauseMovementRequest struct {
	// MessageType Type specifier for server, set automatically.
	MessageType *PauseMovementRequestMessageType `json:"message_type,omitempty"`
}

// PauseMovementRequestMessageType Type specifier for server, set automatically.
type PauseMovementRequestMessageType string

// PauseMovementResponse Acknowledgment for PauseMovementRequest message.
// ATTENTION: No confirmation that the movement was paused. Confirmation that the PauseMovementRequest was received and is processed.
//
//	End of movement execution is signalled by [StillstandResponse](StillstandResponse).
type PauseMovementResponse struct {
	Kind PauseMovementResponseKind `json:"kind"`

	// Message Error message in case of invalid PauseMovementResquest.
	Message *string `json:"message,omitempty"`
}

// PauseMovementResponseKind defines model for PauseMovementResponse.Kind.
type PauseMovementResponseKind string

// PauseOnIO Defines an input/output that the motion will be paused for. The motion will stop gracefully on path.
type PauseOnIO struct {
	// Comparator Comparator for the comparison of two values.
	// The comparator is used to compare two values and return a boolean result.
	// The default comparator is unknown.
	Comparator Comparator `json:"comparator"`
	Io         IOValue    `json:"io"`
}

// Payload defines model for Payload.
type Payload struct {
	// CenterOfMass A three-dimensional vector [x, y, z] with double precision.
	CenterOfMass *Vector3d `json:"center_of_mass,omitempty"`

	// MomentOfInertia A three-dimensional vector [x, y, z] with double precision.
	MomentOfInertia *Vector3d `json:"moment_of_inertia,omitempty"`
	Name            string    `json:"name"`

	// Payload Mass of payload in [kg].
	Payload float64 `json:"payload"`
}

// Plan422Response defines model for Plan422Response.
type Plan422Response struct {
	Detail *[]PlanValidationError `json:"detail,omitempty"`
}

// PlanCollisionFreeFailedResponse Response when collision-free trajectory planning fails.
// Contains specific feedback about why the planning failed.
type PlanCollisionFreeFailedResponse struct {
	// ErrorFeedback The collision-free planning algorithm reached its maximum iteration limit
	// without finding a valid path. Increase max_iterations or
	// modify the start/target positions.
	ErrorFeedback ErrorMaxIterationsExceeded `json:"error_feedback"`
}

// PlanCollisionFreeRequest defines model for PlanCollisionFreeRequest.
type PlanCollisionFreeRequest struct {
	// Algorithm Configuration for collision-free path planning algorithms.
	// Different algorithms may have different parameters and behavior.
	Algorithm          CollisionFreeAlgorithm `json:"algorithm"`
	MotionGroupSetup   MotionGroupSetup       `json:"motion_group_setup"`
	StartJointPosition DoubleArray            `json:"start_joint_position"`
	Target             DoubleArray            `json:"target"`
}

// PlanCollisionFreeResponse Response from collision-free trajectory planning.
// Contains either a successful joint trajectory or failure information.
type PlanCollisionFreeResponse struct {
	Response PlanCollisionFreeResponse_Response `json:"response"`
}

// PlanCollisionFreeResponse_Response defines model for PlanCollisionFreeResponse.Response.
type PlanCollisionFreeResponse_Response struct {
	union json.RawMessage
}

// PlanTrajectoryFailedResponse defines model for PlanTrajectoryFailedResponse.
type PlanTrajectoryFailedResponse struct {
	ErrorFeedback             PlanTrajectoryFailedResponse_ErrorFeedback `json:"error_feedback"`
	ErrorLocationOnTrajectory *float64                                   `json:"error_location_on_trajectory,omitempty"`
	JointTrajectory           *JointTrajectory                           `json:"joint_trajectory,omitempty"`
}

// PlanTrajectoryFailedResponse_ErrorFeedback defines model for PlanTrajectoryFailedResponse.ErrorFeedback.
type PlanTrajectoryFailedResponse_ErrorFeedback struct {
	union json.RawMessage
}

// PlanTrajectoryRequest defines model for PlanTrajectoryRequest.
type PlanTrajectoryRequest struct {
	// MotionCommands List of motion commands. A command consists of a path definition (line, circle, joint_ptp, cartesian_ptp, cubic_spline), blending, and limits override.
	MotionCommands     []MotionCommand  `json:"motion_commands"`
	MotionGroupSetup   MotionGroupSetup `json:"motion_group_setup"`
	StartJointPosition DoubleArray      `json:"start_joint_position"`
}

// PlanTrajectoryResponse defines model for PlanTrajectoryResponse.
type PlanTrajectoryResponse struct {
	Response PlanTrajectoryResponse_Response `json:"response"`
}

// PlanTrajectoryResponse_Response defines model for PlanTrajectoryResponse.Response.
type PlanTrajectoryResponse_Response struct {
	union json.RawMessage
}

// PlanValidationError defines model for PlanValidationError.
type PlanValidationError struct {
	// Data Optional data further specifying the validation error.
	Data  *PlanValidationError_Data      `json:"data,omitempty"`
	Input map[string]interface{}         `json:"input"`
	Loc   []PlanValidationError_Loc_Item `json:"loc"`
	Msg   string                         `json:"msg"`
	Type  string                         `json:"type"`
}

// PlanValidationError_Data Optional data further specifying the validation error.
type PlanValidationError_Data struct {
	union json.RawMessage
}

// PlanValidationErrorLoc0 defines model for .
type PlanValidationErrorLoc0 = string

// PlanValidationErrorLoc1 defines model for .
type PlanValidationErrorLoc1 = int

// PlanValidationError_Loc_Item defines model for PlanValidationError.loc.Item.
type PlanValidationError_Loc_Item struct {
	union json.RawMessage
}

// Plane Defines an x/y-plane with infinite size.
type Plane struct {
	ShapeType string `json:"shape_type"`
}

// PlaybackSpeedRequest Sets velocity for executed movements of the motion, in percent. Send after initializing the connection with InitializeMovementRequest.
type PlaybackSpeedRequest struct {
	// MessageType Type specifier for server, set automatically.
	MessageType *PlaybackSpeedRequestMessageType `json:"message_type,omitempty"`

	// PlaybackSpeedInPercent Sets velocity for executed movements of the trajectory, in percent. 100% means that the motion group moves as
	// fast as possible without violating any planning and motion group limits. Setting this value does not affect the overall shape of the velocity profile.
	// The velocity profile of the trajectory is scaled down by the same factor. Therefore, this should only be used for teaching and trajectory
	// evaluation purposes. To maintain a specific velocity, set the respective limits when planning the trajectory.
	PlaybackSpeedInPercent uint32 `json:"playback_speed_in_percent"`
}

// PlaybackSpeedRequestMessageType Type specifier for server, set automatically.
type PlaybackSpeedRequestMessageType string

// PlaybackSpeedResponse Acknowledgment for PlaybackSpeedRequest message.
type PlaybackSpeedResponse struct {
	Kind PlaybackSpeedResponseKind `json:"kind"`

	// Message Error message in case of invalid PlaybackSpeedRequest.
	Message *string `json:"message,omitempty"`
}

// PlaybackSpeedResponseKind defines model for PlaybackSpeedResponse.Kind.
type PlaybackSpeedResponseKind string

// Pose Defines a pose in 3D space.
// A pose is a combination of a position and an orientation.
// The position is applied before the orientation.
type Pose struct {
	// Orientation Defines a rotation in 3D space.
	// A three-dimensional Vector [rx, ry, rz] with double precision.
	// Rotation is applied around the vector.
	// The angle of rotation equals the length of the vector.
	Orientation *RotationVector `json:"orientation,omitempty"`

	// Position A three-dimensional vector [x, y, z] with double precision.
	Position *Vector3d `json:"position,omitempty"`
}

// ProfinetDescription defines model for ProfinetDescription.
type ProfinetDescription struct {
	// DeviceId The device identifier of the PROFINET device, identifying the specific device within the vendor's range.
	DeviceId string `json:"device_id"`

	// DeviceName Name of the PROFINET device
	DeviceName *string `json:"device_name,omitempty"`

	// Ip IP address for the PROFINET device
	Ip    *string                    `json:"ip,omitempty"`
	Slots *[]ProfinetSlotDescription `json:"slots,omitempty"`

	// VendorId The vendor identifier of the PROFINET device, identifying the manufacturer.
	VendorId string `json:"vendor_id"`
}

// ProfinetIO defines model for ProfinetIO.
type ProfinetIO struct {
	// BitAddress The bit address of the input/output value within the byte or word address.
	// The bit address is used to specify the exact bit within the byte or word that corresponds to the input/output value.
	BitAddress *uint8 `json:"bit_address,omitempty"`

	// ByteAddress The byte address of the input/output value in the PROFINET device.
	// The byte address is used to locate the specific input/output within the device's memory or data structure.
	ByteAddress uint16 `json:"byte_address"`

	// Direction Identifies the input/output type.
	Direction ProfinetIODirection `json:"direction"`

	// Io The unique identifier for the input/output value.
	// This identifier is used to reference the specific input/output in the NOVA system.
	Io string `json:"io"`

	// Name The name of the input/output value. This is a human-readable identifier for the value.
	// It can be used to distinguish between different inputs/outputs in the system.
	Name string `json:"name"`

	// Type Value type of the PROFINET input/output.
	Type ProfinetIOTypeEnum `json:"type"`
}

// ProfinetIOData defines model for ProfinetIOData.
type ProfinetIOData struct {
	// BitAddress The bit address of the input/output value within the byte or word address.
	// The bit address is used to specify the exact bit within the byte or word that corresponds to the input/output value.
	BitAddress *uint8 `json:"bit_address,omitempty"`

	// ByteAddress The byte address of the input/output value in the PROFINET device.
	// The byte address is used to locate the specific input/output within the device's memory or data structure.
	ByteAddress uint16 `json:"byte_address"`

	// Direction Identifies the input/output type.
	Direction ProfinetIODirection `json:"direction"`

	// Name The name of the input/output value. This is a human-readable identifier for the value.
	// It can be used to distinguish between different inputs/outputs in the system.
	Name string `json:"name"`

	// Type Value type of the PROFINET input/output.
	Type ProfinetIOTypeEnum `json:"type"`
}

// ProfinetIODirection Identifies the input/output type.
type ProfinetIODirection string

// ProfinetIOTypeEnum Value type of the PROFINET input/output.
type ProfinetIOTypeEnum string

// ProfinetIOs Array of PROFINET inputs and outputs.
type ProfinetIOs = []ProfinetIO

// ProfinetInputOutputConfig defines model for ProfinetInputOutputConfig.
type ProfinetInputOutputConfig struct {
	// Config Content of the input output configuration file.
	Config string `json:"config"`

	// InputOffset Offset in bytes for the input data.
	InputOffset uint32 `json:"input_offset"`

	// OutputOffset Offset in bytes for the output data.
	OutputOffset uint32 `json:"output_offset"`
}

// ProfinetSlotDescription defines model for ProfinetSlotDescription.
type ProfinetSlotDescription struct {
	// Api The API number of the PROFINET input, used to identify the specific API for the input.
	Api uint32 `json:"api"`

	// Number The number of the PROFINET slot.
	Number uint32 `json:"number"`

	// Subslots An array of PROFINET subslots.
	Subslots []ProfinetSubSlotDescription `json:"subslots"`
}

// ProfinetSubSlotDescription defines model for ProfinetSubSlotDescription.
type ProfinetSubSlotDescription struct {
	// InputLength The length in bytes of the PROFINET input.
	InputLength uint32 `json:"input_length"`

	// Number The identifier of the PROFINET subslot.
	Number uint32 `json:"number"`

	// OutputLength The length in bytes of the PROFINET output.
	OutputLength uint32 `json:"output_length"`
}

// RRTConnectAlgorithm <!-- theme: danger -->
//
// > **Experimental**
//
// RRT Connect algorithm configuration for collision-free path planning.
// Rapidly-exploring Random Trees (RRT) builds trees of valid configurations by randomly sampling
// the joint space and connecting feasible points. RRT Connect grows two trees simultaneously
// from start and target positions until they meet. This is a custom implementation optimized
// for manipulator kinematics and collision checking in industrial contexts.
type RRTConnectAlgorithm struct {
	// AlgorithmName Algorithm discriminator.
	AlgorithmName string `json:"algorithm_name"`

	// MaxIterations Maximum number of iterations for the RRT Connect algorithm.
	// Higher values increase likelihood of success, but also computation time.
	MaxIterations *int `json:"max_iterations,omitempty"`
}

// Rectangle Defines an x/y-plane with finite size. Centred around the z-axis.
type Rectangle struct {
	ShapeType string `json:"shape_type"`

	// SizeX The dimension in x-direction in [mm].
	SizeX float64 `json:"size_x"`

	// SizeY The dimension in y-direction in [mm].
	SizeY float64 `json:"size_y"`
}

// RectangularCapsule Convex hull around four spheres. Sphere center points in x/y-plane, offset by either combination "+/- sizeX" or "+/- sizeY".
//
// Alternative description: Rectangle in x/y-plane with a 3D padding.
type RectangularCapsule struct {
	// Radius The radius of the inner spheres in [mm].
	Radius    float64 `json:"radius"`
	ShapeType string  `json:"shape_type"`

	// SphereCenterDistanceX The distance of the sphere center in x-direction in [mm].
	SphereCenterDistanceX float64 `json:"sphere_center_distance_x"`

	// SphereCenterDistanceY The distance of the sphere center in y-direction in [mm].
	SphereCenterDistanceY float64 `json:"sphere_center_distance_y"`
}

// ReleaseChannel The channel that defines what a new Wandelbots NOVA version is.
//
//   - `next` the over all latest version
//   - `stable` newes patch of the current version
type ReleaseChannel string

// RobotController The configuration of a physical or virtual robot controller.
type RobotController struct {
	Configuration ControllerConfig `json:"configuration"`

	// Name Unique name of controller within the cell.
	// It must be a valid k8s label name as defined by [RFC 1035](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#rfc-1035-label-names).
	Name string `json:"name"`
}

// ControllerConfig defines model for .
type ControllerConfig struct {
	union json.RawMessage
}

// RobotControllerState Returns the whole current state of robot controller.
type RobotControllerState struct {
	// Controller Identifier of the configured robot controller.
	Controller string `json:"controller"`

	// LastError Last error stack encountered during initialization process or after a controller disconnect.
	// At this stage, it's unclear whether the error is fatal.
	//
	// Evaluate `last_error` to decide whether to remove the controller using `deleteController`.
	// Examples:
	// - Delete required: Host resolution fails repeatedly due to an incorrect IP.
	// - Delete not required: Temporary network delay caused a disconnect; the system will auto-reconnect.
	LastError *[]string `json:"last_error,omitempty"`

	// Mode Defines the current system mode of the robot system, including NOVA communicating with the robot controller.
	//
	// ### MODE_CONTROLLER_NOT_CONFIGURED
	//
	// No controller with the specified identifier is configured. Call [addRobotController](addRobotController) to register a controller.
	//
	// ### MODE_INITIALIZING
	//
	// Indicates that a connection to the robot controller is established or reestablished in case of a disconnect.
	// On success, the controller is set to MODE_MONITOR.
	// On failure, the initialization process is retried until successful or cancelled by the user.
	//
	// ### MODE_MONITOR
	//
	// Read-only mode with an active controller connection.
	// - Receives robot state and I/O signals
	// - Move requests are rejected
	// - No commands are sent to the controller
	//
	// ### MODE_CONTROL
	//
	// Active control mode.
	//
	// **Movement is possible in this mode**
	//
	// The robot is cyclically commanded to hold its current position.
	// The robot state is received in sync with the controller cycle.
	// Motion and jogging requests are accepted and executed.
	// Input/Output interaction is enabled.
	//
	// ### MODE_FREE_DRIVE
	//
	// Read-only mode with servo motors enabled for manual movement (Free Drive).
	//
	// Move requests are rejected.
	//
	// Not supported by all robots: Use [getSupportedModes](getSupportedModes) to check Free Drive availability.
	Mode RobotSystemMode `json:"mode"`

	// MotionGroups State of indicated motion groups.
	// In case of state request via controller all configured motion groups are returned.
	// In case of executing a motion only the affected motion groups are returned.
	MotionGroups []MotionGroupState `json:"motion_groups"`

	// OperationMode Current operation mode of the configured robot controller.
	// Operation modes in which the attached motion groups can be moved are:
	// - OPERATION_MODE_MANUAL (if enabling switch is pressed)
	// - OPERATION_MODE_MANUAL_T1 (if enabling switch is pressed)
	// - OPERATION_MODE_MANUAL_T2 (if enabling switch is pressed)
	// - OPERATION_MODE_AUTO (without needing to press enabling switch)
	// All other modes are considered as non-operational.
	OperationMode OperationMode `json:"operation_mode"`

	// SafetyState Current safety state of the configured robot controller.
	// Operation modes in which the attached motion groups can be moved are:
	// - SAFETY_STATE_NORMAL
	// - SAFETY_STATE_REDUCED
	// All other modes are considered as non-operational.
	SafetyState SafetyStateType `json:"safety_state"`

	// SequenceNumber Sequence number of the controller state. It starts with 0 upon establishing the connection with a physical controller.
	// The sequence number is reset when the connection to the physical controller is closed and re-established.
	SequenceNumber uint32 `json:"sequence_number"`

	// Timestamp Timestamp indicating when the represented information was received from the robot controller.
	Timestamp time.Time `json:"timestamp"`

	// VelocityOverride If made available by the robot controller, returns the current velocity override in
	// [percentage] for movements adjusted on robot control panel.
	// Valid value range: 1 - 100.
	VelocityOverride *uint32 `json:"velocity_override,omitempty"`
}

// RobotSystemMode Defines the current system mode of the robot system, including NOVA communicating with the robot controller.
//
// ### MODE_CONTROLLER_NOT_CONFIGURED
//
// No controller with the specified identifier is configured. Call [addRobotController](addRobotController) to register a controller.
//
// ### MODE_INITIALIZING
//
// Indicates that a connection to the robot controller is established or reestablished in case of a disconnect.
// On success, the controller is set to MODE_MONITOR.
// On failure, the initialization process is retried until successful or cancelled by the user.
//
// ### MODE_MONITOR
//
// Read-only mode with an active controller connection.
// - Receives robot state and I/O signals
// - Move requests are rejected
// - No commands are sent to the controller
//
// ### MODE_CONTROL
//
// Active control mode.
//
// **Movement is possible in this mode**
//
// The robot is cyclically commanded to hold its current position.
// The robot state is received in sync with the controller cycle.
// Motion and jogging requests are accepted and executed.
// Input/Output interaction is enabled.
//
// ### MODE_FREE_DRIVE
//
// Read-only mode with servo motors enabled for manual movement (Free Drive).
//
// Move requests are rejected.
//
// Not supported by all robots: Use [getSupportedModes](getSupportedModes) to check Free Drive availability.
type RobotSystemMode string

// RobotTcp defines model for RobotTcp.
type RobotTcp struct {
	// Id Identifier of this tcp.
	Id string `json:"id"`

	// Name A readable and changeable name for frontend visualization.
	Name *string `json:"name,omitempty"`

	// Orientation Describes an orientation in 3D space.
	// A tree-to-four-dimensional vector [x, y, z, w] with double precision.
	Orientation *Orientation `json:"orientation,omitempty"`

	// OrientationType The type of rotation description that is used to specify the orientation.
	//
	// **Rotation Vector notation**
	//
	// * The rotation is represented using an axis-angle representation:
	// > axis = Vector[0:2]
	// > angle = |axis| in [rad]
	// > axis.normalized * angle
	//
	// **Quaternion notation**
	//
	// * The rotation is represented using a unit quaternion: [x, y, z, w].
	// * The vector part [x, y, z] is the imaginary part of the quaternion, and the scalar part [w] is the real part.
	//
	// **Euler notation**
	//
	// * *extrinsic* fixed external reference system
	// * *intrinsic* reference system fixed to rotation body
	// > angles = Vector[0:2] in [rad].
	// * ZYX, ZXZ,...
	//   - mapping of the given angles values to the (either intrinsic
	//     or extrinsic) axes in the stated order.
	//  > Example ZYX: Z = Vector[0], Y = Vector[1], X = Vector[2].
	OrientationType *OrientationType `json:"orientation_type,omitempty"`

	// Position A three-dimensional vector [x, y, z] with double precision.
	Position Vector3d `json:"position"`
}

// RobotTcpData defines model for RobotTcpData.
type RobotTcpData struct {
	// Name A readable and changeable name for frontend visualization.
	Name *string `json:"name,omitempty"`

	// Orientation Describes an orientation in 3D space.
	// A tree-to-four-dimensional vector [x, y, z, w] with double precision.
	Orientation *Orientation `json:"orientation,omitempty"`

	// OrientationType The type of rotation description that is used to specify the orientation.
	//
	// **Rotation Vector notation**
	//
	// * The rotation is represented using an axis-angle representation:
	// > axis = Vector[0:2]
	// > angle = |axis| in [rad]
	// > axis.normalized * angle
	//
	// **Quaternion notation**
	//
	// * The rotation is represented using a unit quaternion: [x, y, z, w].
	// * The vector part [x, y, z] is the imaginary part of the quaternion, and the scalar part [w] is the real part.
	//
	// **Euler notation**
	//
	// * *extrinsic* fixed external reference system
	// * *intrinsic* reference system fixed to rotation body
	// > angles = Vector[0:2] in [rad].
	// * ZYX, ZXZ,...
	//   - mapping of the given angles values to the (either intrinsic
	//     or extrinsic) axes in the stated order.
	//  > Example ZYX: Z = Vector[0], Y = Vector[1], X = Vector[2].
	OrientationType *OrientationType `json:"orientation_type,omitempty"`

	// Position A three-dimensional vector [x, y, z] with double precision.
	Position Vector3d `json:"position"`
}

// RobotTcps defines model for RobotTcps.
type RobotTcps = []RobotTcp

// RotationVector Defines a rotation in 3D space.
// A three-dimensional Vector [rx, ry, rz] with double precision.
// Rotation is applied around the vector.
// The angle of rotation equals the length of the vector.
type RotationVector = []float64

// SafetyStateType Current safety state of the configured robot controller.
// Operation modes in which the attached motion groups can be moved are:
// - SAFETY_STATE_NORMAL
// - SAFETY_STATE_REDUCED
// All other modes are considered as non-operational.
type SafetyStateType string

// ServiceGroup defines model for ServiceGroup.
type ServiceGroup string

// ServiceStatus defines model for ServiceStatus.
type ServiceStatus struct {
	Group   ServiceGroup `json:"group"`
	Service string       `json:"service"`
	Status  struct {
		Code     ServiceStatusPhase    `json:"code"`
		Reason   *string               `json:"reason,omitempty"`
		Severity ServiceStatusSeverity `json:"severity"`
	} `json:"status"`
}

// ServiceStatusList defines model for ServiceStatusList.
type ServiceStatusList = []ServiceStatus

// ServiceStatusPhase defines model for ServiceStatusPhase.
type ServiceStatusPhase string

// ServiceStatusResponse Response containing both the overall operating state of the cell and detailed status information for each service within the cell.
//
// The operating state indicates whether the cell is active or inactive, while the service statuses provide specific health and operational
// information for individual service running in the cell.
type ServiceStatusResponse struct {
	// OperatingState The operating state.
	OperatingState OperatingState    `json:"operating_state"`
	ServiceStatus  ServiceStatusList `json:"service_status"`
}

// ServiceStatusSeverity defines model for ServiceStatusSeverity.
type ServiceStatusSeverity string

// SettableRobotSystemMode defines model for SettableRobotSystemMode.
type SettableRobotSystemMode string

// SingularityTypeEnum defines model for SingularityTypeEnum.
type SingularityTypeEnum string

// Sphere Defines a spherical shape centred around the origin.
type Sphere struct {
	// Radius The radius of the sphere in [mm].
	Radius    float64 `json:"radius"`
	ShapeType string  `json:"shape_type"`
}

// StartMovementRequest Moves the motion group along a trajectory, added via [planTrajectory](planTrajectory) or [planMotion](planMotion).
// Trajectories can be executed forwards or backwards("in reverse").
//
// Pause the execution with PauseMovementRequest.
// Resume execution with StartMovementRequest.
//
// Precondition: To start execution, the motion group must be located at the trajectory's start location specified in InitializeMovementRequest.
type StartMovementRequest struct {
	// Direction The direction in which the trajectory is executed. Default: Forward.
	Direction *Direction `json:"direction,omitempty"`

	// MessageType Type specifier for server, set automatically.
	MessageType *StartMovementRequestMessageType `json:"message_type,omitempty"`

	// PauseOnIo Defines an input/output that the motion will be paused for. The motion will stop gracefully on path.
	PauseOnIo *PauseOnIO `json:"pause_on_io,omitempty"`

	// SetOutputs Attaches a list of output commands to the trajectory. The outputs are set to the specified values right after the specified location was reached.
	// If the specified location is located before the start location (forward direction: value is smaller, backward direction: value is bigger), the output is not set.
	SetOutputs *[]IOValue `json:"set_outputs,omitempty"`

	// StartOnIo Defines an input/output that the motion should wait for to start the execution.
	StartOnIo *StartOnIO `json:"start_on_io,omitempty"`
}

// StartMovementRequestMessageType Type specifier for server, set automatically.
type StartMovementRequestMessageType string

// StartMovementResponse Acknowledgment for StartMovementRequest message.
// ATTENTION: No confirmation that the movement was started. Confirmation that the StartMovementRequest was received and is processed.
// Fields `execute` and `standstill` of response of [streamMotionGroupState](streamMotionGroupState) signal start of movement execution.
type StartMovementResponse struct {
	Kind StartMovementResponseKind `json:"kind"`

	// Message Error message in case of invalid StartMovementResquest.
	Message *string `json:"message,omitempty"`
}

// StartMovementResponseKind defines model for StartMovementResponse.Kind.
type StartMovementResponseKind string

// StartOnIO Defines an input/output that the motion should wait for to start the execution.
type StartOnIO struct {
	// Comparator Comparator for the comparison of two values.
	// The comparator is used to compare two values and return a boolean result.
	// The default comparator is unknown.
	Comparator Comparator `json:"comparator"`
	Io         IOValue    `json:"io"`
}

// StreamIOValuesResponse Array of input/output values.
type StreamIOValuesResponse struct {
	IoValues []IOValue `json:"io_values"`

	// SequenceNumber Sequence number of the controller state. It starts with 0 upon establishing the connection with a physical controller.
	// The sequence number is reset when the connection to the physical controller is closed and re-established.
	SequenceNumber uint32 `json:"sequence_number"`

	// Timestamp Timestamp indicating when the represented information was received from the robot controller.
	Timestamp time.Time `json:"timestamp"`
}

// TcpOffset defines model for TcpOffset.
type TcpOffset struct {
	// Name A readable and changeable name for frontend visualization.
	Name string `json:"name"`

	// Pose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	Pose Pose `json:"pose"`
}

// TcpRequired Requested motion group requires TCP to be defined.
type TcpRequired struct {
	TcpMissing interface{} `json:"tcp_missing,omitempty"`
}

// TcpVelocityRequest Sets target TCP velocities for jogging a motion group.
// The motion group needs to have an inverse kinematic solver to be jogged by TCP velocities.
// Check `supports_inverse_kinematics` field in response of [listController](listController) for the motion group.
type TcpVelocityRequest struct {
	// MessageType Type specifier for server, set automatically.
	MessageType *TcpVelocityRequestMessageType `json:"message_type,omitempty"`

	// Rotation A three-dimensional vector [x, y, z] with double precision.
	Rotation Vector3d `json:"rotation"`

	// Translation A three-dimensional vector [x, y, z] with double precision.
	Translation Vector3d `json:"translation"`

	// UseToolCoordinateSystem If true, TCP velocities are interpreted in the tool coordinate system, specified by the TCP.
	// If false, TCP velocities are interpreted in the world coordinate system.
	UseToolCoordinateSystem *bool `json:"use_tool_coordinate_system,omitempty"`
}

// TcpVelocityRequestMessageType Type specifier for server, set automatically.
type TcpVelocityRequestMessageType string

// TcpVelocityResponse Acknowledgment to a TcpVelocityRequest.
type TcpVelocityResponse struct {
	Kind TcpVelocityResponseKind `json:"kind"`

	// Message Error message in case of invalid TcpVelocityRequest.
	Message *string `json:"message,omitempty"`
}

// TcpVelocityResponseKind defines model for TcpVelocityResponse.Kind.
type TcpVelocityResponseKind string

// Tool Defines the shape of a tool.
//
// A tool is a dictionary of colliders.
//
// All colliders that make up a tool are attached to the flange frame of the motion group.
type Tool map[string]Collider

// TorqueExceeded defines model for TorqueExceeded.
type TorqueExceeded struct {
	TorqueExceeded *struct {
		// TorqueLimit The value of the torque limit that was exceeded.
		TorqueLimit *float64 `json:"torque_limit,omitempty"`

		// TorqueValue The torque value that was exceeded.
		TorqueValue *float64 `json:"torque_value,omitempty"`
	} `json:"torque_exceeded,omitempty"`
}

// TrajectoryData defines model for TrajectoryData.
type TrajectoryData struct {
	Data JointTrajectory `json:"data"`

	// MessageType Type specifier for server, set automatically.
	MessageType TrajectoryDataMessageType `json:"message_type"`

	// MotionGroup Identifier of the motion-group.
	MotionGroup *string `json:"motion_group,omitempty"`

	// Tcp Unique identifier of the tool the trajectory is planned for.
	Tcp *string `json:"tcp,omitempty"`
}

// TrajectoryDataMessageType Type specifier for server, set automatically.
type TrajectoryDataMessageType string

// TrajectoryDetails State of trajectory execution.
// This state is sent during trajectory movement, response-rate closest to the nearest multiple of controller step-rate but not exceeding the configured rate.
// The trajectory state can be one of the following:
// - RUNNING: Trajectory is being executed.
// - PAUSED_BY_USER: User has paused execution.
// - END_OF_TRAJECTORY: First or last sample (depending on direction) of trajectory has been sent.
// - WAIT_FOR_IO: Waiting for an I/O event to start execution.
// - PAUSED_ON_IO: Execution was paused because of an I/O event.
type TrajectoryDetails struct {
	// Kind Discriminator for OpenApi generators, which is always "TRAJECTORY" for this schema.
	Kind TrajectoryDetailsKind `json:"kind"`

	// Location Current location of motion group on the trajectory.
	Location float64                 `json:"location"`
	State    TrajectoryDetails_State `json:"state"`

	// Trajectory Unique identifier of the trajectory being executed.
	Trajectory string `json:"trajectory"`
}

// TrajectoryDetailsKind Discriminator for OpenApi generators, which is always "TRAJECTORY" for this schema.
type TrajectoryDetailsKind string

// TrajectoryDetails_State defines model for TrajectoryDetails.State.
type TrajectoryDetails_State struct {
	union json.RawMessage
}

// TrajectoryEnded First or last sample (depending on direction) of trajectory has been sent.
type TrajectoryEnded struct {
	Kind TrajectoryEndedKind `json:"kind"`
}

// TrajectoryEndedKind defines model for TrajectoryEnded.Kind.
type TrajectoryEndedKind string

// TrajectoryPausedByUser User has paused execution.
type TrajectoryPausedByUser struct {
	Kind TrajectoryPausedByUserKind `json:"kind"`
}

// TrajectoryPausedByUserKind defines model for TrajectoryPausedByUser.Kind.
type TrajectoryPausedByUserKind string

// TrajectoryPausedOnIO Execution was paused because of an I/O event.
type TrajectoryPausedOnIO struct {
	Kind TrajectoryPausedOnIOKind `json:"kind"`
}

// TrajectoryPausedOnIOKind defines model for TrajectoryPausedOnIO.Kind.
type TrajectoryPausedOnIOKind string

// TrajectoryRunning Trajectory is being executed.
type TrajectoryRunning struct {
	Kind TrajectoryRunningKind `json:"kind"`

	// TimeToEnd Remaining time in milliseconds (ms) to reach the end of the motion.
	TimeToEnd uint32 `json:"time_to_end"`
}

// TrajectoryRunningKind defines model for TrajectoryRunning.Kind.
type TrajectoryRunningKind string

// TrajectoryWaitForIO Waiting for an I/O event to start execution.
type TrajectoryWaitForIO struct {
	Kind TrajectoryWaitForIOKind `json:"kind"`
}

// TrajectoryWaitForIOKind defines model for TrajectoryWaitForIO.Kind.
type TrajectoryWaitForIOKind string

// UnitType The unit of input/output value.
type UnitType string

// UniversalrobotsController The configuration of a physical Universal Robots controller has to contain IP address of the controller.
type UniversalrobotsController struct {
	ControllerIp string                        `json:"controller_ip"`
	Kind         UniversalrobotsControllerKind `json:"kind,omitempty"`
}

// UniversalrobotsControllerKind defines model for UniversalrobotsController.Kind.
type UniversalrobotsControllerKind string

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Input map[string]interface{}     `json:"input"`
	Loc   []ValidationError_Loc_Item `json:"loc"`
	Msg   string                     `json:"msg"`
	Type  string                     `json:"type"`
}

// ValidationErrorLoc0 defines model for .
type ValidationErrorLoc0 = string

// ValidationErrorLoc1 defines model for .
type ValidationErrorLoc1 = int

// ValidationError_Loc_Item defines model for ValidationError.loc.Item.
type ValidationError_Loc_Item struct {
	union json.RawMessage
}

// Vector3d A three-dimensional vector [x, y, z] with double precision.
type Vector3d = []float64

// VirtualController The configuration of a virtual robot controller has to contain the manufacturer string,
// an optional joint position string array and either a preset `type` **or** the complete JSON configuration.
type VirtualController struct {
	// InitialJointPosition Initial joint position of the first motion group from the virtual robot controller.
	// Provide the joint position as a JSON array containing 7 float values,
	// each representing a joint position in radians, e.g. "[0, 0, 0, 0, 0, 0, 0]". If the robot has fewer than 7 joints,
	// use "0" for each remaining position to ensure the array has exactly 7 values.
	InitialJointPosition *string `json:"initial_joint_position,omitempty"`

	// Json Complete JSON configuration of the virtual robot controller.
	// Can be obtained from the physical controller's configuration via [getVirtualControllerConfiguration](getVirtualControllerConfiguration).
	// If provided, the `type` field should not be used.
	Json         *string                 `json:"json,omitempty"`
	Kind         VirtualControllerKind   `json:"kind,omitempty"`
	Manufacturer Manufacturer            `json:"manufacturer"`
	Type         *VirtualControllerTypes `json:"type,omitempty"`
}

// VirtualControllerKind defines model for VirtualController.Kind.
type VirtualControllerKind string

// VirtualControllerTypes defines model for VirtualControllerTypes.
type VirtualControllerTypes string

// VirtualRobotConfiguration defines model for VirtualRobotConfiguration.
type VirtualRobotConfiguration struct {
	// Content Content of the configuration file. Copy & paste to the [addRobotController](addRobotController) configuration.json parameter.
	Content string `json:"content"`

	// Name Name of the configuration file generated by the unique identifier of the controller and a time stamp.
	Name string `json:"name"`
}

// WaitForIOEventRequest The value to compare with the current value of the input/output.
type WaitForIOEventRequest struct {
	// Comparator Comparator for the comparison of two values.
	// The comparator is used to compare two values and return a boolean result.
	// The default comparator is unknown.
	Comparator Comparator `json:"comparator"`
	Io         IOValue    `json:"io"`
}

// YaskawaController The configuration of a physical Yaskawa robot controller has to contain IP address of the controller.
type YaskawaController struct {
	ControllerIp string                `json:"controller_ip"`
	Kind         YaskawaControllerKind `json:"kind,omitempty"`
}

// YaskawaControllerKind defines model for YaskawaController.Kind.
type YaskawaControllerKind string

// AppID The name of the provided application.
// The name must be unique within the cell and is used as a identifier for addressing the application in all API calls, e.g. when updating the application.
type AppID = string

// CellID defines model for Cell.
type CellID = string

// ColliderID defines model for Collider.
type ColliderID = string

// ControllerID defines model for Controller.
type ControllerID = string

// CoordinateSystemID defines model for CoordinateSystem.
type CoordinateSystemID = string

// IOID defines model for IO.
type IOID = string

// ObjectKey Unique identifier describing to adress an object.
//
// Special characters, such as `;`, `/`, `?`, `:`, `@`, `=` and `&`, have to be URL encoded.
type ObjectKey = Key

// LinkChainID defines model for LinkChain.
type LinkChainID = string

// MetadataHeader A metadata object.
type MetadataHeader = MetadataObject

// MotionGroupID defines model for MotionGroup.
type MotionGroupID = string

// MotionGroupModelParameter defines model for MotionGroupModelParameter.
type MotionGroupModelParameter = string

// Resources defines model for Resources.
type Resources = []ConfigurationResourceId

// ResponseCoordinateSystem defines model for ResponseCoordinateSystem.
type ResponseCoordinateSystem = string

// ResponseRate defines model for ResponseRate.
type ResponseRate = uint32

// Setup defines model for Setup.
type Setup = string

// Tcp defines model for Tcp.
type Tcp = string

// CompletionTimeout The maximum time (**in seconds**) spent waiting until the operation is complete.
//
// If the parameter is set, the request will wait for completion until the specified time is up.
// For POST and PUT requests completion means that all resources are running and usable.
// For DELETE completion means that the deletion process is completed.
type CompletionTimeout = int

// ToolID defines model for Tool.
type ToolID = string

// Trajectory defines model for Trajectory.
type Trajectory = string

// BadRequest defines model for BadRequest.
type BadRequest = Error

// NotFound defines model for NotFound.
type NotFound = Error

// NotImplemented defines model for NotImplemented.
type NotImplemented = Error

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = Error

// DeployCellParams defines parameters for DeployCell.
type DeployCellParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// DeleteCellParams defines parameters for DeleteCell.
type DeleteCellParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// UpdateCellParams defines parameters for UpdateCell.
type UpdateCellParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// ClearAppsParams defines parameters for ClearApps.
type ClearAppsParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// AddAppParams defines parameters for AddApp.
type AddAppParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// DeleteAppParams defines parameters for DeleteApp.
type DeleteAppParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// UpdateAppParams defines parameters for UpdateApp.
type UpdateAppParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// ClearBusIOServiceParams defines parameters for ClearBusIOService.
type ClearBusIOServiceParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// AddBusIOServiceParams defines parameters for AddBusIOService.
type AddBusIOServiceParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// GetBusIOValuesParams defines parameters for GetBusIOValues.
type GetBusIOValuesParams struct {
	Ios *[]string `form:"ios,omitempty" json:"ios,omitempty"`
}

// SetBusIOValuesJSONBody defines parameters for SetBusIOValues.
type SetBusIOValuesJSONBody = []IOValue

// GetProfinetIOsFromFileParams defines parameters for GetProfinetIOsFromFile.
type GetProfinetIOsFromFileParams struct {
	InputOffset  *int32 `form:"input_offset,omitempty" json:"input_offset,omitempty"`
	OutputOffset *int32 `form:"output_offset,omitempty" json:"output_offset,omitempty"`
}

// ClearRobotControllersParams defines parameters for ClearRobotControllers.
type ClearRobotControllersParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// AddRobotControllerParams defines parameters for AddRobotController.
type AddRobotControllerParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// DeleteRobotControllerParams defines parameters for DeleteRobotController.
type DeleteRobotControllerParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// UpdateRobotControllerParams defines parameters for UpdateRobotController.
type UpdateRobotControllerParams struct {
	CompletionTimeout *CompletionTimeout `form:"completion_timeout,omitempty" json:"completion_timeout,omitempty"`
}

// ListCoordinateSystemsParams defines parameters for ListCoordinateSystems.
type ListCoordinateSystemsParams struct {
	OrientationType *OrientationType `form:"orientation_type,omitempty" json:"orientation_type,omitempty"`
}

// GetCoordinateSystemParams defines parameters for GetCoordinateSystem.
type GetCoordinateSystemParams struct {
	OrientationType *OrientationType `form:"orientation_type,omitempty" json:"orientation_type,omitempty"`
}

// ExecuteJoggingJSONBody defines parameters for ExecuteJogging.
type ExecuteJoggingJSONBody struct {
	union json.RawMessage
}

// ExecuteTrajectoryJSONBody defines parameters for ExecuteTrajectory.
type ExecuteTrajectoryJSONBody struct {
	union json.RawMessage
}

// StreamFreeDriveParams defines parameters for StreamFreeDrive.
type StreamFreeDriveParams struct {
	ResponseRate *uint32 `form:"response_rate,omitempty" json:"response_rate,omitempty"`
}

// ListIODescriptionsParams defines parameters for ListIODescriptions.
type ListIODescriptionsParams struct {
	Ios *[]string `form:"ios,omitempty" json:"ios,omitempty"`

	// Direction Return only inputs/outputs with the specified direction.
	Direction *IODirection `form:"direction,omitempty" json:"direction,omitempty"`

	// ValueType Return only inputs/outputs with the specified value type.
	ValueType *IOValueType `form:"value_type,omitempty" json:"value_type,omitempty"`

	// Group Return only inputs/outputs from the specified group.
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// StreamIOValuesParams defines parameters for StreamIOValues.
type StreamIOValuesParams struct {
	Ios *[]string `form:"ios,omitempty" json:"ios,omitempty"`
}

// ListIOValuesParams defines parameters for ListIOValues.
type ListIOValuesParams struct {
	Ios *[]string `form:"ios,omitempty" json:"ios,omitempty"`
}

// SetOutputValuesJSONBody defines parameters for SetOutputValues.
type SetOutputValuesJSONBody = []IOValue

// SetDefaultModeParams defines parameters for SetDefaultMode.
type SetDefaultModeParams struct {
	Mode SettableRobotSystemMode `form:"mode" json:"mode"`
}

// GetCurrentMotionGroupStateParams defines parameters for GetCurrentMotionGroupState.
type GetCurrentMotionGroupStateParams struct {
	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the responses should be converted.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `form:"response_coordinate_system,omitempty" json:"response_coordinate_system,omitempty"`
}

// StreamMotionGroupStateParams defines parameters for StreamMotionGroupState.
type StreamMotionGroupStateParams struct {
	// ResponseRate Update rate for the response message in milliseconds (ms). Default is 200 ms.
	// We recommend to use the step rate of the controller or a multiple of the step rate as NOVA updates the state in the controller's step rate as well.
	// Minimal response rate is the step rate of controller.
	ResponseRate *ResponseRate `form:"response_rate,omitempty" json:"response_rate,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the cartesian data of the responses should be converted.
	// Default is the world coordinate system.
	ResponseCoordinateSystem *ResponseCoordinateSystem `form:"response_coordinate_system,omitempty" json:"response_coordinate_system,omitempty"`
}

// StreamRobotControllerStateParams defines parameters for StreamRobotControllerState.
type StreamRobotControllerStateParams struct {
	ResponseRate         *uint32 `form:"response_rate,omitempty" json:"response_rate,omitempty"`
	AddControllerTimeout *uint32 `form:"add_controller_timeout,omitempty" json:"add_controller_timeout,omitempty"`
}

// SetCellStatusParams defines parameters for SetCellStatus.
type SetCellStatusParams struct {
	// OperatingState Set state of the cell. Active or inactive.
	OperatingState OperatingState `form:"operating_state" json:"operating_state"`
}

// StoreObjectMultipartBody defines parameters for StoreObject.
type StoreObjectMultipartBody struct {
	AnyValue interface{} `json:"any_value,omitempty"`
}

// StoreObjectParams defines parameters for StoreObject.
type StoreObjectParams struct {
	XMetadata *MetadataHeader `json:"X-Metadata,omitempty"`
}

// SetVirtualControllerBehaviorParams defines parameters for SetVirtualControllerBehavior.
type SetVirtualControllerBehaviorParams struct {
	Behavior *Behavior `form:"behavior,omitempty" json:"behavior,omitempty"`
}

// DeleteVirtualControllerCoordinateSystemParams defines parameters for DeleteVirtualControllerCoordinateSystem.
type DeleteVirtualControllerCoordinateSystemParams struct {
	// DeleteDependent If true, all dependent coordinate systems will be deleted as well.
	DeleteDependent *bool `form:"delete_dependent,omitempty" json:"delete_dependent,omitempty"`
}

// SetEmergencyStopParams defines parameters for SetEmergencyStop.
type SetEmergencyStopParams struct {
	Active *bool `form:"active,omitempty" json:"active,omitempty"`
}

// ListVirtualControllerIODescriptionsParams defines parameters for ListVirtualControllerIODescriptions.
type ListVirtualControllerIODescriptionsParams struct {
	Ios *[]string `form:"ios,omitempty" json:"ios,omitempty"`

	// Direction Return only inputs/outputs with the specified direction.
	Direction *IODirection `form:"direction,omitempty" json:"direction,omitempty"`

	// ValueType Return only inputs/outputs with the specified value type.
	ValueType *IOValueType `form:"value_type,omitempty" json:"value_type,omitempty"`

	// Group Return only inputs/outputs from the specified group.
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// ListIOsParams defines parameters for ListIOs.
type ListIOsParams struct {
	Ios []string `form:"ios" json:"ios"`
}

// SetIOValuesJSONBody defines parameters for SetIOValues.
type SetIOValuesJSONBody = []IOValue

// SetOperationModeParams defines parameters for SetOperationMode.
type SetOperationModeParams struct {
	Mode OperationMode `form:"mode" json:"mode"`
}

// ActivateLicenseJSONBody defines parameters for ActivateLicense.
type ActivateLicenseJSONBody struct {
	OwnerRefreshToken string `json:"owner_refresh_token"`
}

// BackupConfigurationParams defines parameters for BackupConfiguration.
type BackupConfigurationParams struct {
	// Resources List of resource identifiers to include in the retrieval.
	Resources *[]ConfigurationResourceId `form:"resources,omitempty" json:"resources,omitempty"`

	// Metadata Additional metadata to add to the backup
	Metadata *Metadata `form:"metadata,omitempty" json:"metadata,omitempty"`
}

// RestoreConfigurationParams defines parameters for RestoreConfiguration.
type RestoreConfigurationParams struct {
	// Resources List of resource identifiers to included in the backup and restore operations.
	Resources Resources `form:"resources" json:"resources"`
}

// GetConfigurationBackupStatusParams defines parameters for GetConfigurationBackupStatus.
type GetConfigurationBackupStatusParams struct {
	OperationId openapi_types.UUID `form:"operation_id" json:"operation_id"`
}

// CheckNovaVersionUpdateParams defines parameters for CheckNovaVersionUpdate.
type CheckNovaVersionUpdateParams struct {
	Channel ReleaseChannel `form:"channel" json:"channel"`
}

// UpdateNovaVersionJSONBody defines parameters for UpdateNovaVersion.
type UpdateNovaVersionJSONBody struct {
	// Channel The channel that defines what a new Wandelbots NOVA version is.
	//
	//   * `next` the over all latest version
	//   * `stable` newes patch of the current version
	Channel ReleaseChannel `json:"channel"`
}

// DeployCellJSONRequestBody defines body for DeployCell for application/json ContentType.
type DeployCellJSONRequestBody = Cell

// UpdateCellJSONRequestBody defines body for UpdateCell for application/json ContentType.
type UpdateCellJSONRequestBody = Cell

// AddAppJSONRequestBody defines body for AddApp for application/json ContentType.
type AddAppJSONRequestBody = App

// UpdateAppJSONRequestBody defines body for UpdateApp for application/json ContentType.
type UpdateAppJSONRequestBody = App

// AddBusIOServiceJSONRequestBody defines body for AddBusIOService for application/json ContentType.
type AddBusIOServiceJSONRequestBody = BusIOType

// SetBusIOValuesJSONRequestBody defines body for SetBusIOValues for application/json ContentType.
type SetBusIOValuesJSONRequestBody = SetBusIOValuesJSONBody

// SetProfinetIOsFromFileJSONRequestBody defines body for SetProfinetIOsFromFile for application/json ContentType.
type SetProfinetIOsFromFileJSONRequestBody = ProfinetInputOutputConfig

// AddProfinetIOJSONRequestBody defines body for AddProfinetIO for application/json ContentType.
type AddProfinetIOJSONRequestBody = ProfinetIOData

// AddRobotControllerJSONRequestBody defines body for AddRobotController for application/json ContentType.
type AddRobotControllerJSONRequestBody = RobotController

// UpdateRobotControllerJSONRequestBody defines body for UpdateRobotController for application/json ContentType.
type UpdateRobotControllerJSONRequestBody = RobotController

// ExecuteJoggingJSONRequestBody defines body for ExecuteJogging for application/json ContentType.
type ExecuteJoggingJSONRequestBody ExecuteJoggingJSONBody

// ExecuteTrajectoryJSONRequestBody defines body for ExecuteTrajectory for application/json ContentType.
type ExecuteTrajectoryJSONRequestBody ExecuteTrajectoryJSONBody

// SetOutputValuesJSONRequestBody defines body for SetOutputValues for application/json ContentType.
type SetOutputValuesJSONRequestBody = SetOutputValuesJSONBody

// WaitForIOEventJSONRequestBody defines body for WaitForIOEvent for application/json ContentType.
type WaitForIOEventJSONRequestBody = WaitForIOEventRequest

// AddTrajectoryJSONRequestBody defines body for AddTrajectory for application/json ContentType.
type AddTrajectoryJSONRequestBody = AddTrajectoryRequest

// ForwardKinematicsJSONRequestBody defines body for ForwardKinematics for application/json ContentType.
type ForwardKinematicsJSONRequestBody = ForwardKinematicsRequest

// InverseKinematicsJSONRequestBody defines body for InverseKinematics for application/json ContentType.
type InverseKinematicsJSONRequestBody = InverseKinematicsRequest

// StoreColliderJSONRequestBody defines body for StoreCollider for application/json ContentType.
type StoreColliderJSONRequestBody = Collider

// StoreCollisionLinkChainJSONRequestBody defines body for StoreCollisionLinkChain for application/json ContentType.
type StoreCollisionLinkChainJSONRequestBody = LinkChain

// StoreCollisionSetupJSONRequestBody defines body for StoreCollisionSetup for application/json ContentType.
type StoreCollisionSetupJSONRequestBody = CollisionSetup

// StoreCollisionToolJSONRequestBody defines body for StoreCollisionTool for application/json ContentType.
type StoreCollisionToolJSONRequestBody = Tool

// StoreObjectMultipartRequestBody defines body for StoreObject for multipart/form-data ContentType.
type StoreObjectMultipartRequestBody StoreObjectMultipartBody

// PlanCollisionFreeJSONRequestBody defines body for PlanCollisionFree for application/json ContentType.
type PlanCollisionFreeJSONRequestBody = PlanCollisionFreeRequest

// PlanTrajectoryJSONRequestBody defines body for PlanTrajectory for application/json ContentType.
type PlanTrajectoryJSONRequestBody = PlanTrajectoryRequest

// AddVirtualControllerCoordinateSystemJSONRequestBody defines body for AddVirtualControllerCoordinateSystem for application/json ContentType.
type AddVirtualControllerCoordinateSystemJSONRequestBody = CoordinateSystemData

// ExternalJointsStreamJSONRequestBody defines body for ExternalJointsStream for application/json ContentType.
type ExternalJointsStreamJSONRequestBody = ExternalJointStreamRequest

// SetIOValuesJSONRequestBody defines body for SetIOValues for application/json ContentType.
type SetIOValuesJSONRequestBody = SetIOValuesJSONBody

// SetVirtualControllerMountingJSONRequestBody defines body for SetVirtualControllerMounting for application/json ContentType.
type SetVirtualControllerMountingJSONRequestBody = CoordinateSystem

// SetMotionGroupStateJSONRequestBody defines body for SetMotionGroupState for application/json ContentType.
type SetMotionGroupStateJSONRequestBody = MotionGroupJoints

// AddVirtualControllerTcpJSONRequestBody defines body for AddVirtualControllerTcp for application/json ContentType.
type AddVirtualControllerTcpJSONRequestBody = RobotTcpData

// ActivateLicenseJSONRequestBody defines body for ActivateLicense for application/json ContentType.
type ActivateLicenseJSONRequestBody ActivateLicenseJSONBody

// UpdateNovaVersionJSONRequestBody defines body for UpdateNovaVersion for application/json ContentType.
type UpdateNovaVersionJSONRequestBody UpdateNovaVersionJSONBody

// AsTcpRequired returns the union data inside the AddTrajectoryError_Data as a TcpRequired
func (t AddTrajectoryError_Data) AsTcpRequired() (TcpRequired, error) {
	var body TcpRequired
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTcpRequired overwrites any union data inside the AddTrajectoryError_Data as the provided TcpRequired
func (t *AddTrajectoryError_Data) FromTcpRequired(v TcpRequired) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTcpRequired performs a merge with any union data inside the AddTrajectoryError_Data, using the provided TcpRequired
func (t *AddTrajectoryError_Data) MergeTcpRequired(v TcpRequired) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInconsitentTrajectorySize returns the union data inside the AddTrajectoryError_Data as a InconsitentTrajectorySize
func (t AddTrajectoryError_Data) AsInconsitentTrajectorySize() (InconsitentTrajectorySize, error) {
	var body InconsitentTrajectorySize
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInconsitentTrajectorySize overwrites any union data inside the AddTrajectoryError_Data as the provided InconsitentTrajectorySize
func (t *AddTrajectoryError_Data) FromInconsitentTrajectorySize(v InconsitentTrajectorySize) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInconsitentTrajectorySize performs a merge with any union data inside the AddTrajectoryError_Data, using the provided InconsitentTrajectorySize
func (t *AddTrajectoryError_Data) MergeInconsitentTrajectorySize(v InconsitentTrajectorySize) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJointLimitExceeded returns the union data inside the AddTrajectoryError_Data as a JointLimitExceeded
func (t AddTrajectoryError_Data) AsJointLimitExceeded() (JointLimitExceeded, error) {
	var body JointLimitExceeded
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJointLimitExceeded overwrites any union data inside the AddTrajectoryError_Data as the provided JointLimitExceeded
func (t *AddTrajectoryError_Data) FromJointLimitExceeded(v JointLimitExceeded) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJointLimitExceeded performs a merge with any union data inside the AddTrajectoryError_Data, using the provided JointLimitExceeded
func (t *AddTrajectoryError_Data) MergeJointLimitExceeded(v JointLimitExceeded) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCollisionError returns the union data inside the AddTrajectoryError_Data as a CollisionError
func (t AddTrajectoryError_Data) AsCollisionError() (CollisionError, error) {
	var body CollisionError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCollisionError overwrites any union data inside the AddTrajectoryError_Data as the provided CollisionError
func (t *AddTrajectoryError_Data) FromCollisionError(v CollisionError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCollisionError performs a merge with any union data inside the AddTrajectoryError_Data, using the provided CollisionError
func (t *AddTrajectoryError_Data) MergeCollisionError(v CollisionError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTorqueExceeded returns the union data inside the AddTrajectoryError_Data as a TorqueExceeded
func (t AddTrajectoryError_Data) AsTorqueExceeded() (TorqueExceeded, error) {
	var body TorqueExceeded
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTorqueExceeded overwrites any union data inside the AddTrajectoryError_Data as the provided TorqueExceeded
func (t *AddTrajectoryError_Data) FromTorqueExceeded(v TorqueExceeded) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTorqueExceeded performs a merge with any union data inside the AddTrajectoryError_Data, using the provided TorqueExceeded
func (t *AddTrajectoryError_Data) MergeTorqueExceeded(v TorqueExceeded) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInvalidDof returns the union data inside the AddTrajectoryError_Data as a InvalidDof
func (t AddTrajectoryError_Data) AsInvalidDof() (InvalidDof, error) {
	var body InvalidDof
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInvalidDof overwrites any union data inside the AddTrajectoryError_Data as the provided InvalidDof
func (t *AddTrajectoryError_Data) FromInvalidDof(v InvalidDof) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInvalidDof performs a merge with any union data inside the AddTrajectoryError_Data, using the provided InvalidDof
func (t *AddTrajectoryError_Data) MergeInvalidDof(v InvalidDof) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNanValue returns the union data inside the AddTrajectoryError_Data as a NanValue
func (t AddTrajectoryError_Data) AsNanValue() (NanValue, error) {
	var body NanValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNanValue overwrites any union data inside the AddTrajectoryError_Data as the provided NanValue
func (t *AddTrajectoryError_Data) FromNanValue(v NanValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNanValue performs a merge with any union data inside the AddTrajectoryError_Data, using the provided NanValue
func (t *AddTrajectoryError_Data) MergeNanValue(v NanValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AddTrajectoryError_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AddTrajectoryError_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBusIOProfinet returns the union data inside the BusIOType as a BusIOProfinet
func (t BusIOType) AsBusIOProfinet() (BusIOProfinet, error) {
	var body BusIOProfinet
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBusIOProfinet overwrites any union data inside the BusIOType as the provided BusIOProfinet
func (t *BusIOType) FromBusIOProfinet(v BusIOProfinet) error {
	v.BusType = "profinet"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBusIOProfinet performs a merge with any union data inside the BusIOType, using the provided BusIOProfinet
func (t *BusIOType) MergeBusIOProfinet(v BusIOProfinet) error {
	v.BusType = "profinet"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBusIOProfinetVirtual returns the union data inside the BusIOType as a BusIOProfinetVirtual
func (t BusIOType) AsBusIOProfinetVirtual() (BusIOProfinetVirtual, error) {
	var body BusIOProfinetVirtual
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBusIOProfinetVirtual overwrites any union data inside the BusIOType as the provided BusIOProfinetVirtual
func (t *BusIOType) FromBusIOProfinetVirtual(v BusIOProfinetVirtual) error {
	v.BusType = "profinet_virtual"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBusIOProfinetVirtual performs a merge with any union data inside the BusIOType, using the provided BusIOProfinetVirtual
func (t *BusIOType) MergeBusIOProfinetVirtual(v BusIOProfinetVirtual) error {
	v.BusType = "profinet_virtual"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BusIOType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"bus_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t BusIOType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "profinet":
		return t.AsBusIOProfinet()
	case "profinet_virtual":
		return t.AsBusIOProfinetVirtual()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t BusIOType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BusIOType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSphere returns the union data inside the Collider_Shape as a Sphere
func (t Collider_Shape) AsSphere() (Sphere, error) {
	var body Sphere
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSphere overwrites any union data inside the Collider_Shape as the provided Sphere
func (t *Collider_Shape) FromSphere(v Sphere) error {
	v.ShapeType = "sphere"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSphere performs a merge with any union data inside the Collider_Shape, using the provided Sphere
func (t *Collider_Shape) MergeSphere(v Sphere) error {
	v.ShapeType = "sphere"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBox returns the union data inside the Collider_Shape as a Box
func (t Collider_Shape) AsBox() (Box, error) {
	var body Box
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBox overwrites any union data inside the Collider_Shape as the provided Box
func (t *Collider_Shape) FromBox(v Box) error {
	v.ShapeType = "box"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBox performs a merge with any union data inside the Collider_Shape, using the provided Box
func (t *Collider_Shape) MergeBox(v Box) error {
	v.ShapeType = "box"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRectangle returns the union data inside the Collider_Shape as a Rectangle
func (t Collider_Shape) AsRectangle() (Rectangle, error) {
	var body Rectangle
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRectangle overwrites any union data inside the Collider_Shape as the provided Rectangle
func (t *Collider_Shape) FromRectangle(v Rectangle) error {
	v.ShapeType = "rectangle"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRectangle performs a merge with any union data inside the Collider_Shape, using the provided Rectangle
func (t *Collider_Shape) MergeRectangle(v Rectangle) error {
	v.ShapeType = "rectangle"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlane returns the union data inside the Collider_Shape as a Plane
func (t Collider_Shape) AsPlane() (Plane, error) {
	var body Plane
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlane overwrites any union data inside the Collider_Shape as the provided Plane
func (t *Collider_Shape) FromPlane(v Plane) error {
	v.ShapeType = "plane"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlane performs a merge with any union data inside the Collider_Shape, using the provided Plane
func (t *Collider_Shape) MergePlane(v Plane) error {
	v.ShapeType = "plane"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCylinder returns the union data inside the Collider_Shape as a Cylinder
func (t Collider_Shape) AsCylinder() (Cylinder, error) {
	var body Cylinder
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCylinder overwrites any union data inside the Collider_Shape as the provided Cylinder
func (t *Collider_Shape) FromCylinder(v Cylinder) error {
	v.ShapeType = "cylinder"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCylinder performs a merge with any union data inside the Collider_Shape, using the provided Cylinder
func (t *Collider_Shape) MergeCylinder(v Cylinder) error {
	v.ShapeType = "cylinder"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapsule returns the union data inside the Collider_Shape as a Capsule
func (t Collider_Shape) AsCapsule() (Capsule, error) {
	var body Capsule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapsule overwrites any union data inside the Collider_Shape as the provided Capsule
func (t *Collider_Shape) FromCapsule(v Capsule) error {
	v.ShapeType = "capsule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapsule performs a merge with any union data inside the Collider_Shape, using the provided Capsule
func (t *Collider_Shape) MergeCapsule(v Capsule) error {
	v.ShapeType = "capsule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRectangularCapsule returns the union data inside the Collider_Shape as a RectangularCapsule
func (t Collider_Shape) AsRectangularCapsule() (RectangularCapsule, error) {
	var body RectangularCapsule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRectangularCapsule overwrites any union data inside the Collider_Shape as the provided RectangularCapsule
func (t *Collider_Shape) FromRectangularCapsule(v RectangularCapsule) error {
	v.ShapeType = "rectangular_capsule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRectangularCapsule performs a merge with any union data inside the Collider_Shape, using the provided RectangularCapsule
func (t *Collider_Shape) MergeRectangularCapsule(v RectangularCapsule) error {
	v.ShapeType = "rectangular_capsule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConvexHull returns the union data inside the Collider_Shape as a ConvexHull
func (t Collider_Shape) AsConvexHull() (ConvexHull, error) {
	var body ConvexHull
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConvexHull overwrites any union data inside the Collider_Shape as the provided ConvexHull
func (t *Collider_Shape) FromConvexHull(v ConvexHull) error {
	v.ShapeType = "convex_hull"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConvexHull performs a merge with any union data inside the Collider_Shape, using the provided ConvexHull
func (t *Collider_Shape) MergeConvexHull(v ConvexHull) error {
	v.ShapeType = "convex_hull"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Collider_Shape) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"shape_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Collider_Shape) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "box":
		return t.AsBox()
	case "capsule":
		return t.AsCapsule()
	case "convex_hull":
		return t.AsConvexHull()
	case "cylinder":
		return t.AsCylinder()
	case "plane":
		return t.AsPlane()
	case "rectangle":
		return t.AsRectangle()
	case "rectangular_capsule":
		return t.AsRectangularCapsule()
	case "sphere":
		return t.AsSphere()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Collider_Shape) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Collider_Shape) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMidpointInsertionAlgorithm returns the union data inside the CollisionFreeAlgorithm as a MidpointInsertionAlgorithm
func (t CollisionFreeAlgorithm) AsMidpointInsertionAlgorithm() (MidpointInsertionAlgorithm, error) {
	var body MidpointInsertionAlgorithm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMidpointInsertionAlgorithm overwrites any union data inside the CollisionFreeAlgorithm as the provided MidpointInsertionAlgorithm
func (t *CollisionFreeAlgorithm) FromMidpointInsertionAlgorithm(v MidpointInsertionAlgorithm) error {
	v.AlgorithmName = "MidpointInsertionAlgorithm"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMidpointInsertionAlgorithm performs a merge with any union data inside the CollisionFreeAlgorithm, using the provided MidpointInsertionAlgorithm
func (t *CollisionFreeAlgorithm) MergeMidpointInsertionAlgorithm(v MidpointInsertionAlgorithm) error {
	v.AlgorithmName = "MidpointInsertionAlgorithm"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRRTConnectAlgorithm returns the union data inside the CollisionFreeAlgorithm as a RRTConnectAlgorithm
func (t CollisionFreeAlgorithm) AsRRTConnectAlgorithm() (RRTConnectAlgorithm, error) {
	var body RRTConnectAlgorithm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRRTConnectAlgorithm overwrites any union data inside the CollisionFreeAlgorithm as the provided RRTConnectAlgorithm
func (t *CollisionFreeAlgorithm) FromRRTConnectAlgorithm(v RRTConnectAlgorithm) error {
	v.AlgorithmName = "RRTConnectAlgorithm"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRRTConnectAlgorithm performs a merge with any union data inside the CollisionFreeAlgorithm, using the provided RRTConnectAlgorithm
func (t *CollisionFreeAlgorithm) MergeRRTConnectAlgorithm(v RRTConnectAlgorithm) error {
	v.AlgorithmName = "RRTConnectAlgorithm"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CollisionFreeAlgorithm) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"algorithm_name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CollisionFreeAlgorithm) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "MidpointInsertionAlgorithm":
		return t.AsMidpointInsertionAlgorithm()
	case "RRTConnectAlgorithm":
		return t.AsRRTConnectAlgorithm()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CollisionFreeAlgorithm) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CollisionFreeAlgorithm) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsConfigurationArchiveStatusCreating returns the union data inside the ConfigurationArchiveStatus as a ConfigurationArchiveStatusCreating
func (t ConfigurationArchiveStatus) AsConfigurationArchiveStatusCreating() (ConfigurationArchiveStatusCreating, error) {
	var body ConfigurationArchiveStatusCreating
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConfigurationArchiveStatusCreating overwrites any union data inside the ConfigurationArchiveStatus as the provided ConfigurationArchiveStatusCreating
func (t *ConfigurationArchiveStatus) FromConfigurationArchiveStatusCreating(v ConfigurationArchiveStatusCreating) error {
	v.Status = "creating"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConfigurationArchiveStatusCreating performs a merge with any union data inside the ConfigurationArchiveStatus, using the provided ConfigurationArchiveStatusCreating
func (t *ConfigurationArchiveStatus) MergeConfigurationArchiveStatusCreating(v ConfigurationArchiveStatusCreating) error {
	v.Status = "creating"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConfigurationArchiveStatusError returns the union data inside the ConfigurationArchiveStatus as a ConfigurationArchiveStatusError
func (t ConfigurationArchiveStatus) AsConfigurationArchiveStatusError() (ConfigurationArchiveStatusError, error) {
	var body ConfigurationArchiveStatusError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConfigurationArchiveStatusError overwrites any union data inside the ConfigurationArchiveStatus as the provided ConfigurationArchiveStatusError
func (t *ConfigurationArchiveStatus) FromConfigurationArchiveStatusError(v ConfigurationArchiveStatusError) error {
	v.Status = "error"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConfigurationArchiveStatusError performs a merge with any union data inside the ConfigurationArchiveStatus, using the provided ConfigurationArchiveStatusError
func (t *ConfigurationArchiveStatus) MergeConfigurationArchiveStatusError(v ConfigurationArchiveStatusError) error {
	v.Status = "error"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConfigurationArchiveStatusSuccess returns the union data inside the ConfigurationArchiveStatus as a ConfigurationArchiveStatusSuccess
func (t ConfigurationArchiveStatus) AsConfigurationArchiveStatusSuccess() (ConfigurationArchiveStatusSuccess, error) {
	var body ConfigurationArchiveStatusSuccess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConfigurationArchiveStatusSuccess overwrites any union data inside the ConfigurationArchiveStatus as the provided ConfigurationArchiveStatusSuccess
func (t *ConfigurationArchiveStatus) FromConfigurationArchiveStatusSuccess(v ConfigurationArchiveStatusSuccess) error {
	v.Status = "success"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConfigurationArchiveStatusSuccess performs a merge with any union data inside the ConfigurationArchiveStatus, using the provided ConfigurationArchiveStatusSuccess
func (t *ConfigurationArchiveStatus) MergeConfigurationArchiveStatusSuccess(v ConfigurationArchiveStatusSuccess) error {
	v.Status = "success"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConfigurationArchiveStatus) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"status"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ConfigurationArchiveStatus) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "creating":
		return t.AsConfigurationArchiveStatusCreating()
	case "error":
		return t.AsConfigurationArchiveStatusError()
	case "success":
		return t.AsConfigurationArchiveStatusSuccess()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ConfigurationArchiveStatus) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConfigurationArchiveStatus) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJoggingDetails returns the union data inside the Execute_Details as a JoggingDetails
func (t Execute_Details) AsJoggingDetails() (JoggingDetails, error) {
	var body JoggingDetails
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJoggingDetails overwrites any union data inside the Execute_Details as the provided JoggingDetails
func (t *Execute_Details) FromJoggingDetails(v JoggingDetails) error {
	v.Kind = "JOGGING"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJoggingDetails performs a merge with any union data inside the Execute_Details, using the provided JoggingDetails
func (t *Execute_Details) MergeJoggingDetails(v JoggingDetails) error {
	v.Kind = "JOGGING"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTrajectoryDetails returns the union data inside the Execute_Details as a TrajectoryDetails
func (t Execute_Details) AsTrajectoryDetails() (TrajectoryDetails, error) {
	var body TrajectoryDetails
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrajectoryDetails overwrites any union data inside the Execute_Details as the provided TrajectoryDetails
func (t *Execute_Details) FromTrajectoryDetails(v TrajectoryDetails) error {
	v.Kind = "TRAJECTORY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrajectoryDetails performs a merge with any union data inside the Execute_Details, using the provided TrajectoryDetails
func (t *Execute_Details) MergeTrajectoryDetails(v TrajectoryDetails) error {
	v.Kind = "TRAJECTORY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Execute_Details) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"kind"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Execute_Details) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "JOGGING":
		return t.AsJoggingDetails()
	case "TRAJECTORY":
		return t.AsTrajectoryDetails()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Execute_Details) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Execute_Details) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInitializeJoggingResponse returns the union data inside the ExecuteJoggingResponse as a InitializeJoggingResponse
func (t ExecuteJoggingResponse) AsInitializeJoggingResponse() (InitializeJoggingResponse, error) {
	var body InitializeJoggingResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInitializeJoggingResponse overwrites any union data inside the ExecuteJoggingResponse as the provided InitializeJoggingResponse
func (t *ExecuteJoggingResponse) FromInitializeJoggingResponse(v InitializeJoggingResponse) error {
	v.Kind = "InitializeJoggingResponse"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInitializeJoggingResponse performs a merge with any union data inside the ExecuteJoggingResponse, using the provided InitializeJoggingResponse
func (t *ExecuteJoggingResponse) MergeInitializeJoggingResponse(v InitializeJoggingResponse) error {
	v.Kind = "InitializeJoggingResponse"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPauseJoggingResponse returns the union data inside the ExecuteJoggingResponse as a PauseJoggingResponse
func (t ExecuteJoggingResponse) AsPauseJoggingResponse() (PauseJoggingResponse, error) {
	var body PauseJoggingResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPauseJoggingResponse overwrites any union data inside the ExecuteJoggingResponse as the provided PauseJoggingResponse
func (t *ExecuteJoggingResponse) FromPauseJoggingResponse(v PauseJoggingResponse) error {
	v.Kind = "PauseJoggingResponse"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePauseJoggingResponse performs a merge with any union data inside the ExecuteJoggingResponse, using the provided PauseJoggingResponse
func (t *ExecuteJoggingResponse) MergePauseJoggingResponse(v PauseJoggingResponse) error {
	v.Kind = "PauseJoggingResponse"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTcpVelocityResponse returns the union data inside the ExecuteJoggingResponse as a TcpVelocityResponse
func (t ExecuteJoggingResponse) AsTcpVelocityResponse() (TcpVelocityResponse, error) {
	var body TcpVelocityResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTcpVelocityResponse overwrites any union data inside the ExecuteJoggingResponse as the provided TcpVelocityResponse
func (t *ExecuteJoggingResponse) FromTcpVelocityResponse(v TcpVelocityResponse) error {
	v.Kind = "TcpVelocityResponse"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTcpVelocityResponse performs a merge with any union data inside the ExecuteJoggingResponse, using the provided TcpVelocityResponse
func (t *ExecuteJoggingResponse) MergeTcpVelocityResponse(v TcpVelocityResponse) error {
	v.Kind = "TcpVelocityResponse"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJointVelocityResponse returns the union data inside the ExecuteJoggingResponse as a JointVelocityResponse
func (t ExecuteJoggingResponse) AsJointVelocityResponse() (JointVelocityResponse, error) {
	var body JointVelocityResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJointVelocityResponse overwrites any union data inside the ExecuteJoggingResponse as the provided JointVelocityResponse
func (t *ExecuteJoggingResponse) FromJointVelocityResponse(v JointVelocityResponse) error {
	v.Kind = "JointVelocityResponse"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJointVelocityResponse performs a merge with any union data inside the ExecuteJoggingResponse, using the provided JointVelocityResponse
func (t *ExecuteJoggingResponse) MergeJointVelocityResponse(v JointVelocityResponse) error {
	v.Kind = "JointVelocityResponse"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMovementErrorResponse returns the union data inside the ExecuteJoggingResponse as a MovementErrorResponse
func (t ExecuteJoggingResponse) AsMovementErrorResponse() (MovementErrorResponse, error) {
	var body MovementErrorResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMovementErrorResponse overwrites any union data inside the ExecuteJoggingResponse as the provided MovementErrorResponse
func (t *ExecuteJoggingResponse) FromMovementErrorResponse(v MovementErrorResponse) error {
	v.Kind = "MovementErrorResponse"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMovementErrorResponse performs a merge with any union data inside the ExecuteJoggingResponse, using the provided MovementErrorResponse
func (t *ExecuteJoggingResponse) MergeMovementErrorResponse(v MovementErrorResponse) error {
	v.Kind = "MovementErrorResponse"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ExecuteJoggingResponse) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"kind"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ExecuteJoggingResponse) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "InitializeJoggingResponse":
		return t.AsInitializeJoggingResponse()
	case "JointVelocityResponse":
		return t.AsJointVelocityResponse()
	case "MovementErrorResponse":
		return t.AsMovementErrorResponse()
	case "PauseJoggingResponse":
		return t.AsPauseJoggingResponse()
	case "TcpVelocityResponse":
		return t.AsTcpVelocityResponse()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ExecuteJoggingResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExecuteJoggingResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInitializeMovementResponse returns the union data inside the ExecuteTrajectoryResponse as a InitializeMovementResponse
func (t ExecuteTrajectoryResponse) AsInitializeMovementResponse() (InitializeMovementResponse, error) {
	var body InitializeMovementResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInitializeMovementResponse overwrites any union data inside the ExecuteTrajectoryResponse as the provided InitializeMovementResponse
func (t *ExecuteTrajectoryResponse) FromInitializeMovementResponse(v InitializeMovementResponse) error {
	v.Kind = "InitializeMovementResponse"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInitializeMovementResponse performs a merge with any union data inside the ExecuteTrajectoryResponse, using the provided InitializeMovementResponse
func (t *ExecuteTrajectoryResponse) MergeInitializeMovementResponse(v InitializeMovementResponse) error {
	v.Kind = "InitializeMovementResponse"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStartMovementResponse returns the union data inside the ExecuteTrajectoryResponse as a StartMovementResponse
func (t ExecuteTrajectoryResponse) AsStartMovementResponse() (StartMovementResponse, error) {
	var body StartMovementResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStartMovementResponse overwrites any union data inside the ExecuteTrajectoryResponse as the provided StartMovementResponse
func (t *ExecuteTrajectoryResponse) FromStartMovementResponse(v StartMovementResponse) error {
	v.Kind = "StartMovementResponse"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStartMovementResponse performs a merge with any union data inside the ExecuteTrajectoryResponse, using the provided StartMovementResponse
func (t *ExecuteTrajectoryResponse) MergeStartMovementResponse(v StartMovementResponse) error {
	v.Kind = "StartMovementResponse"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPauseMovementResponse returns the union data inside the ExecuteTrajectoryResponse as a PauseMovementResponse
func (t ExecuteTrajectoryResponse) AsPauseMovementResponse() (PauseMovementResponse, error) {
	var body PauseMovementResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPauseMovementResponse overwrites any union data inside the ExecuteTrajectoryResponse as the provided PauseMovementResponse
func (t *ExecuteTrajectoryResponse) FromPauseMovementResponse(v PauseMovementResponse) error {
	v.Kind = "PauseMovementResponse"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePauseMovementResponse performs a merge with any union data inside the ExecuteTrajectoryResponse, using the provided PauseMovementResponse
func (t *ExecuteTrajectoryResponse) MergePauseMovementResponse(v PauseMovementResponse) error {
	v.Kind = "PauseMovementResponse"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlaybackSpeedResponse returns the union data inside the ExecuteTrajectoryResponse as a PlaybackSpeedResponse
func (t ExecuteTrajectoryResponse) AsPlaybackSpeedResponse() (PlaybackSpeedResponse, error) {
	var body PlaybackSpeedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaybackSpeedResponse overwrites any union data inside the ExecuteTrajectoryResponse as the provided PlaybackSpeedResponse
func (t *ExecuteTrajectoryResponse) FromPlaybackSpeedResponse(v PlaybackSpeedResponse) error {
	v.Kind = "PlaybackSpeedResponse"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaybackSpeedResponse performs a merge with any union data inside the ExecuteTrajectoryResponse, using the provided PlaybackSpeedResponse
func (t *ExecuteTrajectoryResponse) MergePlaybackSpeedResponse(v PlaybackSpeedResponse) error {
	v.Kind = "PlaybackSpeedResponse"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMovementErrorResponse returns the union data inside the ExecuteTrajectoryResponse as a MovementErrorResponse
func (t ExecuteTrajectoryResponse) AsMovementErrorResponse() (MovementErrorResponse, error) {
	var body MovementErrorResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMovementErrorResponse overwrites any union data inside the ExecuteTrajectoryResponse as the provided MovementErrorResponse
func (t *ExecuteTrajectoryResponse) FromMovementErrorResponse(v MovementErrorResponse) error {
	v.Kind = "MovementErrorResponse"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMovementErrorResponse performs a merge with any union data inside the ExecuteTrajectoryResponse, using the provided MovementErrorResponse
func (t *ExecuteTrajectoryResponse) MergeMovementErrorResponse(v MovementErrorResponse) error {
	v.Kind = "MovementErrorResponse"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ExecuteTrajectoryResponse) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"kind"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ExecuteTrajectoryResponse) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "InitializeMovementResponse":
		return t.AsInitializeMovementResponse()
	case "MovementErrorResponse":
		return t.AsMovementErrorResponse()
	case "PauseMovementResponse":
		return t.AsPauseMovementResponse()
	case "PlaybackSpeedResponse":
		return t.AsPlaybackSpeedResponse()
	case "StartMovementResponse":
		return t.AsStartMovementResponse()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ExecuteTrajectoryResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExecuteTrajectoryResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsForwardKinematicsValidationErrorLoc0 returns the union data inside the ForwardKinematicsValidationError_Loc_Item as a ForwardKinematicsValidationErrorLoc0
func (t ForwardKinematicsValidationError_Loc_Item) AsForwardKinematicsValidationErrorLoc0() (ForwardKinematicsValidationErrorLoc0, error) {
	var body ForwardKinematicsValidationErrorLoc0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForwardKinematicsValidationErrorLoc0 overwrites any union data inside the ForwardKinematicsValidationError_Loc_Item as the provided ForwardKinematicsValidationErrorLoc0
func (t *ForwardKinematicsValidationError_Loc_Item) FromForwardKinematicsValidationErrorLoc0(v ForwardKinematicsValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForwardKinematicsValidationErrorLoc0 performs a merge with any union data inside the ForwardKinematicsValidationError_Loc_Item, using the provided ForwardKinematicsValidationErrorLoc0
func (t *ForwardKinematicsValidationError_Loc_Item) MergeForwardKinematicsValidationErrorLoc0(v ForwardKinematicsValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsForwardKinematicsValidationErrorLoc1 returns the union data inside the ForwardKinematicsValidationError_Loc_Item as a ForwardKinematicsValidationErrorLoc1
func (t ForwardKinematicsValidationError_Loc_Item) AsForwardKinematicsValidationErrorLoc1() (ForwardKinematicsValidationErrorLoc1, error) {
	var body ForwardKinematicsValidationErrorLoc1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromForwardKinematicsValidationErrorLoc1 overwrites any union data inside the ForwardKinematicsValidationError_Loc_Item as the provided ForwardKinematicsValidationErrorLoc1
func (t *ForwardKinematicsValidationError_Loc_Item) FromForwardKinematicsValidationErrorLoc1(v ForwardKinematicsValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeForwardKinematicsValidationErrorLoc1 performs a merge with any union data inside the ForwardKinematicsValidationError_Loc_Item, using the provided ForwardKinematicsValidationErrorLoc1
func (t *ForwardKinematicsValidationError_Loc_Item) MergeForwardKinematicsValidationErrorLoc1(v ForwardKinematicsValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ForwardKinematicsValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ForwardKinematicsValidationError_Loc_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBooleanValue returns the union data inside the IODescription_Max as a BooleanValue
func (t IODescription_Max) AsBooleanValue() (BooleanValue, error) {
	var body BooleanValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanValue overwrites any union data inside the IODescription_Max as the provided BooleanValue
func (t *IODescription_Max) FromBooleanValue(v BooleanValue) error {
	v.ValueType = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanValue performs a merge with any union data inside the IODescription_Max, using the provided BooleanValue
func (t *IODescription_Max) MergeBooleanValue(v BooleanValue) error {
	v.ValueType = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerValue returns the union data inside the IODescription_Max as a IntegerValue
func (t IODescription_Max) AsIntegerValue() (IntegerValue, error) {
	var body IntegerValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerValue overwrites any union data inside the IODescription_Max as the provided IntegerValue
func (t *IODescription_Max) FromIntegerValue(v IntegerValue) error {
	v.ValueType = "integer"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerValue performs a merge with any union data inside the IODescription_Max, using the provided IntegerValue
func (t *IODescription_Max) MergeIntegerValue(v IntegerValue) error {
	v.ValueType = "integer"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatValue returns the union data inside the IODescription_Max as a FloatValue
func (t IODescription_Max) AsFloatValue() (FloatValue, error) {
	var body FloatValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatValue overwrites any union data inside the IODescription_Max as the provided FloatValue
func (t *IODescription_Max) FromFloatValue(v FloatValue) error {
	v.ValueType = "float"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatValue performs a merge with any union data inside the IODescription_Max, using the provided FloatValue
func (t *IODescription_Max) MergeFloatValue(v FloatValue) error {
	v.ValueType = "float"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IODescription_Max) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"value_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t IODescription_Max) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsBooleanValue()
	case "float":
		return t.AsFloatValue()
	case "integer":
		return t.AsIntegerValue()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t IODescription_Max) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IODescription_Max) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBooleanValue returns the union data inside the IODescription_Min as a BooleanValue
func (t IODescription_Min) AsBooleanValue() (BooleanValue, error) {
	var body BooleanValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanValue overwrites any union data inside the IODescription_Min as the provided BooleanValue
func (t *IODescription_Min) FromBooleanValue(v BooleanValue) error {
	v.ValueType = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanValue performs a merge with any union data inside the IODescription_Min, using the provided BooleanValue
func (t *IODescription_Min) MergeBooleanValue(v BooleanValue) error {
	v.ValueType = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerValue returns the union data inside the IODescription_Min as a IntegerValue
func (t IODescription_Min) AsIntegerValue() (IntegerValue, error) {
	var body IntegerValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerValue overwrites any union data inside the IODescription_Min as the provided IntegerValue
func (t *IODescription_Min) FromIntegerValue(v IntegerValue) error {
	v.ValueType = "integer"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerValue performs a merge with any union data inside the IODescription_Min, using the provided IntegerValue
func (t *IODescription_Min) MergeIntegerValue(v IntegerValue) error {
	v.ValueType = "integer"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatValue returns the union data inside the IODescription_Min as a FloatValue
func (t IODescription_Min) AsFloatValue() (FloatValue, error) {
	var body FloatValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatValue overwrites any union data inside the IODescription_Min as the provided FloatValue
func (t *IODescription_Min) FromFloatValue(v FloatValue) error {
	v.ValueType = "float"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatValue performs a merge with any union data inside the IODescription_Min, using the provided FloatValue
func (t *IODescription_Min) MergeFloatValue(v FloatValue) error {
	v.ValueType = "float"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IODescription_Min) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"value_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t IODescription_Min) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsBooleanValue()
	case "float":
		return t.AsFloatValue()
	case "integer":
		return t.AsIntegerValue()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t IODescription_Min) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IODescription_Min) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIOBooleanValue returns the union data inside the IOValue as a IOBooleanValue
func (t IOValue) AsIOBooleanValue() (IOBooleanValue, error) {
	var body IOBooleanValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIOBooleanValue overwrites any union data inside the IOValue as the provided IOBooleanValue
func (t *IOValue) FromIOBooleanValue(v IOBooleanValue) error {
	v.ValueType = "boolean"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIOBooleanValue performs a merge with any union data inside the IOValue, using the provided IOBooleanValue
func (t *IOValue) MergeIOBooleanValue(v IOBooleanValue) error {
	v.ValueType = "boolean"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIOIntegerValue returns the union data inside the IOValue as a IOIntegerValue
func (t IOValue) AsIOIntegerValue() (IOIntegerValue, error) {
	var body IOIntegerValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIOIntegerValue overwrites any union data inside the IOValue as the provided IOIntegerValue
func (t *IOValue) FromIOIntegerValue(v IOIntegerValue) error {
	v.ValueType = "integer"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIOIntegerValue performs a merge with any union data inside the IOValue, using the provided IOIntegerValue
func (t *IOValue) MergeIOIntegerValue(v IOIntegerValue) error {
	v.ValueType = "integer"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIOFloatValue returns the union data inside the IOValue as a IOFloatValue
func (t IOValue) AsIOFloatValue() (IOFloatValue, error) {
	var body IOFloatValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIOFloatValue overwrites any union data inside the IOValue as the provided IOFloatValue
func (t *IOValue) FromIOFloatValue(v IOFloatValue) error {
	v.ValueType = "float"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIOFloatValue performs a merge with any union data inside the IOValue, using the provided IOFloatValue
func (t *IOValue) MergeIOFloatValue(v IOFloatValue) error {
	v.ValueType = "float"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IOValue) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"value_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t IOValue) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsIOBooleanValue()
	case "float":
		return t.AsIOFloatValue()
	case "integer":
		return t.AsIOIntegerValue()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t IOValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IOValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTrajectoryId returns the union data inside the InitializeMovementRequest_Trajectory as a TrajectoryId
func (t InitializeMovementRequest_Trajectory) AsTrajectoryId() (TrajectoryId, error) {
	var body TrajectoryId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrajectoryId overwrites any union data inside the InitializeMovementRequest_Trajectory as the provided TrajectoryId
func (t *InitializeMovementRequest_Trajectory) FromTrajectoryId(v TrajectoryId) error {
	v.MessageType = "TrajectoryId"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrajectoryId performs a merge with any union data inside the InitializeMovementRequest_Trajectory, using the provided TrajectoryId
func (t *InitializeMovementRequest_Trajectory) MergeTrajectoryId(v TrajectoryId) error {
	v.MessageType = "TrajectoryId"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTrajectoryData returns the union data inside the InitializeMovementRequest_Trajectory as a TrajectoryData
func (t InitializeMovementRequest_Trajectory) AsTrajectoryData() (TrajectoryData, error) {
	var body TrajectoryData
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrajectoryData overwrites any union data inside the InitializeMovementRequest_Trajectory as the provided TrajectoryData
func (t *InitializeMovementRequest_Trajectory) FromTrajectoryData(v TrajectoryData) error {
	v.MessageType = "TrajectoryData"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrajectoryData performs a merge with any union data inside the InitializeMovementRequest_Trajectory, using the provided TrajectoryData
func (t *InitializeMovementRequest_Trajectory) MergeTrajectoryData(v TrajectoryData) error {
	v.MessageType = "TrajectoryData"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InitializeMovementRequest_Trajectory) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"message_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t InitializeMovementRequest_Trajectory) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "TrajectoryData":
		return t.AsTrajectoryData()
	case "TrajectoryId":
		return t.AsTrajectoryId()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t InitializeMovementRequest_Trajectory) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InitializeMovementRequest_Trajectory) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsErrorInvalidJointCount returns the union data inside the InverseKinematicsValidationError_Data as a ErrorInvalidJointCount
func (t InverseKinematicsValidationError_Data) AsErrorInvalidJointCount() (ErrorInvalidJointCount, error) {
	var body ErrorInvalidJointCount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorInvalidJointCount overwrites any union data inside the InverseKinematicsValidationError_Data as the provided ErrorInvalidJointCount
func (t *InverseKinematicsValidationError_Data) FromErrorInvalidJointCount(v ErrorInvalidJointCount) error {
	v.ErrorFeedbackName = "ErrorInvalidJointCount"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorInvalidJointCount performs a merge with any union data inside the InverseKinematicsValidationError_Data, using the provided ErrorInvalidJointCount
func (t *InverseKinematicsValidationError_Data) MergeErrorInvalidJointCount(v ErrorInvalidJointCount) error {
	v.ErrorFeedbackName = "ErrorInvalidJointCount"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorJointLimitExceeded returns the union data inside the InverseKinematicsValidationError_Data as a ErrorJointLimitExceeded
func (t InverseKinematicsValidationError_Data) AsErrorJointLimitExceeded() (ErrorJointLimitExceeded, error) {
	var body ErrorJointLimitExceeded
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorJointLimitExceeded overwrites any union data inside the InverseKinematicsValidationError_Data as the provided ErrorJointLimitExceeded
func (t *InverseKinematicsValidationError_Data) FromErrorJointLimitExceeded(v ErrorJointLimitExceeded) error {
	v.ErrorFeedbackName = "ErrorJointLimitExceeded"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorJointLimitExceeded performs a merge with any union data inside the InverseKinematicsValidationError_Data, using the provided ErrorJointLimitExceeded
func (t *InverseKinematicsValidationError_Data) MergeErrorJointLimitExceeded(v ErrorJointLimitExceeded) error {
	v.ErrorFeedbackName = "ErrorJointLimitExceeded"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InverseKinematicsValidationError_Data) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"error_feedback_name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t InverseKinematicsValidationError_Data) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ErrorInvalidJointCount":
		return t.AsErrorInvalidJointCount()
	case "ErrorJointLimitExceeded":
		return t.AsErrorJointLimitExceeded()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t InverseKinematicsValidationError_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InverseKinematicsValidationError_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInverseKinematicsValidationErrorLoc0 returns the union data inside the InverseKinematicsValidationError_Loc_Item as a InverseKinematicsValidationErrorLoc0
func (t InverseKinematicsValidationError_Loc_Item) AsInverseKinematicsValidationErrorLoc0() (InverseKinematicsValidationErrorLoc0, error) {
	var body InverseKinematicsValidationErrorLoc0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInverseKinematicsValidationErrorLoc0 overwrites any union data inside the InverseKinematicsValidationError_Loc_Item as the provided InverseKinematicsValidationErrorLoc0
func (t *InverseKinematicsValidationError_Loc_Item) FromInverseKinematicsValidationErrorLoc0(v InverseKinematicsValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInverseKinematicsValidationErrorLoc0 performs a merge with any union data inside the InverseKinematicsValidationError_Loc_Item, using the provided InverseKinematicsValidationErrorLoc0
func (t *InverseKinematicsValidationError_Loc_Item) MergeInverseKinematicsValidationErrorLoc0(v InverseKinematicsValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInverseKinematicsValidationErrorLoc1 returns the union data inside the InverseKinematicsValidationError_Loc_Item as a InverseKinematicsValidationErrorLoc1
func (t InverseKinematicsValidationError_Loc_Item) AsInverseKinematicsValidationErrorLoc1() (InverseKinematicsValidationErrorLoc1, error) {
	var body InverseKinematicsValidationErrorLoc1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInverseKinematicsValidationErrorLoc1 overwrites any union data inside the InverseKinematicsValidationError_Loc_Item as the provided InverseKinematicsValidationErrorLoc1
func (t *InverseKinematicsValidationError_Loc_Item) FromInverseKinematicsValidationErrorLoc1(v InverseKinematicsValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInverseKinematicsValidationErrorLoc1 performs a merge with any union data inside the InverseKinematicsValidationError_Loc_Item, using the provided InverseKinematicsValidationErrorLoc1
func (t *InverseKinematicsValidationError_Loc_Item) MergeInverseKinematicsValidationErrorLoc1(v InverseKinematicsValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InverseKinematicsValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InverseKinematicsValidationError_Loc_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJoggingRunning returns the union data inside the JoggingDetails_State as a JoggingRunning
func (t JoggingDetails_State) AsJoggingRunning() (JoggingRunning, error) {
	var body JoggingRunning
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJoggingRunning overwrites any union data inside the JoggingDetails_State as the provided JoggingRunning
func (t *JoggingDetails_State) FromJoggingRunning(v JoggingRunning) error {
	v.Kind = "RUNNING"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJoggingRunning performs a merge with any union data inside the JoggingDetails_State, using the provided JoggingRunning
func (t *JoggingDetails_State) MergeJoggingRunning(v JoggingRunning) error {
	v.Kind = "RUNNING"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJoggingPausedByUser returns the union data inside the JoggingDetails_State as a JoggingPausedByUser
func (t JoggingDetails_State) AsJoggingPausedByUser() (JoggingPausedByUser, error) {
	var body JoggingPausedByUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJoggingPausedByUser overwrites any union data inside the JoggingDetails_State as the provided JoggingPausedByUser
func (t *JoggingDetails_State) FromJoggingPausedByUser(v JoggingPausedByUser) error {
	v.Kind = "PAUSED_BY_USER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJoggingPausedByUser performs a merge with any union data inside the JoggingDetails_State, using the provided JoggingPausedByUser
func (t *JoggingDetails_State) MergeJoggingPausedByUser(v JoggingPausedByUser) error {
	v.Kind = "PAUSED_BY_USER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJoggingPausedOnIO returns the union data inside the JoggingDetails_State as a JoggingPausedOnIO
func (t JoggingDetails_State) AsJoggingPausedOnIO() (JoggingPausedOnIO, error) {
	var body JoggingPausedOnIO
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJoggingPausedOnIO overwrites any union data inside the JoggingDetails_State as the provided JoggingPausedOnIO
func (t *JoggingDetails_State) FromJoggingPausedOnIO(v JoggingPausedOnIO) error {
	v.Kind = "PAUSED_ON_IO"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJoggingPausedOnIO performs a merge with any union data inside the JoggingDetails_State, using the provided JoggingPausedOnIO
func (t *JoggingDetails_State) MergeJoggingPausedOnIO(v JoggingPausedOnIO) error {
	v.Kind = "PAUSED_ON_IO"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJoggingPausedNearJointLimit returns the union data inside the JoggingDetails_State as a JoggingPausedNearJointLimit
func (t JoggingDetails_State) AsJoggingPausedNearJointLimit() (JoggingPausedNearJointLimit, error) {
	var body JoggingPausedNearJointLimit
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJoggingPausedNearJointLimit overwrites any union data inside the JoggingDetails_State as the provided JoggingPausedNearJointLimit
func (t *JoggingDetails_State) FromJoggingPausedNearJointLimit(v JoggingPausedNearJointLimit) error {
	v.Kind = "PAUSED_NEAR_JOINT_LIMIT"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJoggingPausedNearJointLimit performs a merge with any union data inside the JoggingDetails_State, using the provided JoggingPausedNearJointLimit
func (t *JoggingDetails_State) MergeJoggingPausedNearJointLimit(v JoggingPausedNearJointLimit) error {
	v.Kind = "PAUSED_NEAR_JOINT_LIMIT"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJoggingPausedNearCollision returns the union data inside the JoggingDetails_State as a JoggingPausedNearCollision
func (t JoggingDetails_State) AsJoggingPausedNearCollision() (JoggingPausedNearCollision, error) {
	var body JoggingPausedNearCollision
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJoggingPausedNearCollision overwrites any union data inside the JoggingDetails_State as the provided JoggingPausedNearCollision
func (t *JoggingDetails_State) FromJoggingPausedNearCollision(v JoggingPausedNearCollision) error {
	v.Kind = "PAUSED_NEAR_COLLISION"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJoggingPausedNearCollision performs a merge with any union data inside the JoggingDetails_State, using the provided JoggingPausedNearCollision
func (t *JoggingDetails_State) MergeJoggingPausedNearCollision(v JoggingPausedNearCollision) error {
	v.Kind = "PAUSED_NEAR_COLLISION"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t JoggingDetails_State) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"kind"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t JoggingDetails_State) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "PAUSED_BY_USER":
		return t.AsJoggingPausedByUser()
	case "PAUSED_NEAR_COLLISION":
		return t.AsJoggingPausedNearCollision()
	case "PAUSED_NEAR_JOINT_LIMIT":
		return t.AsJoggingPausedNearJointLimit()
	case "PAUSED_ON_IO":
		return t.AsJoggingPausedOnIO()
	case "RUNNING":
		return t.AsJoggingRunning()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t JoggingDetails_State) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JoggingDetails_State) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBlendingAuto returns the union data inside the MotionCommand_Blending as a BlendingAuto
func (t MotionCommand_Blending) AsBlendingAuto() (BlendingAuto, error) {
	var body BlendingAuto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlendingAuto overwrites any union data inside the MotionCommand_Blending as the provided BlendingAuto
func (t *MotionCommand_Blending) FromBlendingAuto(v BlendingAuto) error {
	v.BlendingName = "BlendingAuto"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlendingAuto performs a merge with any union data inside the MotionCommand_Blending, using the provided BlendingAuto
func (t *MotionCommand_Blending) MergeBlendingAuto(v BlendingAuto) error {
	v.BlendingName = "BlendingAuto"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlendingPosition returns the union data inside the MotionCommand_Blending as a BlendingPosition
func (t MotionCommand_Blending) AsBlendingPosition() (BlendingPosition, error) {
	var body BlendingPosition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlendingPosition overwrites any union data inside the MotionCommand_Blending as the provided BlendingPosition
func (t *MotionCommand_Blending) FromBlendingPosition(v BlendingPosition) error {
	v.BlendingName = "BlendingPosition"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlendingPosition performs a merge with any union data inside the MotionCommand_Blending, using the provided BlendingPosition
func (t *MotionCommand_Blending) MergeBlendingPosition(v BlendingPosition) error {
	v.BlendingName = "BlendingPosition"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MotionCommand_Blending) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"blending_name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MotionCommand_Blending) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BlendingAuto":
		return t.AsBlendingAuto()
	case "BlendingPosition":
		return t.AsBlendingPosition()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MotionCommand_Blending) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MotionCommand_Blending) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPathCartesianPTP returns the union data inside the MotionCommand_Path as a PathCartesianPTP
func (t MotionCommand_Path) AsPathCartesianPTP() (PathCartesianPTP, error) {
	var body PathCartesianPTP
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathCartesianPTP overwrites any union data inside the MotionCommand_Path as the provided PathCartesianPTP
func (t *MotionCommand_Path) FromPathCartesianPTP(v PathCartesianPTP) error {
	v.PathDefinitionName = "PathCartesianPTP"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathCartesianPTP performs a merge with any union data inside the MotionCommand_Path, using the provided PathCartesianPTP
func (t *MotionCommand_Path) MergePathCartesianPTP(v PathCartesianPTP) error {
	v.PathDefinitionName = "PathCartesianPTP"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPathCubicSpline returns the union data inside the MotionCommand_Path as a PathCubicSpline
func (t MotionCommand_Path) AsPathCubicSpline() (PathCubicSpline, error) {
	var body PathCubicSpline
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathCubicSpline overwrites any union data inside the MotionCommand_Path as the provided PathCubicSpline
func (t *MotionCommand_Path) FromPathCubicSpline(v PathCubicSpline) error {
	v.PathDefinitionName = "PathCubicSpline"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathCubicSpline performs a merge with any union data inside the MotionCommand_Path, using the provided PathCubicSpline
func (t *MotionCommand_Path) MergePathCubicSpline(v PathCubicSpline) error {
	v.PathDefinitionName = "PathCubicSpline"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPathLine returns the union data inside the MotionCommand_Path as a PathLine
func (t MotionCommand_Path) AsPathLine() (PathLine, error) {
	var body PathLine
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathLine overwrites any union data inside the MotionCommand_Path as the provided PathLine
func (t *MotionCommand_Path) FromPathLine(v PathLine) error {
	v.PathDefinitionName = "PathLine"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathLine performs a merge with any union data inside the MotionCommand_Path, using the provided PathLine
func (t *MotionCommand_Path) MergePathLine(v PathLine) error {
	v.PathDefinitionName = "PathLine"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPathCircle returns the union data inside the MotionCommand_Path as a PathCircle
func (t MotionCommand_Path) AsPathCircle() (PathCircle, error) {
	var body PathCircle
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathCircle overwrites any union data inside the MotionCommand_Path as the provided PathCircle
func (t *MotionCommand_Path) FromPathCircle(v PathCircle) error {
	v.PathDefinitionName = "PathCircle"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathCircle performs a merge with any union data inside the MotionCommand_Path, using the provided PathCircle
func (t *MotionCommand_Path) MergePathCircle(v PathCircle) error {
	v.PathDefinitionName = "PathCircle"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPathJointPTP returns the union data inside the MotionCommand_Path as a PathJointPTP
func (t MotionCommand_Path) AsPathJointPTP() (PathJointPTP, error) {
	var body PathJointPTP
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathJointPTP overwrites any union data inside the MotionCommand_Path as the provided PathJointPTP
func (t *MotionCommand_Path) FromPathJointPTP(v PathJointPTP) error {
	v.PathDefinitionName = "PathJointPTP"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathJointPTP performs a merge with any union data inside the MotionCommand_Path, using the provided PathJointPTP
func (t *MotionCommand_Path) MergePathJointPTP(v PathJointPTP) error {
	v.PathDefinitionName = "PathJointPTP"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MotionCommand_Path) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"path_definition_name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MotionCommand_Path) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "PathCartesianPTP":
		return t.AsPathCartesianPTP()
	case "PathCircle":
		return t.AsPathCircle()
	case "PathCubicSpline":
		return t.AsPathCubicSpline()
	case "PathJointPTP":
		return t.AsPathJointPTP()
	case "PathLine":
		return t.AsPathLine()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MotionCommand_Path) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MotionCommand_Path) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJointTrajectory returns the union data inside the PlanCollisionFreeResponse_Response as a JointTrajectory
func (t PlanCollisionFreeResponse_Response) AsJointTrajectory() (JointTrajectory, error) {
	var body JointTrajectory
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJointTrajectory overwrites any union data inside the PlanCollisionFreeResponse_Response as the provided JointTrajectory
func (t *PlanCollisionFreeResponse_Response) FromJointTrajectory(v JointTrajectory) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJointTrajectory performs a merge with any union data inside the PlanCollisionFreeResponse_Response, using the provided JointTrajectory
func (t *PlanCollisionFreeResponse_Response) MergeJointTrajectory(v JointTrajectory) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlanCollisionFreeFailedResponse returns the union data inside the PlanCollisionFreeResponse_Response as a PlanCollisionFreeFailedResponse
func (t PlanCollisionFreeResponse_Response) AsPlanCollisionFreeFailedResponse() (PlanCollisionFreeFailedResponse, error) {
	var body PlanCollisionFreeFailedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlanCollisionFreeFailedResponse overwrites any union data inside the PlanCollisionFreeResponse_Response as the provided PlanCollisionFreeFailedResponse
func (t *PlanCollisionFreeResponse_Response) FromPlanCollisionFreeFailedResponse(v PlanCollisionFreeFailedResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlanCollisionFreeFailedResponse performs a merge with any union data inside the PlanCollisionFreeResponse_Response, using the provided PlanCollisionFreeFailedResponse
func (t *PlanCollisionFreeResponse_Response) MergePlanCollisionFreeFailedResponse(v PlanCollisionFreeFailedResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlanCollisionFreeResponse_Response) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlanCollisionFreeResponse_Response) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFeedbackOutOfWorkspace returns the union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as a FeedbackOutOfWorkspace
func (t PlanTrajectoryFailedResponse_ErrorFeedback) AsFeedbackOutOfWorkspace() (FeedbackOutOfWorkspace, error) {
	var body FeedbackOutOfWorkspace
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeedbackOutOfWorkspace overwrites any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as the provided FeedbackOutOfWorkspace
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) FromFeedbackOutOfWorkspace(v FeedbackOutOfWorkspace) error {
	v.ErrorFeedbackName = "FeedbackOutOfWorkspace"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeedbackOutOfWorkspace performs a merge with any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback, using the provided FeedbackOutOfWorkspace
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) MergeFeedbackOutOfWorkspace(v FeedbackOutOfWorkspace) error {
	v.ErrorFeedbackName = "FeedbackOutOfWorkspace"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeedbackSingularity returns the union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as a FeedbackSingularity
func (t PlanTrajectoryFailedResponse_ErrorFeedback) AsFeedbackSingularity() (FeedbackSingularity, error) {
	var body FeedbackSingularity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeedbackSingularity overwrites any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as the provided FeedbackSingularity
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) FromFeedbackSingularity(v FeedbackSingularity) error {
	v.ErrorFeedbackName = "FeedbackSingularity"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeedbackSingularity performs a merge with any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback, using the provided FeedbackSingularity
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) MergeFeedbackSingularity(v FeedbackSingularity) error {
	v.ErrorFeedbackName = "FeedbackSingularity"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeedbackJointLimitExceeded returns the union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as a FeedbackJointLimitExceeded
func (t PlanTrajectoryFailedResponse_ErrorFeedback) AsFeedbackJointLimitExceeded() (FeedbackJointLimitExceeded, error) {
	var body FeedbackJointLimitExceeded
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeedbackJointLimitExceeded overwrites any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as the provided FeedbackJointLimitExceeded
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) FromFeedbackJointLimitExceeded(v FeedbackJointLimitExceeded) error {
	v.ErrorFeedbackName = "FeedbackJointLimitExceeded"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeedbackJointLimitExceeded performs a merge with any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback, using the provided FeedbackJointLimitExceeded
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) MergeFeedbackJointLimitExceeded(v FeedbackJointLimitExceeded) error {
	v.ErrorFeedbackName = "FeedbackJointLimitExceeded"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeedbackCollision returns the union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as a FeedbackCollision
func (t PlanTrajectoryFailedResponse_ErrorFeedback) AsFeedbackCollision() (FeedbackCollision, error) {
	var body FeedbackCollision
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeedbackCollision overwrites any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as the provided FeedbackCollision
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) FromFeedbackCollision(v FeedbackCollision) error {
	v.ErrorFeedbackName = "FeedbackCollision"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeedbackCollision performs a merge with any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback, using the provided FeedbackCollision
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) MergeFeedbackCollision(v FeedbackCollision) error {
	v.ErrorFeedbackName = "FeedbackCollision"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlanTrajectoryFailedResponse_ErrorFeedback) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"error_feedback_name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlanTrajectoryFailedResponse_ErrorFeedback) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FeedbackCollision":
		return t.AsFeedbackCollision()
	case "FeedbackJointLimitExceeded":
		return t.AsFeedbackJointLimitExceeded()
	case "FeedbackOutOfWorkspace":
		return t.AsFeedbackOutOfWorkspace()
	case "FeedbackSingularity":
		return t.AsFeedbackSingularity()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlanTrajectoryFailedResponse_ErrorFeedback) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlanTrajectoryFailedResponse_ErrorFeedback) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJointTrajectory returns the union data inside the PlanTrajectoryResponse_Response as a JointTrajectory
func (t PlanTrajectoryResponse_Response) AsJointTrajectory() (JointTrajectory, error) {
	var body JointTrajectory
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJointTrajectory overwrites any union data inside the PlanTrajectoryResponse_Response as the provided JointTrajectory
func (t *PlanTrajectoryResponse_Response) FromJointTrajectory(v JointTrajectory) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJointTrajectory performs a merge with any union data inside the PlanTrajectoryResponse_Response, using the provided JointTrajectory
func (t *PlanTrajectoryResponse_Response) MergeJointTrajectory(v JointTrajectory) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlanTrajectoryFailedResponse returns the union data inside the PlanTrajectoryResponse_Response as a PlanTrajectoryFailedResponse
func (t PlanTrajectoryResponse_Response) AsPlanTrajectoryFailedResponse() (PlanTrajectoryFailedResponse, error) {
	var body PlanTrajectoryFailedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlanTrajectoryFailedResponse overwrites any union data inside the PlanTrajectoryResponse_Response as the provided PlanTrajectoryFailedResponse
func (t *PlanTrajectoryResponse_Response) FromPlanTrajectoryFailedResponse(v PlanTrajectoryFailedResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlanTrajectoryFailedResponse performs a merge with any union data inside the PlanTrajectoryResponse_Response, using the provided PlanTrajectoryFailedResponse
func (t *PlanTrajectoryResponse_Response) MergePlanTrajectoryFailedResponse(v PlanTrajectoryFailedResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlanTrajectoryResponse_Response) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlanTrajectoryResponse_Response) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsErrorInvalidJointCount returns the union data inside the PlanValidationError_Data as a ErrorInvalidJointCount
func (t PlanValidationError_Data) AsErrorInvalidJointCount() (ErrorInvalidJointCount, error) {
	var body ErrorInvalidJointCount
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorInvalidJointCount overwrites any union data inside the PlanValidationError_Data as the provided ErrorInvalidJointCount
func (t *PlanValidationError_Data) FromErrorInvalidJointCount(v ErrorInvalidJointCount) error {
	v.ErrorFeedbackName = "ErrorInvalidJointCount"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorInvalidJointCount performs a merge with any union data inside the PlanValidationError_Data, using the provided ErrorInvalidJointCount
func (t *PlanValidationError_Data) MergeErrorInvalidJointCount(v ErrorInvalidJointCount) error {
	v.ErrorFeedbackName = "ErrorInvalidJointCount"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorJointLimitExceeded returns the union data inside the PlanValidationError_Data as a ErrorJointLimitExceeded
func (t PlanValidationError_Data) AsErrorJointLimitExceeded() (ErrorJointLimitExceeded, error) {
	var body ErrorJointLimitExceeded
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorJointLimitExceeded overwrites any union data inside the PlanValidationError_Data as the provided ErrorJointLimitExceeded
func (t *PlanValidationError_Data) FromErrorJointLimitExceeded(v ErrorJointLimitExceeded) error {
	v.ErrorFeedbackName = "ErrorJointLimitExceeded"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorJointLimitExceeded performs a merge with any union data inside the PlanValidationError_Data, using the provided ErrorJointLimitExceeded
func (t *PlanValidationError_Data) MergeErrorJointLimitExceeded(v ErrorJointLimitExceeded) error {
	v.ErrorFeedbackName = "ErrorJointLimitExceeded"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsErrorJointPositionCollision returns the union data inside the PlanValidationError_Data as a ErrorJointPositionCollision
func (t PlanValidationError_Data) AsErrorJointPositionCollision() (ErrorJointPositionCollision, error) {
	var body ErrorJointPositionCollision
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromErrorJointPositionCollision overwrites any union data inside the PlanValidationError_Data as the provided ErrorJointPositionCollision
func (t *PlanValidationError_Data) FromErrorJointPositionCollision(v ErrorJointPositionCollision) error {
	v.ErrorFeedbackName = "ErrorJointPositionCollision"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeErrorJointPositionCollision performs a merge with any union data inside the PlanValidationError_Data, using the provided ErrorJointPositionCollision
func (t *PlanValidationError_Data) MergeErrorJointPositionCollision(v ErrorJointPositionCollision) error {
	v.ErrorFeedbackName = "ErrorJointPositionCollision"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlanValidationError_Data) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"error_feedback_name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlanValidationError_Data) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ErrorInvalidJointCount":
		return t.AsErrorInvalidJointCount()
	case "ErrorJointLimitExceeded":
		return t.AsErrorJointLimitExceeded()
	case "ErrorJointPositionCollision":
		return t.AsErrorJointPositionCollision()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlanValidationError_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlanValidationError_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPlanValidationErrorLoc0 returns the union data inside the PlanValidationError_Loc_Item as a PlanValidationErrorLoc0
func (t PlanValidationError_Loc_Item) AsPlanValidationErrorLoc0() (PlanValidationErrorLoc0, error) {
	var body PlanValidationErrorLoc0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlanValidationErrorLoc0 overwrites any union data inside the PlanValidationError_Loc_Item as the provided PlanValidationErrorLoc0
func (t *PlanValidationError_Loc_Item) FromPlanValidationErrorLoc0(v PlanValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlanValidationErrorLoc0 performs a merge with any union data inside the PlanValidationError_Loc_Item, using the provided PlanValidationErrorLoc0
func (t *PlanValidationError_Loc_Item) MergePlanValidationErrorLoc0(v PlanValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlanValidationErrorLoc1 returns the union data inside the PlanValidationError_Loc_Item as a PlanValidationErrorLoc1
func (t PlanValidationError_Loc_Item) AsPlanValidationErrorLoc1() (PlanValidationErrorLoc1, error) {
	var body PlanValidationErrorLoc1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlanValidationErrorLoc1 overwrites any union data inside the PlanValidationError_Loc_Item as the provided PlanValidationErrorLoc1
func (t *PlanValidationError_Loc_Item) FromPlanValidationErrorLoc1(v PlanValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlanValidationErrorLoc1 performs a merge with any union data inside the PlanValidationError_Loc_Item, using the provided PlanValidationErrorLoc1
func (t *PlanValidationError_Loc_Item) MergePlanValidationErrorLoc1(v PlanValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlanValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlanValidationError_Loc_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAbbController returns the union data inside the ControllerConfig as a AbbController
func (t ControllerConfig) AsAbbController() (AbbController, error) {
	var body AbbController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbbController overwrites any union data inside the ControllerConfig as the provided AbbController
func (t *ControllerConfig) FromAbbController(v AbbController) error {
	v.Kind = "AbbController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbbController performs a merge with any union data inside the ControllerConfig, using the provided AbbController
func (t *ControllerConfig) MergeAbbController(v AbbController) error {
	v.Kind = "AbbController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFanucController returns the union data inside the ControllerConfig as a FanucController
func (t ControllerConfig) AsFanucController() (FanucController, error) {
	var body FanucController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFanucController overwrites any union data inside the ControllerConfig as the provided FanucController
func (t *ControllerConfig) FromFanucController(v FanucController) error {
	v.Kind = "FanucController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFanucController performs a merge with any union data inside the ControllerConfig, using the provided FanucController
func (t *ControllerConfig) MergeFanucController(v FanucController) error {
	v.Kind = "FanucController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKukaController returns the union data inside the ControllerConfig as a KukaController
func (t ControllerConfig) AsKukaController() (KukaController, error) {
	var body KukaController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKukaController overwrites any union data inside the ControllerConfig as the provided KukaController
func (t *ControllerConfig) FromKukaController(v KukaController) error {
	v.Kind = "KukaController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKukaController performs a merge with any union data inside the ControllerConfig, using the provided KukaController
func (t *ControllerConfig) MergeKukaController(v KukaController) error {
	v.Kind = "KukaController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUniversalrobotsController returns the union data inside the ControllerConfig as a UniversalrobotsController
func (t ControllerConfig) AsUniversalrobotsController() (UniversalrobotsController, error) {
	var body UniversalrobotsController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUniversalrobotsController overwrites any union data inside the ControllerConfig as the provided UniversalrobotsController
func (t *ControllerConfig) FromUniversalrobotsController(v UniversalrobotsController) error {
	v.Kind = "UniversalrobotsController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUniversalrobotsController performs a merge with any union data inside the ControllerConfig, using the provided UniversalrobotsController
func (t *ControllerConfig) MergeUniversalrobotsController(v UniversalrobotsController) error {
	v.Kind = "UniversalrobotsController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualController returns the union data inside the ControllerConfig as a VirtualController
func (t ControllerConfig) AsVirtualController() (VirtualController, error) {
	var body VirtualController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualController overwrites any union data inside the ControllerConfig as the provided VirtualController
func (t *ControllerConfig) FromVirtualController(v VirtualController) error {
	v.Kind = "VirtualController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualController performs a merge with any union data inside the ControllerConfig, using the provided VirtualController
func (t *ControllerConfig) MergeVirtualController(v VirtualController) error {
	v.Kind = "VirtualController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsYaskawaController returns the union data inside the ControllerConfig as a YaskawaController
func (t ControllerConfig) AsYaskawaController() (YaskawaController, error) {
	var body YaskawaController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromYaskawaController overwrites any union data inside the ControllerConfig as the provided YaskawaController
func (t *ControllerConfig) FromYaskawaController(v YaskawaController) error {
	v.Kind = "YaskawaController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeYaskawaController performs a merge with any union data inside the ControllerConfig, using the provided YaskawaController
func (t *ControllerConfig) MergeYaskawaController(v YaskawaController) error {
	v.Kind = "YaskawaController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ControllerConfig) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"kind"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ControllerConfig) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "AbbController":
		return t.AsAbbController()
	case "FanucController":
		return t.AsFanucController()
	case "KukaController":
		return t.AsKukaController()
	case "UniversalrobotsController":
		return t.AsUniversalrobotsController()
	case "VirtualController":
		return t.AsVirtualController()
	case "YaskawaController":
		return t.AsYaskawaController()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ControllerConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ControllerConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTrajectoryRunning returns the union data inside the TrajectoryDetails_State as a TrajectoryRunning
func (t TrajectoryDetails_State) AsTrajectoryRunning() (TrajectoryRunning, error) {
	var body TrajectoryRunning
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrajectoryRunning overwrites any union data inside the TrajectoryDetails_State as the provided TrajectoryRunning
func (t *TrajectoryDetails_State) FromTrajectoryRunning(v TrajectoryRunning) error {
	v.Kind = "RUNNING"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrajectoryRunning performs a merge with any union data inside the TrajectoryDetails_State, using the provided TrajectoryRunning
func (t *TrajectoryDetails_State) MergeTrajectoryRunning(v TrajectoryRunning) error {
	v.Kind = "RUNNING"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTrajectoryPausedByUser returns the union data inside the TrajectoryDetails_State as a TrajectoryPausedByUser
func (t TrajectoryDetails_State) AsTrajectoryPausedByUser() (TrajectoryPausedByUser, error) {
	var body TrajectoryPausedByUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrajectoryPausedByUser overwrites any union data inside the TrajectoryDetails_State as the provided TrajectoryPausedByUser
func (t *TrajectoryDetails_State) FromTrajectoryPausedByUser(v TrajectoryPausedByUser) error {
	v.Kind = "PAUSED_BY_USER"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrajectoryPausedByUser performs a merge with any union data inside the TrajectoryDetails_State, using the provided TrajectoryPausedByUser
func (t *TrajectoryDetails_State) MergeTrajectoryPausedByUser(v TrajectoryPausedByUser) error {
	v.Kind = "PAUSED_BY_USER"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTrajectoryEnded returns the union data inside the TrajectoryDetails_State as a TrajectoryEnded
func (t TrajectoryDetails_State) AsTrajectoryEnded() (TrajectoryEnded, error) {
	var body TrajectoryEnded
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrajectoryEnded overwrites any union data inside the TrajectoryDetails_State as the provided TrajectoryEnded
func (t *TrajectoryDetails_State) FromTrajectoryEnded(v TrajectoryEnded) error {
	v.Kind = "END_OF_TRAJECTORY"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrajectoryEnded performs a merge with any union data inside the TrajectoryDetails_State, using the provided TrajectoryEnded
func (t *TrajectoryDetails_State) MergeTrajectoryEnded(v TrajectoryEnded) error {
	v.Kind = "END_OF_TRAJECTORY"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTrajectoryWaitForIO returns the union data inside the TrajectoryDetails_State as a TrajectoryWaitForIO
func (t TrajectoryDetails_State) AsTrajectoryWaitForIO() (TrajectoryWaitForIO, error) {
	var body TrajectoryWaitForIO
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrajectoryWaitForIO overwrites any union data inside the TrajectoryDetails_State as the provided TrajectoryWaitForIO
func (t *TrajectoryDetails_State) FromTrajectoryWaitForIO(v TrajectoryWaitForIO) error {
	v.Kind = "WAIT_FOR_IO"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrajectoryWaitForIO performs a merge with any union data inside the TrajectoryDetails_State, using the provided TrajectoryWaitForIO
func (t *TrajectoryDetails_State) MergeTrajectoryWaitForIO(v TrajectoryWaitForIO) error {
	v.Kind = "WAIT_FOR_IO"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTrajectoryPausedOnIO returns the union data inside the TrajectoryDetails_State as a TrajectoryPausedOnIO
func (t TrajectoryDetails_State) AsTrajectoryPausedOnIO() (TrajectoryPausedOnIO, error) {
	var body TrajectoryPausedOnIO
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrajectoryPausedOnIO overwrites any union data inside the TrajectoryDetails_State as the provided TrajectoryPausedOnIO
func (t *TrajectoryDetails_State) FromTrajectoryPausedOnIO(v TrajectoryPausedOnIO) error {
	v.Kind = "PAUSED_ON_IO"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrajectoryPausedOnIO performs a merge with any union data inside the TrajectoryDetails_State, using the provided TrajectoryPausedOnIO
func (t *TrajectoryDetails_State) MergeTrajectoryPausedOnIO(v TrajectoryPausedOnIO) error {
	v.Kind = "PAUSED_ON_IO"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TrajectoryDetails_State) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"kind"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TrajectoryDetails_State) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "END_OF_TRAJECTORY":
		return t.AsTrajectoryEnded()
	case "PAUSED_BY_USER":
		return t.AsTrajectoryPausedByUser()
	case "PAUSED_ON_IO":
		return t.AsTrajectoryPausedOnIO()
	case "RUNNING":
		return t.AsTrajectoryRunning()
	case "WAIT_FOR_IO":
		return t.AsTrajectoryWaitForIO()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TrajectoryDetails_State) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TrajectoryDetails_State) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsValidationErrorLoc0 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc0
func (t ValidationError_Loc_Item) AsValidationErrorLoc0() (ValidationErrorLoc0, error) {
	var body ValidationErrorLoc0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc0 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) FromValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc0 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsValidationErrorLoc1 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc1
func (t ValidationError_Loc_Item) AsValidationErrorLoc1() (ValidationErrorLoc1, error) {
	var body ValidationErrorLoc1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc1 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) FromValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc1 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ValidationError_Loc_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListCells request
	ListCells(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeployCellWithBody request with any body
	DeployCellWithBody(ctx context.Context, params *DeployCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeployCell(ctx context.Context, params *DeployCellParams, body DeployCellJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCell request
	DeleteCell(ctx context.Context, cellID CellID, params *DeleteCellParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCell request
	GetCell(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCellWithBody request with any body
	UpdateCellWithBody(ctx context.Context, cellID CellID, params *UpdateCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCell(ctx context.Context, cellID CellID, params *UpdateCellParams, body UpdateCellJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearApps request
	ClearApps(ctx context.Context, cellID CellID, params *ClearAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApps request
	ListApps(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAppWithBody request with any body
	AddAppWithBody(ctx context.Context, cellID CellID, params *AddAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddApp(ctx context.Context, cellID CellID, params *AddAppParams, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApp request
	DeleteApp(ctx context.Context, cellID CellID, appID AppID, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppWithBody request with any body
	UpdateAppWithBody(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApp(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearBusIOService request
	ClearBusIOService(ctx context.Context, cellID CellID, params *ClearBusIOServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBusIOService request
	GetBusIOService(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddBusIOServiceWithBody request with any body
	AddBusIOServiceWithBody(ctx context.Context, cellID CellID, params *AddBusIOServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddBusIOService(ctx context.Context, cellID CellID, params *AddBusIOServiceParams, body AddBusIOServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBusIODescriptions request
	ListBusIODescriptions(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBusIOValues request
	GetBusIOValues(ctx context.Context, cellID CellID, params *GetBusIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBusIOValuesWithBody request with any body
	SetBusIOValuesWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetBusIOValues(ctx context.Context, cellID CellID, body SetBusIOValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProfinetDescription request
	GetProfinetDescription(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProfinetIOsFromFile request
	GetProfinetIOsFromFile(ctx context.Context, cellID CellID, params *GetProfinetIOsFromFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetProfinetIOsFromFileWithBody request with any body
	SetProfinetIOsFromFileWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetProfinetIOsFromFile(ctx context.Context, cellID CellID, body SetProfinetIOsFromFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProfinetIOs request
	ListProfinetIOs(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProfinetIO request
	DeleteProfinetIO(ctx context.Context, cellID CellID, ioid IOID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddProfinetIOWithBody request with any body
	AddProfinetIOWithBody(ctx context.Context, cellID CellID, ioid IOID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddProfinetIO(ctx context.Context, cellID CellID, ioid IOID, body AddProfinetIOJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBusIOState request
	GetBusIOState(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearRobotControllers request
	ClearRobotControllers(ctx context.Context, cellID CellID, params *ClearRobotControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRobotControllers request
	ListRobotControllers(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRobotControllerWithBody request with any body
	AddRobotControllerWithBody(ctx context.Context, cellID CellID, params *AddRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRobotController(ctx context.Context, cellID CellID, params *AddRobotControllerParams, body AddRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRobotController request
	DeleteRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, params *DeleteRobotControllerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRobotController request
	GetRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRobotControllerWithBody request with any body
	UpdateRobotControllerWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, body UpdateRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCoordinateSystems request
	ListCoordinateSystems(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListCoordinateSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoordinateSystem request
	GetCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, params *GetCoordinateSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetControllerDescription request
	GetControllerDescription(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteJoggingWithBody request with any body
	ExecuteJoggingWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteJogging(ctx context.Context, cellID CellID, controllerID ControllerID, body ExecuteJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteTrajectoryWithBody request with any body
	ExecuteTrajectoryWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteTrajectory(ctx context.Context, cellID CellID, controllerID ControllerID, body ExecuteTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamFreeDrive request
	StreamFreeDrive(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIODescriptions request
	ListIODescriptions(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamIOValues request
	StreamIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIOValues request
	ListIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOutputValuesWithBody request with any body
	SetOutputValuesWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetOutputValues(ctx context.Context, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WaitForIOEventWithBody request with any body
	WaitForIOEventWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WaitForIOEvent(ctx context.Context, cellID CellID, controllerID ControllerID, body WaitForIOEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDefaultMode request
	SetDefaultMode(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroupDescription request
	GetMotionGroupDescription(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentMotionGroupState request
	GetCurrentMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, params *GetCurrentMotionGroupStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamMotionGroupState request
	StreamMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, params *StreamMotionGroupStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentRobotControllerState request
	GetCurrentRobotControllerState(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamRobotControllerState request
	StreamRobotControllerState(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearTrajectories request
	ClearTrajectories(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTrajectories request
	ListTrajectories(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTrajectoryWithBody request with any body
	AddTrajectoryWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTrajectory(ctx context.Context, cellID CellID, controllerID ControllerID, body AddTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTrajectory request
	DeleteTrajectory(ctx context.Context, cellID CellID, controllerID ControllerID, trajectory Trajectory, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTrajectory request
	GetTrajectory(ctx context.Context, cellID CellID, controllerID ControllerID, trajectory Trajectory, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualControllerConfiguration request
	GetVirtualControllerConfiguration(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ForwardKinematicsWithBody request with any body
	ForwardKinematicsWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ForwardKinematics(ctx context.Context, cellID CellID, body ForwardKinematicsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InverseKinematicsWithBody request with any body
	InverseKinematicsWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InverseKinematics(ctx context.Context, cellID CellID, body InverseKinematicsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroupModels request
	GetMotionGroupModels(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroupCollisionModel request
	GetMotionGroupCollisionModel(ctx context.Context, cellID CellID, motionGroupModel MotionGroupModelParameter, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCellStatus request
	GetCellStatus(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCellStatus request
	SetCellStatus(ctx context.Context, cellID CellID, params *SetCellStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStoredColliders request
	ListStoredColliders(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoredCollider request
	DeleteStoredCollider(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoredCollider request
	GetStoredCollider(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreColliderWithBody request with any body
	StoreColliderWithBody(ctx context.Context, cellID CellID, colliderID ColliderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCollider(ctx context.Context, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCollisionLinkChains request
	ListCollisionLinkChains(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoredCollisionLinkChain request
	DeleteStoredCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoredCollisionLinkChain request
	GetStoredCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreCollisionLinkChainWithBody request with any body
	StoreCollisionLinkChainWithBody(ctx context.Context, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStoredCollisionSetups request
	ListStoredCollisionSetups(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoredCollisionSetup request
	DeleteStoredCollisionSetup(ctx context.Context, cellID CellID, setup Setup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoredCollisionSetup request
	GetStoredCollisionSetup(ctx context.Context, cellID CellID, setup Setup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreCollisionSetupWithBody request with any body
	StoreCollisionSetupWithBody(ctx context.Context, cellID CellID, setup Setup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCollisionSetup(ctx context.Context, cellID CellID, setup Setup, body StoreCollisionSetupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStoredCollisionTools request
	ListStoredCollisionTools(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoredCollisionTool request
	DeleteStoredCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoredCollisionTool request
	GetStoredCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreCollisionToolWithBody request with any body
	StoreCollisionToolWithBody(ctx context.Context, cellID CellID, toolID ToolID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearAllObjects request
	ClearAllObjects(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllObjectKeys request
	ListAllObjectKeys(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObject request
	DeleteObject(ctx context.Context, cellID CellID, objectKey ObjectKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObject request
	GetObject(ctx context.Context, cellID CellID, objectKey ObjectKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObjectMetadata request
	GetObjectMetadata(ctx context.Context, cellID CellID, objectKey ObjectKey, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreObjectWithBody request with any body
	StoreObjectWithBody(ctx context.Context, cellID CellID, objectKey ObjectKey, params *StoreObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlanCollisionFreeWithBody request with any body
	PlanCollisionFreeWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PlanCollisionFree(ctx context.Context, cellID CellID, body PlanCollisionFreeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlanTrajectoryWithBody request with any body
	PlanTrajectoryWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PlanTrajectory(ctx context.Context, cellID CellID, body PlanTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualControllerBehavior request
	GetVirtualControllerBehavior(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetVirtualControllerBehavior request
	SetVirtualControllerBehavior(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetVirtualControllerBehaviorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVirtualControllerCoordinateSystems request
	ListVirtualControllerCoordinateSystems(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualControllerCoordinateSystem request
	DeleteVirtualControllerCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, params *DeleteVirtualControllerCoordinateSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddVirtualControllerCoordinateSystemWithBody request with any body
	AddVirtualControllerCoordinateSystemWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddVirtualControllerCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, body AddVirtualControllerCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCycleTime request
	GetCycleTime(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmergencyStop request
	GetEmergencyStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetEmergencyStop request
	SetEmergencyStop(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetEmergencyStopParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExternalJointsStreamWithBody request with any body
	ExternalJointsStreamWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExternalJointsStream(ctx context.Context, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVirtualControllerIODescriptions request
	ListVirtualControllerIODescriptions(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListVirtualControllerIODescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIOs request
	ListIOs(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIOValuesWithBody request with any body
	SetIOValuesWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, body SetIOValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroups request
	GetMotionGroups(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualControllerMounting request
	GetVirtualControllerMounting(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetVirtualControllerMountingWithBody request with any body
	SetVirtualControllerMountingWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetVirtualControllerMounting(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, body SetVirtualControllerMountingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroupState request
	GetMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMotionGroupStateWithBody request with any body
	SetMotionGroupStateWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, body SetMotionGroupStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVirtualControllerTcps request
	ListVirtualControllerTcps(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualControllerTcp request
	DeleteVirtualControllerTcp(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddVirtualControllerTcpWithBody request with any body
	AddVirtualControllerTcpWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddVirtualControllerTcp(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, body AddVirtualControllerTcpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOperationMode request
	GetOperationMode(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOperationMode request
	SetOperationMode(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetOperationModeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeactivateLicense request
	DeactivateLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicense request
	GetLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateLicenseWithBody request with any body
	ActivateLicenseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateLicense(ctx context.Context, body ActivateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicenseStatus request
	GetLicenseStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BackupConfiguration request
	BackupConfiguration(ctx context.Context, params *BackupConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreConfigurationWithBody request with any body
	RestoreConfigurationWithBody(ctx context.Context, params *RestoreConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListConfigurationResources request
	ListConfigurationResources(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationBackupStatus request
	GetConfigurationBackupStatus(ctx context.Context, params *GetConfigurationBackupStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiagnosePackage request
	GetDiagnosePackage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemStatus request
	GetSystemStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckNovaVersionUpdate request
	CheckNovaVersionUpdate(ctx context.Context, params *CheckNovaVersionUpdateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNovaVersionWithBody request with any body
	UpdateNovaVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNovaVersion(ctx context.Context, body UpdateNovaVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemVersion request
	GetSystemVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListCells(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCellsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeployCellWithBody(ctx context.Context, params *DeployCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeployCellRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeployCell(ctx context.Context, params *DeployCellParams, body DeployCellJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeployCellRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCell(ctx context.Context, cellID CellID, params *DeleteCellParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCellRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCell(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCellRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCellWithBody(ctx context.Context, cellID CellID, params *UpdateCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCellRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCell(ctx context.Context, cellID CellID, params *UpdateCellParams, body UpdateCellJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCellRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearApps(ctx context.Context, cellID CellID, params *ClearAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearAppsRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApps(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAppWithBody(ctx context.Context, cellID CellID, params *AddAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAppRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddApp(ctx context.Context, cellID CellID, params *AddAppParams, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAppRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApp(ctx context.Context, cellID CellID, appID AppID, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppRequest(c.Server, cellID, appID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApp(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, cellID, appID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppWithBody(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequestWithBody(c.Server, cellID, appID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApp(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequest(c.Server, cellID, appID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearBusIOService(ctx context.Context, cellID CellID, params *ClearBusIOServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearBusIOServiceRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBusIOService(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBusIOServiceRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBusIOServiceWithBody(ctx context.Context, cellID CellID, params *AddBusIOServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBusIOServiceRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBusIOService(ctx context.Context, cellID CellID, params *AddBusIOServiceParams, body AddBusIOServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBusIOServiceRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBusIODescriptions(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBusIODescriptionsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBusIOValues(ctx context.Context, cellID CellID, params *GetBusIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBusIOValuesRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBusIOValuesWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBusIOValuesRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBusIOValues(ctx context.Context, cellID CellID, body SetBusIOValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBusIOValuesRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProfinetDescription(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProfinetDescriptionRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProfinetIOsFromFile(ctx context.Context, cellID CellID, params *GetProfinetIOsFromFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProfinetIOsFromFileRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetProfinetIOsFromFileWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetProfinetIOsFromFileRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetProfinetIOsFromFile(ctx context.Context, cellID CellID, body SetProfinetIOsFromFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetProfinetIOsFromFileRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProfinetIOs(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProfinetIOsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProfinetIO(ctx context.Context, cellID CellID, ioid IOID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProfinetIORequest(c.Server, cellID, ioid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProfinetIOWithBody(ctx context.Context, cellID CellID, ioid IOID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProfinetIORequestWithBody(c.Server, cellID, ioid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProfinetIO(ctx context.Context, cellID CellID, ioid IOID, body AddProfinetIOJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProfinetIORequest(c.Server, cellID, ioid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBusIOState(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBusIOStateRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearRobotControllers(ctx context.Context, cellID CellID, params *ClearRobotControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearRobotControllersRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRobotControllers(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRobotControllersRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRobotControllerWithBody(ctx context.Context, cellID CellID, params *AddRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRobotControllerRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRobotController(ctx context.Context, cellID CellID, params *AddRobotControllerParams, body AddRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRobotControllerRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, params *DeleteRobotControllerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRobotControllerRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRobotControllerRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRobotControllerWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRobotControllerRequestWithBody(c.Server, cellID, controllerID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, body UpdateRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRobotControllerRequest(c.Server, cellID, controllerID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCoordinateSystems(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListCoordinateSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCoordinateSystemsRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, params *GetCoordinateSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoordinateSystemRequest(c.Server, cellID, controllerID, coordinateSystemID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetControllerDescription(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetControllerDescriptionRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteJoggingWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteJoggingRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteJogging(ctx context.Context, cellID CellID, controllerID ControllerID, body ExecuteJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteJoggingRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteTrajectoryWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteTrajectoryRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteTrajectory(ctx context.Context, cellID CellID, controllerID ControllerID, body ExecuteTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteTrajectoryRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamFreeDrive(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamFreeDriveRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIODescriptions(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIODescriptionsRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamIOValuesRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIOValuesRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOutputValuesWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOutputValuesRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOutputValues(ctx context.Context, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOutputValuesRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WaitForIOEventWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWaitForIOEventRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WaitForIOEvent(ctx context.Context, cellID CellID, controllerID ControllerID, body WaitForIOEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWaitForIOEventRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultMode(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultModeRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroupDescription(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupDescriptionRequest(c.Server, cellID, controllerID, motionGroupID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, params *GetCurrentMotionGroupStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentMotionGroupStateRequest(c.Server, cellID, controllerID, motionGroupID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, params *StreamMotionGroupStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMotionGroupStateRequest(c.Server, cellID, controllerID, motionGroupID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentRobotControllerState(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentRobotControllerStateRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamRobotControllerState(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamRobotControllerStateRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearTrajectories(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearTrajectoriesRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTrajectories(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTrajectoriesRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTrajectoryWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTrajectoryRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTrajectory(ctx context.Context, cellID CellID, controllerID ControllerID, body AddTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTrajectoryRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTrajectory(ctx context.Context, cellID CellID, controllerID ControllerID, trajectory Trajectory, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTrajectoryRequest(c.Server, cellID, controllerID, trajectory)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrajectory(ctx context.Context, cellID CellID, controllerID ControllerID, trajectory Trajectory, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTrajectoryRequest(c.Server, cellID, controllerID, trajectory)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualControllerConfiguration(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualControllerConfigurationRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForwardKinematicsWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForwardKinematicsRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForwardKinematics(ctx context.Context, cellID CellID, body ForwardKinematicsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForwardKinematicsRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InverseKinematicsWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInverseKinematicsRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InverseKinematics(ctx context.Context, cellID CellID, body InverseKinematicsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInverseKinematicsRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroupModels(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupModelsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroupCollisionModel(ctx context.Context, cellID CellID, motionGroupModel MotionGroupModelParameter, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupCollisionModelRequest(c.Server, cellID, motionGroupModel)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCellStatus(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCellStatusRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCellStatus(ctx context.Context, cellID CellID, params *SetCellStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCellStatusRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStoredColliders(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStoredCollidersRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoredCollider(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoredColliderRequest(c.Server, cellID, colliderID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoredCollider(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoredColliderRequest(c.Server, cellID, colliderID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreColliderWithBody(ctx context.Context, cellID CellID, colliderID ColliderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreColliderRequestWithBody(c.Server, cellID, colliderID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollider(ctx context.Context, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreColliderRequest(c.Server, cellID, colliderID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCollisionLinkChains(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCollisionLinkChainsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoredCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoredCollisionLinkChainRequest(c.Server, cellID, linkChainID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoredCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoredCollisionLinkChainRequest(c.Server, cellID, linkChainID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionLinkChainWithBody(ctx context.Context, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionLinkChainRequestWithBody(c.Server, cellID, linkChainID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionLinkChainRequest(c.Server, cellID, linkChainID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStoredCollisionSetups(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStoredCollisionSetupsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoredCollisionSetup(ctx context.Context, cellID CellID, setup Setup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoredCollisionSetupRequest(c.Server, cellID, setup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoredCollisionSetup(ctx context.Context, cellID CellID, setup Setup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoredCollisionSetupRequest(c.Server, cellID, setup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionSetupWithBody(ctx context.Context, cellID CellID, setup Setup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionSetupRequestWithBody(c.Server, cellID, setup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionSetup(ctx context.Context, cellID CellID, setup Setup, body StoreCollisionSetupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionSetupRequest(c.Server, cellID, setup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStoredCollisionTools(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStoredCollisionToolsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoredCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoredCollisionToolRequest(c.Server, cellID, toolID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoredCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoredCollisionToolRequest(c.Server, cellID, toolID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionToolWithBody(ctx context.Context, cellID CellID, toolID ToolID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionToolRequestWithBody(c.Server, cellID, toolID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionToolRequest(c.Server, cellID, toolID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearAllObjects(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearAllObjectsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllObjectKeys(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllObjectKeysRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObject(ctx context.Context, cellID CellID, objectKey ObjectKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectRequest(c.Server, cellID, objectKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObject(ctx context.Context, cellID CellID, objectKey ObjectKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectRequest(c.Server, cellID, objectKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObjectMetadata(ctx context.Context, cellID CellID, objectKey ObjectKey, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectMetadataRequest(c.Server, cellID, objectKey)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreObjectWithBody(ctx context.Context, cellID CellID, objectKey ObjectKey, params *StoreObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreObjectRequestWithBody(c.Server, cellID, objectKey, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanCollisionFreeWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanCollisionFreeRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanCollisionFree(ctx context.Context, cellID CellID, body PlanCollisionFreeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanCollisionFreeRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanTrajectoryWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanTrajectoryRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanTrajectory(ctx context.Context, cellID CellID, body PlanTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanTrajectoryRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualControllerBehavior(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualControllerBehaviorRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetVirtualControllerBehavior(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetVirtualControllerBehaviorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetVirtualControllerBehaviorRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVirtualControllerCoordinateSystems(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVirtualControllerCoordinateSystemsRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualControllerCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, params *DeleteVirtualControllerCoordinateSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualControllerCoordinateSystemRequest(c.Server, cellID, controllerID, coordinateSystemID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualControllerCoordinateSystemWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualControllerCoordinateSystemRequestWithBody(c.Server, cellID, controllerID, coordinateSystemID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualControllerCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, body AddVirtualControllerCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualControllerCoordinateSystemRequest(c.Server, cellID, controllerID, coordinateSystemID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCycleTime(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCycleTimeRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmergencyStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmergencyStopRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetEmergencyStop(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetEmergencyStopParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetEmergencyStopRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalJointsStreamWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalJointsStreamRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalJointsStream(ctx context.Context, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalJointsStreamRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVirtualControllerIODescriptions(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListVirtualControllerIODescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVirtualControllerIODescriptionsRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIOs(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIOsRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIOValuesWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIOValuesRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, body SetIOValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIOValuesRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroups(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupsRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualControllerMounting(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualControllerMountingRequest(c.Server, cellID, controllerID, motionGroupID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetVirtualControllerMountingWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetVirtualControllerMountingRequestWithBody(c.Server, cellID, controllerID, motionGroupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetVirtualControllerMounting(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, body SetVirtualControllerMountingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetVirtualControllerMountingRequest(c.Server, cellID, controllerID, motionGroupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupStateRequest(c.Server, cellID, controllerID, motionGroupID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMotionGroupStateWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMotionGroupStateRequestWithBody(c.Server, cellID, controllerID, motionGroupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, body SetMotionGroupStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMotionGroupStateRequest(c.Server, cellID, controllerID, motionGroupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVirtualControllerTcps(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVirtualControllerTcpsRequest(c.Server, cellID, controllerID, motionGroupID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualControllerTcp(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualControllerTcpRequest(c.Server, cellID, controllerID, motionGroupID, tcp)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualControllerTcpWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualControllerTcpRequestWithBody(c.Server, cellID, controllerID, motionGroupID, tcp, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualControllerTcp(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, body AddVirtualControllerTcpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualControllerTcpRequest(c.Server, cellID, controllerID, motionGroupID, tcp, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOperationMode(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOperationModeRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOperationMode(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetOperationModeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOperationModeRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeactivateLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeactivateLicenseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateLicenseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateLicenseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateLicense(ctx context.Context, body ActivateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateLicenseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicenseStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BackupConfiguration(ctx context.Context, params *BackupConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackupConfigurationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreConfigurationWithBody(ctx context.Context, params *RestoreConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreConfigurationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListConfigurationResources(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListConfigurationResourcesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationBackupStatus(ctx context.Context, params *GetConfigurationBackupStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationBackupStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiagnosePackage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiagnosePackageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckNovaVersionUpdate(ctx context.Context, params *CheckNovaVersionUpdateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckNovaVersionUpdateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNovaVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNovaVersionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNovaVersion(ctx context.Context, body UpdateNovaVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNovaVersionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListCellsRequest generates requests for ListCells
func NewListCellsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeployCellRequest calls the generic DeployCell builder with application/json body
func NewDeployCellRequest(server string, params *DeployCellParams, body DeployCellJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeployCellRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDeployCellRequestWithBody generates requests for DeployCell with any type of body
func NewDeployCellRequestWithBody(server string, params *DeployCellParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCellRequest generates requests for DeleteCell
func NewDeleteCellRequest(server string, cellID CellID, params *DeleteCellParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCellRequest generates requests for GetCell
func NewGetCellRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCellRequest calls the generic UpdateCell builder with application/json body
func NewUpdateCellRequest(server string, cellID CellID, params *UpdateCellParams, body UpdateCellJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCellRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewUpdateCellRequestWithBody generates requests for UpdateCell with any type of body
func NewUpdateCellRequestWithBody(server string, cellID CellID, params *UpdateCellParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearAppsRequest generates requests for ClearApps
func NewClearAppsRequest(server string, cellID CellID, params *ClearAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddAppRequest calls the generic AddApp builder with application/json body
func NewAddAppRequest(server string, cellID CellID, params *AddAppParams, body AddAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAppRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewAddAppRequestWithBody generates requests for AddApp with any type of body
func NewAddAppRequestWithBody(server string, cellID CellID, params *AddAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppRequest generates requests for DeleteApp
func NewDeleteAppRequest(server string, cellID CellID, appID AppID, params *DeleteAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, appID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, cellID CellID, appID AppID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, appID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppRequest calls the generic UpdateApp builder with application/json body
func NewUpdateAppRequest(server string, cellID CellID, appID AppID, params *UpdateAppParams, body UpdateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppRequestWithBody(server, cellID, appID, params, "application/json", bodyReader)
}

// NewUpdateAppRequestWithBody generates requests for UpdateApp with any type of body
func NewUpdateAppRequestWithBody(server string, cellID CellID, appID AppID, params *UpdateAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, appID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearBusIOServiceRequest generates requests for ClearBusIOService
func NewClearBusIOServiceRequest(server string, cellID CellID, params *ClearBusIOServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBusIOServiceRequest generates requests for GetBusIOService
func NewGetBusIOServiceRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddBusIOServiceRequest calls the generic AddBusIOService builder with application/json body
func NewAddBusIOServiceRequest(server string, cellID CellID, params *AddBusIOServiceParams, body AddBusIOServiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddBusIOServiceRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewAddBusIOServiceRequestWithBody generates requests for AddBusIOService with any type of body
func NewAddBusIOServiceRequestWithBody(server string, cellID CellID, params *AddBusIOServiceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBusIODescriptionsRequest generates requests for ListBusIODescriptions
func NewListBusIODescriptionsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios/ios/description", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBusIOValuesRequest generates requests for GetBusIOValues
func NewGetBusIOValuesRequest(server string, cellID CellID, params *GetBusIOValuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios/ios/values", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ios", runtime.ParamLocationQuery, *params.Ios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetBusIOValuesRequest calls the generic SetBusIOValues builder with application/json body
func NewSetBusIOValuesRequest(server string, cellID CellID, body SetBusIOValuesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetBusIOValuesRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewSetBusIOValuesRequestWithBody generates requests for SetBusIOValues with any type of body
func NewSetBusIOValuesRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios/ios/values", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProfinetDescriptionRequest generates requests for GetProfinetDescription
func NewGetProfinetDescriptionRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios/profinet/description", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProfinetIOsFromFileRequest generates requests for GetProfinetIOsFromFile
func NewGetProfinetIOsFromFileRequest(server string, cellID CellID, params *GetProfinetIOsFromFileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios/profinet/iofile", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.InputOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "input_offset", runtime.ParamLocationQuery, *params.InputOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OutputOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "output_offset", runtime.ParamLocationQuery, *params.OutputOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetProfinetIOsFromFileRequest calls the generic SetProfinetIOsFromFile builder with application/json body
func NewSetProfinetIOsFromFileRequest(server string, cellID CellID, body SetProfinetIOsFromFileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetProfinetIOsFromFileRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewSetProfinetIOsFromFileRequestWithBody generates requests for SetProfinetIOsFromFile with any type of body
func NewSetProfinetIOsFromFileRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios/profinet/iofile", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProfinetIOsRequest generates requests for ListProfinetIOs
func NewListProfinetIOsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios/profinet/ios", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProfinetIORequest generates requests for DeleteProfinetIO
func NewDeleteProfinetIORequest(server string, cellID CellID, ioid IOID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "io", runtime.ParamLocationPath, ioid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios/profinet/ios/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddProfinetIORequest calls the generic AddProfinetIO builder with application/json body
func NewAddProfinetIORequest(server string, cellID CellID, ioid IOID, body AddProfinetIOJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddProfinetIORequestWithBody(server, cellID, ioid, "application/json", bodyReader)
}

// NewAddProfinetIORequestWithBody generates requests for AddProfinetIO with any type of body
func NewAddProfinetIORequestWithBody(server string, cellID CellID, ioid IOID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "io", runtime.ParamLocationPath, ioid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios/profinet/ios/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBusIOStateRequest generates requests for GetBusIOState
func NewGetBusIOStateRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/bus-ios/state", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearRobotControllersRequest generates requests for ClearRobotControllers
func NewClearRobotControllersRequest(server string, cellID CellID, params *ClearRobotControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRobotControllersRequest generates requests for ListRobotControllers
func NewListRobotControllersRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRobotControllerRequest calls the generic AddRobotController builder with application/json body
func NewAddRobotControllerRequest(server string, cellID CellID, params *AddRobotControllerParams, body AddRobotControllerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRobotControllerRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewAddRobotControllerRequestWithBody generates requests for AddRobotController with any type of body
func NewAddRobotControllerRequestWithBody(server string, cellID CellID, params *AddRobotControllerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRobotControllerRequest generates requests for DeleteRobotController
func NewDeleteRobotControllerRequest(server string, cellID CellID, controllerID ControllerID, params *DeleteRobotControllerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRobotControllerRequest generates requests for GetRobotController
func NewGetRobotControllerRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRobotControllerRequest calls the generic UpdateRobotController builder with application/json body
func NewUpdateRobotControllerRequest(server string, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, body UpdateRobotControllerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRobotControllerRequestWithBody(server, cellID, controllerID, params, "application/json", bodyReader)
}

// NewUpdateRobotControllerRequestWithBody generates requests for UpdateRobotController with any type of body
func NewUpdateRobotControllerRequestWithBody(server string, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completion_timeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCoordinateSystemsRequest generates requests for ListCoordinateSystems
func NewListCoordinateSystemsRequest(server string, cellID CellID, controllerID ControllerID, params *ListCoordinateSystemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/coordinate-systems", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrientationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orientation_type", runtime.ParamLocationQuery, *params.OrientationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoordinateSystemRequest generates requests for GetCoordinateSystem
func NewGetCoordinateSystemRequest(server string, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, params *GetCoordinateSystemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "coordinate-system", runtime.ParamLocationPath, coordinateSystemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/coordinate-systems/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OrientationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orientation_type", runtime.ParamLocationQuery, *params.OrientationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetControllerDescriptionRequest generates requests for GetControllerDescription
func NewGetControllerDescriptionRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/description", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExecuteJoggingRequest calls the generic ExecuteJogging builder with application/json body
func NewExecuteJoggingRequest(server string, cellID CellID, controllerID ControllerID, body ExecuteJoggingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteJoggingRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewExecuteJoggingRequestWithBody generates requests for ExecuteJogging with any type of body
func NewExecuteJoggingRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/execution/jogging", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExecuteTrajectoryRequest calls the generic ExecuteTrajectory builder with application/json body
func NewExecuteTrajectoryRequest(server string, cellID CellID, controllerID ControllerID, body ExecuteTrajectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteTrajectoryRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewExecuteTrajectoryRequestWithBody generates requests for ExecuteTrajectory with any type of body
func NewExecuteTrajectoryRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/execution/trajectory", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStreamFreeDriveRequest generates requests for StreamFreeDrive
func NewStreamFreeDriveRequest(server string, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/free-drive-stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIODescriptionsRequest generates requests for ListIODescriptions
func NewListIODescriptionsRequest(server string, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/description", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ios", runtime.ParamLocationQuery, *params.Ios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ValueType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value_type", runtime.ParamLocationQuery, *params.ValueType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamIOValuesRequest generates requests for StreamIOValues
func NewStreamIOValuesRequest(server string, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ios", runtime.ParamLocationQuery, *params.Ios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIOValuesRequest generates requests for ListIOValues
func NewListIOValuesRequest(server string, cellID CellID, controllerID ControllerID, params *ListIOValuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/values", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ios", runtime.ParamLocationQuery, *params.Ios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetOutputValuesRequest calls the generic SetOutputValues builder with application/json body
func NewSetOutputValuesRequest(server string, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetOutputValuesRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewSetOutputValuesRequestWithBody generates requests for SetOutputValues with any type of body
func NewSetOutputValuesRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/values", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWaitForIOEventRequest calls the generic WaitForIOEvent builder with application/json body
func NewWaitForIOEventRequest(server string, cellID CellID, controllerID ControllerID, body WaitForIOEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWaitForIOEventRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewWaitForIOEventRequestWithBody generates requests for WaitForIOEvent with any type of body
func NewWaitForIOEventRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/wait-for", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetDefaultModeRequest generates requests for SetDefaultMode
func NewSetDefaultModeRequest(server string, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/mode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMotionGroupDescriptionRequest generates requests for GetMotionGroupDescription
func NewGetMotionGroupDescriptionRequest(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/motion-groups/%s/description", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentMotionGroupStateRequest generates requests for GetCurrentMotionGroupState
func NewGetCurrentMotionGroupStateRequest(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, params *GetCurrentMotionGroupStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/motion-groups/%s/state", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResponseCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_coordinate_system", runtime.ParamLocationQuery, *params.ResponseCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamMotionGroupStateRequest generates requests for StreamMotionGroupState
func NewStreamMotionGroupStateRequest(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, params *StreamMotionGroupStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/motion-groups/%s/state-stream", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponseCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_coordinate_system", runtime.ParamLocationQuery, *params.ResponseCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentRobotControllerStateRequest generates requests for GetCurrentRobotControllerState
func NewGetCurrentRobotControllerStateRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/state", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamRobotControllerStateRequest generates requests for StreamRobotControllerState
func NewStreamRobotControllerStateRequest(server string, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/state-stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AddControllerTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "add_controller_timeout", runtime.ParamLocationQuery, *params.AddControllerTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearTrajectoriesRequest generates requests for ClearTrajectories
func NewClearTrajectoriesRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/trajectories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTrajectoriesRequest generates requests for ListTrajectories
func NewListTrajectoriesRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/trajectories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddTrajectoryRequest calls the generic AddTrajectory builder with application/json body
func NewAddTrajectoryRequest(server string, cellID CellID, controllerID ControllerID, body AddTrajectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTrajectoryRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewAddTrajectoryRequestWithBody generates requests for AddTrajectory with any type of body
func NewAddTrajectoryRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/trajectories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTrajectoryRequest generates requests for DeleteTrajectory
func NewDeleteTrajectoryRequest(server string, cellID CellID, controllerID ControllerID, trajectory Trajectory) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "trajectory", runtime.ParamLocationPath, trajectory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/trajectories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTrajectoryRequest generates requests for GetTrajectory
func NewGetTrajectoryRequest(server string, cellID CellID, controllerID ControllerID, trajectory Trajectory) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "trajectory", runtime.ParamLocationPath, trajectory)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/trajectories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualControllerConfigurationRequest generates requests for GetVirtualControllerConfiguration
func NewGetVirtualControllerConfigurationRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/virtual-robot-configuration", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewForwardKinematicsRequest calls the generic ForwardKinematics builder with application/json body
func NewForwardKinematicsRequest(server string, cellID CellID, body ForwardKinematicsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewForwardKinematicsRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewForwardKinematicsRequestWithBody generates requests for ForwardKinematics with any type of body
func NewForwardKinematicsRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/kinematic/forward", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInverseKinematicsRequest calls the generic InverseKinematics builder with application/json body
func NewInverseKinematicsRequest(server string, cellID CellID, body InverseKinematicsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInverseKinematicsRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewInverseKinematicsRequestWithBody generates requests for InverseKinematics with any type of body
func NewInverseKinematicsRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/kinematic/inverse", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMotionGroupModelsRequest generates requests for GetMotionGroupModels
func NewGetMotionGroupModelsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-group-models", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMotionGroupCollisionModelRequest generates requests for GetMotionGroupCollisionModel
func NewGetMotionGroupCollisionModelRequest(server string, cellID CellID, motionGroupModel MotionGroupModelParameter) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group-model", runtime.ParamLocationPath, motionGroupModel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-group-models/%s/collision-model", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCellStatusRequest generates requests for GetCellStatus
func NewGetCellStatusRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetCellStatusRequest generates requests for SetCellStatus
func NewSetCellStatusRequest(server string, cellID CellID, params *SetCellStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operating_state", runtime.ParamLocationQuery, params.OperatingState); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListStoredCollidersRequest generates requests for ListStoredColliders
func NewListStoredCollidersRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/colliders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStoredColliderRequest generates requests for DeleteStoredCollider
func NewDeleteStoredColliderRequest(server string, cellID CellID, colliderID ColliderID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collider", runtime.ParamLocationPath, colliderID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/colliders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoredColliderRequest generates requests for GetStoredCollider
func NewGetStoredColliderRequest(server string, cellID CellID, colliderID ColliderID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collider", runtime.ParamLocationPath, colliderID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/colliders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreColliderRequest calls the generic StoreCollider builder with application/json body
func NewStoreColliderRequest(server string, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreColliderRequestWithBody(server, cellID, colliderID, "application/json", bodyReader)
}

// NewStoreColliderRequestWithBody generates requests for StoreCollider with any type of body
func NewStoreColliderRequestWithBody(server string, cellID CellID, colliderID ColliderID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collider", runtime.ParamLocationPath, colliderID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/colliders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCollisionLinkChainsRequest generates requests for ListCollisionLinkChains
func NewListCollisionLinkChainsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/link-chains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStoredCollisionLinkChainRequest generates requests for DeleteStoredCollisionLinkChain
func NewDeleteStoredCollisionLinkChainRequest(server string, cellID CellID, linkChainID LinkChainID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "link-chain", runtime.ParamLocationPath, linkChainID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/link-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoredCollisionLinkChainRequest generates requests for GetStoredCollisionLinkChain
func NewGetStoredCollisionLinkChainRequest(server string, cellID CellID, linkChainID LinkChainID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "link-chain", runtime.ParamLocationPath, linkChainID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/link-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreCollisionLinkChainRequest calls the generic StoreCollisionLinkChain builder with application/json body
func NewStoreCollisionLinkChainRequest(server string, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreCollisionLinkChainRequestWithBody(server, cellID, linkChainID, "application/json", bodyReader)
}

// NewStoreCollisionLinkChainRequestWithBody generates requests for StoreCollisionLinkChain with any type of body
func NewStoreCollisionLinkChainRequestWithBody(server string, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "link-chain", runtime.ParamLocationPath, linkChainID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/link-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListStoredCollisionSetupsRequest generates requests for ListStoredCollisionSetups
func NewListStoredCollisionSetupsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/setups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStoredCollisionSetupRequest generates requests for DeleteStoredCollisionSetup
func NewDeleteStoredCollisionSetupRequest(server string, cellID CellID, setup Setup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "setup", runtime.ParamLocationPath, setup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/setups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoredCollisionSetupRequest generates requests for GetStoredCollisionSetup
func NewGetStoredCollisionSetupRequest(server string, cellID CellID, setup Setup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "setup", runtime.ParamLocationPath, setup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/setups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreCollisionSetupRequest calls the generic StoreCollisionSetup builder with application/json body
func NewStoreCollisionSetupRequest(server string, cellID CellID, setup Setup, body StoreCollisionSetupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreCollisionSetupRequestWithBody(server, cellID, setup, "application/json", bodyReader)
}

// NewStoreCollisionSetupRequestWithBody generates requests for StoreCollisionSetup with any type of body
func NewStoreCollisionSetupRequestWithBody(server string, cellID CellID, setup Setup, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "setup", runtime.ParamLocationPath, setup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/setups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListStoredCollisionToolsRequest generates requests for ListStoredCollisionTools
func NewListStoredCollisionToolsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/tools", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStoredCollisionToolRequest generates requests for DeleteStoredCollisionTool
func NewDeleteStoredCollisionToolRequest(server string, cellID CellID, toolID ToolID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tool", runtime.ParamLocationPath, toolID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/tools/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoredCollisionToolRequest generates requests for GetStoredCollisionTool
func NewGetStoredCollisionToolRequest(server string, cellID CellID, toolID ToolID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tool", runtime.ParamLocationPath, toolID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/tools/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreCollisionToolRequest calls the generic StoreCollisionTool builder with application/json body
func NewStoreCollisionToolRequest(server string, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreCollisionToolRequestWithBody(server, cellID, toolID, "application/json", bodyReader)
}

// NewStoreCollisionToolRequestWithBody generates requests for StoreCollisionTool with any type of body
func NewStoreCollisionToolRequestWithBody(server string, cellID CellID, toolID ToolID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tool", runtime.ParamLocationPath, toolID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/tools/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearAllObjectsRequest generates requests for ClearAllObjects
func NewClearAllObjectsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllObjectKeysRequest generates requests for ListAllObjectKeys
func NewListAllObjectKeysRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteObjectRequest generates requests for DeleteObject
func NewDeleteObjectRequest(server string, cellID CellID, objectKey ObjectKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, objectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetObjectRequest generates requests for GetObject
func NewGetObjectRequest(server string, cellID CellID, objectKey ObjectKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, objectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetObjectMetadataRequest generates requests for GetObjectMetadata
func NewGetObjectMetadataRequest(server string, cellID CellID, objectKey ObjectKey) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, objectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreObjectRequestWithBody generates requests for StoreObject with any type of body
func NewStoreObjectRequestWithBody(server string, cellID CellID, objectKey ObjectKey, params *StoreObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, objectKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XMetadata != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Metadata", runtime.ParamLocationHeader, *params.XMetadata)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Metadata", headerParam0)
		}

	}

	return req, nil
}

// NewPlanCollisionFreeRequest calls the generic PlanCollisionFree builder with application/json body
func NewPlanCollisionFreeRequest(server string, cellID CellID, body PlanCollisionFreeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPlanCollisionFreeRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewPlanCollisionFreeRequestWithBody generates requests for PlanCollisionFree with any type of body
func NewPlanCollisionFreeRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/trajectory-planning/plan-collision-free", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPlanTrajectoryRequest calls the generic PlanTrajectory builder with application/json body
func NewPlanTrajectoryRequest(server string, cellID CellID, body PlanTrajectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPlanTrajectoryRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewPlanTrajectoryRequestWithBody generates requests for PlanTrajectory with any type of body
func NewPlanTrajectoryRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/trajectory-planning/plan-trajectory", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVirtualControllerBehaviorRequest generates requests for GetVirtualControllerBehavior
func NewGetVirtualControllerBehaviorRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/behavior", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetVirtualControllerBehaviorRequest generates requests for SetVirtualControllerBehavior
func NewSetVirtualControllerBehaviorRequest(server string, cellID CellID, controllerID ControllerID, params *SetVirtualControllerBehaviorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/behavior", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Behavior != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "behavior", runtime.ParamLocationQuery, *params.Behavior); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVirtualControllerCoordinateSystemsRequest generates requests for ListVirtualControllerCoordinateSystems
func NewListVirtualControllerCoordinateSystemsRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/coordinate-systems", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVirtualControllerCoordinateSystemRequest generates requests for DeleteVirtualControllerCoordinateSystem
func NewDeleteVirtualControllerCoordinateSystemRequest(server string, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, params *DeleteVirtualControllerCoordinateSystemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "coordinate-system", runtime.ParamLocationPath, coordinateSystemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/coordinate-systems/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteDependent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_dependent", runtime.ParamLocationQuery, *params.DeleteDependent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddVirtualControllerCoordinateSystemRequest calls the generic AddVirtualControllerCoordinateSystem builder with application/json body
func NewAddVirtualControllerCoordinateSystemRequest(server string, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, body AddVirtualControllerCoordinateSystemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddVirtualControllerCoordinateSystemRequestWithBody(server, cellID, controllerID, coordinateSystemID, "application/json", bodyReader)
}

// NewAddVirtualControllerCoordinateSystemRequestWithBody generates requests for AddVirtualControllerCoordinateSystem with any type of body
func NewAddVirtualControllerCoordinateSystemRequestWithBody(server string, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "coordinate-system", runtime.ParamLocationPath, coordinateSystemID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/coordinate-systems/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCycleTimeRequest generates requests for GetCycleTime
func NewGetCycleTimeRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/cycle-time", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmergencyStopRequest generates requests for GetEmergencyStop
func NewGetEmergencyStopRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/emergency-stop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetEmergencyStopRequest generates requests for SetEmergencyStop
func NewSetEmergencyStopRequest(server string, cellID CellID, controllerID ControllerID, params *SetEmergencyStopParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/emergency-stop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Active != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExternalJointsStreamRequest calls the generic ExternalJointsStream builder with application/json body
func NewExternalJointsStreamRequest(server string, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExternalJointsStreamRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewExternalJointsStreamRequestWithBody generates requests for ExternalJointsStream with any type of body
func NewExternalJointsStreamRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/external-joints-stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVirtualControllerIODescriptionsRequest generates requests for ListVirtualControllerIODescriptions
func NewListVirtualControllerIODescriptionsRequest(server string, cellID CellID, controllerID ControllerID, params *ListVirtualControllerIODescriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/ios/description", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ios", runtime.ParamLocationQuery, *params.Ios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ValueType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value_type", runtime.ParamLocationQuery, *params.ValueType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIOsRequest generates requests for ListIOs
func NewListIOsRequest(server string, cellID CellID, controllerID ControllerID, params *ListIOsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/ios/values", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ios", runtime.ParamLocationQuery, params.Ios); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIOValuesRequest calls the generic SetIOValues builder with application/json body
func NewSetIOValuesRequest(server string, cellID CellID, controllerID ControllerID, body SetIOValuesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIOValuesRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewSetIOValuesRequestWithBody generates requests for SetIOValues with any type of body
func NewSetIOValuesRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/ios/values", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMotionGroupsRequest generates requests for GetMotionGroups
func NewGetMotionGroupsRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/motion-groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualControllerMountingRequest generates requests for GetVirtualControllerMounting
func NewGetVirtualControllerMountingRequest(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/motion-groups/%s/mounting", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetVirtualControllerMountingRequest calls the generic SetVirtualControllerMounting builder with application/json body
func NewSetVirtualControllerMountingRequest(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, body SetVirtualControllerMountingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetVirtualControllerMountingRequestWithBody(server, cellID, controllerID, motionGroupID, "application/json", bodyReader)
}

// NewSetVirtualControllerMountingRequestWithBody generates requests for SetVirtualControllerMounting with any type of body
func NewSetVirtualControllerMountingRequestWithBody(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/motion-groups/%s/mounting", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMotionGroupStateRequest generates requests for GetMotionGroupState
func NewGetMotionGroupStateRequest(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/motion-groups/%s/state", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMotionGroupStateRequest calls the generic SetMotionGroupState builder with application/json body
func NewSetMotionGroupStateRequest(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, body SetMotionGroupStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMotionGroupStateRequestWithBody(server, cellID, controllerID, motionGroupID, "application/json", bodyReader)
}

// NewSetMotionGroupStateRequestWithBody generates requests for SetMotionGroupState with any type of body
func NewSetMotionGroupStateRequestWithBody(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/motion-groups/%s/state", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVirtualControllerTcpsRequest generates requests for ListVirtualControllerTcps
func NewListVirtualControllerTcpsRequest(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/motion-groups/%s/tcps", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVirtualControllerTcpRequest generates requests for DeleteVirtualControllerTcp
func NewDeleteVirtualControllerTcpRequest(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroupID)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "tcp", runtime.ParamLocationPath, tcp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/motion-groups/%s/tcps/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddVirtualControllerTcpRequest calls the generic AddVirtualControllerTcp builder with application/json body
func NewAddVirtualControllerTcpRequest(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, body AddVirtualControllerTcpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddVirtualControllerTcpRequestWithBody(server, cellID, controllerID, motionGroupID, tcp, "application/json", bodyReader)
}

// NewAddVirtualControllerTcpRequestWithBody generates requests for AddVirtualControllerTcp with any type of body
func NewAddVirtualControllerTcpRequestWithBody(server string, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroupID)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "tcp", runtime.ParamLocationPath, tcp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/motion-groups/%s/tcps/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOperationModeRequest generates requests for GetOperationMode
func NewGetOperationModeRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/operationmode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetOperationModeRequest generates requests for SetOperationMode
func NewSetOperationModeRequest(server string, cellID CellID, controllerID ControllerID, params *SetOperationModeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/virtual-controllers/%s/operationmode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeactivateLicenseRequest generates requests for DeactivateLicense
func NewDeactivateLicenseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLicenseRequest generates requests for GetLicense
func NewGetLicenseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivateLicenseRequest calls the generic ActivateLicense builder with application/json body
func NewActivateLicenseRequest(server string, body ActivateLicenseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateLicenseRequestWithBody(server, "application/json", bodyReader)
}

// NewActivateLicenseRequestWithBody generates requests for ActivateLicense with any type of body
func NewActivateLicenseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLicenseStatusRequest generates requests for GetLicenseStatus
func NewGetLicenseStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBackupConfigurationRequest generates requests for BackupConfiguration
func NewBackupConfigurationRequest(server string, params *BackupConfigurationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Resources != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "resources", runtime.ParamLocationQuery, *params.Resources); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreConfigurationRequestWithBody generates requests for RestoreConfiguration with any type of body
func NewRestoreConfigurationRequestWithBody(server string, params *RestoreConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "resources", runtime.ParamLocationQuery, params.Resources); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListConfigurationResourcesRequest generates requests for ListConfigurationResources
func NewListConfigurationResourcesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/configuration/resources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationBackupStatusRequest generates requests for GetConfigurationBackupStatus
func NewGetConfigurationBackupStatusRequest(server string, params *GetConfigurationBackupStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/configuration/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operation_id", runtime.ParamLocationQuery, params.OperationId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDiagnosePackageRequest generates requests for GetDiagnosePackage
func NewGetDiagnosePackageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/diagnosis-package/zip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemStatusRequest generates requests for GetSystemStatus
func NewGetSystemStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckNovaVersionUpdateRequest generates requests for CheckNovaVersionUpdate
func NewCheckNovaVersionUpdateRequest(server string, params *CheckNovaVersionUpdateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel", runtime.ParamLocationQuery, params.Channel); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNovaVersionRequest calls the generic UpdateNovaVersion builder with application/json body
func NewUpdateNovaVersionRequest(server string, body UpdateNovaVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNovaVersionRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateNovaVersionRequestWithBody generates requests for UpdateNovaVersion with any type of body
func NewUpdateNovaVersionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemVersionRequest generates requests for GetSystemVersion
func NewGetSystemVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListCellsWithResponse request
	ListCellsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCellsResp, error)

	// DeployCellWithBodyWithResponse request with any body
	DeployCellWithBodyWithResponse(ctx context.Context, params *DeployCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeployCellResp, error)

	DeployCellWithResponse(ctx context.Context, params *DeployCellParams, body DeployCellJSONRequestBody, reqEditors ...RequestEditorFn) (*DeployCellResp, error)

	// DeleteCellWithResponse request
	DeleteCellWithResponse(ctx context.Context, cellID CellID, params *DeleteCellParams, reqEditors ...RequestEditorFn) (*DeleteCellResp, error)

	// GetCellWithResponse request
	GetCellWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetCellResp, error)

	// UpdateCellWithBodyWithResponse request with any body
	UpdateCellWithBodyWithResponse(ctx context.Context, cellID CellID, params *UpdateCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCellResp, error)

	UpdateCellWithResponse(ctx context.Context, cellID CellID, params *UpdateCellParams, body UpdateCellJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCellResp, error)

	// ClearAppsWithResponse request
	ClearAppsWithResponse(ctx context.Context, cellID CellID, params *ClearAppsParams, reqEditors ...RequestEditorFn) (*ClearAppsResp, error)

	// ListAppsWithResponse request
	ListAppsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListAppsResp, error)

	// AddAppWithBodyWithResponse request with any body
	AddAppWithBodyWithResponse(ctx context.Context, cellID CellID, params *AddAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAppResp, error)

	AddAppWithResponse(ctx context.Context, cellID CellID, params *AddAppParams, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAppResp, error)

	// DeleteAppWithResponse request
	DeleteAppWithResponse(ctx context.Context, cellID CellID, appID AppID, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*DeleteAppResp, error)

	// GetAppWithResponse request
	GetAppWithResponse(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*GetAppResp, error)

	// UpdateAppWithBodyWithResponse request with any body
	UpdateAppWithBodyWithResponse(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResp, error)

	UpdateAppWithResponse(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResp, error)

	// ClearBusIOServiceWithResponse request
	ClearBusIOServiceWithResponse(ctx context.Context, cellID CellID, params *ClearBusIOServiceParams, reqEditors ...RequestEditorFn) (*ClearBusIOServiceResp, error)

	// GetBusIOServiceWithResponse request
	GetBusIOServiceWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetBusIOServiceResp, error)

	// AddBusIOServiceWithBodyWithResponse request with any body
	AddBusIOServiceWithBodyWithResponse(ctx context.Context, cellID CellID, params *AddBusIOServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddBusIOServiceResp, error)

	AddBusIOServiceWithResponse(ctx context.Context, cellID CellID, params *AddBusIOServiceParams, body AddBusIOServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddBusIOServiceResp, error)

	// ListBusIODescriptionsWithResponse request
	ListBusIODescriptionsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListBusIODescriptionsResp, error)

	// GetBusIOValuesWithResponse request
	GetBusIOValuesWithResponse(ctx context.Context, cellID CellID, params *GetBusIOValuesParams, reqEditors ...RequestEditorFn) (*GetBusIOValuesResp, error)

	// SetBusIOValuesWithBodyWithResponse request with any body
	SetBusIOValuesWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBusIOValuesResp, error)

	SetBusIOValuesWithResponse(ctx context.Context, cellID CellID, body SetBusIOValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBusIOValuesResp, error)

	// GetProfinetDescriptionWithResponse request
	GetProfinetDescriptionWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetProfinetDescriptionResp, error)

	// GetProfinetIOsFromFileWithResponse request
	GetProfinetIOsFromFileWithResponse(ctx context.Context, cellID CellID, params *GetProfinetIOsFromFileParams, reqEditors ...RequestEditorFn) (*GetProfinetIOsFromFileResp, error)

	// SetProfinetIOsFromFileWithBodyWithResponse request with any body
	SetProfinetIOsFromFileWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetProfinetIOsFromFileResp, error)

	SetProfinetIOsFromFileWithResponse(ctx context.Context, cellID CellID, body SetProfinetIOsFromFileJSONRequestBody, reqEditors ...RequestEditorFn) (*SetProfinetIOsFromFileResp, error)

	// ListProfinetIOsWithResponse request
	ListProfinetIOsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListProfinetIOsResp, error)

	// DeleteProfinetIOWithResponse request
	DeleteProfinetIOWithResponse(ctx context.Context, cellID CellID, ioid IOID, reqEditors ...RequestEditorFn) (*DeleteProfinetIOResp, error)

	// AddProfinetIOWithBodyWithResponse request with any body
	AddProfinetIOWithBodyWithResponse(ctx context.Context, cellID CellID, ioid IOID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProfinetIOResp, error)

	AddProfinetIOWithResponse(ctx context.Context, cellID CellID, ioid IOID, body AddProfinetIOJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProfinetIOResp, error)

	// GetBusIOStateWithResponse request
	GetBusIOStateWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetBusIOStateResp, error)

	// ClearRobotControllersWithResponse request
	ClearRobotControllersWithResponse(ctx context.Context, cellID CellID, params *ClearRobotControllersParams, reqEditors ...RequestEditorFn) (*ClearRobotControllersResp, error)

	// ListRobotControllersWithResponse request
	ListRobotControllersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListRobotControllersResp, error)

	// AddRobotControllerWithBodyWithResponse request with any body
	AddRobotControllerWithBodyWithResponse(ctx context.Context, cellID CellID, params *AddRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRobotControllerResp, error)

	AddRobotControllerWithResponse(ctx context.Context, cellID CellID, params *AddRobotControllerParams, body AddRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRobotControllerResp, error)

	// DeleteRobotControllerWithResponse request
	DeleteRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *DeleteRobotControllerParams, reqEditors ...RequestEditorFn) (*DeleteRobotControllerResp, error)

	// GetRobotControllerWithResponse request
	GetRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetRobotControllerResp, error)

	// UpdateRobotControllerWithBodyWithResponse request with any body
	UpdateRobotControllerWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRobotControllerResp, error)

	UpdateRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, body UpdateRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRobotControllerResp, error)

	// ListCoordinateSystemsWithResponse request
	ListCoordinateSystemsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListCoordinateSystemsParams, reqEditors ...RequestEditorFn) (*ListCoordinateSystemsResp, error)

	// GetCoordinateSystemWithResponse request
	GetCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, params *GetCoordinateSystemParams, reqEditors ...RequestEditorFn) (*GetCoordinateSystemResp, error)

	// GetControllerDescriptionWithResponse request
	GetControllerDescriptionWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetControllerDescriptionResp, error)

	// ExecuteJoggingWithBodyWithResponse request with any body
	ExecuteJoggingWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteJoggingResp, error)

	ExecuteJoggingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body ExecuteJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteJoggingResp, error)

	// ExecuteTrajectoryWithBodyWithResponse request with any body
	ExecuteTrajectoryWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteTrajectoryResp, error)

	ExecuteTrajectoryWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body ExecuteTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteTrajectoryResp, error)

	// StreamFreeDriveWithResponse request
	StreamFreeDriveWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams, reqEditors ...RequestEditorFn) (*StreamFreeDriveResp, error)

	// ListIODescriptionsWithResponse request
	ListIODescriptionsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams, reqEditors ...RequestEditorFn) (*ListIODescriptionsResp, error)

	// StreamIOValuesWithResponse request
	StreamIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams, reqEditors ...RequestEditorFn) (*StreamIOValuesResp, error)

	// ListIOValuesWithResponse request
	ListIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOValuesParams, reqEditors ...RequestEditorFn) (*ListIOValuesResp, error)

	// SetOutputValuesWithBodyWithResponse request with any body
	SetOutputValuesWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOutputValuesResp, error)

	SetOutputValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOutputValuesResp, error)

	// WaitForIOEventWithBodyWithResponse request with any body
	WaitForIOEventWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WaitForIOEventResp, error)

	WaitForIOEventWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body WaitForIOEventJSONRequestBody, reqEditors ...RequestEditorFn) (*WaitForIOEventResp, error)

	// SetDefaultModeWithResponse request
	SetDefaultModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams, reqEditors ...RequestEditorFn) (*SetDefaultModeResp, error)

	// GetMotionGroupDescriptionWithResponse request
	GetMotionGroupDescriptionWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*GetMotionGroupDescriptionResp, error)

	// GetCurrentMotionGroupStateWithResponse request
	GetCurrentMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, params *GetCurrentMotionGroupStateParams, reqEditors ...RequestEditorFn) (*GetCurrentMotionGroupStateResp, error)

	// StreamMotionGroupStateWithResponse request
	StreamMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, params *StreamMotionGroupStateParams, reqEditors ...RequestEditorFn) (*StreamMotionGroupStateResp, error)

	// GetCurrentRobotControllerStateWithResponse request
	GetCurrentRobotControllerStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetCurrentRobotControllerStateResp, error)

	// StreamRobotControllerStateWithResponse request
	StreamRobotControllerStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams, reqEditors ...RequestEditorFn) (*StreamRobotControllerStateResp, error)

	// ClearTrajectoriesWithResponse request
	ClearTrajectoriesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ClearTrajectoriesResp, error)

	// ListTrajectoriesWithResponse request
	ListTrajectoriesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListTrajectoriesResp, error)

	// AddTrajectoryWithBodyWithResponse request with any body
	AddTrajectoryWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTrajectoryResp, error)

	AddTrajectoryWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body AddTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTrajectoryResp, error)

	// DeleteTrajectoryWithResponse request
	DeleteTrajectoryWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, trajectory Trajectory, reqEditors ...RequestEditorFn) (*DeleteTrajectoryResp, error)

	// GetTrajectoryWithResponse request
	GetTrajectoryWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, trajectory Trajectory, reqEditors ...RequestEditorFn) (*GetTrajectoryResp, error)

	// GetVirtualControllerConfigurationWithResponse request
	GetVirtualControllerConfigurationWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetVirtualControllerConfigurationResp, error)

	// ForwardKinematicsWithBodyWithResponse request with any body
	ForwardKinematicsWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForwardKinematicsResp, error)

	ForwardKinematicsWithResponse(ctx context.Context, cellID CellID, body ForwardKinematicsJSONRequestBody, reqEditors ...RequestEditorFn) (*ForwardKinematicsResp, error)

	// InverseKinematicsWithBodyWithResponse request with any body
	InverseKinematicsWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InverseKinematicsResp, error)

	InverseKinematicsWithResponse(ctx context.Context, cellID CellID, body InverseKinematicsJSONRequestBody, reqEditors ...RequestEditorFn) (*InverseKinematicsResp, error)

	// GetMotionGroupModelsWithResponse request
	GetMotionGroupModelsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetMotionGroupModelsResp, error)

	// GetMotionGroupCollisionModelWithResponse request
	GetMotionGroupCollisionModelWithResponse(ctx context.Context, cellID CellID, motionGroupModel MotionGroupModelParameter, reqEditors ...RequestEditorFn) (*GetMotionGroupCollisionModelResp, error)

	// GetCellStatusWithResponse request
	GetCellStatusWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetCellStatusResp, error)

	// SetCellStatusWithResponse request
	SetCellStatusWithResponse(ctx context.Context, cellID CellID, params *SetCellStatusParams, reqEditors ...RequestEditorFn) (*SetCellStatusResp, error)

	// ListStoredCollidersWithResponse request
	ListStoredCollidersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollidersResp, error)

	// DeleteStoredColliderWithResponse request
	DeleteStoredColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*DeleteStoredColliderResp, error)

	// GetStoredColliderWithResponse request
	GetStoredColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*GetStoredColliderResp, error)

	// StoreColliderWithBodyWithResponse request with any body
	StoreColliderWithBodyWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreColliderResp, error)

	StoreColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreColliderResp, error)

	// ListCollisionLinkChainsWithResponse request
	ListCollisionLinkChainsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListCollisionLinkChainsResp, error)

	// DeleteStoredCollisionLinkChainWithResponse request
	DeleteStoredCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionLinkChainResp, error)

	// GetStoredCollisionLinkChainWithResponse request
	GetStoredCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*GetStoredCollisionLinkChainResp, error)

	// StoreCollisionLinkChainWithBodyWithResponse request with any body
	StoreCollisionLinkChainWithBodyWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionLinkChainResp, error)

	StoreCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionLinkChainResp, error)

	// ListStoredCollisionSetupsWithResponse request
	ListStoredCollisionSetupsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollisionSetupsResp, error)

	// DeleteStoredCollisionSetupWithResponse request
	DeleteStoredCollisionSetupWithResponse(ctx context.Context, cellID CellID, setup Setup, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionSetupResp, error)

	// GetStoredCollisionSetupWithResponse request
	GetStoredCollisionSetupWithResponse(ctx context.Context, cellID CellID, setup Setup, reqEditors ...RequestEditorFn) (*GetStoredCollisionSetupResp, error)

	// StoreCollisionSetupWithBodyWithResponse request with any body
	StoreCollisionSetupWithBodyWithResponse(ctx context.Context, cellID CellID, setup Setup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionSetupResp, error)

	StoreCollisionSetupWithResponse(ctx context.Context, cellID CellID, setup Setup, body StoreCollisionSetupJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionSetupResp, error)

	// ListStoredCollisionToolsWithResponse request
	ListStoredCollisionToolsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollisionToolsResp, error)

	// DeleteStoredCollisionToolWithResponse request
	DeleteStoredCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionToolResp, error)

	// GetStoredCollisionToolWithResponse request
	GetStoredCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*GetStoredCollisionToolResp, error)

	// StoreCollisionToolWithBodyWithResponse request with any body
	StoreCollisionToolWithBodyWithResponse(ctx context.Context, cellID CellID, toolID ToolID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionToolResp, error)

	StoreCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionToolResp, error)

	// ClearAllObjectsWithResponse request
	ClearAllObjectsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearAllObjectsResp, error)

	// ListAllObjectKeysWithResponse request
	ListAllObjectKeysWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListAllObjectKeysResp, error)

	// DeleteObjectWithResponse request
	DeleteObjectWithResponse(ctx context.Context, cellID CellID, objectKey ObjectKey, reqEditors ...RequestEditorFn) (*DeleteObjectResp, error)

	// GetObjectWithResponse request
	GetObjectWithResponse(ctx context.Context, cellID CellID, objectKey ObjectKey, reqEditors ...RequestEditorFn) (*GetObjectResp, error)

	// GetObjectMetadataWithResponse request
	GetObjectMetadataWithResponse(ctx context.Context, cellID CellID, objectKey ObjectKey, reqEditors ...RequestEditorFn) (*GetObjectMetadataResp, error)

	// StoreObjectWithBodyWithResponse request with any body
	StoreObjectWithBodyWithResponse(ctx context.Context, cellID CellID, objectKey ObjectKey, params *StoreObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreObjectResp, error)

	// PlanCollisionFreeWithBodyWithResponse request with any body
	PlanCollisionFreeWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanCollisionFreeResp, error)

	PlanCollisionFreeWithResponse(ctx context.Context, cellID CellID, body PlanCollisionFreeJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanCollisionFreeResp, error)

	// PlanTrajectoryWithBodyWithResponse request with any body
	PlanTrajectoryWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanTrajectoryResp, error)

	PlanTrajectoryWithResponse(ctx context.Context, cellID CellID, body PlanTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanTrajectoryResp, error)

	// GetVirtualControllerBehaviorWithResponse request
	GetVirtualControllerBehaviorWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetVirtualControllerBehaviorResp, error)

	// SetVirtualControllerBehaviorWithResponse request
	SetVirtualControllerBehaviorWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetVirtualControllerBehaviorParams, reqEditors ...RequestEditorFn) (*SetVirtualControllerBehaviorResp, error)

	// ListVirtualControllerCoordinateSystemsWithResponse request
	ListVirtualControllerCoordinateSystemsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListVirtualControllerCoordinateSystemsResp, error)

	// DeleteVirtualControllerCoordinateSystemWithResponse request
	DeleteVirtualControllerCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, params *DeleteVirtualControllerCoordinateSystemParams, reqEditors ...RequestEditorFn) (*DeleteVirtualControllerCoordinateSystemResp, error)

	// AddVirtualControllerCoordinateSystemWithBodyWithResponse request with any body
	AddVirtualControllerCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualControllerCoordinateSystemResp, error)

	AddVirtualControllerCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, body AddVirtualControllerCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualControllerCoordinateSystemResp, error)

	// GetCycleTimeWithResponse request
	GetCycleTimeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetCycleTimeResp, error)

	// GetEmergencyStopWithResponse request
	GetEmergencyStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetEmergencyStopResp, error)

	// SetEmergencyStopWithResponse request
	SetEmergencyStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetEmergencyStopParams, reqEditors ...RequestEditorFn) (*SetEmergencyStopResp, error)

	// ExternalJointsStreamWithBodyWithResponse request with any body
	ExternalJointsStreamWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExternalJointsStreamResp, error)

	ExternalJointsStreamWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*ExternalJointsStreamResp, error)

	// ListVirtualControllerIODescriptionsWithResponse request
	ListVirtualControllerIODescriptionsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListVirtualControllerIODescriptionsParams, reqEditors ...RequestEditorFn) (*ListVirtualControllerIODescriptionsResp, error)

	// ListIOsWithResponse request
	ListIOsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOsParams, reqEditors ...RequestEditorFn) (*ListIOsResp, error)

	// SetIOValuesWithBodyWithResponse request with any body
	SetIOValuesWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIOValuesResp, error)

	SetIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body SetIOValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIOValuesResp, error)

	// GetMotionGroupsWithResponse request
	GetMotionGroupsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetMotionGroupsResp, error)

	// GetVirtualControllerMountingWithResponse request
	GetVirtualControllerMountingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*GetVirtualControllerMountingResp, error)

	// SetVirtualControllerMountingWithBodyWithResponse request with any body
	SetVirtualControllerMountingWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetVirtualControllerMountingResp, error)

	SetVirtualControllerMountingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, body SetVirtualControllerMountingJSONRequestBody, reqEditors ...RequestEditorFn) (*SetVirtualControllerMountingResp, error)

	// GetMotionGroupStateWithResponse request
	GetMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*GetMotionGroupStateResp, error)

	// SetMotionGroupStateWithBodyWithResponse request with any body
	SetMotionGroupStateWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMotionGroupStateResp, error)

	SetMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, body SetMotionGroupStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMotionGroupStateResp, error)

	// ListVirtualControllerTcpsWithResponse request
	ListVirtualControllerTcpsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*ListVirtualControllerTcpsResp, error)

	// DeleteVirtualControllerTcpWithResponse request
	DeleteVirtualControllerTcpWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, reqEditors ...RequestEditorFn) (*DeleteVirtualControllerTcpResp, error)

	// AddVirtualControllerTcpWithBodyWithResponse request with any body
	AddVirtualControllerTcpWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualControllerTcpResp, error)

	AddVirtualControllerTcpWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, body AddVirtualControllerTcpJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualControllerTcpResp, error)

	// GetOperationModeWithResponse request
	GetOperationModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetOperationModeResp, error)

	// SetOperationModeWithResponse request
	SetOperationModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetOperationModeParams, reqEditors ...RequestEditorFn) (*SetOperationModeResp, error)

	// DeactivateLicenseWithResponse request
	DeactivateLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeactivateLicenseResp, error)

	// GetLicenseWithResponse request
	GetLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseResp, error)

	// ActivateLicenseWithBodyWithResponse request with any body
	ActivateLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateLicenseResp, error)

	ActivateLicenseWithResponse(ctx context.Context, body ActivateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateLicenseResp, error)

	// GetLicenseStatusWithResponse request
	GetLicenseStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseStatusResp, error)

	// BackupConfigurationWithResponse request
	BackupConfigurationWithResponse(ctx context.Context, params *BackupConfigurationParams, reqEditors ...RequestEditorFn) (*BackupConfigurationResp, error)

	// RestoreConfigurationWithBodyWithResponse request with any body
	RestoreConfigurationWithBodyWithResponse(ctx context.Context, params *RestoreConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreConfigurationResp, error)

	// ListConfigurationResourcesWithResponse request
	ListConfigurationResourcesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConfigurationResourcesResp, error)

	// GetConfigurationBackupStatusWithResponse request
	GetConfigurationBackupStatusWithResponse(ctx context.Context, params *GetConfigurationBackupStatusParams, reqEditors ...RequestEditorFn) (*GetConfigurationBackupStatusResp, error)

	// GetDiagnosePackageWithResponse request
	GetDiagnosePackageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDiagnosePackageResp, error)

	// GetSystemStatusWithResponse request
	GetSystemStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemStatusResp, error)

	// CheckNovaVersionUpdateWithResponse request
	CheckNovaVersionUpdateWithResponse(ctx context.Context, params *CheckNovaVersionUpdateParams, reqEditors ...RequestEditorFn) (*CheckNovaVersionUpdateResp, error)

	// UpdateNovaVersionWithBodyWithResponse request with any body
	UpdateNovaVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNovaVersionResp, error)

	UpdateNovaVersionWithResponse(ctx context.Context, body UpdateNovaVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNovaVersionResp, error)

	// GetSystemVersionWithResponse request
	GetSystemVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemVersionResp, error)
}

type ListCellsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameList
}

// Status returns HTTPResponse.Status
func (r ListCellsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCellsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeployCellResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Error
}

// Status returns HTTPResponse.Status
func (r DeployCellResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeployCellResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCellResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteCellResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCellResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCellResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cell
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetCellResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCellResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCellResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON403      *Error
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateCellResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCellResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearAppsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ClearAppsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearAppsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameList
}

// Status returns HTTPResponse.Status
func (r ListAppsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearBusIOServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ClearBusIOServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearBusIOServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBusIOServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BusIOType
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetBusIOServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBusIOServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddBusIOServiceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Error
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AddBusIOServiceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddBusIOServiceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBusIODescriptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIODescriptionsResponse
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ListBusIODescriptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBusIODescriptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBusIOValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIOValuesResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetBusIOValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBusIOValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBusIOValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SetBusIOValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBusIOValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProfinetDescriptionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfinetDescription
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetProfinetDescriptionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProfinetDescriptionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProfinetIOsFromFileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetProfinetIOsFromFileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProfinetIOsFromFileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetProfinetIOsFromFileResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SetProfinetIOsFromFileResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetProfinetIOsFromFileResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProfinetIOsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfinetIOs
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ListProfinetIOsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProfinetIOsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProfinetIOResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteProfinetIOResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProfinetIOResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddProfinetIOResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AddProfinetIOResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddProfinetIOResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBusIOStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BusIOsState
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetBusIOStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBusIOStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearRobotControllersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ClearRobotControllersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearRobotControllersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRobotControllersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameList
}

// Status returns HTTPResponse.Status
func (r ListRobotControllersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRobotControllersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRobotControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Error
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AddRobotControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRobotControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRobotControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteRobotControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRobotControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRobotControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotController
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetRobotControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRobotControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRobotControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateRobotControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRobotControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCoordinateSystemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCoordinateSystemsResponse
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r ListCoordinateSystemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCoordinateSystemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystem
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetControllerDescriptionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ControllerDescription
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetControllerDescriptionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetControllerDescriptionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteJoggingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExecuteJoggingResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ExecuteJoggingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteJoggingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteTrajectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExecuteTrajectoryResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ExecuteTrajectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteTrajectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamFreeDriveResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotControllerState
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r StreamFreeDriveResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamFreeDriveResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIODescriptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIODescriptionsResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ListIODescriptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIODescriptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamIOValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamIOValuesResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r StreamIOValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamIOValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIOValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIOValuesResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ListIOValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIOValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOutputValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON429      *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r SetOutputValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOutputValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WaitForIOEventResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r WaitForIOEventResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WaitForIOEventResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDefaultModeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SetDefaultModeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDefaultModeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupDescriptionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupDescription
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupDescriptionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupDescriptionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentMotionGroupStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupState
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetCurrentMotionGroupStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentMotionGroupStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamMotionGroupStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupState
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r StreamMotionGroupStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamMotionGroupStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentRobotControllerStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotControllerState
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetCurrentRobotControllerStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentRobotControllerStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamRobotControllerStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotControllerState
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r StreamRobotControllerStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamRobotControllerStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearTrajectoriesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r ClearTrajectoriesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearTrajectoriesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTrajectoriesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTrajectoriesResponse
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r ListTrajectoriesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTrajectoriesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTrajectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddTrajectoryResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AddTrajectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTrajectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTrajectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteTrajectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTrajectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTrajectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTrajectoryResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTrajectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTrajectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualControllerConfigurationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VirtualRobotConfiguration
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetVirtualControllerConfigurationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualControllerConfigurationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ForwardKinematicsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ForwardKinematicsResponse
	JSON422      *ForwardKinematics422Response
}

// Status returns HTTPResponse.Status
func (r ForwardKinematicsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ForwardKinematicsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InverseKinematicsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InverseKinematicsResponse
	JSON422      *InverseKinematics422Response
}

// Status returns HTTPResponse.Status
func (r InverseKinematicsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InverseKinematicsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupModelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupModelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupModelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupCollisionModelResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkChain
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupCollisionModelResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupCollisionModelResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCellStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceStatusResponse
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetCellStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCellStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCellStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SetCellStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCellStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStoredCollidersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ColliderDictionary
}

// Status returns HTTPResponse.Status
func (r ListStoredCollidersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStoredCollidersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoredColliderResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteStoredColliderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoredColliderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoredColliderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collider
}

// Status returns HTTPResponse.Status
func (r GetStoredColliderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoredColliderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreColliderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collider
}

// Status returns HTTPResponse.Status
func (r StoreColliderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreColliderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCollisionLinkChainsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]LinkChain
}

// Status returns HTTPResponse.Status
func (r ListCollisionLinkChainsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCollisionLinkChainsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoredCollisionLinkChainResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteStoredCollisionLinkChainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoredCollisionLinkChainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoredCollisionLinkChainResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkChain
}

// Status returns HTTPResponse.Status
func (r GetStoredCollisionLinkChainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoredCollisionLinkChainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreCollisionLinkChainResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkChain
}

// Status returns HTTPResponse.Status
func (r StoreCollisionLinkChainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreCollisionLinkChainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStoredCollisionSetupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]CollisionSetup
}

// Status returns HTTPResponse.Status
func (r ListStoredCollisionSetupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStoredCollisionSetupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoredCollisionSetupResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteStoredCollisionSetupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoredCollisionSetupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoredCollisionSetupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollisionSetup
}

// Status returns HTTPResponse.Status
func (r GetStoredCollisionSetupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoredCollisionSetupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreCollisionSetupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollisionSetup
}

// Status returns HTTPResponse.Status
func (r StoreCollisionSetupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreCollisionSetupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStoredCollisionToolsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]Tool
}

// Status returns HTTPResponse.Status
func (r ListStoredCollisionToolsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStoredCollisionToolsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoredCollisionToolResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteStoredCollisionToolResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoredCollisionToolResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoredCollisionToolResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tool
}

// Status returns HTTPResponse.Status
func (r GetStoredCollisionToolResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoredCollisionToolResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreCollisionToolResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tool
}

// Status returns HTTPResponse.Status
func (r StoreCollisionToolResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreCollisionToolResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearAllObjectsResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearAllObjectsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearAllObjectsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllObjectKeysResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Key
}

// Status returns HTTPResponse.Status
func (r ListAllObjectKeysResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllObjectKeysResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteObjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetObjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetObjectMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreObjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r StoreObjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreObjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlanCollisionFreeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlanCollisionFreeResponse
	JSON422      *Plan422Response
}

// Status returns HTTPResponse.Status
func (r PlanCollisionFreeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlanCollisionFreeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlanTrajectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlanTrajectoryResponse
	JSON422      *Plan422Response
}

// Status returns HTTPResponse.Status
func (r PlanTrajectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlanTrajectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualControllerBehaviorResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Behavior
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetVirtualControllerBehaviorResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualControllerBehaviorResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetVirtualControllerBehaviorResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r SetVirtualControllerBehaviorResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetVirtualControllerBehaviorResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVirtualControllerCoordinateSystemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCoordinateSystemsResponse
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r ListVirtualControllerCoordinateSystemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVirtualControllerCoordinateSystemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualControllerCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualControllerCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualControllerCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddVirtualControllerCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AddVirtualControllerCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddVirtualControllerCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCycleTimeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CycleTime
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r GetCycleTimeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCycleTimeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmergencyStopResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Flag
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r GetEmergencyStopResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmergencyStopResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetEmergencyStopResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r SetEmergencyStopResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetEmergencyStopResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExternalJointsStreamResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalJointStreamDatapoints
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ExternalJointsStreamResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExternalJointsStreamResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVirtualControllerIODescriptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIODescriptionsResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ListVirtualControllerIODescriptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVirtualControllerIODescriptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIOsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIOValuesResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ListIOsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIOsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIOValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON501      *NotImplemented
}

// Status returns HTTPResponse.Status
func (r SetIOValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIOValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupInfos
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualControllerMountingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystem
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetVirtualControllerMountingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualControllerMountingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetVirtualControllerMountingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystem
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SetVirtualControllerMountingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetVirtualControllerMountingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupJoints
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMotionGroupStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SetMotionGroupStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMotionGroupStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVirtualControllerTcpsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotTcps
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ListVirtualControllerTcpsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVirtualControllerTcpsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualControllerTcpResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualControllerTcpResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualControllerTcpResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddVirtualControllerTcpResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AddVirtualControllerTcpResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddVirtualControllerTcpResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOperationModeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OpMode
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r GetOperationModeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOperationModeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOperationModeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
}

// Status returns HTTPResponse.Status
func (r SetOperationModeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOperationModeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeactivateLicenseResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeactivateLicenseResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeactivateLicenseResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *License
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetLicenseResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateLicenseResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *License
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r ActivateLicenseResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateLicenseResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LicenseStatus
	JSON403      *LicenseStatus
}

// Status returns HTTPResponse.Status
func (r GetLicenseStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BackupConfigurationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r BackupConfigurationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BackupConfigurationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreConfigurationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r RestoreConfigurationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreConfigurationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListConfigurationResourcesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigurationResourceArray
}

// Status returns HTTPResponse.Status
func (r ListConfigurationResourcesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConfigurationResourcesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationBackupStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigurationArchiveStatus
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetConfigurationBackupStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationBackupStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiagnosePackageResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDiagnosePackageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiagnosePackageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceStatusList
}

// Status returns HTTPResponse.Status
func (r GetSystemStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckNovaVersionUpdateResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CheckNovaVersionUpdateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckNovaVersionUpdateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNovaVersionResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateNovaVersionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNovaVersionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemVersionResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSystemVersionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemVersionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListCellsWithResponse request returning *ListCellsResp
func (c *ClientWithResponses) ListCellsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCellsResp, error) {
	rsp, err := c.ListCells(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCellsResp(rsp)
}

// DeployCellWithBodyWithResponse request with arbitrary body returning *DeployCellResp
func (c *ClientWithResponses) DeployCellWithBodyWithResponse(ctx context.Context, params *DeployCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeployCellResp, error) {
	rsp, err := c.DeployCellWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeployCellResp(rsp)
}

func (c *ClientWithResponses) DeployCellWithResponse(ctx context.Context, params *DeployCellParams, body DeployCellJSONRequestBody, reqEditors ...RequestEditorFn) (*DeployCellResp, error) {
	rsp, err := c.DeployCell(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeployCellResp(rsp)
}

// DeleteCellWithResponse request returning *DeleteCellResp
func (c *ClientWithResponses) DeleteCellWithResponse(ctx context.Context, cellID CellID, params *DeleteCellParams, reqEditors ...RequestEditorFn) (*DeleteCellResp, error) {
	rsp, err := c.DeleteCell(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCellResp(rsp)
}

// GetCellWithResponse request returning *GetCellResp
func (c *ClientWithResponses) GetCellWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetCellResp, error) {
	rsp, err := c.GetCell(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCellResp(rsp)
}

// UpdateCellWithBodyWithResponse request with arbitrary body returning *UpdateCellResp
func (c *ClientWithResponses) UpdateCellWithBodyWithResponse(ctx context.Context, cellID CellID, params *UpdateCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCellResp, error) {
	rsp, err := c.UpdateCellWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCellResp(rsp)
}

func (c *ClientWithResponses) UpdateCellWithResponse(ctx context.Context, cellID CellID, params *UpdateCellParams, body UpdateCellJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCellResp, error) {
	rsp, err := c.UpdateCell(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCellResp(rsp)
}

// ClearAppsWithResponse request returning *ClearAppsResp
func (c *ClientWithResponses) ClearAppsWithResponse(ctx context.Context, cellID CellID, params *ClearAppsParams, reqEditors ...RequestEditorFn) (*ClearAppsResp, error) {
	rsp, err := c.ClearApps(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearAppsResp(rsp)
}

// ListAppsWithResponse request returning *ListAppsResp
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListAppsResp, error) {
	rsp, err := c.ListApps(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResp(rsp)
}

// AddAppWithBodyWithResponse request with arbitrary body returning *AddAppResp
func (c *ClientWithResponses) AddAppWithBodyWithResponse(ctx context.Context, cellID CellID, params *AddAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAppResp, error) {
	rsp, err := c.AddAppWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAppResp(rsp)
}

func (c *ClientWithResponses) AddAppWithResponse(ctx context.Context, cellID CellID, params *AddAppParams, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAppResp, error) {
	rsp, err := c.AddApp(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAppResp(rsp)
}

// DeleteAppWithResponse request returning *DeleteAppResp
func (c *ClientWithResponses) DeleteAppWithResponse(ctx context.Context, cellID CellID, appID AppID, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*DeleteAppResp, error) {
	rsp, err := c.DeleteApp(ctx, cellID, appID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppResp(rsp)
}

// GetAppWithResponse request returning *GetAppResp
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*GetAppResp, error) {
	rsp, err := c.GetApp(ctx, cellID, appID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppResp(rsp)
}

// UpdateAppWithBodyWithResponse request with arbitrary body returning *UpdateAppResp
func (c *ClientWithResponses) UpdateAppWithBodyWithResponse(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResp, error) {
	rsp, err := c.UpdateAppWithBody(ctx, cellID, appID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResp(rsp)
}

func (c *ClientWithResponses) UpdateAppWithResponse(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResp, error) {
	rsp, err := c.UpdateApp(ctx, cellID, appID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResp(rsp)
}

// ClearBusIOServiceWithResponse request returning *ClearBusIOServiceResp
func (c *ClientWithResponses) ClearBusIOServiceWithResponse(ctx context.Context, cellID CellID, params *ClearBusIOServiceParams, reqEditors ...RequestEditorFn) (*ClearBusIOServiceResp, error) {
	rsp, err := c.ClearBusIOService(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearBusIOServiceResp(rsp)
}

// GetBusIOServiceWithResponse request returning *GetBusIOServiceResp
func (c *ClientWithResponses) GetBusIOServiceWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetBusIOServiceResp, error) {
	rsp, err := c.GetBusIOService(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBusIOServiceResp(rsp)
}

// AddBusIOServiceWithBodyWithResponse request with arbitrary body returning *AddBusIOServiceResp
func (c *ClientWithResponses) AddBusIOServiceWithBodyWithResponse(ctx context.Context, cellID CellID, params *AddBusIOServiceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddBusIOServiceResp, error) {
	rsp, err := c.AddBusIOServiceWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddBusIOServiceResp(rsp)
}

func (c *ClientWithResponses) AddBusIOServiceWithResponse(ctx context.Context, cellID CellID, params *AddBusIOServiceParams, body AddBusIOServiceJSONRequestBody, reqEditors ...RequestEditorFn) (*AddBusIOServiceResp, error) {
	rsp, err := c.AddBusIOService(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddBusIOServiceResp(rsp)
}

// ListBusIODescriptionsWithResponse request returning *ListBusIODescriptionsResp
func (c *ClientWithResponses) ListBusIODescriptionsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListBusIODescriptionsResp, error) {
	rsp, err := c.ListBusIODescriptions(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBusIODescriptionsResp(rsp)
}

// GetBusIOValuesWithResponse request returning *GetBusIOValuesResp
func (c *ClientWithResponses) GetBusIOValuesWithResponse(ctx context.Context, cellID CellID, params *GetBusIOValuesParams, reqEditors ...RequestEditorFn) (*GetBusIOValuesResp, error) {
	rsp, err := c.GetBusIOValues(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBusIOValuesResp(rsp)
}

// SetBusIOValuesWithBodyWithResponse request with arbitrary body returning *SetBusIOValuesResp
func (c *ClientWithResponses) SetBusIOValuesWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBusIOValuesResp, error) {
	rsp, err := c.SetBusIOValuesWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBusIOValuesResp(rsp)
}

func (c *ClientWithResponses) SetBusIOValuesWithResponse(ctx context.Context, cellID CellID, body SetBusIOValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBusIOValuesResp, error) {
	rsp, err := c.SetBusIOValues(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBusIOValuesResp(rsp)
}

// GetProfinetDescriptionWithResponse request returning *GetProfinetDescriptionResp
func (c *ClientWithResponses) GetProfinetDescriptionWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetProfinetDescriptionResp, error) {
	rsp, err := c.GetProfinetDescription(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProfinetDescriptionResp(rsp)
}

// GetProfinetIOsFromFileWithResponse request returning *GetProfinetIOsFromFileResp
func (c *ClientWithResponses) GetProfinetIOsFromFileWithResponse(ctx context.Context, cellID CellID, params *GetProfinetIOsFromFileParams, reqEditors ...RequestEditorFn) (*GetProfinetIOsFromFileResp, error) {
	rsp, err := c.GetProfinetIOsFromFile(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProfinetIOsFromFileResp(rsp)
}

// SetProfinetIOsFromFileWithBodyWithResponse request with arbitrary body returning *SetProfinetIOsFromFileResp
func (c *ClientWithResponses) SetProfinetIOsFromFileWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetProfinetIOsFromFileResp, error) {
	rsp, err := c.SetProfinetIOsFromFileWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetProfinetIOsFromFileResp(rsp)
}

func (c *ClientWithResponses) SetProfinetIOsFromFileWithResponse(ctx context.Context, cellID CellID, body SetProfinetIOsFromFileJSONRequestBody, reqEditors ...RequestEditorFn) (*SetProfinetIOsFromFileResp, error) {
	rsp, err := c.SetProfinetIOsFromFile(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetProfinetIOsFromFileResp(rsp)
}

// ListProfinetIOsWithResponse request returning *ListProfinetIOsResp
func (c *ClientWithResponses) ListProfinetIOsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListProfinetIOsResp, error) {
	rsp, err := c.ListProfinetIOs(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProfinetIOsResp(rsp)
}

// DeleteProfinetIOWithResponse request returning *DeleteProfinetIOResp
func (c *ClientWithResponses) DeleteProfinetIOWithResponse(ctx context.Context, cellID CellID, ioid IOID, reqEditors ...RequestEditorFn) (*DeleteProfinetIOResp, error) {
	rsp, err := c.DeleteProfinetIO(ctx, cellID, ioid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProfinetIOResp(rsp)
}

// AddProfinetIOWithBodyWithResponse request with arbitrary body returning *AddProfinetIOResp
func (c *ClientWithResponses) AddProfinetIOWithBodyWithResponse(ctx context.Context, cellID CellID, ioid IOID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddProfinetIOResp, error) {
	rsp, err := c.AddProfinetIOWithBody(ctx, cellID, ioid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProfinetIOResp(rsp)
}

func (c *ClientWithResponses) AddProfinetIOWithResponse(ctx context.Context, cellID CellID, ioid IOID, body AddProfinetIOJSONRequestBody, reqEditors ...RequestEditorFn) (*AddProfinetIOResp, error) {
	rsp, err := c.AddProfinetIO(ctx, cellID, ioid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProfinetIOResp(rsp)
}

// GetBusIOStateWithResponse request returning *GetBusIOStateResp
func (c *ClientWithResponses) GetBusIOStateWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetBusIOStateResp, error) {
	rsp, err := c.GetBusIOState(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBusIOStateResp(rsp)
}

// ClearRobotControllersWithResponse request returning *ClearRobotControllersResp
func (c *ClientWithResponses) ClearRobotControllersWithResponse(ctx context.Context, cellID CellID, params *ClearRobotControllersParams, reqEditors ...RequestEditorFn) (*ClearRobotControllersResp, error) {
	rsp, err := c.ClearRobotControllers(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearRobotControllersResp(rsp)
}

// ListRobotControllersWithResponse request returning *ListRobotControllersResp
func (c *ClientWithResponses) ListRobotControllersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListRobotControllersResp, error) {
	rsp, err := c.ListRobotControllers(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRobotControllersResp(rsp)
}

// AddRobotControllerWithBodyWithResponse request with arbitrary body returning *AddRobotControllerResp
func (c *ClientWithResponses) AddRobotControllerWithBodyWithResponse(ctx context.Context, cellID CellID, params *AddRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRobotControllerResp, error) {
	rsp, err := c.AddRobotControllerWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRobotControllerResp(rsp)
}

func (c *ClientWithResponses) AddRobotControllerWithResponse(ctx context.Context, cellID CellID, params *AddRobotControllerParams, body AddRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRobotControllerResp, error) {
	rsp, err := c.AddRobotController(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRobotControllerResp(rsp)
}

// DeleteRobotControllerWithResponse request returning *DeleteRobotControllerResp
func (c *ClientWithResponses) DeleteRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *DeleteRobotControllerParams, reqEditors ...RequestEditorFn) (*DeleteRobotControllerResp, error) {
	rsp, err := c.DeleteRobotController(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRobotControllerResp(rsp)
}

// GetRobotControllerWithResponse request returning *GetRobotControllerResp
func (c *ClientWithResponses) GetRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetRobotControllerResp, error) {
	rsp, err := c.GetRobotController(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRobotControllerResp(rsp)
}

// UpdateRobotControllerWithBodyWithResponse request with arbitrary body returning *UpdateRobotControllerResp
func (c *ClientWithResponses) UpdateRobotControllerWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRobotControllerResp, error) {
	rsp, err := c.UpdateRobotControllerWithBody(ctx, cellID, controllerID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRobotControllerResp(rsp)
}

func (c *ClientWithResponses) UpdateRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, body UpdateRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRobotControllerResp, error) {
	rsp, err := c.UpdateRobotController(ctx, cellID, controllerID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRobotControllerResp(rsp)
}

// ListCoordinateSystemsWithResponse request returning *ListCoordinateSystemsResp
func (c *ClientWithResponses) ListCoordinateSystemsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListCoordinateSystemsParams, reqEditors ...RequestEditorFn) (*ListCoordinateSystemsResp, error) {
	rsp, err := c.ListCoordinateSystems(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCoordinateSystemsResp(rsp)
}

// GetCoordinateSystemWithResponse request returning *GetCoordinateSystemResp
func (c *ClientWithResponses) GetCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, params *GetCoordinateSystemParams, reqEditors ...RequestEditorFn) (*GetCoordinateSystemResp, error) {
	rsp, err := c.GetCoordinateSystem(ctx, cellID, controllerID, coordinateSystemID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoordinateSystemResp(rsp)
}

// GetControllerDescriptionWithResponse request returning *GetControllerDescriptionResp
func (c *ClientWithResponses) GetControllerDescriptionWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetControllerDescriptionResp, error) {
	rsp, err := c.GetControllerDescription(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetControllerDescriptionResp(rsp)
}

// ExecuteJoggingWithBodyWithResponse request with arbitrary body returning *ExecuteJoggingResp
func (c *ClientWithResponses) ExecuteJoggingWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteJoggingResp, error) {
	rsp, err := c.ExecuteJoggingWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteJoggingResp(rsp)
}

func (c *ClientWithResponses) ExecuteJoggingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body ExecuteJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteJoggingResp, error) {
	rsp, err := c.ExecuteJogging(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteJoggingResp(rsp)
}

// ExecuteTrajectoryWithBodyWithResponse request with arbitrary body returning *ExecuteTrajectoryResp
func (c *ClientWithResponses) ExecuteTrajectoryWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteTrajectoryResp, error) {
	rsp, err := c.ExecuteTrajectoryWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteTrajectoryResp(rsp)
}

func (c *ClientWithResponses) ExecuteTrajectoryWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body ExecuteTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteTrajectoryResp, error) {
	rsp, err := c.ExecuteTrajectory(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteTrajectoryResp(rsp)
}

// StreamFreeDriveWithResponse request returning *StreamFreeDriveResp
func (c *ClientWithResponses) StreamFreeDriveWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams, reqEditors ...RequestEditorFn) (*StreamFreeDriveResp, error) {
	rsp, err := c.StreamFreeDrive(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamFreeDriveResp(rsp)
}

// ListIODescriptionsWithResponse request returning *ListIODescriptionsResp
func (c *ClientWithResponses) ListIODescriptionsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams, reqEditors ...RequestEditorFn) (*ListIODescriptionsResp, error) {
	rsp, err := c.ListIODescriptions(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIODescriptionsResp(rsp)
}

// StreamIOValuesWithResponse request returning *StreamIOValuesResp
func (c *ClientWithResponses) StreamIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams, reqEditors ...RequestEditorFn) (*StreamIOValuesResp, error) {
	rsp, err := c.StreamIOValues(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamIOValuesResp(rsp)
}

// ListIOValuesWithResponse request returning *ListIOValuesResp
func (c *ClientWithResponses) ListIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOValuesParams, reqEditors ...RequestEditorFn) (*ListIOValuesResp, error) {
	rsp, err := c.ListIOValues(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIOValuesResp(rsp)
}

// SetOutputValuesWithBodyWithResponse request with arbitrary body returning *SetOutputValuesResp
func (c *ClientWithResponses) SetOutputValuesWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOutputValuesResp, error) {
	rsp, err := c.SetOutputValuesWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOutputValuesResp(rsp)
}

func (c *ClientWithResponses) SetOutputValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOutputValuesResp, error) {
	rsp, err := c.SetOutputValues(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOutputValuesResp(rsp)
}

// WaitForIOEventWithBodyWithResponse request with arbitrary body returning *WaitForIOEventResp
func (c *ClientWithResponses) WaitForIOEventWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WaitForIOEventResp, error) {
	rsp, err := c.WaitForIOEventWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWaitForIOEventResp(rsp)
}

func (c *ClientWithResponses) WaitForIOEventWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body WaitForIOEventJSONRequestBody, reqEditors ...RequestEditorFn) (*WaitForIOEventResp, error) {
	rsp, err := c.WaitForIOEvent(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWaitForIOEventResp(rsp)
}

// SetDefaultModeWithResponse request returning *SetDefaultModeResp
func (c *ClientWithResponses) SetDefaultModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams, reqEditors ...RequestEditorFn) (*SetDefaultModeResp, error) {
	rsp, err := c.SetDefaultMode(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultModeResp(rsp)
}

// GetMotionGroupDescriptionWithResponse request returning *GetMotionGroupDescriptionResp
func (c *ClientWithResponses) GetMotionGroupDescriptionWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*GetMotionGroupDescriptionResp, error) {
	rsp, err := c.GetMotionGroupDescription(ctx, cellID, controllerID, motionGroupID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupDescriptionResp(rsp)
}

// GetCurrentMotionGroupStateWithResponse request returning *GetCurrentMotionGroupStateResp
func (c *ClientWithResponses) GetCurrentMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, params *GetCurrentMotionGroupStateParams, reqEditors ...RequestEditorFn) (*GetCurrentMotionGroupStateResp, error) {
	rsp, err := c.GetCurrentMotionGroupState(ctx, cellID, controllerID, motionGroupID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentMotionGroupStateResp(rsp)
}

// StreamMotionGroupStateWithResponse request returning *StreamMotionGroupStateResp
func (c *ClientWithResponses) StreamMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, params *StreamMotionGroupStateParams, reqEditors ...RequestEditorFn) (*StreamMotionGroupStateResp, error) {
	rsp, err := c.StreamMotionGroupState(ctx, cellID, controllerID, motionGroupID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMotionGroupStateResp(rsp)
}

// GetCurrentRobotControllerStateWithResponse request returning *GetCurrentRobotControllerStateResp
func (c *ClientWithResponses) GetCurrentRobotControllerStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetCurrentRobotControllerStateResp, error) {
	rsp, err := c.GetCurrentRobotControllerState(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentRobotControllerStateResp(rsp)
}

// StreamRobotControllerStateWithResponse request returning *StreamRobotControllerStateResp
func (c *ClientWithResponses) StreamRobotControllerStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams, reqEditors ...RequestEditorFn) (*StreamRobotControllerStateResp, error) {
	rsp, err := c.StreamRobotControllerState(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamRobotControllerStateResp(rsp)
}

// ClearTrajectoriesWithResponse request returning *ClearTrajectoriesResp
func (c *ClientWithResponses) ClearTrajectoriesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ClearTrajectoriesResp, error) {
	rsp, err := c.ClearTrajectories(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearTrajectoriesResp(rsp)
}

// ListTrajectoriesWithResponse request returning *ListTrajectoriesResp
func (c *ClientWithResponses) ListTrajectoriesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListTrajectoriesResp, error) {
	rsp, err := c.ListTrajectories(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTrajectoriesResp(rsp)
}

// AddTrajectoryWithBodyWithResponse request with arbitrary body returning *AddTrajectoryResp
func (c *ClientWithResponses) AddTrajectoryWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTrajectoryResp, error) {
	rsp, err := c.AddTrajectoryWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTrajectoryResp(rsp)
}

func (c *ClientWithResponses) AddTrajectoryWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body AddTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTrajectoryResp, error) {
	rsp, err := c.AddTrajectory(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTrajectoryResp(rsp)
}

// DeleteTrajectoryWithResponse request returning *DeleteTrajectoryResp
func (c *ClientWithResponses) DeleteTrajectoryWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, trajectory Trajectory, reqEditors ...RequestEditorFn) (*DeleteTrajectoryResp, error) {
	rsp, err := c.DeleteTrajectory(ctx, cellID, controllerID, trajectory, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTrajectoryResp(rsp)
}

// GetTrajectoryWithResponse request returning *GetTrajectoryResp
func (c *ClientWithResponses) GetTrajectoryWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, trajectory Trajectory, reqEditors ...RequestEditorFn) (*GetTrajectoryResp, error) {
	rsp, err := c.GetTrajectory(ctx, cellID, controllerID, trajectory, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTrajectoryResp(rsp)
}

// GetVirtualControllerConfigurationWithResponse request returning *GetVirtualControllerConfigurationResp
func (c *ClientWithResponses) GetVirtualControllerConfigurationWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetVirtualControllerConfigurationResp, error) {
	rsp, err := c.GetVirtualControllerConfiguration(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualControllerConfigurationResp(rsp)
}

// ForwardKinematicsWithBodyWithResponse request with arbitrary body returning *ForwardKinematicsResp
func (c *ClientWithResponses) ForwardKinematicsWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForwardKinematicsResp, error) {
	rsp, err := c.ForwardKinematicsWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForwardKinematicsResp(rsp)
}

func (c *ClientWithResponses) ForwardKinematicsWithResponse(ctx context.Context, cellID CellID, body ForwardKinematicsJSONRequestBody, reqEditors ...RequestEditorFn) (*ForwardKinematicsResp, error) {
	rsp, err := c.ForwardKinematics(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForwardKinematicsResp(rsp)
}

// InverseKinematicsWithBodyWithResponse request with arbitrary body returning *InverseKinematicsResp
func (c *ClientWithResponses) InverseKinematicsWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InverseKinematicsResp, error) {
	rsp, err := c.InverseKinematicsWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInverseKinematicsResp(rsp)
}

func (c *ClientWithResponses) InverseKinematicsWithResponse(ctx context.Context, cellID CellID, body InverseKinematicsJSONRequestBody, reqEditors ...RequestEditorFn) (*InverseKinematicsResp, error) {
	rsp, err := c.InverseKinematics(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInverseKinematicsResp(rsp)
}

// GetMotionGroupModelsWithResponse request returning *GetMotionGroupModelsResp
func (c *ClientWithResponses) GetMotionGroupModelsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetMotionGroupModelsResp, error) {
	rsp, err := c.GetMotionGroupModels(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupModelsResp(rsp)
}

// GetMotionGroupCollisionModelWithResponse request returning *GetMotionGroupCollisionModelResp
func (c *ClientWithResponses) GetMotionGroupCollisionModelWithResponse(ctx context.Context, cellID CellID, motionGroupModel MotionGroupModelParameter, reqEditors ...RequestEditorFn) (*GetMotionGroupCollisionModelResp, error) {
	rsp, err := c.GetMotionGroupCollisionModel(ctx, cellID, motionGroupModel, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupCollisionModelResp(rsp)
}

// GetCellStatusWithResponse request returning *GetCellStatusResp
func (c *ClientWithResponses) GetCellStatusWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetCellStatusResp, error) {
	rsp, err := c.GetCellStatus(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCellStatusResp(rsp)
}

// SetCellStatusWithResponse request returning *SetCellStatusResp
func (c *ClientWithResponses) SetCellStatusWithResponse(ctx context.Context, cellID CellID, params *SetCellStatusParams, reqEditors ...RequestEditorFn) (*SetCellStatusResp, error) {
	rsp, err := c.SetCellStatus(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCellStatusResp(rsp)
}

// ListStoredCollidersWithResponse request returning *ListStoredCollidersResp
func (c *ClientWithResponses) ListStoredCollidersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollidersResp, error) {
	rsp, err := c.ListStoredColliders(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStoredCollidersResp(rsp)
}

// DeleteStoredColliderWithResponse request returning *DeleteStoredColliderResp
func (c *ClientWithResponses) DeleteStoredColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*DeleteStoredColliderResp, error) {
	rsp, err := c.DeleteStoredCollider(ctx, cellID, colliderID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoredColliderResp(rsp)
}

// GetStoredColliderWithResponse request returning *GetStoredColliderResp
func (c *ClientWithResponses) GetStoredColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*GetStoredColliderResp, error) {
	rsp, err := c.GetStoredCollider(ctx, cellID, colliderID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoredColliderResp(rsp)
}

// StoreColliderWithBodyWithResponse request with arbitrary body returning *StoreColliderResp
func (c *ClientWithResponses) StoreColliderWithBodyWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreColliderResp, error) {
	rsp, err := c.StoreColliderWithBody(ctx, cellID, colliderID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreColliderResp(rsp)
}

func (c *ClientWithResponses) StoreColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreColliderResp, error) {
	rsp, err := c.StoreCollider(ctx, cellID, colliderID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreColliderResp(rsp)
}

// ListCollisionLinkChainsWithResponse request returning *ListCollisionLinkChainsResp
func (c *ClientWithResponses) ListCollisionLinkChainsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListCollisionLinkChainsResp, error) {
	rsp, err := c.ListCollisionLinkChains(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCollisionLinkChainsResp(rsp)
}

// DeleteStoredCollisionLinkChainWithResponse request returning *DeleteStoredCollisionLinkChainResp
func (c *ClientWithResponses) DeleteStoredCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionLinkChainResp, error) {
	rsp, err := c.DeleteStoredCollisionLinkChain(ctx, cellID, linkChainID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoredCollisionLinkChainResp(rsp)
}

// GetStoredCollisionLinkChainWithResponse request returning *GetStoredCollisionLinkChainResp
func (c *ClientWithResponses) GetStoredCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*GetStoredCollisionLinkChainResp, error) {
	rsp, err := c.GetStoredCollisionLinkChain(ctx, cellID, linkChainID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoredCollisionLinkChainResp(rsp)
}

// StoreCollisionLinkChainWithBodyWithResponse request with arbitrary body returning *StoreCollisionLinkChainResp
func (c *ClientWithResponses) StoreCollisionLinkChainWithBodyWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionLinkChainResp, error) {
	rsp, err := c.StoreCollisionLinkChainWithBody(ctx, cellID, linkChainID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionLinkChainResp(rsp)
}

func (c *ClientWithResponses) StoreCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionLinkChainResp, error) {
	rsp, err := c.StoreCollisionLinkChain(ctx, cellID, linkChainID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionLinkChainResp(rsp)
}

// ListStoredCollisionSetupsWithResponse request returning *ListStoredCollisionSetupsResp
func (c *ClientWithResponses) ListStoredCollisionSetupsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollisionSetupsResp, error) {
	rsp, err := c.ListStoredCollisionSetups(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStoredCollisionSetupsResp(rsp)
}

// DeleteStoredCollisionSetupWithResponse request returning *DeleteStoredCollisionSetupResp
func (c *ClientWithResponses) DeleteStoredCollisionSetupWithResponse(ctx context.Context, cellID CellID, setup Setup, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionSetupResp, error) {
	rsp, err := c.DeleteStoredCollisionSetup(ctx, cellID, setup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoredCollisionSetupResp(rsp)
}

// GetStoredCollisionSetupWithResponse request returning *GetStoredCollisionSetupResp
func (c *ClientWithResponses) GetStoredCollisionSetupWithResponse(ctx context.Context, cellID CellID, setup Setup, reqEditors ...RequestEditorFn) (*GetStoredCollisionSetupResp, error) {
	rsp, err := c.GetStoredCollisionSetup(ctx, cellID, setup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoredCollisionSetupResp(rsp)
}

// StoreCollisionSetupWithBodyWithResponse request with arbitrary body returning *StoreCollisionSetupResp
func (c *ClientWithResponses) StoreCollisionSetupWithBodyWithResponse(ctx context.Context, cellID CellID, setup Setup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionSetupResp, error) {
	rsp, err := c.StoreCollisionSetupWithBody(ctx, cellID, setup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionSetupResp(rsp)
}

func (c *ClientWithResponses) StoreCollisionSetupWithResponse(ctx context.Context, cellID CellID, setup Setup, body StoreCollisionSetupJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionSetupResp, error) {
	rsp, err := c.StoreCollisionSetup(ctx, cellID, setup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionSetupResp(rsp)
}

// ListStoredCollisionToolsWithResponse request returning *ListStoredCollisionToolsResp
func (c *ClientWithResponses) ListStoredCollisionToolsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollisionToolsResp, error) {
	rsp, err := c.ListStoredCollisionTools(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStoredCollisionToolsResp(rsp)
}

// DeleteStoredCollisionToolWithResponse request returning *DeleteStoredCollisionToolResp
func (c *ClientWithResponses) DeleteStoredCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionToolResp, error) {
	rsp, err := c.DeleteStoredCollisionTool(ctx, cellID, toolID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoredCollisionToolResp(rsp)
}

// GetStoredCollisionToolWithResponse request returning *GetStoredCollisionToolResp
func (c *ClientWithResponses) GetStoredCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*GetStoredCollisionToolResp, error) {
	rsp, err := c.GetStoredCollisionTool(ctx, cellID, toolID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoredCollisionToolResp(rsp)
}

// StoreCollisionToolWithBodyWithResponse request with arbitrary body returning *StoreCollisionToolResp
func (c *ClientWithResponses) StoreCollisionToolWithBodyWithResponse(ctx context.Context, cellID CellID, toolID ToolID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionToolResp, error) {
	rsp, err := c.StoreCollisionToolWithBody(ctx, cellID, toolID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionToolResp(rsp)
}

func (c *ClientWithResponses) StoreCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionToolResp, error) {
	rsp, err := c.StoreCollisionTool(ctx, cellID, toolID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionToolResp(rsp)
}

// ClearAllObjectsWithResponse request returning *ClearAllObjectsResp
func (c *ClientWithResponses) ClearAllObjectsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearAllObjectsResp, error) {
	rsp, err := c.ClearAllObjects(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearAllObjectsResp(rsp)
}

// ListAllObjectKeysWithResponse request returning *ListAllObjectKeysResp
func (c *ClientWithResponses) ListAllObjectKeysWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListAllObjectKeysResp, error) {
	rsp, err := c.ListAllObjectKeys(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllObjectKeysResp(rsp)
}

// DeleteObjectWithResponse request returning *DeleteObjectResp
func (c *ClientWithResponses) DeleteObjectWithResponse(ctx context.Context, cellID CellID, objectKey ObjectKey, reqEditors ...RequestEditorFn) (*DeleteObjectResp, error) {
	rsp, err := c.DeleteObject(ctx, cellID, objectKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectResp(rsp)
}

// GetObjectWithResponse request returning *GetObjectResp
func (c *ClientWithResponses) GetObjectWithResponse(ctx context.Context, cellID CellID, objectKey ObjectKey, reqEditors ...RequestEditorFn) (*GetObjectResp, error) {
	rsp, err := c.GetObject(ctx, cellID, objectKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectResp(rsp)
}

// GetObjectMetadataWithResponse request returning *GetObjectMetadataResp
func (c *ClientWithResponses) GetObjectMetadataWithResponse(ctx context.Context, cellID CellID, objectKey ObjectKey, reqEditors ...RequestEditorFn) (*GetObjectMetadataResp, error) {
	rsp, err := c.GetObjectMetadata(ctx, cellID, objectKey, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectMetadataResp(rsp)
}

// StoreObjectWithBodyWithResponse request with arbitrary body returning *StoreObjectResp
func (c *ClientWithResponses) StoreObjectWithBodyWithResponse(ctx context.Context, cellID CellID, objectKey ObjectKey, params *StoreObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreObjectResp, error) {
	rsp, err := c.StoreObjectWithBody(ctx, cellID, objectKey, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreObjectResp(rsp)
}

// PlanCollisionFreeWithBodyWithResponse request with arbitrary body returning *PlanCollisionFreeResp
func (c *ClientWithResponses) PlanCollisionFreeWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanCollisionFreeResp, error) {
	rsp, err := c.PlanCollisionFreeWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanCollisionFreeResp(rsp)
}

func (c *ClientWithResponses) PlanCollisionFreeWithResponse(ctx context.Context, cellID CellID, body PlanCollisionFreeJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanCollisionFreeResp, error) {
	rsp, err := c.PlanCollisionFree(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanCollisionFreeResp(rsp)
}

// PlanTrajectoryWithBodyWithResponse request with arbitrary body returning *PlanTrajectoryResp
func (c *ClientWithResponses) PlanTrajectoryWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanTrajectoryResp, error) {
	rsp, err := c.PlanTrajectoryWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanTrajectoryResp(rsp)
}

func (c *ClientWithResponses) PlanTrajectoryWithResponse(ctx context.Context, cellID CellID, body PlanTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanTrajectoryResp, error) {
	rsp, err := c.PlanTrajectory(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanTrajectoryResp(rsp)
}

// GetVirtualControllerBehaviorWithResponse request returning *GetVirtualControllerBehaviorResp
func (c *ClientWithResponses) GetVirtualControllerBehaviorWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetVirtualControllerBehaviorResp, error) {
	rsp, err := c.GetVirtualControllerBehavior(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualControllerBehaviorResp(rsp)
}

// SetVirtualControllerBehaviorWithResponse request returning *SetVirtualControllerBehaviorResp
func (c *ClientWithResponses) SetVirtualControllerBehaviorWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetVirtualControllerBehaviorParams, reqEditors ...RequestEditorFn) (*SetVirtualControllerBehaviorResp, error) {
	rsp, err := c.SetVirtualControllerBehavior(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetVirtualControllerBehaviorResp(rsp)
}

// ListVirtualControllerCoordinateSystemsWithResponse request returning *ListVirtualControllerCoordinateSystemsResp
func (c *ClientWithResponses) ListVirtualControllerCoordinateSystemsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListVirtualControllerCoordinateSystemsResp, error) {
	rsp, err := c.ListVirtualControllerCoordinateSystems(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVirtualControllerCoordinateSystemsResp(rsp)
}

// DeleteVirtualControllerCoordinateSystemWithResponse request returning *DeleteVirtualControllerCoordinateSystemResp
func (c *ClientWithResponses) DeleteVirtualControllerCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, params *DeleteVirtualControllerCoordinateSystemParams, reqEditors ...RequestEditorFn) (*DeleteVirtualControllerCoordinateSystemResp, error) {
	rsp, err := c.DeleteVirtualControllerCoordinateSystem(ctx, cellID, controllerID, coordinateSystemID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualControllerCoordinateSystemResp(rsp)
}

// AddVirtualControllerCoordinateSystemWithBodyWithResponse request with arbitrary body returning *AddVirtualControllerCoordinateSystemResp
func (c *ClientWithResponses) AddVirtualControllerCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualControllerCoordinateSystemResp, error) {
	rsp, err := c.AddVirtualControllerCoordinateSystemWithBody(ctx, cellID, controllerID, coordinateSystemID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualControllerCoordinateSystemResp(rsp)
}

func (c *ClientWithResponses) AddVirtualControllerCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystemID CoordinateSystemID, body AddVirtualControllerCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualControllerCoordinateSystemResp, error) {
	rsp, err := c.AddVirtualControllerCoordinateSystem(ctx, cellID, controllerID, coordinateSystemID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualControllerCoordinateSystemResp(rsp)
}

// GetCycleTimeWithResponse request returning *GetCycleTimeResp
func (c *ClientWithResponses) GetCycleTimeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetCycleTimeResp, error) {
	rsp, err := c.GetCycleTime(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCycleTimeResp(rsp)
}

// GetEmergencyStopWithResponse request returning *GetEmergencyStopResp
func (c *ClientWithResponses) GetEmergencyStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetEmergencyStopResp, error) {
	rsp, err := c.GetEmergencyStop(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmergencyStopResp(rsp)
}

// SetEmergencyStopWithResponse request returning *SetEmergencyStopResp
func (c *ClientWithResponses) SetEmergencyStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetEmergencyStopParams, reqEditors ...RequestEditorFn) (*SetEmergencyStopResp, error) {
	rsp, err := c.SetEmergencyStop(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetEmergencyStopResp(rsp)
}

// ExternalJointsStreamWithBodyWithResponse request with arbitrary body returning *ExternalJointsStreamResp
func (c *ClientWithResponses) ExternalJointsStreamWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExternalJointsStreamResp, error) {
	rsp, err := c.ExternalJointsStreamWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalJointsStreamResp(rsp)
}

func (c *ClientWithResponses) ExternalJointsStreamWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*ExternalJointsStreamResp, error) {
	rsp, err := c.ExternalJointsStream(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalJointsStreamResp(rsp)
}

// ListVirtualControllerIODescriptionsWithResponse request returning *ListVirtualControllerIODescriptionsResp
func (c *ClientWithResponses) ListVirtualControllerIODescriptionsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListVirtualControllerIODescriptionsParams, reqEditors ...RequestEditorFn) (*ListVirtualControllerIODescriptionsResp, error) {
	rsp, err := c.ListVirtualControllerIODescriptions(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVirtualControllerIODescriptionsResp(rsp)
}

// ListIOsWithResponse request returning *ListIOsResp
func (c *ClientWithResponses) ListIOsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOsParams, reqEditors ...RequestEditorFn) (*ListIOsResp, error) {
	rsp, err := c.ListIOs(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIOsResp(rsp)
}

// SetIOValuesWithBodyWithResponse request with arbitrary body returning *SetIOValuesResp
func (c *ClientWithResponses) SetIOValuesWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIOValuesResp, error) {
	rsp, err := c.SetIOValuesWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIOValuesResp(rsp)
}

func (c *ClientWithResponses) SetIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body SetIOValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIOValuesResp, error) {
	rsp, err := c.SetIOValues(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIOValuesResp(rsp)
}

// GetMotionGroupsWithResponse request returning *GetMotionGroupsResp
func (c *ClientWithResponses) GetMotionGroupsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetMotionGroupsResp, error) {
	rsp, err := c.GetMotionGroups(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupsResp(rsp)
}

// GetVirtualControllerMountingWithResponse request returning *GetVirtualControllerMountingResp
func (c *ClientWithResponses) GetVirtualControllerMountingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*GetVirtualControllerMountingResp, error) {
	rsp, err := c.GetVirtualControllerMounting(ctx, cellID, controllerID, motionGroupID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualControllerMountingResp(rsp)
}

// SetVirtualControllerMountingWithBodyWithResponse request with arbitrary body returning *SetVirtualControllerMountingResp
func (c *ClientWithResponses) SetVirtualControllerMountingWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetVirtualControllerMountingResp, error) {
	rsp, err := c.SetVirtualControllerMountingWithBody(ctx, cellID, controllerID, motionGroupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetVirtualControllerMountingResp(rsp)
}

func (c *ClientWithResponses) SetVirtualControllerMountingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, body SetVirtualControllerMountingJSONRequestBody, reqEditors ...RequestEditorFn) (*SetVirtualControllerMountingResp, error) {
	rsp, err := c.SetVirtualControllerMounting(ctx, cellID, controllerID, motionGroupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetVirtualControllerMountingResp(rsp)
}

// GetMotionGroupStateWithResponse request returning *GetMotionGroupStateResp
func (c *ClientWithResponses) GetMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*GetMotionGroupStateResp, error) {
	rsp, err := c.GetMotionGroupState(ctx, cellID, controllerID, motionGroupID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupStateResp(rsp)
}

// SetMotionGroupStateWithBodyWithResponse request with arbitrary body returning *SetMotionGroupStateResp
func (c *ClientWithResponses) SetMotionGroupStateWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMotionGroupStateResp, error) {
	rsp, err := c.SetMotionGroupStateWithBody(ctx, cellID, controllerID, motionGroupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMotionGroupStateResp(rsp)
}

func (c *ClientWithResponses) SetMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, body SetMotionGroupStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMotionGroupStateResp, error) {
	rsp, err := c.SetMotionGroupState(ctx, cellID, controllerID, motionGroupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMotionGroupStateResp(rsp)
}

// ListVirtualControllerTcpsWithResponse request returning *ListVirtualControllerTcpsResp
func (c *ClientWithResponses) ListVirtualControllerTcpsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, reqEditors ...RequestEditorFn) (*ListVirtualControllerTcpsResp, error) {
	rsp, err := c.ListVirtualControllerTcps(ctx, cellID, controllerID, motionGroupID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVirtualControllerTcpsResp(rsp)
}

// DeleteVirtualControllerTcpWithResponse request returning *DeleteVirtualControllerTcpResp
func (c *ClientWithResponses) DeleteVirtualControllerTcpWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, reqEditors ...RequestEditorFn) (*DeleteVirtualControllerTcpResp, error) {
	rsp, err := c.DeleteVirtualControllerTcp(ctx, cellID, controllerID, motionGroupID, tcp, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualControllerTcpResp(rsp)
}

// AddVirtualControllerTcpWithBodyWithResponse request with arbitrary body returning *AddVirtualControllerTcpResp
func (c *ClientWithResponses) AddVirtualControllerTcpWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualControllerTcpResp, error) {
	rsp, err := c.AddVirtualControllerTcpWithBody(ctx, cellID, controllerID, motionGroupID, tcp, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualControllerTcpResp(rsp)
}

func (c *ClientWithResponses) AddVirtualControllerTcpWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, motionGroupID MotionGroupID, tcp Tcp, body AddVirtualControllerTcpJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualControllerTcpResp, error) {
	rsp, err := c.AddVirtualControllerTcp(ctx, cellID, controllerID, motionGroupID, tcp, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualControllerTcpResp(rsp)
}

// GetOperationModeWithResponse request returning *GetOperationModeResp
func (c *ClientWithResponses) GetOperationModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetOperationModeResp, error) {
	rsp, err := c.GetOperationMode(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOperationModeResp(rsp)
}

// SetOperationModeWithResponse request returning *SetOperationModeResp
func (c *ClientWithResponses) SetOperationModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetOperationModeParams, reqEditors ...RequestEditorFn) (*SetOperationModeResp, error) {
	rsp, err := c.SetOperationMode(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOperationModeResp(rsp)
}

// DeactivateLicenseWithResponse request returning *DeactivateLicenseResp
func (c *ClientWithResponses) DeactivateLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeactivateLicenseResp, error) {
	rsp, err := c.DeactivateLicense(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeactivateLicenseResp(rsp)
}

// GetLicenseWithResponse request returning *GetLicenseResp
func (c *ClientWithResponses) GetLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseResp, error) {
	rsp, err := c.GetLicense(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseResp(rsp)
}

// ActivateLicenseWithBodyWithResponse request with arbitrary body returning *ActivateLicenseResp
func (c *ClientWithResponses) ActivateLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateLicenseResp, error) {
	rsp, err := c.ActivateLicenseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateLicenseResp(rsp)
}

func (c *ClientWithResponses) ActivateLicenseWithResponse(ctx context.Context, body ActivateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateLicenseResp, error) {
	rsp, err := c.ActivateLicense(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateLicenseResp(rsp)
}

// GetLicenseStatusWithResponse request returning *GetLicenseStatusResp
func (c *ClientWithResponses) GetLicenseStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseStatusResp, error) {
	rsp, err := c.GetLicenseStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseStatusResp(rsp)
}

// BackupConfigurationWithResponse request returning *BackupConfigurationResp
func (c *ClientWithResponses) BackupConfigurationWithResponse(ctx context.Context, params *BackupConfigurationParams, reqEditors ...RequestEditorFn) (*BackupConfigurationResp, error) {
	rsp, err := c.BackupConfiguration(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackupConfigurationResp(rsp)
}

// RestoreConfigurationWithBodyWithResponse request with arbitrary body returning *RestoreConfigurationResp
func (c *ClientWithResponses) RestoreConfigurationWithBodyWithResponse(ctx context.Context, params *RestoreConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreConfigurationResp, error) {
	rsp, err := c.RestoreConfigurationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreConfigurationResp(rsp)
}

// ListConfigurationResourcesWithResponse request returning *ListConfigurationResourcesResp
func (c *ClientWithResponses) ListConfigurationResourcesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListConfigurationResourcesResp, error) {
	rsp, err := c.ListConfigurationResources(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListConfigurationResourcesResp(rsp)
}

// GetConfigurationBackupStatusWithResponse request returning *GetConfigurationBackupStatusResp
func (c *ClientWithResponses) GetConfigurationBackupStatusWithResponse(ctx context.Context, params *GetConfigurationBackupStatusParams, reqEditors ...RequestEditorFn) (*GetConfigurationBackupStatusResp, error) {
	rsp, err := c.GetConfigurationBackupStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationBackupStatusResp(rsp)
}

// GetDiagnosePackageWithResponse request returning *GetDiagnosePackageResp
func (c *ClientWithResponses) GetDiagnosePackageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDiagnosePackageResp, error) {
	rsp, err := c.GetDiagnosePackage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDiagnosePackageResp(rsp)
}

// GetSystemStatusWithResponse request returning *GetSystemStatusResp
func (c *ClientWithResponses) GetSystemStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemStatusResp, error) {
	rsp, err := c.GetSystemStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemStatusResp(rsp)
}

// CheckNovaVersionUpdateWithResponse request returning *CheckNovaVersionUpdateResp
func (c *ClientWithResponses) CheckNovaVersionUpdateWithResponse(ctx context.Context, params *CheckNovaVersionUpdateParams, reqEditors ...RequestEditorFn) (*CheckNovaVersionUpdateResp, error) {
	rsp, err := c.CheckNovaVersionUpdate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckNovaVersionUpdateResp(rsp)
}

// UpdateNovaVersionWithBodyWithResponse request with arbitrary body returning *UpdateNovaVersionResp
func (c *ClientWithResponses) UpdateNovaVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNovaVersionResp, error) {
	rsp, err := c.UpdateNovaVersionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNovaVersionResp(rsp)
}

func (c *ClientWithResponses) UpdateNovaVersionWithResponse(ctx context.Context, body UpdateNovaVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNovaVersionResp, error) {
	rsp, err := c.UpdateNovaVersion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNovaVersionResp(rsp)
}

// GetSystemVersionWithResponse request returning *GetSystemVersionResp
func (c *ClientWithResponses) GetSystemVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemVersionResp, error) {
	rsp, err := c.GetSystemVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemVersionResp(rsp)
}

// ParseListCellsResp parses an HTTP response from a ListCellsWithResponse call
func ParseListCellsResp(rsp *http.Response) (*ListCellsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCellsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeployCellResp parses an HTTP response from a DeployCellWithResponse call
func ParseDeployCellResp(rsp *http.Response) (*DeployCellResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeployCellResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteCellResp parses an HTTP response from a DeleteCellWithResponse call
func ParseDeleteCellResp(rsp *http.Response) (*DeleteCellResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCellResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCellResp parses an HTTP response from a GetCellWithResponse call
func ParseGetCellResp(rsp *http.Response) (*GetCellResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCellResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cell
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateCellResp parses an HTTP response from a UpdateCellWithResponse call
func ParseUpdateCellResp(rsp *http.Response) (*UpdateCellResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCellResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseClearAppsResp parses an HTTP response from a ClearAppsWithResponse call
func ParseClearAppsResp(rsp *http.Response) (*ClearAppsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearAppsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListAppsResp parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResp(rsp *http.Response) (*ListAppsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddAppResp parses an HTTP response from a AddAppWithResponse call
func ParseAddAppResp(rsp *http.Response) (*AddAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteAppResp parses an HTTP response from a DeleteAppWithResponse call
func ParseDeleteAppResp(rsp *http.Response) (*DeleteAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAppResp parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResp(rsp *http.Response) (*GetAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAppResp parses an HTTP response from a UpdateAppWithResponse call
func ParseUpdateAppResp(rsp *http.Response) (*UpdateAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseClearBusIOServiceResp parses an HTTP response from a ClearBusIOServiceWithResponse call
func ParseClearBusIOServiceResp(rsp *http.Response) (*ClearBusIOServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearBusIOServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetBusIOServiceResp parses an HTTP response from a GetBusIOServiceWithResponse call
func ParseGetBusIOServiceResp(rsp *http.Response) (*GetBusIOServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBusIOServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BusIOType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddBusIOServiceResp parses an HTTP response from a AddBusIOServiceWithResponse call
func ParseAddBusIOServiceResp(rsp *http.Response) (*AddBusIOServiceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddBusIOServiceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListBusIODescriptionsResp parses an HTTP response from a ListBusIODescriptionsWithResponse call
func ParseListBusIODescriptionsResp(rsp *http.Response) (*ListBusIODescriptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBusIODescriptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIODescriptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetBusIOValuesResp parses an HTTP response from a GetBusIOValuesWithResponse call
func ParseGetBusIOValuesResp(rsp *http.Response) (*GetBusIOValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBusIOValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIOValuesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetBusIOValuesResp parses an HTTP response from a SetBusIOValuesWithResponse call
func ParseSetBusIOValuesResp(rsp *http.Response) (*SetBusIOValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetBusIOValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetProfinetDescriptionResp parses an HTTP response from a GetProfinetDescriptionWithResponse call
func ParseGetProfinetDescriptionResp(rsp *http.Response) (*GetProfinetDescriptionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProfinetDescriptionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfinetDescription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetProfinetIOsFromFileResp parses an HTTP response from a GetProfinetIOsFromFileWithResponse call
func ParseGetProfinetIOsFromFileResp(rsp *http.Response) (*GetProfinetIOsFromFileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProfinetIOsFromFileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetProfinetIOsFromFileResp parses an HTTP response from a SetProfinetIOsFromFileWithResponse call
func ParseSetProfinetIOsFromFileResp(rsp *http.Response) (*SetProfinetIOsFromFileResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetProfinetIOsFromFileResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListProfinetIOsResp parses an HTTP response from a ListProfinetIOsWithResponse call
func ParseListProfinetIOsResp(rsp *http.Response) (*ListProfinetIOsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProfinetIOsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfinetIOs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteProfinetIOResp parses an HTTP response from a DeleteProfinetIOWithResponse call
func ParseDeleteProfinetIOResp(rsp *http.Response) (*DeleteProfinetIOResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProfinetIOResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddProfinetIOResp parses an HTTP response from a AddProfinetIOWithResponse call
func ParseAddProfinetIOResp(rsp *http.Response) (*AddProfinetIOResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddProfinetIOResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetBusIOStateResp parses an HTTP response from a GetBusIOStateWithResponse call
func ParseGetBusIOStateResp(rsp *http.Response) (*GetBusIOStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBusIOStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BusIOsState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseClearRobotControllersResp parses an HTTP response from a ClearRobotControllersWithResponse call
func ParseClearRobotControllersResp(rsp *http.Response) (*ClearRobotControllersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearRobotControllersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListRobotControllersResp parses an HTTP response from a ListRobotControllersWithResponse call
func ParseListRobotControllersResp(rsp *http.Response) (*ListRobotControllersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRobotControllersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddRobotControllerResp parses an HTTP response from a AddRobotControllerWithResponse call
func ParseAddRobotControllerResp(rsp *http.Response) (*AddRobotControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRobotControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteRobotControllerResp parses an HTTP response from a DeleteRobotControllerWithResponse call
func ParseDeleteRobotControllerResp(rsp *http.Response) (*DeleteRobotControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRobotControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRobotControllerResp parses an HTTP response from a GetRobotControllerWithResponse call
func ParseGetRobotControllerResp(rsp *http.Response) (*GetRobotControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRobotControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotController
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateRobotControllerResp parses an HTTP response from a UpdateRobotControllerWithResponse call
func ParseUpdateRobotControllerResp(rsp *http.Response) (*UpdateRobotControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRobotControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListCoordinateSystemsResp parses an HTTP response from a ListCoordinateSystemsWithResponse call
func ParseListCoordinateSystemsResp(rsp *http.Response) (*ListCoordinateSystemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCoordinateSystemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCoordinateSystemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetCoordinateSystemResp parses an HTTP response from a GetCoordinateSystemWithResponse call
func ParseGetCoordinateSystemResp(rsp *http.Response) (*GetCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetControllerDescriptionResp parses an HTTP response from a GetControllerDescriptionWithResponse call
func ParseGetControllerDescriptionResp(rsp *http.Response) (*GetControllerDescriptionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetControllerDescriptionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ControllerDescription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseExecuteJoggingResp parses an HTTP response from a ExecuteJoggingWithResponse call
func ParseExecuteJoggingResp(rsp *http.Response) (*ExecuteJoggingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteJoggingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExecuteJoggingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseExecuteTrajectoryResp parses an HTTP response from a ExecuteTrajectoryWithResponse call
func ParseExecuteTrajectoryResp(rsp *http.Response) (*ExecuteTrajectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteTrajectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExecuteTrajectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamFreeDriveResp parses an HTTP response from a StreamFreeDriveWithResponse call
func ParseStreamFreeDriveResp(rsp *http.Response) (*StreamFreeDriveResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamFreeDriveResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotControllerState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListIODescriptionsResp parses an HTTP response from a ListIODescriptionsWithResponse call
func ParseListIODescriptionsResp(rsp *http.Response) (*ListIODescriptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIODescriptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIODescriptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamIOValuesResp parses an HTTP response from a StreamIOValuesWithResponse call
func ParseStreamIOValuesResp(rsp *http.Response) (*StreamIOValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamIOValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamIOValuesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListIOValuesResp parses an HTTP response from a ListIOValuesWithResponse call
func ParseListIOValuesResp(rsp *http.Response) (*ListIOValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIOValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIOValuesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetOutputValuesResp parses an HTTP response from a SetOutputValuesWithResponse call
func ParseSetOutputValuesResp(rsp *http.Response) (*SetOutputValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOutputValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseWaitForIOEventResp parses an HTTP response from a WaitForIOEventWithResponse call
func ParseWaitForIOEventResp(rsp *http.Response) (*WaitForIOEventResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WaitForIOEventResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetDefaultModeResp parses an HTTP response from a SetDefaultModeWithResponse call
func ParseSetDefaultModeResp(rsp *http.Response) (*SetDefaultModeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDefaultModeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMotionGroupDescriptionResp parses an HTTP response from a GetMotionGroupDescriptionWithResponse call
func ParseGetMotionGroupDescriptionResp(rsp *http.Response) (*GetMotionGroupDescriptionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupDescriptionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupDescription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCurrentMotionGroupStateResp parses an HTTP response from a GetCurrentMotionGroupStateWithResponse call
func ParseGetCurrentMotionGroupStateResp(rsp *http.Response) (*GetCurrentMotionGroupStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentMotionGroupStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamMotionGroupStateResp parses an HTTP response from a StreamMotionGroupStateWithResponse call
func ParseStreamMotionGroupStateResp(rsp *http.Response) (*StreamMotionGroupStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamMotionGroupStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCurrentRobotControllerStateResp parses an HTTP response from a GetCurrentRobotControllerStateWithResponse call
func ParseGetCurrentRobotControllerStateResp(rsp *http.Response) (*GetCurrentRobotControllerStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentRobotControllerStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotControllerState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamRobotControllerStateResp parses an HTTP response from a StreamRobotControllerStateWithResponse call
func ParseStreamRobotControllerStateResp(rsp *http.Response) (*StreamRobotControllerStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamRobotControllerStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotControllerState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseClearTrajectoriesResp parses an HTTP response from a ClearTrajectoriesWithResponse call
func ParseClearTrajectoriesResp(rsp *http.Response) (*ClearTrajectoriesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearTrajectoriesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListTrajectoriesResp parses an HTTP response from a ListTrajectoriesWithResponse call
func ParseListTrajectoriesResp(rsp *http.Response) (*ListTrajectoriesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTrajectoriesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTrajectoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAddTrajectoryResp parses an HTTP response from a AddTrajectoryWithResponse call
func ParseAddTrajectoryResp(rsp *http.Response) (*AddTrajectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTrajectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddTrajectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteTrajectoryResp parses an HTTP response from a DeleteTrajectoryWithResponse call
func ParseDeleteTrajectoryResp(rsp *http.Response) (*DeleteTrajectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTrajectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTrajectoryResp parses an HTTP response from a GetTrajectoryWithResponse call
func ParseGetTrajectoryResp(rsp *http.Response) (*GetTrajectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTrajectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTrajectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetVirtualControllerConfigurationResp parses an HTTP response from a GetVirtualControllerConfigurationWithResponse call
func ParseGetVirtualControllerConfigurationResp(rsp *http.Response) (*GetVirtualControllerConfigurationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualControllerConfigurationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VirtualRobotConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseForwardKinematicsResp parses an HTTP response from a ForwardKinematicsWithResponse call
func ParseForwardKinematicsResp(rsp *http.Response) (*ForwardKinematicsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ForwardKinematicsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ForwardKinematicsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ForwardKinematics422Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseInverseKinematicsResp parses an HTTP response from a InverseKinematicsWithResponse call
func ParseInverseKinematicsResp(rsp *http.Response) (*InverseKinematicsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InverseKinematicsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InverseKinematicsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest InverseKinematics422Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetMotionGroupModelsResp parses an HTTP response from a GetMotionGroupModelsWithResponse call
func ParseGetMotionGroupModelsResp(rsp *http.Response) (*GetMotionGroupModelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupModelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetMotionGroupCollisionModelResp parses an HTTP response from a GetMotionGroupCollisionModelWithResponse call
func ParseGetMotionGroupCollisionModelResp(rsp *http.Response) (*GetMotionGroupCollisionModelResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupCollisionModelResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkChain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetCellStatusResp parses an HTTP response from a GetCellStatusWithResponse call
func ParseGetCellStatusResp(rsp *http.Response) (*GetCellStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCellStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetCellStatusResp parses an HTTP response from a SetCellStatusWithResponse call
func ParseSetCellStatusResp(rsp *http.Response) (*SetCellStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCellStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListStoredCollidersResp parses an HTTP response from a ListStoredCollidersWithResponse call
func ParseListStoredCollidersResp(rsp *http.Response) (*ListStoredCollidersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStoredCollidersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ColliderDictionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStoredColliderResp parses an HTTP response from a DeleteStoredColliderWithResponse call
func ParseDeleteStoredColliderResp(rsp *http.Response) (*DeleteStoredColliderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoredColliderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStoredColliderResp parses an HTTP response from a GetStoredColliderWithResponse call
func ParseGetStoredColliderResp(rsp *http.Response) (*GetStoredColliderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoredColliderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreColliderResp parses an HTTP response from a StoreColliderWithResponse call
func ParseStoreColliderResp(rsp *http.Response) (*StoreColliderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreColliderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCollisionLinkChainsResp parses an HTTP response from a ListCollisionLinkChainsWithResponse call
func ParseListCollisionLinkChainsResp(rsp *http.Response) (*ListCollisionLinkChainsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCollisionLinkChainsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]LinkChain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStoredCollisionLinkChainResp parses an HTTP response from a DeleteStoredCollisionLinkChainWithResponse call
func ParseDeleteStoredCollisionLinkChainResp(rsp *http.Response) (*DeleteStoredCollisionLinkChainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoredCollisionLinkChainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStoredCollisionLinkChainResp parses an HTTP response from a GetStoredCollisionLinkChainWithResponse call
func ParseGetStoredCollisionLinkChainResp(rsp *http.Response) (*GetStoredCollisionLinkChainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoredCollisionLinkChainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkChain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreCollisionLinkChainResp parses an HTTP response from a StoreCollisionLinkChainWithResponse call
func ParseStoreCollisionLinkChainResp(rsp *http.Response) (*StoreCollisionLinkChainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreCollisionLinkChainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkChain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListStoredCollisionSetupsResp parses an HTTP response from a ListStoredCollisionSetupsWithResponse call
func ParseListStoredCollisionSetupsResp(rsp *http.Response) (*ListStoredCollisionSetupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStoredCollisionSetupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]CollisionSetup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStoredCollisionSetupResp parses an HTTP response from a DeleteStoredCollisionSetupWithResponse call
func ParseDeleteStoredCollisionSetupResp(rsp *http.Response) (*DeleteStoredCollisionSetupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoredCollisionSetupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStoredCollisionSetupResp parses an HTTP response from a GetStoredCollisionSetupWithResponse call
func ParseGetStoredCollisionSetupResp(rsp *http.Response) (*GetStoredCollisionSetupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoredCollisionSetupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollisionSetup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreCollisionSetupResp parses an HTTP response from a StoreCollisionSetupWithResponse call
func ParseStoreCollisionSetupResp(rsp *http.Response) (*StoreCollisionSetupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreCollisionSetupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollisionSetup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListStoredCollisionToolsResp parses an HTTP response from a ListStoredCollisionToolsWithResponse call
func ParseListStoredCollisionToolsResp(rsp *http.Response) (*ListStoredCollisionToolsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStoredCollisionToolsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]Tool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStoredCollisionToolResp parses an HTTP response from a DeleteStoredCollisionToolWithResponse call
func ParseDeleteStoredCollisionToolResp(rsp *http.Response) (*DeleteStoredCollisionToolResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoredCollisionToolResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStoredCollisionToolResp parses an HTTP response from a GetStoredCollisionToolWithResponse call
func ParseGetStoredCollisionToolResp(rsp *http.Response) (*GetStoredCollisionToolResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoredCollisionToolResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreCollisionToolResp parses an HTTP response from a StoreCollisionToolWithResponse call
func ParseStoreCollisionToolResp(rsp *http.Response) (*StoreCollisionToolResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreCollisionToolResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClearAllObjectsResp parses an HTTP response from a ClearAllObjectsWithResponse call
func ParseClearAllObjectsResp(rsp *http.Response) (*ClearAllObjectsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearAllObjectsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListAllObjectKeysResp parses an HTTP response from a ListAllObjectKeysWithResponse call
func ParseListAllObjectKeysResp(rsp *http.Response) (*ListAllObjectKeysResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllObjectKeysResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteObjectResp parses an HTTP response from a DeleteObjectWithResponse call
func ParseDeleteObjectResp(rsp *http.Response) (*DeleteObjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetObjectResp parses an HTTP response from a GetObjectWithResponse call
func ParseGetObjectResp(rsp *http.Response) (*GetObjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetObjectMetadataResp parses an HTTP response from a GetObjectMetadataWithResponse call
func ParseGetObjectMetadataResp(rsp *http.Response) (*GetObjectMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObjectMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStoreObjectResp parses an HTTP response from a StoreObjectWithResponse call
func ParseStoreObjectResp(rsp *http.Response) (*StoreObjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreObjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePlanCollisionFreeResp parses an HTTP response from a PlanCollisionFreeWithResponse call
func ParsePlanCollisionFreeResp(rsp *http.Response) (*PlanCollisionFreeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlanCollisionFreeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanCollisionFreeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Plan422Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePlanTrajectoryResp parses an HTTP response from a PlanTrajectoryWithResponse call
func ParsePlanTrajectoryResp(rsp *http.Response) (*PlanTrajectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlanTrajectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanTrajectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Plan422Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetVirtualControllerBehaviorResp parses an HTTP response from a GetVirtualControllerBehaviorWithResponse call
func ParseGetVirtualControllerBehaviorResp(rsp *http.Response) (*GetVirtualControllerBehaviorResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualControllerBehaviorResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Behavior
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetVirtualControllerBehaviorResp parses an HTTP response from a SetVirtualControllerBehaviorWithResponse call
func ParseSetVirtualControllerBehaviorResp(rsp *http.Response) (*SetVirtualControllerBehaviorResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetVirtualControllerBehaviorResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListVirtualControllerCoordinateSystemsResp parses an HTTP response from a ListVirtualControllerCoordinateSystemsWithResponse call
func ParseListVirtualControllerCoordinateSystemsResp(rsp *http.Response) (*ListVirtualControllerCoordinateSystemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVirtualControllerCoordinateSystemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCoordinateSystemsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteVirtualControllerCoordinateSystemResp parses an HTTP response from a DeleteVirtualControllerCoordinateSystemWithResponse call
func ParseDeleteVirtualControllerCoordinateSystemResp(rsp *http.Response) (*DeleteVirtualControllerCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualControllerCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddVirtualControllerCoordinateSystemResp parses an HTTP response from a AddVirtualControllerCoordinateSystemWithResponse call
func ParseAddVirtualControllerCoordinateSystemResp(rsp *http.Response) (*AddVirtualControllerCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddVirtualControllerCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCycleTimeResp parses an HTTP response from a GetCycleTimeWithResponse call
func ParseGetCycleTimeResp(rsp *http.Response) (*GetCycleTimeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCycleTimeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CycleTime
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEmergencyStopResp parses an HTTP response from a GetEmergencyStopWithResponse call
func ParseGetEmergencyStopResp(rsp *http.Response) (*GetEmergencyStopResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmergencyStopResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Flag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSetEmergencyStopResp parses an HTTP response from a SetEmergencyStopWithResponse call
func ParseSetEmergencyStopResp(rsp *http.Response) (*SetEmergencyStopResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetEmergencyStopResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseExternalJointsStreamResp parses an HTTP response from a ExternalJointsStreamWithResponse call
func ParseExternalJointsStreamResp(rsp *http.Response) (*ExternalJointsStreamResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExternalJointsStreamResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalJointStreamDatapoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListVirtualControllerIODescriptionsResp parses an HTTP response from a ListVirtualControllerIODescriptionsWithResponse call
func ParseListVirtualControllerIODescriptionsResp(rsp *http.Response) (*ListVirtualControllerIODescriptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVirtualControllerIODescriptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIODescriptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListIOsResp parses an HTTP response from a ListIOsWithResponse call
func ParseListIOsResp(rsp *http.Response) (*ListIOsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIOsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIOValuesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetIOValuesResp parses an HTTP response from a SetIOValuesWithResponse call
func ParseSetIOValuesResp(rsp *http.Response) (*SetIOValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIOValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON501 = &dest

	}

	return response, nil
}

// ParseGetMotionGroupsResp parses an HTTP response from a GetMotionGroupsWithResponse call
func ParseGetMotionGroupsResp(rsp *http.Response) (*GetMotionGroupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupInfos
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetVirtualControllerMountingResp parses an HTTP response from a GetVirtualControllerMountingWithResponse call
func ParseGetVirtualControllerMountingResp(rsp *http.Response) (*GetVirtualControllerMountingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualControllerMountingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetVirtualControllerMountingResp parses an HTTP response from a SetVirtualControllerMountingWithResponse call
func ParseSetVirtualControllerMountingResp(rsp *http.Response) (*SetVirtualControllerMountingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetVirtualControllerMountingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMotionGroupStateResp parses an HTTP response from a GetMotionGroupStateWithResponse call
func ParseGetMotionGroupStateResp(rsp *http.Response) (*GetMotionGroupStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupJoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetMotionGroupStateResp parses an HTTP response from a SetMotionGroupStateWithResponse call
func ParseSetMotionGroupStateResp(rsp *http.Response) (*SetMotionGroupStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMotionGroupStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListVirtualControllerTcpsResp parses an HTTP response from a ListVirtualControllerTcpsWithResponse call
func ParseListVirtualControllerTcpsResp(rsp *http.Response) (*ListVirtualControllerTcpsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVirtualControllerTcpsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotTcps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteVirtualControllerTcpResp parses an HTTP response from a DeleteVirtualControllerTcpWithResponse call
func ParseDeleteVirtualControllerTcpResp(rsp *http.Response) (*DeleteVirtualControllerTcpResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualControllerTcpResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddVirtualControllerTcpResp parses an HTTP response from a AddVirtualControllerTcpWithResponse call
func ParseAddVirtualControllerTcpResp(rsp *http.Response) (*AddVirtualControllerTcpResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddVirtualControllerTcpResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetOperationModeResp parses an HTTP response from a GetOperationModeWithResponse call
func ParseGetOperationModeResp(rsp *http.Response) (*GetOperationModeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOperationModeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OpMode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSetOperationModeResp parses an HTTP response from a SetOperationModeWithResponse call
func ParseSetOperationModeResp(rsp *http.Response) (*SetOperationModeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOperationModeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeactivateLicenseResp parses an HTTP response from a DeactivateLicenseWithResponse call
func ParseDeactivateLicenseResp(rsp *http.Response) (*DeactivateLicenseResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeactivateLicenseResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLicenseResp parses an HTTP response from a GetLicenseWithResponse call
func ParseGetLicenseResp(rsp *http.Response) (*GetLicenseResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActivateLicenseResp parses an HTTP response from a ActivateLicenseWithResponse call
func ParseActivateLicenseResp(rsp *http.Response) (*ActivateLicenseResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateLicenseResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLicenseStatusResp parses an HTTP response from a GetLicenseStatusWithResponse call
func ParseGetLicenseStatusResp(rsp *http.Response) (*GetLicenseStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LicenseStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest LicenseStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBackupConfigurationResp parses an HTTP response from a BackupConfigurationWithResponse call
func ParseBackupConfigurationResp(rsp *http.Response) (*BackupConfigurationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BackupConfigurationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRestoreConfigurationResp parses an HTTP response from a RestoreConfigurationWithResponse call
func ParseRestoreConfigurationResp(rsp *http.Response) (*RestoreConfigurationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestoreConfigurationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListConfigurationResourcesResp parses an HTTP response from a ListConfigurationResourcesWithResponse call
func ParseListConfigurationResourcesResp(rsp *http.Response) (*ListConfigurationResourcesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListConfigurationResourcesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigurationResourceArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConfigurationBackupStatusResp parses an HTTP response from a GetConfigurationBackupStatusWithResponse call
func ParseGetConfigurationBackupStatusResp(rsp *http.Response) (*GetConfigurationBackupStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationBackupStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigurationArchiveStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDiagnosePackageResp parses an HTTP response from a GetDiagnosePackageWithResponse call
func ParseGetDiagnosePackageResp(rsp *http.Response) (*GetDiagnosePackageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDiagnosePackageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSystemStatusResp parses an HTTP response from a GetSystemStatusWithResponse call
func ParseGetSystemStatusResp(rsp *http.Response) (*GetSystemStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckNovaVersionUpdateResp parses an HTTP response from a CheckNovaVersionUpdateWithResponse call
func ParseCheckNovaVersionUpdateResp(rsp *http.Response) (*CheckNovaVersionUpdateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckNovaVersionUpdateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateNovaVersionResp parses an HTTP response from a UpdateNovaVersionWithResponse call
func ParseUpdateNovaVersionResp(rsp *http.Response) (*UpdateNovaVersionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNovaVersionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSystemVersionResp parses an HTTP response from a GetSystemVersionWithResponse call
func ParseGetSystemVersionResp(rsp *http.Response) (*GetSystemVersionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemVersionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
