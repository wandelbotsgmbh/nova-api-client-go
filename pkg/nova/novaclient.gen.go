// Package nova provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package nova

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AbbControllerKind.
const (
	AbbControllerKindAbbController AbbControllerKind = "AbbController"
)

// Defines values for Behavior.
const (
	BEHAVIORAUTOMATIC                       Behavior = "BEHAVIOR_AUTOMATIC"
	BEHAVIORAUTOMATICNOTCOMPLYWITHCYCLETIME Behavior = "BEHAVIOR_AUTOMATIC_NOT_COMPLY_WITH_CYCLETIME"
	BEHAVIOREXTERNALSOURCE                  Behavior = "BEHAVIOR_EXTERNAL_SOURCE"
)

// Defines values for BoxType.
const (
	TYPEFULL   BoxType = "TYPE_FULL"
	TYPEHOLLOW BoxType = "TYPE_HOLLOW"
)

// Defines values for Box2BoxType.
const (
	Box2BoxTypeFULL   Box2BoxType = "FULL"
	Box2BoxTypeHOLLOW Box2BoxType = "HOLLOW"
)

// Defines values for Box3ShapeType.
const (
	Box3ShapeTypeBox Box3ShapeType = "box"
)

// Defines values for Box3Type.
const (
	Box3TypeFULL   Box3Type = "FULL"
	Box3TypeHOLLOW Box3Type = "HOLLOW"
)

// Defines values for Capsule3ShapeType.
const (
	Capsule3ShapeTypeCapsule Capsule3ShapeType = "capsule"
)

// Defines values for Comparator.
const (
	COMPARATOREQUALS       Comparator = "COMPARATOR_EQUALS"
	COMPARATORGREATER      Comparator = "COMPARATOR_GREATER"
	COMPARATORGREATEREQUAL Comparator = "COMPARATOR_GREATER_EQUAL"
	COMPARATORLESS         Comparator = "COMPARATOR_LESS"
	COMPARATORLESSEQUAL    Comparator = "COMPARATOR_LESS_EQUAL"
	COMPARATORNOTEQUALS    Comparator = "COMPARATOR_NOT_EQUALS"
	COMPARATORUNKNOWN      Comparator = "COMPARATOR_UNKNOWN"
)

// Defines values for ConvexHull3ShapeType.
const (
	ConvexHull3ShapeTypeConvexHull ConvexHull3ShapeType = "convex_hull"
)

// Defines values for Cylinder3ShapeType.
const (
	Cylinder3ShapeTypeCylinder Cylinder3ShapeType = "cylinder"
)

// Defines values for FanucControllerKind.
const (
	FanucControllerKindFanucController FanucControllerKind = "FanucController"
)

// Defines values for IODescriptionType.
const (
	IOTYPEINPUT  IODescriptionType = "IO_TYPE_INPUT"
	IOTYPEOUTPUT IODescriptionType = "IO_TYPE_OUTPUT"
)

// Defines values for IODescriptionUnit.
const (
	UNITAMPERE      IODescriptionUnit = "UNIT_AMPERE"
	UNITCELSIUS     IODescriptionUnit = "UNIT_CELSIUS"
	UNITHERTZ       IODescriptionUnit = "UNIT_HERTZ"
	UNITKELVIN      IODescriptionUnit = "UNIT_KELVIN"
	UNITKILOGRAM    IODescriptionUnit = "UNIT_KILOGRAM"
	UNITMETER       IODescriptionUnit = "UNIT_METER"
	UNITNEWTON      IODescriptionUnit = "UNIT_NEWTON"
	UNITNEWTONMETER IODescriptionUnit = "UNIT_NEWTON_METER"
	UNITNONE        IODescriptionUnit = "UNIT_NONE"
	UNITVOLT        IODescriptionUnit = "UNIT_VOLT"
)

// Defines values for IODescriptionValueType.
const (
	IOVALUEANALOGFLOATING IODescriptionValueType = "IO_VALUE_ANALOG_FLOATING"
	IOVALUEANALOGINTEGER  IODescriptionValueType = "IO_VALUE_ANALOG_INTEGER"
	IOVALUEDIGITAL        IODescriptionValueType = "IO_VALUE_DIGITAL"
)

// Defines values for InternalAbbControllerKind.
const (
	InternalAbbControllerKindInternalAbbController InternalAbbControllerKind = "InternalAbbController"
)

// Defines values for InternalFanucControllerKind.
const (
	InternalFanucControllerKindInternalFanucController InternalFanucControllerKind = "InternalFanucController"
)

// Defines values for InternalKukaControllerKind.
const (
	InternalKukaControllerKindInternalKukaController InternalKukaControllerKind = "InternalKukaController"
)

// Defines values for InternalVirtualControllerKind.
const (
	InternalVirtualControllerKindInternalVirtualController InternalVirtualControllerKind = "InternalVirtualController"
)

// Defines values for JoggingResponseMovementState.
const (
	MOVEMENTSTATEERROR             JoggingResponseMovementState = "MOVEMENT_STATE_ERROR"
	MOVEMENTSTATEJOINTLIMITREACHED JoggingResponseMovementState = "MOVEMENT_STATE_JOINT_LIMIT_REACHED"
	MOVEMENTSTATEMOVING            JoggingResponseMovementState = "MOVEMENT_STATE_MOVING"
	MOVEMENTSTATESTOPBYREQUEST     JoggingResponseMovementState = "MOVEMENT_STATE_STOP_BY_REQUEST"
	MOVEMENTSTATESTOPFORFORCELIMIT JoggingResponseMovementState = "MOVEMENT_STATE_STOP_FOR_FORCE_LIMIT"
	MOVEMENTSTATESTOPFORIO         JoggingResponseMovementState = "MOVEMENT_STATE_STOP_FOR_IO"
	MOVEMENTSTATEUNKNOWN           JoggingResponseMovementState = "MOVEMENT_STATE_UNKNOWN"
)

// Defines values for JointLimitJoint.
const (
	JointLimitJointJOINTNAMEAXIS1       JointLimitJoint = "JOINTNAME_AXIS_1"
	JointLimitJointJOINTNAMEAXIS10      JointLimitJoint = "JOINTNAME_AXIS_10"
	JointLimitJointJOINTNAMEAXIS11      JointLimitJoint = "JOINTNAME_AXIS_11"
	JointLimitJointJOINTNAMEAXIS12      JointLimitJoint = "JOINTNAME_AXIS_12"
	JointLimitJointJOINTNAMEAXIS2       JointLimitJoint = "JOINTNAME_AXIS_2"
	JointLimitJointJOINTNAMEAXIS3       JointLimitJoint = "JOINTNAME_AXIS_3"
	JointLimitJointJOINTNAMEAXIS4       JointLimitJoint = "JOINTNAME_AXIS_4"
	JointLimitJointJOINTNAMEAXIS5       JointLimitJoint = "JOINTNAME_AXIS_5"
	JointLimitJointJOINTNAMEAXIS6       JointLimitJoint = "JOINTNAME_AXIS_6"
	JointLimitJointJOINTNAMEAXIS7       JointLimitJoint = "JOINTNAME_AXIS_7"
	JointLimitJointJOINTNAMEAXIS8       JointLimitJoint = "JOINTNAME_AXIS_8"
	JointLimitJointJOINTNAMEAXIS9       JointLimitJoint = "JOINTNAME_AXIS_9"
	JointLimitJointJOINTNAMEAXISINVALID JointLimitJoint = "JOINTNAME_AXIS_INVALID"
)

// Defines values for KukaControllerKind.
const (
	KukaControllerKindKukaController KukaControllerKind = "KukaController"
)

// Defines values for Manufacturer.
const (
	Abb             Manufacturer = "abb"
	Fanuc           Manufacturer = "fanuc"
	Kuka            Manufacturer = "kuka"
	Universalrobots Manufacturer = "universalrobots"
	Yaskawa         Manufacturer = "yaskawa"
)

// Defines values for OpModeMode.
const (
	OpModeModeOPERATIONMODEAUTO   OpModeMode = "OPERATION_MODE_AUTO"
	OpModeModeOPERATIONMODEMANUAL OpModeMode = "OPERATION_MODE_MANUAL"
)

// Defines values for Plane3ShapeType.
const (
	Plane3ShapeTypePlane Plane3ShapeType = "plane"
)

// Defines values for Rectangle3ShapeType.
const (
	Rectangle3ShapeTypeRectangle Rectangle3ShapeType = "rectangle"
)

// Defines values for RectangularCapsule3ShapeType.
const (
	RectangularCapsule3ShapeTypeRectangularCapsule RectangularCapsule3ShapeType = "rectangular_capsule"
)

// Defines values for ReleaseChannel.
const (
	Next   ReleaseChannel = "next"
	Stable ReleaseChannel = "stable"
)

// Defines values for RobotControllerStateOperationMode.
const (
	RobotControllerStateOperationModeOPERATIONMODEAUTO         RobotControllerStateOperationMode = "OPERATION_MODE_AUTO"
	RobotControllerStateOperationModeOPERATIONMODEDISCONNECTED RobotControllerStateOperationMode = "OPERATION_MODE_DISCONNECTED"
	RobotControllerStateOperationModeOPERATIONMODEMANUAL       RobotControllerStateOperationMode = "OPERATION_MODE_MANUAL"
	RobotControllerStateOperationModeOPERATIONMODEMANUALT1     RobotControllerStateOperationMode = "OPERATION_MODE_MANUAL_T1"
	RobotControllerStateOperationModeOPERATIONMODEMANUALT2     RobotControllerStateOperationMode = "OPERATION_MODE_MANUAL_T2"
	RobotControllerStateOperationModeOPERATIONMODENOCONTROLLER RobotControllerStateOperationMode = "OPERATION_MODE_NO_CONTROLLER"
	RobotControllerStateOperationModeOPERATIONMODEPENDING      RobotControllerStateOperationMode = "OPERATION_MODE_PENDING"
	RobotControllerStateOperationModeOPERATIONMODEPOWERON      RobotControllerStateOperationMode = "OPERATION_MODE_POWER_ON"
	RobotControllerStateOperationModeOPERATIONMODERECOVERY     RobotControllerStateOperationMode = "OPERATION_MODE_RECOVERY"
	RobotControllerStateOperationModeOPERATIONMODEUNKNOWN      RobotControllerStateOperationMode = "OPERATION_MODE_UNKNOWN"
)

// Defines values for RobotControllerStateSafetyState.
const (
	SAFETYSTATECONFIRMSAFETY       RobotControllerStateSafetyState = "SAFETY_STATE_CONFIRM_SAFETY"
	SAFETYSTATEDEVICEEMERGENCYSTOP RobotControllerStateSafetyState = "SAFETY_STATE_DEVICE_EMERGENCY_STOP"
	SAFETYSTATEFAULT               RobotControllerStateSafetyState = "SAFETY_STATE_FAULT"
	SAFETYSTATEMASTERING           RobotControllerStateSafetyState = "SAFETY_STATE_MASTERING"
	SAFETYSTATENORMAL              RobotControllerStateSafetyState = "SAFETY_STATE_NORMAL"
	SAFETYSTATEOPERATORSAFETY      RobotControllerStateSafetyState = "SAFETY_STATE_OPERATOR_SAFETY"
	SAFETYSTATEPROTECTIVESTOP      RobotControllerStateSafetyState = "SAFETY_STATE_PROTECTIVE_STOP"
	SAFETYSTATERECOVERY            RobotControllerStateSafetyState = "SAFETY_STATE_RECOVERY"
	SAFETYSTATEREDUCED             RobotControllerStateSafetyState = "SAFETY_STATE_REDUCED"
	SAFETYSTATEROBOTEMERGENCYSTOP  RobotControllerStateSafetyState = "SAFETY_STATE_ROBOT_EMERGENCY_STOP"
	SAFETYSTATESTOP                RobotControllerStateSafetyState = "SAFETY_STATE_STOP"
	SAFETYSTATESTOP0               RobotControllerStateSafetyState = "SAFETY_STATE_STOP_0"
	SAFETYSTATESTOP1               RobotControllerStateSafetyState = "SAFETY_STATE_STOP_1"
	SAFETYSTATESTOP2               RobotControllerStateSafetyState = "SAFETY_STATE_STOP_2"
	SAFETYSTATEUNKNOWN             RobotControllerStateSafetyState = "SAFETY_STATE_UNKNOWN"
	SAFETYSTATEVIOLATION           RobotControllerStateSafetyState = "SAFETY_STATE_VIOLATION"
)

// Defines values for RobotSystemMode.
const (
	ROBOTSYSTEMMODECONTROL    RobotSystemMode = "ROBOT_SYSTEM_MODE_CONTROL"
	ROBOTSYSTEMMODEDISCONNECT RobotSystemMode = "ROBOT_SYSTEM_MODE_DISCONNECT"
	ROBOTSYSTEMMODEFREEDRIVE  RobotSystemMode = "ROBOT_SYSTEM_MODE_FREE_DRIVE"
	ROBOTSYSTEMMODEMONITOR    RobotSystemMode = "ROBOT_SYSTEM_MODE_MONITOR"
	ROBOTSYSTEMMODEUNDEFINED  RobotSystemMode = "ROBOT_SYSTEM_MODE_UNDEFINED"
)

// Defines values for RotationAngleTypes.
const (
	EULERANGLESEXTRINSICXYX RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_XYX"
	EULERANGLESEXTRINSICXYZ RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_XYZ"
	EULERANGLESEXTRINSICXZX RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_XZX"
	EULERANGLESEXTRINSICXZY RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_XZY"
	EULERANGLESEXTRINSICYXY RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_YXY"
	EULERANGLESEXTRINSICYXZ RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_YXZ"
	EULERANGLESEXTRINSICYZX RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_YZX"
	EULERANGLESEXTRINSICYZY RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_YZY"
	EULERANGLESEXTRINSICZXY RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_ZXY"
	EULERANGLESEXTRINSICZXZ RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_ZXZ"
	EULERANGLESEXTRINSICZYX RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_ZYX"
	EULERANGLESEXTRINSICZYZ RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_ZYZ"
	EULERANGLESINTRINSICXYX RotationAngleTypes = "EULER_ANGLES_INTRINSIC_XYX"
	EULERANGLESINTRINSICXYZ RotationAngleTypes = "EULER_ANGLES_INTRINSIC_XYZ"
	EULERANGLESINTRINSICXZX RotationAngleTypes = "EULER_ANGLES_INTRINSIC_XZX"
	EULERANGLESINTRINSICXZY RotationAngleTypes = "EULER_ANGLES_INTRINSIC_XZY"
	EULERANGLESINTRINSICYXY RotationAngleTypes = "EULER_ANGLES_INTRINSIC_YXY"
	EULERANGLESINTRINSICYXZ RotationAngleTypes = "EULER_ANGLES_INTRINSIC_YXZ"
	EULERANGLESINTRINSICYZX RotationAngleTypes = "EULER_ANGLES_INTRINSIC_YZX"
	EULERANGLESINTRINSICYZY RotationAngleTypes = "EULER_ANGLES_INTRINSIC_YZY"
	EULERANGLESINTRINSICZXY RotationAngleTypes = "EULER_ANGLES_INTRINSIC_ZXY"
	EULERANGLESINTRINSICZXZ RotationAngleTypes = "EULER_ANGLES_INTRINSIC_ZXZ"
	EULERANGLESINTRINSICZYX RotationAngleTypes = "EULER_ANGLES_INTRINSIC_ZYX"
	EULERANGLESINTRINSICZYZ RotationAngleTypes = "EULER_ANGLES_INTRINSIC_ZYZ"
	QUATERNION              RotationAngleTypes = "QUATERNION"
	ROTATIONVECTOR          RotationAngleTypes = "ROTATION_VECTOR"
)

// Defines values for SafetySetupSafetySettingsSafetyState.
const (
	SAFETYINVALID SafetySetupSafetySettingsSafetyState = "SAFETY_INVALID"
	SAFETYNORMAL  SafetySetupSafetySettingsSafetyState = "SAFETY_NORMAL"
	SAFETYREDUCED SafetySetupSafetySettingsSafetyState = "SAFETY_REDUCED"
)

// Defines values for ServiceStatusPhase.
const (
	ServiceStatusPhaseCompleted         ServiceStatusPhase = "Completed"
	ServiceStatusPhaseContainerCreating ServiceStatusPhase = "ContainerCreating"
	ServiceStatusPhaseCrashLoopBackOff  ServiceStatusPhase = "CrashLoopBackOff"
	ServiceStatusPhaseError             ServiceStatusPhase = "Error"
	ServiceStatusPhaseEvicted           ServiceStatusPhase = "Evicted"
	ServiceStatusPhaseImagePullBackOff  ServiceStatusPhase = "ImagePullBackOff"
	ServiceStatusPhaseInitialized       ServiceStatusPhase = "Initialized"
	ServiceStatusPhaseNoReady           ServiceStatusPhase = "NoReady"
	ServiceStatusPhaseOOMKilled         ServiceStatusPhase = "OOMKilled"
	ServiceStatusPhasePending           ServiceStatusPhase = "Pending"
	ServiceStatusPhasePodInitializing   ServiceStatusPhase = "PodInitializing"
	ServiceStatusPhaseRunning           ServiceStatusPhase = "Running"
	ServiceStatusPhaseTerminating       ServiceStatusPhase = "Terminating"
	ServiceStatusPhaseUnknown           ServiceStatusPhase = "Unknown"
)

// Defines values for ServiceStatusSeverity.
const (
	ERROR   ServiceStatusSeverity = "ERROR"
	INFO    ServiceStatusSeverity = "INFO"
	WARNING ServiceStatusSeverity = "WARNING"
)

// Defines values for SingleJointLimitJoint.
const (
	SingleJointLimitJointJOINTNAMEAXIS1       SingleJointLimitJoint = "JOINTNAME_AXIS_1"
	SingleJointLimitJointJOINTNAMEAXIS10      SingleJointLimitJoint = "JOINTNAME_AXIS_10"
	SingleJointLimitJointJOINTNAMEAXIS11      SingleJointLimitJoint = "JOINTNAME_AXIS_11"
	SingleJointLimitJointJOINTNAMEAXIS12      SingleJointLimitJoint = "JOINTNAME_AXIS_12"
	SingleJointLimitJointJOINTNAMEAXIS2       SingleJointLimitJoint = "JOINTNAME_AXIS_2"
	SingleJointLimitJointJOINTNAMEAXIS3       SingleJointLimitJoint = "JOINTNAME_AXIS_3"
	SingleJointLimitJointJOINTNAMEAXIS4       SingleJointLimitJoint = "JOINTNAME_AXIS_4"
	SingleJointLimitJointJOINTNAMEAXIS5       SingleJointLimitJoint = "JOINTNAME_AXIS_5"
	SingleJointLimitJointJOINTNAMEAXIS6       SingleJointLimitJoint = "JOINTNAME_AXIS_6"
	SingleJointLimitJointJOINTNAMEAXIS7       SingleJointLimitJoint = "JOINTNAME_AXIS_7"
	SingleJointLimitJointJOINTNAMEAXIS8       SingleJointLimitJoint = "JOINTNAME_AXIS_8"
	SingleJointLimitJointJOINTNAMEAXIS9       SingleJointLimitJoint = "JOINTNAME_AXIS_9"
	SingleJointLimitJointJOINTNAMEAXISINVALID SingleJointLimitJoint = "JOINTNAME_AXIS_INVALID"
)

// Defines values for SingularitySingularityType.
const (
	SINGULARITYTYPEELBOW    SingularitySingularityType = "SINGULARITY_TYPE_ELBOW"
	SINGULARITYTYPESHOULDER SingularitySingularityType = "SINGULARITY_TYPE_SHOULDER"
	SINGULARITYTYPEUNKNOWN  SingularitySingularityType = "SINGULARITY_TYPE_UNKNOWN"
	SINGULARITYTYPEWRIST    SingularitySingularityType = "SINGULARITY_TYPE_WRIST"
)

// Defines values for SingularityTypeEnum.
const (
	ELBOW    SingularityTypeEnum = "ELBOW"
	SHOULDER SingularityTypeEnum = "SHOULDER"
	WRIST    SingularityTypeEnum = "WRIST"
)

// Defines values for Sphere3ShapeType.
const (
	Sphere3ShapeTypeSphere Sphere3ShapeType = "sphere"
)

// Defines values for StopResponseStopCode.
const (
	STOPCODEERROR             StopResponseStopCode = "STOP_CODE_ERROR"
	STOPCODEFORCELIMIT        StopResponseStopCode = "STOP_CODE_FORCE_LIMIT"
	STOPCODEIO                StopResponseStopCode = "STOP_CODE_IO"
	STOPCODEJOINTLIMITREACHED StopResponseStopCode = "STOP_CODE_JOINT_LIMIT_REACHED"
	STOPCODEPATHEND           StopResponseStopCode = "STOP_CODE_PATH_END"
	STOPCODEUNKNOWN           StopResponseStopCode = "STOP_CODE_UNKNOWN"
	STOPCODEUSERREQUEST       StopResponseStopCode = "STOP_CODE_USER_REQUEST"
)

// Defines values for UniversalrobotsControllerKind.
const (
	UniversalrobotsControllerKindUniversalrobotsController UniversalrobotsControllerKind = "UniversalrobotsController"
)

// Defines values for VirtualControllerKind.
const (
	VirtualControllerKindVirtualController VirtualControllerKind = "VirtualController"
)

// Defines values for VirtualControllerTypes.
const (
	AbbIrb12007          VirtualControllerTypes = "abb-irb1200_7"
	AbbIrb130011510      VirtualControllerTypes = "abb-irb1300_115_10"
	FanucCrx10ia         VirtualControllerTypes = "fanuc-crx10ia"
	FanucCrx10ial        VirtualControllerTypes = "fanuc-crx10ial"
	FanucCrx20ial        VirtualControllerTypes = "fanuc-crx20ial"
	FanucCrx25ia         VirtualControllerTypes = "fanuc-crx25ia"
	FanucLrMate200iD     VirtualControllerTypes = "fanuc-lr_mate_200iD"
	FanucLrMate200iD4S   VirtualControllerTypes = "fanuc-lr_mate_200iD4S"
	FanucLrMate200iD7L   VirtualControllerTypes = "fanuc-lr_mate_200iD7L"
	FanucM10iD12         VirtualControllerTypes = "fanuc-m10iD12"
	FanucM20iD25         VirtualControllerTypes = "fanuc-m20iD25"
	FanucM20iD35         VirtualControllerTypes = "fanuc-m20iD35"
	KukaKr16R20102       VirtualControllerTypes = "kuka-kr16_r2010_2"
	KukaKr20R18102       VirtualControllerTypes = "kuka-kr20_r1810_2"
	KukaKr6R7002         VirtualControllerTypes = "kuka-kr6_r700_2"
	UniversalrobotsUr10e VirtualControllerTypes = "universalrobots-ur10e"
	UniversalrobotsUr16e VirtualControllerTypes = "universalrobots-ur16e"
	UniversalrobotsUr3e  VirtualControllerTypes = "universalrobots-ur3e"
	UniversalrobotsUr5cb VirtualControllerTypes = "universalrobots-ur5cb"
	UniversalrobotsUr5e  VirtualControllerTypes = "universalrobots-ur5e"
	YaskawaAr1440        VirtualControllerTypes = "yaskawa-ar1440"
	YaskawaAr2010        VirtualControllerTypes = "yaskawa-ar2010"
	YaskawaAr900         VirtualControllerTypes = "yaskawa-ar900"
	YaskawaGp50          VirtualControllerTypes = "yaskawa-gp50"
	YaskawaGp7           VirtualControllerTypes = "yaskawa-gp7"
)

// Defines values for YaskawaControllerKind.
const (
	YaskawaControllerKindYaskawaController YaskawaControllerKind = "YaskawaController"
)

// Defines values for PyripheryRoboticsRobotcellTimerConfigurationType.
const (
	SimulatedTimer PyripheryRoboticsRobotcellTimerConfigurationType = "simulated_timer"
	Timer          PyripheryRoboticsRobotcellTimerConfigurationType = "timer"
)

// Defines values for WaitForIOEventParamsComparisonType.
const (
	COMPARISONTYPEEQUAL   WaitForIOEventParamsComparisonType = "COMPARISON_TYPE_EQUAL"
	COMPARISONTYPEGREATER WaitForIOEventParamsComparisonType = "COMPARISON_TYPE_GREATER"
	COMPARISONTYPELESS    WaitForIOEventParamsComparisonType = "COMPARISON_TYPE_LESS"
)

// Defines values for SetDefaultModeParamsMode.
const (
	MODECONTROL SetDefaultModeParamsMode = "MODE_CONTROL"
	MODEMONITOR SetDefaultModeParamsMode = "MODE_MONITOR"
)

// Defines values for SetOperationModeParamsMode.
const (
	OPERATIONMODEAUTO   SetOperationModeParamsMode = "OPERATION_MODE_AUTO"
	OPERATIONMODEMANUAL SetOperationModeParamsMode = "OPERATION_MODE_MANUAL"
)

// AbbController The configuration of a physical ABB robot controller has to contain IP address.
// Additionally an EGM server configuration has to be specified in order to control the robot.
// Deploying the server is a functionality of this API.
type AbbController struct {
	ControllerIp string `json:"controllerIp"`

	// EgmServer The EGM server runs inside of the cell, thus its IP must be in the same network as the 'controllerIp'
	EgmServer struct {
		Ip   string `json:"ip"`
		Port int    `json:"port"`
	} `json:"egmServer"`
	Kind AbbControllerKind `json:"kind,omitempty"`
}

// AbbControllerKind defines model for AbbController.Kind.
type AbbControllerKind string

// AddRequest This message is used to add a coordinate system with a pose including a position offset in [mm] and a rotational offset in rotation vector notation.
type AddRequest struct {
	// Name Human readable name of this coordinate system, e.g. to simplify recognition.
	Name *string `json:"name,omitempty"`

	// Offset Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	Offset Pose `json:"offset"`
}

// AllJointPositionsRequest Request to calculate the joint positions of a motion group in order to move its TCP to a specific pose (Inverse Kinematic Solutions).
type AllJointPositionsRequest struct {
	// MotionGroup Identifier of the motion-group.
	MotionGroup string `json:"motion_group"`

	// TcpPose Representing a robot pose in operational space aware of a configured TCP.
	TcpPose TcpPose `json:"tcp_pose"`
}

// AllJointPositionsResponse A list of Joint Positions. If any of them is applied to the motion-group, its TCP will be at the specified pose.
type AllJointPositionsResponse struct {
	// JointPositions Joint position in [rad].
	JointPositions *[]Joints `json:"joint_positions,omitempty"`
}

// App An App is defined by a webserver, packed inside a container, serving a web-application.
type App struct {
	// AppIcon The path of the icon for the App (/<cell>/$name/$appIcon).
	AppIcon string `json:"appIcon"`

	// ContainerImage A user provided, custom container image and the required credentials to pull it from a registry.
	ContainerImage ContainerImage `json:"containerImage"`

	// Environment A list of environment variables with name and their value.
	// These can be used to configure the containerized application, and turn features on or off.
	Environment *ContainerEnvironment `json:"environment,omitempty"`

	// Name The name of the provided application.
	// The name must be unique within the cell and is used as a identifier for addressing the application in all API calls
	// , e.g. when updating the application.
	//
	// It also defines where the application is reachable (/<cell>/$name).
	Name string `json:"name"`

	// Port The port the containerized webserver is listening on.
	Port *int `json:"port,omitempty"`
}

// ArrayInput defines model for Array-Input.
type ArrayInput struct {
	Array []ArrayInput_Array_Item `json:"array"`
}

// ArrayInputArray0 defines model for .
type ArrayInputArray0 = float32

// ArrayInputArray1 defines model for .
type ArrayInputArray1 = int

// ArrayInputArray2 defines model for .
type ArrayInputArray2 = string

// ArrayInputArray3 defines model for .
type ArrayInputArray3 = openapi_types.File

// ArrayInput_Array_Item defines model for Array-Input.array.Item.
type ArrayInput_Array_Item struct {
	union json.RawMessage
}

// ArrayOutput defines model for Array-Output.
type ArrayOutput struct {
	Array []ArrayOutput_Array_Item `json:"array"`
}

// ArrayOutputArray0 defines model for .
type ArrayOutputArray0 = float32

// ArrayOutputArray1 defines model for .
type ArrayOutputArray1 = int

// ArrayOutputArray2 defines model for .
type ArrayOutputArray2 = string

// ArrayOutputArray3 defines model for .
type ArrayOutputArray3 = openapi_types.File

// ArrayOutput_Array_Item defines model for Array-Output.array.Item.
type ArrayOutput_Array_Item struct {
	union json.RawMessage
}

// Behavior ## BEHAVIOR_AUTOMATIC
// This is the default behavior.
// The motion group instantly takes any commanded joint configuration as actual joint state.
// Configures the compliance of the virtual robot with the normal ControllerState cycle time. If set, the virtual robot will act like a physical one, e.g. with a cycle time of 8ms to respond to a new joint state command.
// ## BEHAVIOR_AUTOMATIC_NOT_COMPLY_WITH_CYCLETIME
// Configures the compliance of the virtual robot with the normal ControllerState cycle time. If set, the robot will respond as fast as possible, limited only by software execution speed. Because of that the execution of a movement requires less time than with BEHAVIOR_AUTOMATIC.
// ## BEHAVIOR_EXTERNAL_SOURCE
// The external client is the only source of actual joint state changes.
// This mode is used to enable third party software indicating the current joint state via [externalJointsStream](externalJointsStream).
type Behavior string

// BinaryObject Any value encoded as a binary string.
type BinaryObject = openapi_types.File

// BlendingAuto defines model for BlendingAuto.
type BlendingAuto struct {
	BlendingName string `json:"blending_name"`

	// MinVelocityInPercent Auto-blending is used to keep a constant velocity when blending between two motion commands.
	// It changes the TCP path around the target point of the motion command.
	// The value represents the percentage of the original velocity.
	MinVelocityInPercent *uint32 `json:"min_velocity_in_percent,omitempty"`
}

// BlendingPosition defines model for BlendingPosition.
type BlendingPosition struct {
	BlendingName string `json:"blending_name"`

	// PositionZoneRadius Specifies the maximum radius in [mm] around the motion command's target point
	// where the TCP path can be altered to blend the motion command into the following one.
	// If auto-blending blends too much of the resulting trajectory, use position-blending to restrict the blending zone radius.
	PositionZoneRadius *float64 `json:"position_zone_radius,omitempty"`
}

// BodyUploadProgramMetadataImage defines model for Body_uploadProgramMetadataImage.
type BodyUploadProgramMetadataImage struct {
	File openapi_types.File `json:"file"`
}

// BodyUploadRecipeMetadataImage defines model for Body_uploadRecipeMetadataImage.
type BodyUploadRecipeMetadataImage struct {
	File openapi_types.File `json:"file"`
}

// Box Defines a cuboid shape centered around an origin.
type Box struct {
	// SizeX The dimension in x direction in [mm].
	SizeX float64 `json:"size_x"`

	// SizeY The dimension in y direction in [mm].
	SizeY float64 `json:"size_y"`

	// SizeZ The dimension in z direction in [mm].
	SizeZ float64 `json:"size_z"`

	// Type The type defines if the box is hollow or not.
	Type BoxType `json:"type"`
}

// BoxType The type defines if the box is hollow or not.
type BoxType string

// Box2 Defines a cuboid shape centred around an origin.
//
// If a margin is applied to the box type full, it is added to all size values. The shape will keep its edges.
// The hollow box type consists of thin boxes that make up its walls.
// If a margin is applied to the box type hollow, its size values are reduced by the margin.
type Box2 struct {
	// BoxType The box type defines if the box is hollow or full.
	BoxType   Box2BoxType `json:"box_type"`
	ShapeType string      `json:"shape_type"`

	// SizeX The dimension in x-direction in [mm].
	SizeX float64 `json:"size_x"`

	// SizeY The dimension in y-direction in [mm].
	SizeY float64 `json:"size_y"`

	// SizeZ The dimension in z-direction in [mm].
	SizeZ float64 `json:"size_z"`
}

// Box2BoxType The box type defines if the box is hollow or full.
type Box2BoxType string

// Box3 Centered around origin.
//
// If margin is applied to full box, it is added to all sizes (shape still has edges).
// Hollow box is represented by thin boxes that make up its walls.
// If margin is applied to hollow box, its sizes are reduced by the margin.
type Box3 struct {
	ShapeType Box3ShapeType `json:"shape_type"`
	SizeX     float32       `json:"size_x"`
	SizeY     float32       `json:"size_y"`
	SizeZ     float32       `json:"size_z"`
	Type      Box3Type      `json:"type"`
}

// Box3ShapeType defines model for Box3.ShapeType.
type Box3ShapeType string

// Box3Type defines model for Box3.Type.
type Box3Type string

// Capsule Defines a cylinder like shape with 2 semi-spheres on top and bottom.
type Capsule struct {
	// CylinderHeight The height of the inner cylinder in [mm].
	CylinderHeight float64 `json:"cylinder_height"`

	// Radius The radius of the cylinder and semi-spheres in [mm].
	Radius float64 `json:"radius"`
}

// Capsule2 Defines a cylindrical shape with 2 semi-spheres on the top and bottom.
// Centred around origin, symmetric around z-axis.
type Capsule2 struct {
	// CylinderHeight The height of the inner cylinder in [mm].
	CylinderHeight float64 `json:"cylinder_height"`

	// Radius The radius of the cylinder and semi-spheres in [mm].
	Radius    float64 `json:"radius"`
	ShapeType string  `json:"shape_type"`
}

// Capsule3 Centered around origin, symmetric around z-axis.
type Capsule3 struct {
	CylinderHeight float32           `json:"cylinder_height"`
	Radius         float32           `json:"radius"`
	ShapeType      Capsule3ShapeType `json:"shape_type"`
}

// Capsule3ShapeType defines model for Capsule3.ShapeType.
type Capsule3ShapeType string

// Capture defines model for Capture.
type Capture struct {
	Image string `json:"image"`
}

// CellName A unique name for the cell used as an identifier for addressing the cell in all API calls.
// It must be a valid k8s label name as defined by [RFC 1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-label-names).
type CellName = string

// Circle defines model for Circle.
type Circle struct {
	// TargetPose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	TargetPose Pose `json:"target_pose"`

	// ViaPose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	ViaPose Pose `json:"via_pose"`
}

// Collider Defines a collider with a single shape.
//
// A collider is an object that is used for collision detection.
// It defines the `shape` that is attached with the offset of `pose` to a reference frame.
//
// Use colliders to:
// - Define the shape of a workpiece. The reference frame is the scene origin.
// - Define the shape of a link in a motion group. The reference frame is the link coordinate system.
// - Define the shape of a tool. The reference frame is the flange coordinate system.
type Collider struct {
	// Margin Increases the shape's size in all dimensions. Applied in [mm]. Can be used to keep a safe distance to the shape.
	Margin *float32 `json:"margin,omitempty"`

	// Pose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	Pose  *Pose2         `json:"pose,omitempty"`
	Shape Collider_Shape `json:"shape"`
}

// Collider_Shape defines model for Collider.Shape.
type Collider_Shape struct {
	union json.RawMessage
}

// ColliderInput Defines a collider with a single shape.
//
// Pose describes where the shape of the collider is positioned.
type ColliderInput struct {
	// Margin Increases the shape's size in all dimensions. Applied in [mm]. Can be used to keep a safe distance to the shape.
	Margin *float32 `json:"margin,omitempty"`

	// Pose A pose (position and orientation)
	Pose  PyjectoryDatatypesCorePose `json:"pose"`
	Shape ColliderInput_Shape        `json:"shape"`
}

// ColliderInput_Shape defines model for ColliderInput.Shape.
type ColliderInput_Shape struct {
	union json.RawMessage
}

// ColliderDictionary A collection of identifiable colliders.
type ColliderDictionary map[string]Collider

// Collision defines model for Collision.
type Collision struct {
	IdOfA     *string `json:"id_of_a,omitempty"`
	IdOfB     *string `json:"id_of_b,omitempty"`
	IdOfWorld *string `json:"id_of_world,omitempty"`

	// NormalWorldOnB Describes a position in 3D space.
	// A three-dimensional vector [x, y, z] with double precision.
	NormalWorldOnB *Vector3d2        `json:"normal_world_on_b,omitempty"`
	PositionOnA    *CollisionContact `json:"position_on_a,omitempty"`
	PositionOnB    *CollisionContact `json:"position_on_b,omitempty"`
}

// CollisionContact defines model for CollisionContact.
type CollisionContact struct {
	// Local Describes a position in 3D space.
	// A three-dimensional vector [x, y, z] with double precision.
	Local *Vector3d2 `json:"local,omitempty"`

	// World Describes a position in 3D space.
	// A three-dimensional vector [x, y, z] with double precision.
	World *Vector3d2 `json:"world,omitempty"`
}

// CollisionMotionGroup defines model for CollisionMotionGroup.
type CollisionMotionGroup struct {
	// LinkChain A link chain is a kinematic chain of links that is connected via joints.
	// A motion group can be used to control the motion of the joints in a link chain.
	//
	// A link is a group of colliders that is attached to the link reference frame.
	//
	// The reference frame of a link is obtained after applying all sets of Denavit-Hartenberg-parameters from base to (including) the link index.
	//
	// This means that the reference frame of the link is on the rotation axis of the next joint in the kinematic chain.
	// Example: For a motion group with 2 joints, the collider reference frame (CRF) for link 1 is on the rotation axis of joint 2. The chain looks like:
	// - Origin >> Mounting >> Base >> (CRF Base) Joint 0 >> Link 0 >> (CRF Link 0) Joint 1 >> Link 1 >> (CRF Link 1) Flange (CRF Tool) >> TCP
	//
	// Adjacent links in the kinematic chain of the motion group are not checked for mutual collision.
	LinkChain *LinkChain `json:"link_chain,omitempty"`

	// Tool Defines the shape of a tool.
	//
	// A tool is a dictionary of colliders.
	//
	// All colliders that make up a tool are attached to the flange frame of the motion group.
	Tool *Tool `json:"tool,omitempty"`
}

// CollisionMotionGroupAssembly defines model for CollisionMotionGroupAssembly.
type CollisionMotionGroupAssembly struct {
	// LinkChain A link chain is a kinematic chain of links that is connected via joints.
	// A motion group can be used to control the motion of the joints in a link chain.
	//
	// A link is a group of colliders that is attached to the link reference frame.
	//
	// The reference frame of a link is obtained after applying all sets of Denavit-Hartenberg-parameters from base to (including) the link index.
	//
	// This means that the reference frame of the link is on the rotation axis of the next joint in the kinematic chain.
	// Example: For a motion group with 2 joints, the collider reference frame (CRF) for link 1 is on the rotation axis of joint 2. The chain looks like:
	// - Origin >> Mounting >> Base >> (CRF Base) Joint 0 >> Link 0 >> (CRF Link 0) Joint 1 >> Link 1 >> (CRF Link 1) Flange (CRF Tool) >> TCP
	//
	// Adjacent links in the kinematic chain of the motion group are not checked for mutual collision.
	LinkChain *LinkChain `json:"link_chain,omitempty"`

	// StoredLinkChain References a stored link chain.
	StoredLinkChain *string `json:"stored_link_chain,omitempty"`

	// StoredTool References a stored tool.
	StoredTool *string `json:"stored_tool,omitempty"`

	// Tool Defines the shape of a tool.
	//
	// A tool is a dictionary of colliders.
	//
	// All colliders that make up a tool are attached to the flange frame of the motion group.
	Tool *Tool `json:"tool,omitempty"`
}

// CollisionMotionGroupAssemblyDictionary Maps a Wandelbots Nova motion group to its assembly configuration in the collision scene. Key must be a motion group identifier.
//
// A collision motion group defines a motion group in the collision scene.
//
// The motion group is attached to the origin of the scene.
// To relocate the motion group, configure its mounting offset on the physical controller.
// This ensures that the definition of motion commands and collision scenes use the same coordinate system.
// The kinematic chain looks like this:
// - Origin >> Mounting >> Base >> Joint 0 >> Link 0 >> Joint 1 >> […] >> TCP
//
// A `tool` is treated like another link attached to the end (flange) of the kinematic chain.
// All tool colliders are described in the flange frame.
type CollisionMotionGroupAssemblyDictionary map[string]CollisionMotionGroupAssembly

// CollisionMotionGroupDictionary Maps a Wandelbots Nova motion group to its configuration in the collision scene. Key must be a motion group identifier.
//
// Values are collision motion group objects.
//
// A collision motion group defines a motion group in the collision scene.
//
// The motion group is attached to the origin of the scene.
// To relocate the motion group, configure its mounting offset on the physical controller.
// This ensures that the definition of motion commands and collision scenes use the same coordinate system.
// The kinematic chain looks like this:
// - Origin >> Mounting >> Base >> Joint 0 >> Link 0 >> Joint 1 >> […] >> TCP
//
// A `tool` is treated like another link attached to the end (flange) of the kinematic chain.
// All tool colliders are described in the flange frame.
type CollisionMotionGroupDictionary map[string]CollisionMotionGroup

// CollisionRobotConfigurationInput Configuration of a robot in the collision scene.
//
// Default link shapes are provided for all supported robots. Apply `use_default_link_shapes` with `true`.
//
// `link_attachements` are additional shapes that are attached to the link reference frames.
// The reference frame of the `link_attachements` is obtained after applying all sets of DH-parameters
// from base to (including) the specified index.
// Adjacent links in the kinematic chain of the robot are not checked for collision.
//
// The tool is treated like another link attached to the end (flange) of the chain.
// All tool shapes are described in the flange frame.
type CollisionRobotConfigurationInput struct {
	// LinkAttachements Shapes to attach to link reference frames, additionally to default shapes. The keys are integers representing
	// the link indices, and the values are objects mapping shape names to their collider definitions.
	LinkAttachements *map[string]map[string]ColliderInput `json:"link_attachements,omitempty"`

	// Tool Shapes that make up the tool, attached to the flange frame.
	Tool *map[string]ColliderInput `json:"tool,omitempty"`

	// UseDefaultLinkShapes If `true`, default shapes are used for all links.
	UseDefaultLinkShapes bool `json:"use_default_link_shapes"`
}

// CollisionScene Defines the collision scene.
//
// There are two types of objects in the scene:
//   - `colliders`: Each collider is attached directly to the origin of the scene: Origin >> Collider
//   - `motion-groups`: Each motion group is assigned a kinematic chain of links with a special collider, called tool, attached to the last element.
//     The motion group is attached to the origin of the scene via its mounting: Origin >> Mounting >> Motion Group Base >> […]
type CollisionScene struct {
	// Colliders A collection of identifiable colliders.
	Colliders *ColliderDictionary `json:"colliders,omitempty"`

	// MotionGroups Maps a Wandelbots Nova motion group to its configuration in the collision scene. Key must be a motion group identifier.
	//
	// Values are collision motion group objects.
	//
	// A collision motion group defines a motion group in the collision scene.
	//
	// The motion group is attached to the origin of the scene.
	// To relocate the motion group, configure its mounting offset on the physical controller.
	// This ensures that the definition of motion commands and collision scenes use the same coordinate system.
	// The kinematic chain looks like this:
	// - Origin >> Mounting >> Base >> Joint 0 >> Link 0 >> Joint 1 >> […] >> TCP
	//
	// A `tool` is treated like another link attached to the end (flange) of the kinematic chain.
	// All tool colliders are described in the flange frame.
	MotionGroups *CollisionMotionGroupDictionary `json:"motion_groups,omitempty"`
}

// CollisionSceneAssembly Defines the collision scene assembly. Merges all referenced and new scene components into a single scene.
//
// Previously added components with identical identifiers are overwritten within the same group.
//
// There is one group for each of the following components:
// - Colliders attached to the origin of the scene,
// - Tool per motion group, and
// - For each link per motion group.
//
// The scene is assembled by adding components in the following order.
// 1. stored_scenes
// 2. scene
// 3. stored_colliders
// 4. colliders
// 5. stored_link_chains and stored_tools (per motion group)
// 6. link_chains and tools (per motion group)
type CollisionSceneAssembly struct {
	// Colliders A collection of identifiable colliders.
	Colliders *ColliderDictionary `json:"colliders,omitempty"`

	// MotionGroups Maps a Wandelbots Nova motion group to its assembly configuration in the collision scene. Key must be a motion group identifier.
	//
	// A collision motion group defines a motion group in the collision scene.
	//
	// The motion group is attached to the origin of the scene.
	// To relocate the motion group, configure its mounting offset on the physical controller.
	// This ensures that the definition of motion commands and collision scenes use the same coordinate system.
	// The kinematic chain looks like this:
	// - Origin >> Mounting >> Base >> Joint 0 >> Link 0 >> Joint 1 >> […] >> TCP
	//
	// A `tool` is treated like another link attached to the end (flange) of the kinematic chain.
	// All tool colliders are described in the flange frame.
	MotionGroups *CollisionMotionGroupAssemblyDictionary `json:"motion_groups,omitempty"`

	// Scene Defines the collision scene.
	//
	// There are two types of objects in the scene:
	// - `colliders`: Each collider is attached directly to the origin of the scene: Origin >> Collider
	// - `motion-groups`: Each motion group is assigned a kinematic chain of links with a special collider, called tool, attached to the last element.
	//   The motion group is attached to the origin of the scene via its mounting: Origin >> Mounting >> Motion Group Base >> […]
	Scene *CollisionScene `json:"scene,omitempty"`

	// StoredColliders Add stored colliders to the scene via their identifiers.
	// The colliders are added to the the origin of the scene.
	StoredColliders *[]string `json:"stored_colliders,omitempty"`

	// StoredScenes Add stored scenes to the scene via their identifiers.
	// The scenes are merged based on their order in the array.
	// The scene at index zero serves as base.
	// Following scenes overwrite components with identical identifiers, see [Collision Scene Assembly](Collision Scene Assembly).
	StoredScenes *[]string `json:"stored_scenes,omitempty"`
}

// Command A command is a single motion command (line, circle, joint_ptp, cartesian_ptp, cubic_spline) with corresponding settings (limits, blending). The motion commands are a flattened union/oneof type. Only set one of the motion commands per command. A motion command always starts at the end of the previous motion command. Subsequently, a plan request must have start joint configuration to plan a well defined motion.
type Command struct {
	// CartesianPtp Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	CartesianPtp *Pose        `json:"cartesian_ptp,omitempty"`
	Circle       *Circle      `json:"circle,omitempty"`
	CubicSpline  *CubicSpline `json:"cubic_spline,omitempty"`

	// JointPtp This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointPtp *Joints `json:"joint_ptp,omitempty"`

	// Line Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	Line *Pose `json:"line,omitempty"`

	// Settings Settings which can be used to modify the behavior in a command-wise manner.
	Settings *CommandSettings `json:"settings,omitempty"`
}

// CommandSettings Settings which can be used to modify the behavior in a command-wise manner.
type CommandSettings struct {
	// AutoBlending Auto-blending is used to keep a constant velocity when blending between two motion commands.
	// It changes the TCP path around the target point of a motion command.
	// The value represents the percentage of the original velocity.
	//
	// What is blending?
	// Blending alters the geometry of the TCP path at the target point of a motion command
	// to ensure that the velocity does not drop to zero between two motion commands.
	AutoBlending *uint32 `json:"auto_blending,omitempty"`

	// LimitsOverride If a limit is not set, the default value will be used.
	LimitsOverride *LimitsOverride `json:"limits_override,omitempty"`

	// PositionBlending If auto-blending blends too much of the resulting trajectory, position-blending could be used between two motion commands.
	// Specifies the maximum radius in [mm] around the motion command's target point
	// where the geometry of the TCP path is allowed to be changed to blend the current motion command into the next one.
	PositionBlending *float64 `json:"position_blending,omitempty"`
}

// CommandsMissing Error in case no motion commands were provided. Every planning needs to have at least one motion command to describe the path to be followed.
type CommandsMissing = map[string]interface{}

// Comparator Comparator for the comparison of two values.
// The comparator is used to compare two values and return a boolean result.
// The default comparator is unknown.
type Comparator string

// Compound Describes a collision shape compounded from multiple collision objects. All objects are described in the compounds reference frame.
type Compound struct {
	// ChildGeometries A list of geometries sharing the same reference frame.
	ChildGeometries []Geometry `json:"child_geometries"`
}

// ContainerEnvironment A list of environment variables with name and their value.
// These can be used to configure the containerized application, and turn features on or off.
type ContainerEnvironment = []struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// ContainerImage A user provided, custom container image and the required credentials to pull it from a registry.
type ContainerImage struct {
	// Credentials User provided credentials for creating a secret to pull an image from a registry.
	Credentials *ImageCredentials `json:"credentials,omitempty"`

	// Image The location of a container image in the form of `<registry>/<image>:<tag>`.
	Image string `json:"image"`

	// Secrets Known secrets for authentication with the container registry.
	Secrets *[]struct {
		Name string `json:"name"`
	} `json:"secrets,omitempty"`
}

// ControllerCapabilities defines model for ControllerCapabilities.
type ControllerCapabilities struct {
	// SupportControl Can this controller be controlled with NOVA (true) or is it only possible to read data (false).
	SupportControl bool `json:"support_control"`

	// SupportFreedrive Can this controller be moved through freedrive (true), or not (false).
	SupportFreedrive bool `json:"support_freedrive"`
}

// ControllerInstance The data type to describe a robot controller.
type ControllerInstance struct {
	// AllowSoftwareInstallOnController True if the user has actively confirmed that it is allowed
	// to install required communication software onto the robot controller.
	//
	// NOTE: Installing third party software on a robot controller
	// can result in liability issues in regard to the actual certified
	// state of the robot system. Please contact your company's legal responsible before installing third party software.
	AllowSoftwareInstallOnController bool `json:"allow_software_install_on_controller"`

	// Controller The unique identifier to address the robot controller in the cell.
	Controller string `json:"controller"`

	// ErrorDetails If has_error is true, error_details provides detailed background information about the error.
	ErrorDetails *string `json:"error_details,omitempty"`

	// HasError Set to true if there was an error while inspecting this instance,
	// e.g. The robot controller is not reachable due to missing network connection or turned off.
	//
	// The instance remains configured but can't provide information on the robot controller.
	HasError bool `json:"has_error"`

	// Host Resolvable host name or IP address that connects to the robot controller.
	Host string `json:"host"`

	// ModelName The unique identifier to address a robot controller model when configuring the robot controller.
	// Used for evaluation of the robot controller model and to ensure communication with the expected robot controller type.
	ModelName string `json:"model_name"`

	// PhysicalMotionGroups The list of physical connected motion groups as detected by the controller.
	PhysicalMotionGroups []MotionGroupPhysical `json:"physical_motion_groups"`

	// VendorSoftwareVersion A generic representation of a version number.
	VendorSoftwareVersion *VersionNumber `json:"vendor_software_version,omitempty"`
}

// ControllerInstanceList The list of configured robot controllers.
type ControllerInstanceList struct {
	Instances []ControllerInstance `json:"instances"`
}

// ControllerRequest defines model for ControllerRequest.
type ControllerRequest struct {
	// AllowSoftwareInstallOnController Only set true if the user has actively confirmed that it is allowed
	// to install required communication software onto the robot controller.
	// It is expected that you ALWAYS request first without `software install`!
	//
	// Installing foreign software on a robot controller
	// might create legal issues - regarding to the actual certified
	// state of the robot system.
	AllowSoftwareInstallOnController *bool `json:"allow_software_install_on_controller,omitempty"`

	// ControllerCredentials Credentials that will be used when interacting with the robot controller for
	// installation of apps and programs.
	//
	// We know and use the common manufacturer defaults - so just set this up if your
	// controller has something different configured.
	ControllerCredentials *ControllerRequestLoginCredentials `json:"controller_credentials,omitempty"`

	// Host Resolvable host name or IP address that connects to the robot controller.
	Host string `json:"host"`

	// ModelName The requested robot controller model. Must be the correct controller_model
	// string, use [getDescription](getDescription) to consult the complete list.
	ModelName string `json:"model_name"`
}

// ControllerRequestLoginCredentials Credentials that will be used when interacting with the robot controller for
// installation of apps and programs.
//
// We know and use the common manufacturer defaults - so just set this up if your
// controller has something different configured.
type ControllerRequestLoginCredentials struct {
	// Password The password in plain text. NOTE: Prevent potential data leaks by limiting access to the password when Wandelbots Nova is used in open shop floor networks.
	Password string `json:"password"`
	Username string `json:"username"`
}

// ConvexHull Defines a convex hull encapsulating a set of vertices.
type ConvexHull struct {
	// Vertices The list of encapsulated points.
	Vertices []Vector3d `json:"vertices"`
}

// ConvexHull2 Defines a convex hull encapsulating a set of vertices.
type ConvexHull2 struct {
	ShapeType string `json:"shape_type"`

	// Vertices The list of encapsulated points.
	Vertices []Vector3d2 `json:"vertices"`
}

// ConvexHull3 Convex hull around all vertices.
type ConvexHull3 struct {
	ShapeType ConvexHull3ShapeType             `json:"shape_type"`
	Vertices  []PyjectoryDatatypesCorePosition `json:"vertices"`
}

// ConvexHull3ShapeType defines model for ConvexHull3.ShapeType.
type ConvexHull3ShapeType string

// CoordinateSystems defines model for CoordinateSystems.
type CoordinateSystems struct {
	CoordinateSystems []CoordinateSystem `json:"coordinate_systems"`
}

// CubicSpline defines model for CubicSpline.
type CubicSpline struct {
	Parameters []CubicSplineCubicSplineParameter `json:"parameters"`
}

// CubicSplineParameter defines model for CubicSplineParameter.
type CubicSplineParameter struct {
	PathParameter float64 `json:"path_parameter"`

	// Pose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	Pose Pose2 `json:"pose"`
}

// CubicSplineCubicSplineParameter defines model for CubicSpline_CubicSplineParameter.
type CubicSplineCubicSplineParameter struct {
	PathParameter float64 `json:"path_parameter"`

	// Pose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	Pose Pose `json:"pose"`
}

// CycleTime defines model for CycleTime.
type CycleTime struct {
	// CycleTimeMs Cycle time of controller communication in [ms].
	CycleTimeMs uint32 `json:"cycle_time_ms"`
}

// Cylinder Defines a cylindrical shape centered around the z-axis.
type Cylinder struct {
	// Height The height of the cylinder in [mm].
	Height float64 `json:"height"`

	// Radius The radius of the cylinder in [mm].
	Radius float64 `json:"radius"`
}

// Cylinder2 Defines a cylindrical shape.
// Centred around origin, symmetric around z-axis.
//
// If a margin is applied, it is added to radius and height. The shape will keep its edges.
type Cylinder2 struct {
	// Height The height of the cylinder in [mm].
	Height float64 `json:"height"`

	// Radius The radius of the cylinder in [mm].
	Radius    float64 `json:"radius"`
	ShapeType string  `json:"shape_type"`
}

// Cylinder3 Centered around origin, symmetric around z-axis.
//
// If margin is applied, it is added to radius and height (shape still has edges).
type Cylinder3 struct {
	Height    float32            `json:"height"`
	Radius    float32            `json:"radius"`
	ShapeType Cylinder3ShapeType `json:"shape_type"`
}

// Cylinder3ShapeType defines model for Cylinder3.ShapeType.
type Cylinder3ShapeType string

// DHParameter A single set of DH parameters.
type DHParameter struct {
	// A Offset along x-axis in [mm].
	A *float64 `json:"a,omitempty"`

	// Alpha Angle about x-axis in [rad].
	Alpha *float64 `json:"alpha,omitempty"`

	// D Offset along z-axis in [mm].
	D *float64 `json:"d,omitempty"`

	// ReverseRotationDirection True, if rotation direction of joint is reversed.
	ReverseRotationDirection *bool `json:"reverse_rotation_direction,omitempty"`

	// Theta Angle about z-axis in [rad].
	Theta *float64 `json:"theta,omitempty"`
}

// Description Describe the instance and the supported devices.
type Description struct {
	// Installation Name of the installation, eg. 'Demonstrator', 'Cell12', .....
	Installation *string `json:"installation,omitempty"`

	// SupportedControllers The list of supported robot controllers.
	SupportedControllers []string `json:"supported_controllers"`

	// SupportedMotionGroups The list of supported motion groups.
	SupportedMotionGroups []string `json:"supported_motion_groups"`

	// Uuid A unique (non persistent) identifier that identifies the service providing instance.
	Uuid string `json:"uuid"`

	// Version A generic representation of a version number.
	Version VersionNumber `json:"version"`
}

// DeveloperImage Override the default container image with a custom one.
type DeveloperImage struct {
	Repository *string `json:"repository,omitempty"`
	Tag        string  `json:"tag"`
}

// DirectionJoggingRequest A request to move a motion group in a cartesian direction.
type DirectionJoggingRequest struct {
	// CoordinateSystem Unique identifier addressing the base coordinate system of position_direction and rotation_direction.
	// If not set, world coordinate system is used.
	// Set coordinate_system to "tool" to select the current tool coordinate system as base.
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// PositionDirection A 3 dimensional Vector with double precision.
	PositionDirection Vector3d `json:"position_direction"`

	// PositionVelocity in (mm/s)
	PositionVelocity float64 `json:"position_velocity"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system in which the responses should be converted.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `json:"response_coordinate_system,omitempty"`

	// ResponseRate Update rate for the response message in ms. If not set 200ms are used.
	ResponseRate *uint32 `json:"response_rate,omitempty"`

	// RotationDirection A 3 dimensional Vector with double precision.
	RotationDirection Vector3d `json:"rotation_direction"`

	// RotationVelocity in (rad/s)
	RotationVelocity float64 `json:"rotation_velocity"`

	// Tcp The identifier of the tool center point (TCP) used for the jogging motion.
	// If not specified, the TCP currently active on the robot controller will be used.
	// The maximum cartesian velocity limit set at the TCP will not be exceeded during movement.
	Tcp *interface{} `json:"tcp,omitempty"`
}

// DoubleArray defines model for DoubleArray.
type DoubleArray = []float64

// Empty defines model for Empty.
type Empty = map[string]interface{}

// Error defines model for Error.
type Error struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

// ExternalJointStreamDatapoint A datapoint inside external joint stream.
type ExternalJointStreamDatapoint struct {
	// Id Unique identifier addressing a controller in the cell.
	Id uint32 `json:"id"`

	// Value The joint-values of the external joint stream datapoint.
	Value ExternalJointStreamDatapointValue `json:"value"`
}

// ExternalJointStreamDatapointValue The joint-values of the external joint stream datapoint.
type ExternalJointStreamDatapointValue struct {
	// Accelerations The joint accelerations of the robot.
	Accelerations []float64 `json:"accelerations"`

	// Positions The joint positions of the robot.
	Positions []float64 `json:"positions"`

	// Torques The joint torques of the robot.
	Torques []float64 `json:"torques"`

	// Velocities The joint velocities of the robot.
	Velocities []float64 `json:"velocities"`
}

// FanucController The configuration of a physical FANUC robot controller has to contain IP address of the controller.
type FanucController struct {
	ControllerIp string              `json:"controllerIp"`
	Kind         FanucControllerKind `json:"kind,omitempty"`
}

// FanucControllerKind defines model for FanucController.Kind.
type FanucControllerKind string

// FeedbackCollision defines model for FeedbackCollision.
type FeedbackCollision struct {
	Collisions        *[]Collision `json:"collisions,omitempty"`
	ErrorFeedbackName string       `json:"error_feedback_name"`
	JointPosition     *DoubleArray `json:"joint_position,omitempty"`

	// TcpPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TcpPose *Pose2 `json:"tcp_pose,omitempty"`
}

// FeedbackJointLimitExceeded This error is returned when a joint position limit is exceeded.
// The joint index denotes which joint is out of its limits, starting with 1 and followed by the full joint position.
type FeedbackJointLimitExceeded struct {
	ErrorFeedbackName string       `json:"error_feedback_name"`
	JointIndex        *uint32      `json:"joint_index,omitempty"`
	JointPosition     *DoubleArray `json:"joint_position,omitempty"`
}

// FeedbackOutOfWorkspace Requested TCP pose is outside of motion group's workspace.
type FeedbackOutOfWorkspace struct {
	ErrorFeedbackName string `json:"error_feedback_name"`

	// InvalidTcpPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	InvalidTcpPose *Pose2 `json:"invalid_tcp_pose,omitempty"`
}

// FeedbackSingularity A singularity is a point in the robot's workspace where the robot loses one or more degrees of freedom with regards to moving its TCP.
// This means the robot cannot move or rotate the TCP in a certain direction from this specific point.
//
// Use PTP motions if possible. They will almost never fail due to singularities (only if the target point is at a singularity).
//
// Alternatively change the robot TCP's path to avoid moving through this point or try to move the TCP through this point in a different direction.
type FeedbackSingularity struct {
	ErrorFeedbackName     string               `json:"error_feedback_name"`
	SingularJointPosition *DoubleArray         `json:"singular_joint_position,omitempty"`
	SingularityType       *SingularityTypeEnum `json:"singularity_type,omitempty"`
}

// Flag defines model for Flag.
type Flag struct {
	Active bool `json:"active"`
}

// ForceVector Representing a force on a specific point in operational space (e.g. on robot flange).
type ForceVector struct {
	// CoordinateSystem optional, unique name of base coordinate system, if empty world is used
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// Force A 3 dimensional Vector with double precision.
	Force *Vector3d `json:"force,omitempty"`

	// Moment A 3 dimensional Vector with double precision.
	Moment *Vector3d `json:"moment,omitempty"`
}

// FoundationServiceApiGateway The configuration overwrite for the API gateway
type FoundationServiceApiGateway struct {
	// ImageOverwrite Override the default container image with a custom one.
	ImageOverwrite *DeveloperImage `json:"imageOverwrite,omitempty"`
}

// FoundationServiceRae The configuration overwrite for the RAE.
type FoundationServiceRae struct {
	// ImageOverwrite Override the default container image with a custom one.
	ImageOverwrite *DeveloperImage `json:"imageOverwrite,omitempty"`
	RealtimePort   *int            `json:"realtimePort,omitempty"`
}

// FoundationServiceRobotPad The configuration overwrite for the RobotPad App.
type FoundationServiceRobotPad struct {
	// ImageOverwrite Override the default container image with a custom one.
	ImageOverwrite *DeveloperImage `json:"imageOverwrite,omitempty"`
}

// FoundationServiceStorage The configuration overwrite for the storage service.
type FoundationServiceStorage struct {
	// Capacity The amount of local storage available for the service.
	//
	// **NOTE:** The capacity cannot be reduced!!
	Capacity *string `json:"capacity,omitempty"`

	// ImageOverwrite Override the default container image with a custom one.
	ImageOverwrite *DeveloperImage `json:"imageOverwrite,omitempty"`
}

// FoundationServiceWandelengine The configuration overwrite for the Wandelengine.
type FoundationServiceWandelengine struct {
	// EnableLanguageServer Enable the Wandelscript language server shipped with the Wandelengine
	EnableLanguageServer *bool `json:"enableLanguageServer,omitempty"`

	// ImageOverwrite Override the default container image with a custom one.
	ImageOverwrite *DeveloperImage `json:"imageOverwrite,omitempty"`
}

// FoundationServices The configuration overwrite for all foundation services.
type FoundationServices struct {
	// ApiGateway The configuration overwrite for the API gateway
	ApiGateway *FoundationServiceApiGateway `json:"api-gateway,omitempty"`

	// Rae The configuration overwrite for the RAE.
	Rae *FoundationServiceRae `json:"rae,omitempty"`

	// RobotPad The configuration overwrite for the RobotPad App.
	RobotPad *FoundationServiceRobotPad `json:"robot-pad,omitempty"`

	// Storage The configuration overwrite for the storage service.
	Storage *FoundationServiceStorage `json:"storage,omitempty"`

	// Wandelengine The configuration overwrite for the Wandelengine.
	Wandelengine *FoundationServiceWandelengine `json:"wandelengine,omitempty"`
}

// Geometry A Geometry is defined by a shape and a pose.
type Geometry struct {
	// Box Defines a cuboid shape centered around an origin.
	Box *Box `json:"box,omitempty"`

	// Capsule Defines a cylinder like shape with 2 semi-spheres on top and bottom.
	Capsule *Capsule `json:"capsule,omitempty"`

	// Compound Describes a collision shape compounded from multiple collision objects. All objects are described in the compounds reference frame.
	Compound *Compound `json:"compound,omitempty"`

	// ConvexHull Defines a convex hull encapsulating a set of vertices.
	ConvexHull *ConvexHull `json:"convex_hull,omitempty"`

	// Cylinder Defines a cylindrical shape centered around the z-axis.
	Cylinder *Cylinder `json:"cylinder,omitempty"`

	// Id An identifier may be used to refer to this geometry, e.g. when giving feedback.
	Id       *string     `json:"id,omitempty"`
	InitPose PlannerPose `json:"init_pose"`

	// Plane Defines an x-y plane with infinite size.
	Plane *Plane `json:"plane,omitempty"`

	// Rectangle Defines an x-y plane with finite size.
	Rectangle *Rectangle `json:"rectangle,omitempty"`

	// RectangularCapsule A convex hull around four spheres. Sphere center points in x-y-plane, offset by either combination +-sizeX/+-sizeY. Alternative description: Rectangle in x-y-plane with a 3D padding.
	RectangularCapsule *RectangularCapsule `json:"rectangular_capsule,omitempty"`

	// Sphere Defines a spherical shape centered around an origin.
	Sphere *Sphere `json:"sphere,omitempty"`
}

// GetModeResponse defines model for GetModeResponse.
type GetModeResponse struct {
	// RobotSystemMode The system mode of the robot system.
	//
	// ### ROBOT_SYSTEM_MODE_UNDEFINED
	//
	// Indicates that the robot controller is currently performing a mode transition.
	//
	// ### ROBOT_SYSTEM_MODE_DISCONNECT
	//
	// There is no communication with the robot controller at all. All connections are closed.
	// No command is sent to the robot controller while in this mode. No IO interaction is possible in this mode!
	// All move requests will be rejected in this mode!
	//
	// ### ROBOT_SYSTEM_MODE_MONITOR
	//
	// A connection to the robot controller is established to only read the robot controller state.
	// No command is sent to the robot controller while in this mode. It is possible to receive IO information.
	// All move requests will be rejected in this mode!
	//
	// ### ROBOT_SYSTEM_MODE_CONTROL
	//
	// An active connection is established with the robot controller and the robot system is cyclic commanded
	// to stay in its actual position. The robot controller state is received in the cycle time of the robot controller.
	// Requests via the MotionService and JoggingService will be processed and executed in this mode.
	// IO interaction is possible in this mode! **In this mode the robot system can be commanded to move.**
	//
	// ### ROBOT_SYSTEM_MODE_FREE_DRIVE
	//
	// Like ROBOT_SYSTEM_MODE_MONITOR a connection to the robot controller is established to only read the robot controller state.
	// The difference is that the motion groups can be moved by the user (Free Drive). Thus, the servo motors are turned on.
	// All move requests will be rejected in this mode! **This mode is not supported by every robot!**
	// Use [getSupportedModes](getSupportedModes) to evaluate if the device support free drive.
	RobotSystemMode RobotSystemMode `json:"robot_system_mode"`
}

// GetTrajectoryResponse defines model for GetTrajectoryResponse.
type GetTrajectoryResponse struct {
	// Trajectory A list of points representing the trajectory of a planned motion with defined `sample_time` in milliseconds (ms).
	Trajectory *[]TrajectorySample `json:"trajectory,omitempty"`
}

// GetTrajectorySampleResponse defines model for GetTrajectorySampleResponse.
type GetTrajectorySampleResponse struct {
	// Sample A sample of a trajectory is a single point of the trajectory at a specific location.
	Sample *TrajectorySample `json:"sample,omitempty"`
}

// GoogleProtobufAny Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.
type GoogleProtobufAny struct {
	// Type The type of the serialized message.
	Type                 *string                `json:"@type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// HTTPExceptionResponse defines model for HTTPExceptionResponse.
type HTTPExceptionResponse struct {
	// Detail A message describing the error.
	Detail string `json:"detail"`
}

// HTTPValidationError defines model for HTTPValidationError.
type HTTPValidationError struct {
	Detail *[]ValidationError `json:"detail,omitempty"`
}

// IODescription defines model for IODescription.
type IODescription struct {
	// BitSize OBSOLETE! Replaced by min/max. Amount of bits the value is encoded in.
	BitSize uint32 `json:"bit_size"`

	// Group Name of the I/O group. Customize it on the physical controller or in the virtual robot specification.
	Group *string `json:"group,omitempty"`

	// Id Unique identifier defined by the controller. Identifiers are only defined uniquely per controller, e.g. I/Os for two different robots on the same controller can have the same identifier.
	Id string `json:"id"`

	// Max I/O value representation. Depending on the I/O type, only one of the value fields will be set.
	Max *IOValue `json:"max,omitempty"`

	// Min I/O value representation. Depending on the I/O type, only one of the value fields will be set.
	Min *IOValue `json:"min,omitempty"`

	// Name Name of the I/O. Customize it on the physical controller or in the virtual robot specification.
	Name string `json:"name"`

	// Type Identifies the I/O type. Possible responses "input" or "output".
	Type IODescriptionType `json:"type"`

	// Unit The unit of I/O value.
	Unit *IODescriptionUnit `json:"unit,omitempty"`

	// ValueType Data type of the I/O.
	ValueType IODescriptionValueType `json:"value_type"`
}

// IODescriptionType Identifies the I/O type. Possible responses "input" or "output".
type IODescriptionType string

// IODescriptionUnit The unit of I/O value.
type IODescriptionUnit string

// IODescriptionValueType Data type of the I/O.
type IODescriptionValueType string

// IOValue I/O value representation. Depending on the I/O type, only one of the value fields will be set.
type IOValue struct {
	// BooleanValue Value of a digital I/O.
	// This field is only set if the I/O is of type IO_VALUE_DIGITAL.
	BooleanValue *bool `json:"boolean_value,omitempty"`

	// FloatingValue Value of an analog I/O with floating number representation.
	// This field is only set if the I/O is of type IO_VALUE_ANALOG_FLOATING.
	FloatingValue *float64 `json:"floating_value,omitempty"`

	// IntegerValue Value of an analog I/O with integer representation.
	// This field is only set if the I/O is of type IO_VALUE_ANALOG_INTEGER.
	//
	// > The integral value is transmitted as a string to avoid precision loss in conversion to JSON.
	// > We recommend to use int64 for implementation. If you want to interact with int64 in numbers,
	// > there are some JS bigint libraries availible to parse the string into an integral value.
	IntegerValue *string `json:"integer_value,omitempty"`

	// Io Unique identifier of the I/O.
	Io string `json:"io"`
}

// IOs defines model for IOs.
type IOs struct {
	IOs []IO `json:"IOs"`
}

// ImageCredentials User provided credentials for creating a secret to pull an image from a registry.
type ImageCredentials struct {
	Password string `json:"password"`
	Registry string `json:"registry"`
	User     string `json:"user"`
}

// InfoServiceCapabilities defines model for InfoServiceCapabilities.
type InfoServiceCapabilities struct {
	// GetActivePayload Is this motion group able to provide the currently active payload.
	GetActivePayload bool `json:"get_active_payload"`

	// GetActiveTcp Is this motion group able to provide the currently active TCP.
	GetActiveTcp bool `json:"get_active_tcp"`

	// GetMotionGroupSpecification Is this motion group able to provide a motion group specification.
	GetMotionGroupSpecification bool `json:"get_motion_group_specification"`

	// GetMounting Is this motion group able to provide the mounting information.
	GetMounting bool `json:"get_mounting"`

	// GetSafetySetup Is this motion group able to get the safety setup.
	GetSafetySetup bool `json:"get_safety_setup"`

	// ListPayloads Is this motion group able to provide a list of all available payloads.
	ListPayloads bool `json:"list_payloads"`

	// ListTcps Is this motion group able to provide a list of all available TCPs.
	ListTcps bool `json:"list_tcps"`
}

// InternalAbbController The configuration of a physical ABB robot controller has to contain IP address.
// Additionally an EGM server configuration has to be specified in order to control the robot.
// Deploying the server is a functionality of this API.
type InternalAbbController struct {
	ControllerIp string `json:"controllerIp"`

	// EgmServer The EGM server runs inside of the cell, thus its IP must be in the same network as the 'controllerIp'
	EgmServer struct {
		Ip   string `json:"ip"`
		Port int    `json:"port"`
	} `json:"egmServer"`

	// ImageOverwrite Override the default container image with a custom one.
	ImageOverwrite *DeveloperImage           `json:"imageOverwrite,omitempty"`
	Kind           InternalAbbControllerKind `json:"kind,omitempty"`
}

// InternalAbbControllerKind defines model for InternalAbbController.Kind.
type InternalAbbControllerKind string

// InternalCell To create a robot cell, only a valid name is required.
// Once created, a robot cell provides access to the Wandelbots Nova foundation services.
// The configuration can be customized, e.g. robot controllers, also within apps.
type InternalCell struct {
	Apps        *[]App                     `json:"apps,omitempty"`
	Controllers *[]InternalRobotController `json:"controllers,omitempty"`

	// FoundationServices The configuration overwrite for all foundation services.
	FoundationServices *FoundationServices `json:"foundation-services,omitempty"`

	// Name A unique name for the cell used as an identifier for addressing the cell in all API calls.
	// It must be a valid k8s label name as defined by [RFC 1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-label-names).
	Name CellName `json:"name"`
}

// InternalFanucController The configuration of a physical FANUC robot controller has to contain IP address of the controller.
type InternalFanucController struct {
	ControllerIp string `json:"controllerIp"`

	// ImageOverwrite Override the default container image with a custom one.
	ImageOverwrite *DeveloperImage             `json:"imageOverwrite,omitempty"`
	Kind           InternalFanucControllerKind `json:"kind,omitempty"`
}

// InternalFanucControllerKind defines model for InternalFanucController.Kind.
type InternalFanucControllerKind string

// InternalKukaController The configuration of a physical KUKA robot controller has to contain an IP address.
// Additionally an RSI server configuration has to be specified in order to control the robot.
// Deploying the server is a functionality of this API.
type InternalKukaController struct {
	ControllerIp   string `json:"controllerIp"`
	ControllerPort int    `json:"controllerPort"`

	// ImageOverwrite Override the default container image with a custom one.
	ImageOverwrite *DeveloperImage            `json:"imageOverwrite,omitempty"`
	Kind           InternalKukaControllerKind `json:"kind,omitempty"`

	// RsiServer The RSI server runs inside of the cell.
	RsiServer struct {
		Ip   string `json:"ip"`
		Port int    `json:"port"`
	} `json:"rsiServer"`
}

// InternalKukaControllerKind defines model for InternalKukaController.Kind.
type InternalKukaControllerKind string

// InternalRobotController The configuration of a physical or virtual robot controller.
type InternalRobotController struct {
	Configuration InternalControllerConfig `json:"configuration"`

	// Name A unique name of the Controller inside the Cell.
	Name string `json:"name"`
}

// InternalControllerConfig defines model for .
type InternalControllerConfig struct {
	union json.RawMessage
}

// InternalVirtualController The configuration of a virtual robot controller has to contain the manufacturer string,
// an optional joint position string array and either a type or the full JSON configuration.
// The JSON config of a physical controller can be obtained via `/cells/{cell}/controllers/{controller}/virtual-robot-configuration`
type InternalVirtualController struct {
	// ImageOverwrite Override the default container image with a custom one.
	ImageOverwrite *DeveloperImage               `json:"imageOverwrite,omitempty"`
	Json           *string                       `json:"json,omitempty"`
	Kind           InternalVirtualControllerKind `json:"kind,omitempty"`
	Manufacturer   Manufacturer                  `json:"manufacturer"`
	Position       *string                       `json:"position,omitempty"`
	Type           *VirtualControllerTypes       `json:"type,omitempty"`
}

// InternalVirtualControllerKind defines model for InternalVirtualController.Kind.
type InternalVirtualControllerKind string

// JoggingResponse A response for a Jogging Request, is streamed during an active Jogging Movement.
type JoggingResponse struct {
	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// MovementState State of the current movement, e.g. ongoing or stopped due to a particular reason.
	MovementState *JoggingResponseMovementState `json:"movement_state,omitempty"`

	// State Returns the whole current state of robot controller.
	State *RobotControllerState `json:"state,omitempty"`
}

// JoggingResponseMovementState State of the current movement, e.g. ongoing or stopped due to a particular reason.
type JoggingResponseMovementState string

// JoggingServiceCapabilities defines model for JoggingServiceCapabilities.
type JoggingServiceCapabilities struct {
	// CartesianJogging Can this motion group be moved via cartesian jogging.
	CartesianJogging bool `json:"cartesian_jogging"`

	// JointJogging Can this motion group be moved via joint jogging.
	JointJogging bool `json:"joint_jogging"`
}

// JointJoggingRequest A request to move the joints of a motion group.
type JointJoggingRequest struct {
	// JointVelocities in [rad/s]
	JointVelocities []float64 `json:"joint_velocities"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system in which the responses should be converted.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `json:"response_coordinate_system,omitempty"`

	// ResponseRate Update rate for the response message in ms. If not set 200ms are used.
	ResponseRate *uint32 `json:"response_rate,omitempty"`

	// Tcp The identifier of the tool center point (TCP) to be used for the jogging motion.
	// If not specified, the TCP currently active on the robot controller will be used.
	// At this TCP, it will be assured, that the allowed cartesian velocity limits are not exceeded.
	Tcp *interface{} `json:"tcp,omitempty"`
}

// JointLimit A joint limit can contain a position (rad or mm), a velocity (rad/s or mm/s),
// an acceleration (rad/s² or mm/s²) or a jerk (rad/s³ or mm/s³).
type JointLimit struct {
	// Joint Definition of the joint where the limits are applied.
	Joint JointLimitJoint `json:"joint"`

	// LowerLimit Lower joint limit which is smaller than the upper joint limit.
	LowerLimit float64 `json:"lower_limit"`

	// Unlimited True, if joint limit is unlimited. Lower and upper limits are ignored.
	Unlimited *bool `json:"unlimited,omitempty"`

	// UpperLimit Upper joint boundary which is bigger than the lower joint limit.
	UpperLimit float64 `json:"upper_limit"`
}

// JointLimitJoint Definition of the joint where the limits are applied.
type JointLimitJoint string

// JointLimitExceeded This error is returned when a joint position limit is exceeded.
// The joint index denotes which joint is out of its limits, starting with 1 and the full joint position is returned.
type JointLimitExceeded struct {
	JointIndex *uint32 `json:"joint_index,omitempty"`

	// JointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointPosition *Joints `json:"joint_position,omitempty"`
}

// JointPositionRequest Request to find the joint positions the motion-group needs to apply for its TCP to be in a specified pose (Inverse Kinematic Solution).
type JointPositionRequest struct {
	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// ReferenceJointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	ReferenceJointPosition Joints `json:"reference_joint_position"`

	// TcpPose Representing a robot pose in operational space aware of a configured TCP.
	TcpPose TcpPose `json:"tcp_pose"`
}

// JointTrajectory defines model for JointTrajectory.
type JointTrajectory struct {
	// JointPositions List of joint positions [rad] for each sample.
	// The number of samples must match the number of timestamps provided in the times field.
	JointPositions []Joints `json:"joint_positions"`

	// Locations Location for each sample, scalar value defining a position along a path. Typical range: 0 to `n`, `n` denoting the number of motion commands.
	// Each integer value of the location corresponds to a specific motion command.
	// If provided, the number of samples must match the number of timestamps provided in the times field.
	Locations []float64 `json:"locations"`

	// Times Timestamp for each sample [s].
	Times []float64 `json:"times"`
}

// Joints This structure describes a set of joint values of a motion group.
// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
// Float precision is the default.
type Joints struct {
	Joints []float64 `json:"joints"`
}

// Key Unique identifier describing to adress an object.
//
// Special characters, such as `;`, `/`, `?`, `:`, `@`, `=` and `&`, have to be URL encoded.
type Key = string

// KinematicServiceCapabilities defines model for KinematicServiceCapabilities.
type KinematicServiceCapabilities struct {
	// CalculateAllJointPositions Can this motion-group compute all its possible joint positions from a TCP pose.
	CalculateAllJointPositions bool `json:"calculate_all_joint_positions"`

	// CalculateJointPosition Can this motion-group compute its nearest joint position from a TCP pose.
	CalculateJointPosition bool `json:"calculate_joint_position"`

	// CalculateTcpPose Can this motion-group compute its TCP pose from joint positions.
	CalculateTcpPose bool `json:"calculate_tcp_pose"`
}

// KukaController The configuration of a physical KUKA robot controller has to contain an IP address.
// Additionally an RSI server configuration has to be specified in order to control the robot.
// Deploying the server is a functionality of this API.
type KukaController struct {
	ControllerIp   string             `json:"controllerIp"`
	ControllerPort int                `json:"controllerPort"`
	Kind           KukaControllerKind `json:"kind,omitempty"`

	// RsiServer The RSI server runs inside of the cell.
	RsiServer struct {
		Ip   string `json:"ip"`
		Port int    `json:"port"`
	} `json:"rsiServer"`
}

// KukaControllerKind defines model for KukaController.Kind.
type KukaControllerKind string

// LimitSettings NOTE: if a joint or Cartesian limit is not set or present for the corresponding device, then the value is not present (in the list or the optional value is null). The unit depends on the kind of axis (rotational or linear).
type LimitSettings struct {
	// ElbowAccelerationLimit [mm/s^2] max. allowed acceleration at the elbow, 1-dimensional.
	ElbowAccelerationLimit *float64 `json:"elbow_acceleration_limit,omitempty"`

	// ElbowForceLimit [N] max. allowed force at the elbow, 1-dimensional.
	ElbowForceLimit *float64 `json:"elbow_force_limit,omitempty"`

	// ElbowVelocityLimit [mm/s] max. allowed velocity at the elbow, 1-dimensional.
	ElbowVelocityLimit *float64 `json:"elbow_velocity_limit,omitempty"`

	// JointAccelerationLimits Max allowed acceleration for joints in [rad/s^2 or mm/s^2] of the safety setup, starting at base.
	JointAccelerationLimits *[]SingleJointLimit `json:"joint_acceleration_limits,omitempty"`

	// JointPositionLimits Joint position limits in [rad or mm], configured in the safety setup, starting at base.
	JointPositionLimits *[]JointLimit `json:"joint_position_limits,omitempty"`

	// JointTorqueLimits Max allowed torque for joints in [Nm or N] of the safety setup, starting at base.
	JointTorqueLimits *[]SingleJointLimit `json:"joint_torque_limits,omitempty"`

	// JointVelocityLimits Max allowed velocity for joints in [rad/s or mm/s] of the safety setup, starting at base.
	JointVelocityLimits *[]SingleJointLimit `json:"joint_velocity_limits,omitempty"`

	// TcpAccelerationLimit [mm/s^2] max. allowed acceleration at the TCP, 1-dimensional.
	TcpAccelerationLimit *float64 `json:"tcp_acceleration_limit,omitempty"`

	// TcpForceLimit [N] max. allowed force at the TCP, 1-dimensional.
	TcpForceLimit *float64 `json:"tcp_force_limit,omitempty"`

	// TcpOrientationAccelerationLimit [rad/s^2] max. allowed orientation acceleration at the TCP, 1-dimensional.
	TcpOrientationAccelerationLimit *float64 `json:"tcp_orientation_acceleration_limit,omitempty"`

	// TcpOrientationVelocityLimit [rad/s] max. allowed orientation velocity at the TCP, 1-dimensional.
	TcpOrientationVelocityLimit *float64 `json:"tcp_orientation_velocity_limit,omitempty"`

	// TcpVelocityLimit [mm/s] max. allowed velocity at the TCP, 1-dimensional.
	TcpVelocityLimit *float64 `json:"tcp_velocity_limit,omitempty"`
}

// LimitsOverride If a limit is not set, the default value will be used.
type LimitsOverride struct {
	// JointAccelerationLimits This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointAccelerationLimits *Joints `json:"joint_acceleration_limits,omitempty"`

	// JointVelocityLimits This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointVelocityLimits *Joints `json:"joint_velocity_limits,omitempty"`

	// TcpAccelerationLimit Maximum allowed TCP acceleration in [mm/s^2].
	TcpAccelerationLimit *float64 `json:"tcp_acceleration_limit,omitempty"`

	// TcpOrientationAccelerationLimit Maximum allowed TCP rotation acceleration in [rad/s^2].
	TcpOrientationAccelerationLimit *float64 `json:"tcp_orientation_acceleration_limit,omitempty"`

	// TcpOrientationVelocityLimit Maximum allowed TCP rotation velocity in [rad/s].
	TcpOrientationVelocityLimit *float64 `json:"tcp_orientation_velocity_limit,omitempty"`

	// TcpVelocityLimit Maximum allowed TCP velocity in [mm/s].
	TcpVelocityLimit *float64 `json:"tcp_velocity_limit,omitempty"`
}

// Link defines model for Link.
type Link map[string]Collider

// LinkChain A link chain is a kinematic chain of links that is connected via joints.
// A motion group can be used to control the motion of the joints in a link chain.
//
// A link is a group of colliders that is attached to the link reference frame.
//
// The reference frame of a link is obtained after applying all sets of Denavit-Hartenberg-parameters from base to (including) the link index.
//
// This means that the reference frame of the link is on the rotation axis of the next joint in the kinematic chain.
// Example: For a motion group with 2 joints, the collider reference frame (CRF) for link 1 is on the rotation axis of joint 2. The chain looks like:
// - Origin >> Mounting >> Base >> (CRF Base) Joint 0 >> Link 0 >> (CRF Link 0) Joint 1 >> Link 1 >> (CRF Link 1) Flange (CRF Tool) >> TCP
//
// Adjacent links in the kinematic chain of the motion group are not checked for mutual collision.
type LinkChain = []Link

// ListIODescriptionsResponse Array of I/O description values.
type ListIODescriptionsResponse struct {
	IoDescriptions []IODescription `json:"io_descriptions"`
}

// ListIOValuesResponse Array of I/O values.
type ListIOValuesResponse struct {
	IoValues []IOValue `json:"io_values"`
}

// ListPayloadsResponse defines model for ListPayloadsResponse.
type ListPayloadsResponse struct {
	Payloads *[]Payload `json:"payloads,omitempty"`
}

// ListProgramMetadataResponse List of all the stored programs, represented by their metadata.
type ListProgramMetadataResponse struct {
	Programs []ProgramMetadata `json:"programs"`
}

// ListRecipeMetadataResponse List of all the stored recipes, represented by their metadata.
type ListRecipeMetadataResponse struct {
	Recipes []RecipeMetadata `json:"recipes"`
}

// ListResponse defines model for ListResponse.
type ListResponse struct {
	Coordinatesystems *[]CoordinateSystem `json:"coordinatesystems,omitempty"`
}

// ListTcpsResponse defines model for ListTcpsResponse.
type ListTcpsResponse struct {
	// Tcps Represents the tcp offset from the device flange (in other words the absolute transformation from flange to the tcp).
	Tcps *[]RobotTcp `json:"tcps,omitempty"`
}

// Manufacturer defines model for Manufacturer.
type Manufacturer string

// ModeChangeResponse Mode change example:
// * Client sends [jointJogging](jointJogging)](cell="..",...)
// * Server responds with *current_robot_mode: ROBOT_SYSTEM_MODE_UNDEFINED, by_client_request: true* at the beginning of the transition.
// * Server responds with *current_robot_mode: ROBOT_SYSTEM_MODE_CONTROL, by_client_request: true* when transition is done.
//
// In case an error happens during execution, e.g. a path would lead to a joint limit violation:
// * Server responds with *current_robot_mode: ROBOT_SYSTEM_MODE_UNDEFINED, by_client_request: false*
// * Server responds with *current_robot_mode: ROBOT_SYSTEM_MODE_MONITOR, by_client_request: false*
//
// In case an error happens during connection, e.g. the robot is not reachable:
// * Client sends [setDefaultMode](setDefaultMode)(mode: MODE_CONTROL)
// * Server responds with *current_robot_mode:ROBOT_SYSTEM_MODE_UNDEFINED, by_client_request: true*
// * Server responds with *current_robot_mode:ROBOT_SYSTEM_MODE_DISCONNECT, by_client_request: false*
type ModeChangeResponse struct {
	// ByClientRequest True if mode change was requested by client.
	ByClientRequest *bool `json:"by_client_request,omitempty"`

	// CauseOfChange Details about cause of mode change.
	CauseOfChange string `json:"cause_of_change"`

	// CurrentRobotMode The system mode of the robot system.
	//
	// ### ROBOT_SYSTEM_MODE_UNDEFINED
	//
	// Indicates that the robot controller is currently performing a mode transition.
	//
	// ### ROBOT_SYSTEM_MODE_DISCONNECT
	//
	// There is no communication with the robot controller at all. All connections are closed.
	// No command is sent to the robot controller while in this mode. No IO interaction is possible in this mode!
	// All move requests will be rejected in this mode!
	//
	// ### ROBOT_SYSTEM_MODE_MONITOR
	//
	// A connection to the robot controller is established to only read the robot controller state.
	// No command is sent to the robot controller while in this mode. It is possible to receive IO information.
	// All move requests will be rejected in this mode!
	//
	// ### ROBOT_SYSTEM_MODE_CONTROL
	//
	// An active connection is established with the robot controller and the robot system is cyclic commanded
	// to stay in its actual position. The robot controller state is received in the cycle time of the robot controller.
	// Requests via the MotionService and JoggingService will be processed and executed in this mode.
	// IO interaction is possible in this mode! **In this mode the robot system can be commanded to move.**
	//
	// ### ROBOT_SYSTEM_MODE_FREE_DRIVE
	//
	// Like ROBOT_SYSTEM_MODE_MONITOR a connection to the robot controller is established to only read the robot controller state.
	// The difference is that the motion groups can be moved by the user (Free Drive). Thus, the servo motors are turned on.
	// All move requests will be rejected in this mode! **This mode is not supported by every robot!**
	// Use [getSupportedModes](getSupportedModes) to evaluate if the device support free drive.
	CurrentRobotMode RobotSystemMode `json:"current_robot_mode"`

	// PreviousRobotMode The system mode of the robot system.
	//
	// ### ROBOT_SYSTEM_MODE_UNDEFINED
	//
	// Indicates that the robot controller is currently performing a mode transition.
	//
	// ### ROBOT_SYSTEM_MODE_DISCONNECT
	//
	// There is no communication with the robot controller at all. All connections are closed.
	// No command is sent to the robot controller while in this mode. No IO interaction is possible in this mode!
	// All move requests will be rejected in this mode!
	//
	// ### ROBOT_SYSTEM_MODE_MONITOR
	//
	// A connection to the robot controller is established to only read the robot controller state.
	// No command is sent to the robot controller while in this mode. It is possible to receive IO information.
	// All move requests will be rejected in this mode!
	//
	// ### ROBOT_SYSTEM_MODE_CONTROL
	//
	// An active connection is established with the robot controller and the robot system is cyclic commanded
	// to stay in its actual position. The robot controller state is received in the cycle time of the robot controller.
	// Requests via the MotionService and JoggingService will be processed and executed in this mode.
	// IO interaction is possible in this mode! **In this mode the robot system can be commanded to move.**
	//
	// ### ROBOT_SYSTEM_MODE_FREE_DRIVE
	//
	// Like ROBOT_SYSTEM_MODE_MONITOR a connection to the robot controller is established to only read the robot controller state.
	// The difference is that the motion groups can be moved by the user (Free Drive). Thus, the servo motors are turned on.
	// All move requests will be rejected in this mode! **This mode is not supported by every robot!**
	// Use [getSupportedModes](getSupportedModes) to evaluate if the device support free drive.
	PreviousRobotMode RobotSystemMode `json:"previous_robot_mode"`
}

// MotionCommand defines model for MotionCommand.
type MotionCommand struct {
	// Blending Blending alters the TCP path at the target point of a motion command
	// to ensure that the velocity does not drop to zero between two motion commands.
	Blending *MotionCommand_Blending `json:"blending,omitempty"`

	// LimitsOverride If a limit is not set, the default value will be used.
	LimitsOverride *LimitsOverride     `json:"limits_override,omitempty"`
	Path           *MotionCommand_Path `json:"path,omitempty"`
}

// MotionCommand_Blending Blending alters the TCP path at the target point of a motion command
// to ensure that the velocity does not drop to zero between two motion commands.
type MotionCommand_Blending struct {
	union json.RawMessage
}

// MotionCommand_Path defines model for MotionCommand.Path.
type MotionCommand_Path struct {
	union json.RawMessage
}

// MotionGroupBehaviorGetter defines model for MotionGroupBehaviorGetter.
type MotionGroupBehaviorGetter struct {
	// Behavior ## BEHAVIOR_AUTOMATIC
	// This is the default behavior.
	// The motion group instantly takes any commanded joint configuration as actual joint state.
	// Configures the compliance of the virtual robot with the normal ControllerState cycle time. If set, the virtual robot will act like a physical one, e.g. with a cycle time of 8ms to respond to a new joint state command.
	// ## BEHAVIOR_AUTOMATIC_NOT_COMPLY_WITH_CYCLETIME
	// Configures the compliance of the virtual robot with the normal ControllerState cycle time. If set, the robot will respond as fast as possible, limited only by software execution speed. Because of that the execution of a movement requires less time than with BEHAVIOR_AUTOMATIC.
	// ## BEHAVIOR_EXTERNAL_SOURCE
	// The external client is the only source of actual joint state changes.
	// This mode is used to enable third party software indicating the current joint state via [externalJointsStream](externalJointsStream).
	Behavior Behavior `json:"behavior"`
}

// MotionGroupInfo defines model for MotionGroupInfo.
type MotionGroupInfo struct {
	// Dof The number of joints aka degrees of freedom in the motion group.
	Dof uint32 `json:"dof"`

	// Id The unique identifier of the motion group. Use it to refer to the motion group in other calls.
	Id uint32 `json:"id"`

	// Name The name of the motion group for display purposes.
	Name string `json:"name"`
}

// MotionGroupInfos defines model for MotionGroupInfos.
type MotionGroupInfos struct {
	Motiongroups []MotionGroupInfo `json:"motiongroups"`
}

// MotionGroupInstance The data type describes the physically connected motion groups on a robot controller, e.g. a robot arm.
type MotionGroupInstance struct {
	// Controller Identifier of the robot controller the motion group is attached to.
	Controller string `json:"controller"`

	// ModelFromController The robot controller model if available. Usable for frontend 3D visualization.
	ModelFromController string `json:"model_from_controller"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// NameFromController The name of the motion group has on the robot controller.
	NameFromController string `json:"name_from_controller"`

	// SerialNumber The serial number of the motion group if available. If not available, the serial number of the robot controller.
	// if available. If not available, then empty.
	SerialNumber *string `json:"serial_number,omitempty"`
}

// MotionGroupInstanceList A list of motion groups.
type MotionGroupInstanceList struct {
	Instances []MotionGroupInstance `json:"instances"`
}

// MotionGroupJoints Ensure to provide one value for each joint. See [getMotionGroups](getMotionGroups) for the number of joints.
// Everything but positions is optional.
type MotionGroupJoints struct {
	// Accelerations The joint accelerations of the motion group.
	Accelerations *[]float64 `json:"accelerations,omitempty"`

	// Positions The joint positions of the motion group.
	Positions []float64 `json:"positions"`

	// Torques The joint torques of the motion group.
	Torques *[]float64 `json:"torques,omitempty"`

	// Velocities The joint velocities of the motion group.
	Velocities *[]float64 `json:"velocities,omitempty"`
}

// MotionGroupPhysical The data type describes the physically connected motion groups on a robot controller.
type MotionGroupPhysical struct {
	// Active True if this motion group is active.
	// When a request for a motion group is made, the motion group will be activated and remain activated.
	// The robot controller provides the current state and data for all active motion groups.
	// See [getCurrentMotionGroupState](getCurrentMotionGroupState).
	// To deactivate a motion group, use [deactivateMotionGroup](deactivateMotionGroup).
	Active bool `json:"active"`

	// ModelFromController The robot controller model if available. Usable for frontend 3D visualization.
	ModelFromController *string `json:"model_from_controller,omitempty"`

	// MotionGroup The unique identifier to address a motion group.
	MotionGroup string `json:"motion_group"`

	// NameFromController The name the motion group has on the robot controller.
	NameFromController string `json:"name_from_controller"`

	// SerialNumber The serial number of the motion group if available. If not available, the serial number of the robot controller.
	// if available. If not available, then empty.
	SerialNumber *string `json:"serial_number,omitempty"`
}

// MotionGroupSpecification Holding static properties of the motion group.
type MotionGroupSpecification struct {
	// DhParameters A list of DH (Denavit-Hartenberg) parameters.
	// An element in this list contains a set of DH parameters that describe the relation of two cartesian reference frames.
	// Every joint of a serial motion group has an associated cartesian reference frame located in the rotation axis of the joint.
	// A set of DH parameters is applied in the following order: theta, d, a, alpha.
	DhParameters *[]DHParameter `json:"dh_parameters,omitempty"`

	// MechanicalJointLimits Mechanical joint limits in [rad/mm], starting with the first joint in the motion group base.
	// For every joint there is a minimum and maximum value.
	// Those are defined by the motion group manufacturer and can be found in its data sheet.
	// If a mechanical joint limit is exceeded, the motion group stops immediately. The stop is triggered by the physical robot controller.
	// This should be prevented by using proper soft joint limits.
	MechanicalJointLimits *[]JointLimit `json:"mechanical_joint_limits,omitempty"`
}

// MotionGroupState Presents the current state of the motion group.
type MotionGroupState struct {
	// Controller Convenience: Identifier of the robot controller the motion group is attached to.
	Controller string `json:"controller"`

	// FlangePose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	FlangePose *Pose `json:"flange_pose,omitempty"`

	// Force Representing a force on a specific point in operational space (e.g. on robot flange).
	Force *ForceVector `json:"force,omitempty"`

	// JointCurrent This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointCurrent *Joints `json:"joint_current,omitempty"`

	// JointLimitReached Indicates which joint of the motion group is in a limit. If a joint is in its limit, only this joint can be moved. Movements that affect any other joints are not executed.
	JointLimitReached MotionGroupStateJointLimitReached `json:"joint_limit_reached"`

	// JointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointPosition Joints `json:"joint_position"`

	// JointTorque This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointTorque *Joints `json:"joint_torque,omitempty"`

	// JointVelocity This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointVelocity Joints `json:"joint_velocity"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// TcpPose Representing a robot pose in operational space aware of a configured TCP.
	TcpPose  TcpPose      `json:"tcp_pose"`
	Velocity MotionVector `json:"velocity"`
}

// MotionGroupStateResponse defines model for MotionGroupStateResponse.
type MotionGroupStateResponse struct {
	// State Presents the current state of the motion group.
	State MotionGroupState `json:"state"`

	// TcpPose Representing a robot pose in operational space aware of a configured TCP.
	TcpPose *TcpPose `json:"tcp_pose,omitempty"`
}

// MotionGroupStateJointLimitReached Indicates which joint of the motion group is in a limit. If a joint is in its limit, only this joint can be moved. Movements that affect any other joints are not executed.
type MotionGroupStateJointLimitReached struct {
	// LimitReached If true, operational (soft) jointLimit is reached for specific joint.
	LimitReached []bool `json:"limit_reached"`
}

// MotionId defines model for MotionId.
type MotionId struct {
	// Motion This represents the UUID of a motion.
	// Every executable or partially executable motion is cached and an UUID is returned.
	// Indicate the UUID to execute the motion or retrieve information on the motion.
	Motion string `json:"motion"`
}

// MotionIdsListResponse defines model for MotionIdsListResponse.
type MotionIdsListResponse struct {
	// Motions -| Identifiers of all motions which are currently cached. Use [planMotion](planMotion) to add a new motion. Motions are deleted if corresponding motion group or controller is disconnected.
	Motions *[]string `json:"motions,omitempty"`
}

// MotionVector defines model for MotionVector.
type MotionVector struct {
	// Angular A 3 dimensional Vector with double precision.
	Angular *Vector3d `json:"angular,omitempty"`

	// CoordinateSystem optional, unique name of base coordinate system, if empty world is used
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// Linear A 3 dimensional Vector with double precision.
	Linear *Vector3d `json:"linear,omitempty"`
}

// Mounting Mounting of a motion group.
type Mounting struct {
	// CoordinateSystem Identifier of mounting coordinate system. The motion group is based on the origin of this coordinate system.
	CoordinateSystem string `json:"coordinate_system"`

	// Pose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	Pose Pose `json:"pose"`
}

// MoveRequest Moves the motion group forward or backward along a previously planned motion.
//
// Once started, you can stop a motion using the [stop](StreamStop) endpoint.
//
// Prerequisites, before starting the motion executiont he motion group is currently at the start_location_on_trajectory of the
// planned motion.
type MoveRequest struct {
	// Motion This represents the UUID of a motion.
	// Every executable or partially executable motion is cached and an UUID is returned.
	// Indicate the UUID to execute the motion or retrieve information on the motion.
	Motion string `json:"motion"`

	// PauseOnIo Defines an I/O that the motion will be paused for. The motion will stop gracefully on path.
	PauseOnIo *PauseOnIO `json:"pause_on_io,omitempty"`

	// PlaybackSpeedInPercent Set the velocity for executed movements of the motion in percent. A percentage of 100% means that the robot moves as
	// fast as possible without violating the limits. Setting this value does not affect the overall shape of the velocity profile.
	// Everything is slowed down by the same factor. Therefore, this should only be used for teaching and trajectory
	// evaluation purposes. If the process requires a certain velocity, the respective limits should be set when planning the motion.
	// This will not change the velocity override of the controller. The controller velocity override value shall be 100% to ensure
	// controllability of the motion group.
	PlaybackSpeedInPercent uint32 `json:"playback_speed_in_percent"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system in which the responses should be converted.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `json:"response_coordinate_system,omitempty"`

	// ResponseRate Update rate for the response message in milliseconds (ms). Default is 200 ms.
	// We recommend to use the step rate of the controller or a multiple of the step rate as Nova updates the state in the controller's step rate as well.
	// Minimal response rate is the step rate of controller.
	ResponseRate *uint32 `json:"response_rate,omitempty"`

	// SetIOAction Define an arb I/O that is listened to during the motion. If the defined comparator evaluates to true the execution is started.
	SetIOAction *[]SetIO `json:"set_ios,omitempty"`

	// StartLocationOnTrajectory Location the motion is requested to start at.
	// The default value is the begin of the trajectory.
	// The location is a scalar value that defines a position along a path, typically ranging from 0 to `n`,
	// where `n` denotes the number of motion commands. Each integer value of the location corresponds to a specific motion command,
	// while non-integer values interpolate positions within the segments.
	// The location is calculated from the joint path.
	StartLocationOnTrajectory *float64 `json:"start_location_on_trajectory,omitempty"`

	// StartOnIo Defines an I/O that the motion should wait for to start the execution.
	StartOnIo *StartOnIO `json:"start_on_io,omitempty"`
}

// MoveResponse defines model for MoveResponse.
type MoveResponse struct {
	// CurrentLocationOnTrajectory Refers to the current location of motion group on the trajectory.
	CurrentLocationOnTrajectory *float64 `json:"current_location_on_trajectory,omitempty"`

	// TimeToEnd Remaining time in milliseconds (ms) to reach the end of the motion.
	TimeToEnd *uint32 `json:"time_to_end,omitempty"`
}

// MoveToTrajectoryViaJointPTPRequest Request to move the motion group via joint point-to-point to a given location on a planned motion.
// You must use this endpoint in order to start moving from an arbritrary location of the trajectory.
// Afterwards, you are able to call [streamMoveForward](streamMoveForward) or [streamMoveBackward](streamMoveBackward) to move along planned motion.
// Use the [stopExecution](stopExecution) endpoint to stop the motion gracefully.
type MoveToTrajectoryViaJointPTPRequest struct {
	// LimitOverride If a limit is not set, the default value will be used.
	LimitOverride *LimitsOverride `json:"limit_override,omitempty"`

	// LocationOnTrajectory Gets the target location the robot should move to via joint point-to-point (moveJ).
	// The location is a scalar value that defines a position along a path, typically ranging from 0 to `n`,
	// where `n` denotes the number of motion commands. Each integer value of the location corresponds to a specific motion command,
	// while non-integer values interpolate positions within the segments.
	// The location is calculated from the joint path.
	LocationOnTrajectory float64 `json:"location_on_trajectory"`

	// Motion This represents the UUID of a motion.
	// Every executable or partially executable motion is cached and an UUID is returned.
	// Indicate the UUID to execute the motion or retrieve information on the motion.
	Motion string `json:"motion"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system in which the responses should be converted.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `json:"response_coordinate_system,omitempty"`
}

// NameList A list of names
type NameList = []string

// OpMode Controllers have two operating modes: AUTOMATIC and MANUAL.
// MANUAL mode is mainly used for teaching a robot application.
// To ensure safe operation the velocity of the robot is limited to 250 mm/s.
// Running the finished application is done in AUTOMATIC operating mode without the limited velocity of the MANUAL mode.
type OpMode struct {
	Mode OpModeMode `json:"mode"`
}

// OpModeMode defines model for OpMode.Mode.
type OpModeMode string

// OptimizerSetup The configuration of a motion-group used for motion planning.
type OptimizerSetup struct {
	MotionGroupType string      `json:"motion_group_type"`
	Mounting        PlannerPose `json:"mounting"`

	// SafetySetup The safety configuration of a motion-group. Used for motion planning.
	SafetySetup SafetyConfiguration `json:"safety_setup"`
	Tcp         PlannerPose         `json:"tcp"`
}

// OutOfWorkspace Requested TCP pose is outside of motion group's workspace.
type OutOfWorkspace struct {
	// InvalidTcpPose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	InvalidTcpPose *Pose `json:"invalid_tcp_pose,omitempty"`
}

// PathCartesianPTP A cartesian point-to-point is representing a joint point-to-point motion from start point to the indicated target pose.
// The target pose is a joint point-to-point given in cartesian space. The target joint configuration will be calculated
// to be in the same kinematic configuration as the start point is. If that is not possible, planning will fail.
type PathCartesianPTP struct {
	PathDefinitionName string `json:"path_definition_name"`

	// TargetPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TargetPose Pose2 `json:"target_pose"`
}

// PathCircle A circular constructs a circle in translative space from 1) the start position which is provided via position, and 2) the indicated target position.
// The orientation is calculated via a [bezier spline](https://en.wikipedia.org/wiki/B%C3%A9zier_curve) from start orientation to the indicated target orientation.
// The via point defines the control point for the bezier spline.
// Therefore, the control point will not be hit directly.
type PathCircle struct {
	PathDefinitionName string `json:"path_definition_name"`

	// TargetPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TargetPose Pose2 `json:"target_pose"`

	// ViaPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	ViaPose Pose2 `json:"via_pose"`
}

// PathCubicSpline A [cubic spline](https://de.wikipedia.org/wiki/Spline-Interpolation) represents a cartesian cubic spline
// in translative and orientational space from start point to indicated target pose via control points.
type PathCubicSpline struct {
	Parameters         []CubicSplineParameter `json:"parameters"`
	PathDefinitionName string                 `json:"path_definition_name"`
}

// PathJointPTP A joint point-to-point represents a line in joint space. All joints will be moved synchronously.
type PathJointPTP struct {
	PathDefinitionName  string      `json:"path_definition_name"`
	TargetJointPosition DoubleArray `json:"target_joint_position"`
}

// PathLine A line represents a straight line from start position to indicated target position.
// The orientation is calculated via a quaternion [slerp](https://en.wikipedia.org/wiki/Slerp) from start orientation to indicated target orientation.
type PathLine struct {
	PathDefinitionName string `json:"path_definition_name"`

	// TargetPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TargetPose Pose2 `json:"target_pose"`
}

// PauseOnIO Defines an I/O that the motion will be paused for. The motion will stop gracefully on path.
type PauseOnIO struct {
	// Comparator Comparator for the comparison of two values.
	// The comparator is used to compare two values and return a boolean result.
	// The default comparator is unknown.
	Comparator Comparator `json:"comparator"`

	// Io I/O value representation. Depending on the I/O type, only one of the value fields will be set.
	Io IOValue `json:"io"`
}

// Payload defines model for Payload.
type Payload struct {
	// CenterOfMass A 3 dimensional Vector with double precision.
	CenterOfMass *Vector3d `json:"center_of_mass,omitempty"`

	// MomentOfInertia A 3 dimensional Vector with double precision.
	MomentOfInertia *Vector3d `json:"moment_of_inertia,omitempty"`

	// Name Unique identifier of the payload.
	Name string `json:"name"`

	// Payload Mass of payload in [kg].
	Payload float64 `json:"payload"`
}

// PlanFailedOnTrajectoryResponse The planning failed. The motion can be executed until the defected command part starts.
type PlanFailedOnTrajectoryResponse struct {
	Description *string `json:"description,omitempty"`

	// ErrorLocationOnTrajectory Location on the trajectory where the error occurred. The location is defined as a floating point range from 0 to n, where 0 is the start of the trajectory and n is the end of the trajectory. n is the number commands. The decimal places represent the percentage of the defective command.
	ErrorLocationOnTrajectory *float64 `json:"error_location_on_trajectory,omitempty"`

	// JointLimitExceeded This error is returned when a joint position limit is exceeded.
	// The joint index denotes which joint is out of its limits, starting with 1 and the full joint position is returned.
	JointLimitExceeded *JointLimitExceeded `json:"joint_limit_exceeded,omitempty"`

	// LastValidJointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	LastValidJointPosition *Joints `json:"last_valid_joint_position,omitempty"`

	// LastValidTcpPose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	LastValidTcpPose *Pose `json:"last_valid_tcp_pose,omitempty"`

	// Motion Identifier of the motion until the error.
	Motion *string `json:"motion,omitempty"`

	// OutOfWorkspace Requested TCP pose is outside of motion group's workspace.
	OutOfWorkspace *OutOfWorkspace `json:"out_of_workspace,omitempty"`

	// SafetyZoneViolation Safety zone violations occur when a motion is planned within a safety zone set on the controller.
	// The message description indicates which part of the motion group collides with which safety zone.
	SafetyZoneViolation *SafetyZoneViolation `json:"safety_zone_violation,omitempty"`

	// Singularity A Singularity is a point in the robot's workspace where the robot loses one or more degrees of freedom with regards to moving its TCP.
	// This means the robot cannot move or rotate the TCP in a certain direction from this specific point.
	//
	// The singularity type is the type of singularity that the robot is in.
	// The singular joint position is the joint position of the robot when it is in a singularity.
	Singularity *Singularity `json:"singularity,omitempty"`
}

// PlanFailedResponse Starting point of motion is invalid. Therefore, planning a motion is not possible.
type PlanFailedResponse struct {
	// CommandsMissing Error in case no motion commands were provided. Every planning needs to have at least one motion command to describe the path to be followed.
	CommandsMissing *CommandsMissing `json:"commands_missing,omitempty"`
	Description     *string          `json:"description,omitempty"`

	// JointLimitExceeded This error is returned when a joint position limit is exceeded.
	// The joint index denotes which joint is out of its limits, starting with 1 and the full joint position is returned.
	JointLimitExceeded *JointLimitExceeded `json:"joint_limit_exceeded,omitempty"`

	// OutOfWorkspace Requested TCP pose is outside of motion group's workspace.
	OutOfWorkspace *OutOfWorkspace `json:"out_of_workspace,omitempty"`

	// SafetyZoneViolation Safety zone violations occur when a motion is planned within a safety zone set on the controller.
	// The message description indicates which part of the motion group collides with which safety zone.
	SafetyZoneViolation *SafetyZoneViolation `json:"safety_zone_violation,omitempty"`

	// Singularity A Singularity is a point in the robot's workspace where the robot loses one or more degrees of freedom with regards to moving its TCP.
	// This means the robot cannot move or rotate the TCP in a certain direction from this specific point.
	//
	// The singularity type is the type of singularity that the robot is in.
	// The singular joint position is the joint position of the robot when it is in a singularity.
	Singularity *Singularity `json:"singularity,omitempty"`

	// StartJointsMissing Error in case no start joint position was provided.
	// Every motion needs to start with a joint position as reference to uniquely define the kinematic configuration of the motion-group at the start the motion.
	StartJointsMissing *StartJointsMissing `json:"start_joints_missing,omitempty"`
}

// PlanRequest defines model for PlanRequest.
type PlanRequest struct {
	// Commands List of motion commands. A command consists of a motion command (line, circle, joint_ptp, cartesian_ptp, cubic_spline) and corresponding settings (blending, limits override).
	Commands []Command `json:"commands"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// Payload Payload identifier. If unset the currently set payload is used.
	Payload *string `json:"payload,omitempty"`

	// StartJointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	StartJointPosition Joints `json:"start_joint_position"`

	// Tcp Tool identifier. If not set the current tool is used.
	Tcp *string `json:"tcp,omitempty"`
}

// PlanResponse -| The plan response signals if the planned motion is executable, partially executable or not executable. If the motion is executable or partially executable, the response contains an unique identifier for the motion and the end joint position. To execute the motion use the unique identifier for calling move endpoints [streamMoveForward](streamMoveForward) or [streamMoveBackward](streamMoveBackward). Use the unique identifier within the endpoints [getMotionTrajectory](getMotionTrajectory) and [getMotionTrajectorySample](getMotionTrajectorySample) to retrieve information about the motion. Use the end joint position to plan and concatenate the next motion. If an error occurred, the response contains feedback including the reason for failure and the location where the failure occurred.
type PlanResponse struct {
	// PlanFailedOnTrajectoryResponse The planning failed. The motion can be executed until the defected command part starts.
	PlanFailedOnTrajectoryResponse *PlanFailedOnTrajectoryResponse `json:"plan_failed_on_trajectory_response,omitempty"`

	// PlanFailedResponse Starting point of motion is invalid. Therefore, planning a motion is not possible.
	PlanFailedResponse *PlanFailedResponse `json:"plan_failed_response,omitempty"`

	// PlanSuccessfulResponse The motion can be executed entirely.
	PlanSuccessfulResponse *PlanSuccessfulResponse `json:"plan_successful_response,omitempty"`
}

// PlanSuccessfulResponse The motion can be executed entirely.
type PlanSuccessfulResponse struct {
	// EndJointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	EndJointPosition Joints `json:"end_joint_position"`

	// Motion Unique identifier of the motion. Use as reference to execute the motion or to retrieve information on the motion.
	Motion string `json:"motion"`
}

// PlanTrajectoryFailedResponse defines model for PlanTrajectoryFailedResponse.
type PlanTrajectoryFailedResponse struct {
	ErrorFeedback             PlanTrajectoryFailedResponse_ErrorFeedback `json:"error_feedback"`
	ErrorLocationOnTrajectory *float64                                   `json:"error_location_on_trajectory,omitempty"`
	JointTrajectory           *JointTrajectory                           `json:"joint_trajectory,omitempty"`
}

// PlanTrajectoryFailedResponse_ErrorFeedback defines model for PlanTrajectoryFailedResponse.ErrorFeedback.
type PlanTrajectoryFailedResponse_ErrorFeedback struct {
	union json.RawMessage
}

// PlanTrajectoryRequest defines model for PlanTrajectoryRequest.
type PlanTrajectoryRequest struct {
	CollisionMotionGroup *CollisionMotionGroup `json:"collision_motion_group,omitempty"`

	// MotionCommands List of motion commands. A command consists of a path definition (line, circle, joint_ptp, cartesian_ptp, cubic_spline), blending, and limits override.
	MotionCommands []MotionCommand `json:"motion_commands"`

	// RobotSetup The configuration of a motion-group used for motion planning.
	RobotSetup         OptimizerSetup `json:"robot_setup"`
	StartJointPosition DoubleArray    `json:"start_joint_position"`

	// StaticColliders A collection of identifiable colliders.
	StaticColliders *ColliderDictionary `json:"static_colliders,omitempty"`
}

// PlanTrajectoryResponse defines model for PlanTrajectoryResponse.
type PlanTrajectoryResponse struct {
	Response *PlanTrajectoryResponse_Response `json:"response,omitempty"`
}

// PlanTrajectoryResponse_Response defines model for PlanTrajectoryResponse.Response.
type PlanTrajectoryResponse_Response struct {
	union json.RawMessage
}

// Plane Defines an x-y plane with infinite size.
type Plane = map[string]interface{}

// Plane2 Defines an x/y-plane with infinite size.
type Plane2 struct {
	ShapeType string `json:"shape_type"`
}

// Plane3 XY-plane.
type Plane3 struct {
	ShapeType Plane3ShapeType `json:"shape_type"`
}

// Plane3ShapeType defines model for Plane3.ShapeType.
type Plane3ShapeType string

// PlannedMotion defines model for PlannedMotion.
type PlannedMotion struct {
	// JointPositions List of Joint Positions [rad] for eache sample.
	// The number of samples must match the number of timestamps provided in the times field.
	JointPositions []Joints `json:"joint_positions"`

	// Locations Location for each sample, scalar value defining a position along a path. Typical range: 0 to `n`, `n` denoting the number of motion commands.
	// Each integer value of the location corresponds to a specific motion command.
	// If provided, the number of samples must match the number of timestamps provided in the times field.
	Locations *[]float64 `json:"locations,omitempty"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// Tcp Tool identifier for which this sequence was calculated.
	// Relevant for validation of the tcp-velocities.
	// If not set, the current tool is assumed.
	Tcp *string `json:"tcp,omitempty"`

	// Times Timestamp for each sample [s].
	Times []float64 `json:"times"`
}

// PlannerPose defines model for PlannerPose.
type PlannerPose struct {
	// Orientation A unit quaternion with double precision. The quaternion should be normalized: If interpreted as vector, its length has to be 1.
	Orientation *Quaternion `json:"orientation,omitempty"`

	// Position A 3 dimensional Vector with double precision.
	Position *Vector3d `json:"position,omitempty"`
}

// PlanningLimits All known joint and cartesian limits of a motion-group. Used for motion planning.
type PlanningLimits struct {
	// ElbowAccelerationLimit At maximum one dimensional acceleration in [mm/s^2] at the elbow allowed.
	ElbowAccelerationLimit *float64 `json:"elbow_acceleration_limit,omitempty"`

	// ElbowForceLimit At maximum one dimensional force in [N] at the elbow allowed.
	ElbowForceLimit *float64 `json:"elbow_force_limit,omitempty"`

	// ElbowVelocityLimit At maximum one dimensional velocity in [mm/s] at the elbow allowed.
	ElbowVelocityLimit *float64 `json:"elbow_velocity_limit,omitempty"`

	// JointAccelerationLimits Maximum allowed acceleration for joints in [rad/s^2 or mm/s^2] of the safety
	// setup, starting at base.
	JointAccelerationLimits *[]float64 `json:"joint_acceleration_limits,omitempty"`

	// JointPositionLimits Joint position limits in [rad], configured in the safety setup, starting
	// at base.
	JointPositionLimits *[]PlanningLimitsLimitRange `json:"joint_position_limits,omitempty"`

	// JointTorqueLimits Maximum allowed torque for joints in [Nm or N] of the safety setup, starting
	// at base.
	JointTorqueLimits *[]float64 `json:"joint_torque_limits,omitempty"`

	// JointVelocityLimits Maximum allowed velocity for joints in [rad/s or mm/s] of the safety setup,
	// starting at base.
	JointVelocityLimits *[]float64 `json:"joint_velocity_limits,omitempty"`

	// TcpAccelerationLimit At maximum one dimensional acceleration in [mm/s^2] at TCP allowed.
	TcpAccelerationLimit *float64 `json:"tcp_acceleration_limit,omitempty"`

	// TcpForceLimit At maximum one dimensional force in [N] at TCP allowed.
	TcpForceLimit *float64 `json:"tcp_force_limit,omitempty"`

	// TcpOrientationAccelerationLimit At maximum one dimensional orientation acceleration in [rad/s^2] at TCP allowed.
	TcpOrientationAccelerationLimit *float64 `json:"tcp_orientation_acceleration_limit,omitempty"`

	// TcpOrientationVelocityLimit At maximum one dimensional orientation velocity in [rad/s] at TCP allowed.
	TcpOrientationVelocityLimit *float64 `json:"tcp_orientation_velocity_limit,omitempty"`

	// TcpVelocityLimit At maximum one dimensional velocity in [mm/s] at TCP allowed.
	TcpVelocityLimit *float64 `json:"tcp_velocity_limit,omitempty"`
}

// PlanningLimitsLimitRange The upper_limit must be greater then the lower_limit.
type PlanningLimitsLimitRange struct {
	LowerLimit float64 `json:"lower_limit"`
	UpperLimit float64 `json:"upper_limit"`
}

// PointCloud defines model for PointCloud.
type PointCloud struct {
	Pointcloud string `json:"pointcloud"`
}

// Pose Representing a pose in space with its origin in `coordinate_system`.
// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
type Pose struct {
	// CoordinateSystem Unique identifier addressing the reference coordinate system of the pose.
	// Default is the world coordinate system.
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// Orientation A 3 dimensional Vector with double precision.
	Orientation *Vector3d `json:"orientation,omitempty"`

	// Position A 3 dimensional Vector with double precision.
	Position Vector3d `json:"position"`
}

// Pose2 Defines a pose in 3D space.
// A pose is a combination of a position and an orientation.
// The position is applied before the orientation.
type Pose2 struct {
	// Orientation Defines a rotation in 3D space.
	// A three-dimensional Vector [rx, ry, rz] with double precision.
	// Rotation is applied around the vector.
	// The angle of rotation equals the length of the vector.
	Orientation *RotationVector `json:"orientation,omitempty"`

	// Position Describes a position in 3D space.
	// A three-dimensional vector [x, y, z] with double precision.
	Position *Vector3d2 `json:"position,omitempty"`
}

// ProgramMetadata The metadata of a program.
type ProgramMetadata struct {
	// CreatedDate The date when the program was created.
	CreatedDate string `json:"created_date"`

	// Id The unique identifier of the program.
	Id string `json:"id"`

	// Image The path to the image of the program
	Image *string `json:"image,omitempty"`

	// IsHidden Whether the program is accessible for the enduser or only for the developer.
	IsHidden bool `json:"is_hidden"`

	// LastUpdatedDate The date when the program was last updated.
	LastUpdatedDate string `json:"last_updated_date"`

	// Name The name of the program presented to the enduser.
	Name string `json:"name"`
}

// Quaternion A unit quaternion with double precision. The quaternion should be normalized: If interpreted as vector, its length has to be 1.
type Quaternion struct {
	W float64 `json:"w"`
	X float64 `json:"x"`
	Y float64 `json:"y"`
	Z float64 `json:"z"`
}

// RecipeMetadata The metadata of a recipe.
type RecipeMetadata struct {
	CreatedDate string `json:"created_date"`

	// Id The unique identifier of the recipe.
	Id              *string `json:"id,omitempty"`
	Image           *string `json:"image,omitempty"`
	IsProduction    bool    `json:"is_production"`
	LastUpdatedDate string  `json:"last_updated_date"`
	Name            string  `json:"name"`
	ProgramId       string  `json:"program_id"`
}

// Rectangle Defines an x-y plane with finite size.
type Rectangle struct {
	// SizeX The dimension in x direction in [mm].
	SizeX float64 `json:"size_x"`

	// SizeY The dimension in y direction in [mm].
	SizeY float64 `json:"size_y"`
}

// Rectangle2 Defines an x/y-plane with finite size. Centred around the z-axis.
type Rectangle2 struct {
	ShapeType string `json:"shape_type"`

	// SizeX The dimension in x-direction in [mm].
	SizeX float64 `json:"size_x"`

	// SizeY The dimension in y-direction in [mm].
	SizeY float64 `json:"size_y"`
}

// Rectangle3 Centered in XY-plane.
type Rectangle3 struct {
	ShapeType Rectangle3ShapeType `json:"shape_type"`
	SizeX     float32             `json:"size_x"`
	SizeY     float32             `json:"size_y"`
}

// Rectangle3ShapeType defines model for Rectangle3.ShapeType.
type Rectangle3ShapeType string

// RectangularCapsule A convex hull around four spheres. Sphere center points in x-y-plane, offset by either combination +-sizeX/+-sizeY. Alternative description: Rectangle in x-y-plane with a 3D padding.
type RectangularCapsule struct {
	// Radius The radius of the inner spheres in [mm].
	Radius float64 `json:"radius"`

	// SphereCenterDistanceX The distance of the sphere center in x direction in [mm].
	SphereCenterDistanceX float64 `json:"sphere_center_distance_x"`

	// SphereCenterDistanceY The distance of the sphere center in y direction in [mm].
	SphereCenterDistanceY float64 `json:"sphere_center_distance_y"`
}

// RectangularCapsule2 Convex hull around four spheres. Sphere center points in x/y-plane, offset by either combination "+/- sizeX" or "+/- sizeY".
//
// Alternative description: Rectangle in x/y-plane with a 3D padding.
type RectangularCapsule2 struct {
	// Radius The radius of the inner spheres in [mm].
	Radius    float64 `json:"radius"`
	ShapeType string  `json:"shape_type"`

	// SphereCenterDistanceX The distance of the sphere center in x-direction in [mm].
	SphereCenterDistanceX float64 `json:"sphere_center_distance_x"`

	// SphereCenterDistanceY The distance of the sphere center in y-direction in [mm].
	SphereCenterDistanceY float64 `json:"sphere_center_distance_y"`
}

// RectangularCapsule3 Convex hull around four spheres. Sphere center points in XY-plane, offset by either combination "+/- sizeX" or "+/- sizeY".
//
// Alternative description: Rectangle in x-y-plane with a 3D padding.
type RectangularCapsule3 struct {
	Radius                float32                      `json:"radius"`
	ShapeType             RectangularCapsule3ShapeType `json:"shape_type"`
	SphereCenterDistanceX float32                      `json:"sphere_center_distance_x"`
	SphereCenterDistanceY float32                      `json:"sphere_center_distance_y"`
}

// RectangularCapsule3ShapeType defines model for RectangularCapsule3.ShapeType.
type RectangularCapsule3ShapeType string

// ReleaseChannel The channel that defines what a new Wandelbots Nova version is.
//
//   - `next` the over all latest version
//   - `stable` newes patch of the current version
type ReleaseChannel string

// RobotControllerState Returns the whole current state of robot controller.
type RobotControllerState struct {
	// Controller Identifier of the configured robot controller.
	Controller string `json:"controller"`

	// MotionGroups State of indicated motion groups. In case of state request via controller all configured motion groups are returned. In case of executing a motion only the affected motion groups are returned.
	MotionGroups []MotionGroupState `json:"motion_groups"`

	// OperationMode Current operation mode of the configured robot controller.
	// Operation modes in which the attached motion groups can be moved are:
	// - OPERATION_MODE_MANUAL (if enabling switch is pressed)
	// - OPERATION_MODE_MANUAL_T1 (if enabling switch is pressed)
	// - OPERATION_MODE_MANUAL_T2 (if enabling switch is pressed)
	// - OPERATION_MODE_AUTO (without needing to press enabling switch)
	// All other modes are considered as non-operational.
	OperationMode RobotControllerStateOperationMode `json:"operation_mode"`

	// SafetyState Current safety state of the configured robot controller.
	// Operation modes in which the attached motion groups can be moved are:
	// - SAFETY_STATE_NORMAL
	// - SAFETY_STATE_REDUCED
	// All other modes are considered as non-operational.
	SafetyState RobotControllerStateSafetyState `json:"safety_state"`

	// Timestamp Timestamp indicating when the represented information was received from the robot controller.
	Timestamp time.Time `json:"timestamp"`

	// VelocityOverride If made available by the robot controller, returns the current velocity override in
	// [percentage] for movements adjusted on robot control panel.
	// Valid value range: 1 - 100.
	VelocityOverride *uint32 `json:"velocity_override,omitempty"`
}

// RobotControllerStateOperationMode Current operation mode of the configured robot controller.
// Operation modes in which the attached motion groups can be moved are:
// - OPERATION_MODE_MANUAL (if enabling switch is pressed)
// - OPERATION_MODE_MANUAL_T1 (if enabling switch is pressed)
// - OPERATION_MODE_MANUAL_T2 (if enabling switch is pressed)
// - OPERATION_MODE_AUTO (without needing to press enabling switch)
// All other modes are considered as non-operational.
type RobotControllerStateOperationMode string

// RobotControllerStateSafetyState Current safety state of the configured robot controller.
// Operation modes in which the attached motion groups can be moved are:
// - SAFETY_STATE_NORMAL
// - SAFETY_STATE_REDUCED
// All other modes are considered as non-operational.
type RobotControllerStateSafetyState string

// RobotLinkGeometry Describes a geometry encapsulating a given link from a robot.
type RobotLinkGeometry struct {
	// Geometry A Geometry is defined by a shape and a pose.
	Geometry Geometry `json:"geometry"`

	// LinkIndex Determines how many sets of DH-parameter are applied to get from robot base coordinate system to the link coordinate system in which the geometry is defined.
	LinkIndex uint32 `json:"link_index"`
}

// RobotSystemMode The system mode of the robot system.
//
// ### ROBOT_SYSTEM_MODE_UNDEFINED
//
// Indicates that the robot controller is currently performing a mode transition.
//
// ### ROBOT_SYSTEM_MODE_DISCONNECT
//
// There is no communication with the robot controller at all. All connections are closed.
// No command is sent to the robot controller while in this mode. No IO interaction is possible in this mode!
// All move requests will be rejected in this mode!
//
// ### ROBOT_SYSTEM_MODE_MONITOR
//
// A connection to the robot controller is established to only read the robot controller state.
// No command is sent to the robot controller while in this mode. It is possible to receive IO information.
// All move requests will be rejected in this mode!
//
// ### ROBOT_SYSTEM_MODE_CONTROL
//
// An active connection is established with the robot controller and the robot system is cyclic commanded
// to stay in its actual position. The robot controller state is received in the cycle time of the robot controller.
// Requests via the MotionService and JoggingService will be processed and executed in this mode.
// IO interaction is possible in this mode! **In this mode the robot system can be commanded to move.**
//
// ### ROBOT_SYSTEM_MODE_FREE_DRIVE
//
// Like ROBOT_SYSTEM_MODE_MONITOR a connection to the robot controller is established to only read the robot controller state.
// The difference is that the motion groups can be moved by the user (Free Drive). Thus, the servo motors are turned on.
// All move requests will be rejected in this mode! **This mode is not supported by every robot!**
// Use [getSupportedModes](getSupportedModes) to evaluate if the device support free drive.
type RobotSystemMode string

// RobotTcp defines model for RobotTcp.
type RobotTcp struct {
	// Id Identifier of this tcp.
	Id string `json:"id"`

	// Position A 3 dimensional Vector with double precision.
	Position Vector3d `json:"position"`

	// ReadableName A readable and changeable name for frontend visualization.
	ReadableName *string `json:"readable_name,omitempty"`

	// Rotation Defines rotation angles and their interpretation.
	// Except of QUATERNION the angles are in [rad].
	// Rotation Vector order: X = Vector[0], Y = Vector[1], Z = Vector[2], W = Vector[3].
	Rotation *RotationAngles `json:"rotation,omitempty"`
}

// RobotTcps defines model for RobotTcps.
type RobotTcps struct {
	Tcps []RobotTcp `json:"tcps"`
}

// RotationAngleTypes The type of rotation description that is used to specify the rotation.
//
// **Quaternion notation**
//
// * The rotation is represented using a quaternion: [x, y, z, w].
// * The vector part [x, y, z] is the imaginary part of the quaternion, and the scalar part [w] is the real part.
//
// **Rotation Vector notation**
//
// * The rotation is represented using an axis-angle representation:
// > axis = Vector[0:2]
// > angle = |axis| in [rad]
// > axis.normalized * angle
//
// **Euler notation**
//
// * *extrinsic* fixed external reference system
// * *intrinsic* reference system fixed to rotation body
// > angles = Vector[0:2] in [rad].
// * ZYX, ZXZ,...
//   - mapping of the given angles values to the (either intrinsic
//     or extrinsic) axes in the stated order.
//     > Example ZYX: Z = Vector[0], Y = Vector[1], X = Vector[2].
type RotationAngleTypes string

// RotationAngles Defines rotation angles and their interpretation.
// Except of QUATERNION the angles are in [rad].
// Rotation Vector order: X = Vector[0], Y = Vector[1], Z = Vector[2], W = Vector[3].
type RotationAngles struct {
	// Angles The values for the rotation notation.
	Angles []float64 `json:"angles"`

	// Type The type of rotation description that is used to specify the rotation.
	//
	// **Quaternion notation**
	//
	// * The rotation is represented using a quaternion: [x, y, z, w].
	// * The vector part [x, y, z] is the imaginary part of the quaternion, and the scalar part [w] is the real part.
	//
	// **Rotation Vector notation**
	//
	// * The rotation is represented using an axis-angle representation:
	// > axis = Vector[0:2]
	// > angle = |axis| in [rad]
	// > axis.normalized * angle
	//
	// **Euler notation**
	//
	// * *extrinsic* fixed external reference system
	// * *intrinsic* reference system fixed to rotation body
	// > angles = Vector[0:2] in [rad].
	// * ZYX, ZXZ,...
	//   - mapping of the given angles values to the (either intrinsic
	//     or extrinsic) axes in the stated order.
	//  > Example ZYX: Z = Vector[0], Y = Vector[1], X = Vector[2].
	Type RotationAngleTypes `json:"type"`
}

// RotationVector Defines a rotation in 3D space.
// A three-dimensional Vector [rx, ry, rz] with double precision.
// Rotation is applied around the vector.
// The angle of rotation equals the length of the vector.
type RotationVector = []float64

// SafetyConfiguration The safety configuration of a motion-group. Used for motion planning.
type SafetyConfiguration struct {
	// GlobalLimits All known joint and cartesian limits of a motion-group. Used for motion planning.
	GlobalLimits PlanningLimits `json:"global_limits"`

	// RobotModelGeometries The shape of the motion-group to validate against SafetyZones.
	RobotModelGeometries *[]RobotLinkGeometry `json:"robot_model_geometries,omitempty"`

	// SafetyZoneLimits All limits applied in certain SafetyZones.
	SafetyZoneLimits *[]SafetyZoneLimits `json:"safety_zone_limits,omitempty"`

	// SafetyZones SafetyZones are areas which cannot be entered or impose certain limits.
	SafetyZones *[]SafetyZone `json:"safety_zones,omitempty"`

	// TcpGeometries The shape of the TCP to validate against SafetyZones.
	TcpGeometries *[]Geometry `json:"tcp_geometries,omitempty"`
}

// SafetySetup defines model for SafetySetup.
type SafetySetup struct {
	RobotModelGeometries *[]RobotLinkGeometry         `json:"robot_model_geometries,omitempty"`
	SafetySettings       *[]SafetySetupSafetySettings `json:"safety_settings,omitempty"`
	SafetyZones          *[]SafetySetupSafetyZone     `json:"safety_zones,omitempty"`
	ToolGeometries       *[]ToolGeometry              `json:"tool_geometries,omitempty"`
}

// SafetySetupSafetySettings Restricts the robot movements due to the safety configuration.
type SafetySetupSafetySettings struct {
	// SafetyState The safety state that the settings are valid for.
	SafetyState *SafetySetupSafetySettingsSafetyState `json:"safety_state,omitempty"`

	// Settings NOTE: if a joint or Cartesian limit is not set or present for the corresponding device, then the value is not present (in the list or the optional value is null). The unit depends on the kind of axis (rotational or linear).
	Settings *LimitSettings `json:"settings,omitempty"`
}

// SafetySetupSafetySettingsSafetyState The safety state that the settings are valid for.
type SafetySetupSafetySettingsSafetyState string

// SafetySetupSafetyZone Describes the physical space in which the safety limitations will be applied.
type SafetySetupSafetyZone struct {
	// Geometry A Geometry is defined by a shape and a pose.
	Geometry *Geometry `json:"geometry,omitempty"`

	// Id A unique identifier.
	Id *uint32 `json:"id,omitempty"`

	// MotionGroupUid Unique identifier of an specific motion-group if the safety zone only applies to it.
	// If it is not set, then the safety zone applies to all motion-groups.
	MotionGroupUid *uint32 `json:"motion_group_uid,omitempty"`

	// Priority The precedence if two zones overlap.
	Priority *uint32 `json:"priority,omitempty"`
}

// SafetyZone A zone where the MotionGroup cannot enter or certain limits apply.
type SafetyZone struct {
	// Geometry A Geometry is defined by a shape and a pose.
	Geometry Geometry `json:"geometry"`

	// Id A unique identifier.
	Id uint32 `json:"id"`

	// Priority The precedence if multiple zones overlap.
	Priority uint32 `json:"priority"`
}

// SafetyZoneLimits All limits which apply within a single safety zone.
type SafetyZoneLimits struct {
	// Limits All known joint and cartesian limits of a motion-group. Used for motion planning.
	Limits     PlanningLimits `json:"limits"`
	SafetyZone uint32         `json:"safety_zone"`
}

// SafetyZoneViolation Safety zone violations occur when a motion is planned within a safety zone set on the controller.
// The message description indicates which part of the motion group collides with which safety zone.
type SafetyZoneViolation struct {
	Description *string `json:"description,omitempty"`
}

// ServiceStatus defines model for ServiceStatus.
type ServiceStatus struct {
	Service string `json:"service"`
	Status  struct {
		Code     ServiceStatusPhase    `json:"code"`
		Reason   *string               `json:"reason,omitempty"`
		Severity ServiceStatusSeverity `json:"severity"`
	} `json:"status"`
}

// ServiceStatusList defines model for ServiceStatusList.
type ServiceStatusList = []ServiceStatus

// ServiceStatusPhase defines model for ServiceStatusPhase.
type ServiceStatusPhase string

// ServiceStatusSeverity defines model for ServiceStatusSeverity.
type ServiceStatusSeverity string

// SetIO Defines an I/O that should be set upon reaching a certain location on the trajectory.
type SetIO struct {
	// Io I/O value representation. Depending on the I/O type, only one of the value fields will be set.
	Io IOValue `json:"io"`

	// Location The location on the trajectory where the I/O should be set.
	Location float64 `json:"location"`
}

// SetPlaybackSpeed Set the velocity for executed movements of the motion in percent.
type SetPlaybackSpeed struct {
	// Motion This represents the UUID of a motion.
	// Every executable or partially executable motion is cached and an UUID is returned.
	// Indicate the UUID to execute the motion or retrieve information on the motion.
	Motion string `json:"motion"`

	// PlaybackSpeedInPercent Set the velocity for executed movements of the motion in percent. A percentage of 100% means that the robot moves as
	// fast as possible without violating the limits. Setting this value does not affect the overall shape of the velocity profile.
	// Everything is slowed down by the same factor. Therefore, this should only be used for teaching and trajectory
	// evaluation purposes. If the process requires a certain velocity, the respective limits should be set when planning the motion.
	// This will not change the velocity override of the controller. The controller velocity override value shall be 100% to ensure
	// controllability of the motion group.
	PlaybackSpeedInPercent uint32 `json:"playback_speed_in_percent"`
}

// SingleJointLimit A joint limit can contain a position (rad or mm), a velocity (rad/s or mm/s), an acceleration (rad/s² or mm/s²) or a jerk (rad/s³ or mm/s³).
type SingleJointLimit struct {
	// Joint Definition of the joint where the limits are applied.
	Joint SingleJointLimitJoint `json:"joint"`

	// Limit Limit, unit depends on usage of this message structure.
	Limit float64 `json:"limit"`
}

// SingleJointLimitJoint Definition of the joint where the limits are applied.
type SingleJointLimitJoint string

// Singularity A Singularity is a point in the robot's workspace where the robot loses one or more degrees of freedom with regards to moving its TCP.
// This means the robot cannot move or rotate the TCP in a certain direction from this specific point.
//
// The singularity type is the type of singularity that the robot is in.
// The singular joint position is the joint position of the robot when it is in a singularity.
type Singularity struct {
	// SingularJointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	SingularJointPosition *Joints                     `json:"singular_joint_position,omitempty"`
	SingularityType       *SingularitySingularityType `json:"singularity_type,omitempty"`
}

// SingularitySingularityType defines model for Singularity.SingularityType.
type SingularitySingularityType string

// SingularityTypeEnum defines model for SingularityTypeEnum.
type SingularityTypeEnum string

// Sphere Defines a spherical shape centered around an origin.
type Sphere struct {
	// Radius The radius of the sphere in [mm].
	Radius float64 `json:"radius"`
}

// Sphere2 Defines a spherical shape centred around the origin.
type Sphere2 struct {
	// Radius The radius of the sphere in [mm].
	Radius    float64 `json:"radius"`
	ShapeType string  `json:"shape_type"`
}

// Sphere3 Centered around origin.
type Sphere3 struct {
	Radius    float32          `json:"radius"`
	ShapeType Sphere3ShapeType `json:"shape_type"`
}

// Sphere3ShapeType defines model for Sphere3.ShapeType.
type Sphere3ShapeType string

// StartJointsMissing Error in case no start joint position was provided.
// Every motion needs to start with a joint position as reference to uniquely define the kinematic configuration of the motion-group at the start the motion.
type StartJointsMissing = map[string]interface{}

// StartOnIO Defines an I/O that the motion should wait for to start the execution.
type StartOnIO struct {
	// Comparator Comparator for the comparison of two values.
	// The comparator is used to compare two values and return a boolean result.
	// The default comparator is unknown.
	Comparator Comparator `json:"comparator"`

	// Io I/O value representation. Depending on the I/O type, only one of the value fields will be set.
	Io IOValue `json:"io"`
}

// Status The `Status` type defines a logical error model that is suitable for different
// programming environments including REST APIs and RPC APIs. It is used by
// [gRPC](https://github.com/grpc). Each `status` message contains three pieces
// of data: error code, error message, and error details. You can find out more
// about this error model and how to work with it in the [API Design
// Guide](https://cloud.google.com/apis/design/errors).
type Status struct {
	// Code The status code, which should be an enum value of
	// [google.rpc.Code](https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto).
	Code *int32 `json:"code,omitempty"`

	// Details A list of messages that carry the error details. There is a common set of
	// message types for APIs to use.
	// > Currently, this is unused.
	Details *[]GoogleProtobufAny `json:"details,omitempty"`

	// Message An error message in English.
	Message *string `json:"message,omitempty"`
}

// StopResponse The response will be sent once at the end of every motion signalling that the motion group has stopped moving.
type StopResponse struct {
	LocationOnTrajectory float64 `json:"location_on_trajectory"`

	// Message Will provide detailed information about the reason for stopping.
	Message  *string              `json:"message,omitempty"`
	StopCode StopResponseStopCode `json:"stop_code"`
}

// StopResponseStopCode defines model for StopResponse.StopCode.
type StopResponseStopCode string

// StreamMoveBackward defines model for StreamMoveBackward.
type StreamMoveBackward struct {
	// Backward Moves the motion group forward or backward along a previously planned motion.
	//
	// Once started, you can stop a motion using the [stop](StreamStop) endpoint.
	//
	// Prerequisites, before starting the motion executiont he motion group is currently at the start_location_on_trajectory of the
	// planned motion.
	Backward MoveRequest `json:"backward"`
}

// StreamMoveForward defines model for StreamMoveForward.
type StreamMoveForward struct {
	// Forward Moves the motion group forward or backward along a previously planned motion.
	//
	// Once started, you can stop a motion using the [stop](StreamStop) endpoint.
	//
	// Prerequisites, before starting the motion executiont he motion group is currently at the start_location_on_trajectory of the
	// planned motion.
	Forward MoveRequest `json:"forward"`
}

// StreamMovePlaybackSpeed defines model for StreamMovePlaybackSpeed.
type StreamMovePlaybackSpeed struct {
	// PlaybackSpeed Set the velocity for executed movements of the motion in percent.
	PlaybackSpeed SetPlaybackSpeed `json:"playback_speed"`
}

// StreamMoveResponse The stream will return MoveResponse repeatedly as long as defined in `response_rate` until the movement is
// completed. Finally, a single StopResponse is returned and the stream is closed.
type StreamMoveResponse struct {
	MoveResponse *MoveResponse `json:"move_response,omitempty"`

	// State Returns the whole current state of robot controller.
	State *RobotControllerState `json:"state,omitempty"`

	// StopResponse The response will be sent once at the end of every motion signalling that the motion group has stopped moving.
	StopResponse *StopResponse `json:"stop_response,omitempty"`
}

// StreamMoveToTrajectory defines model for StreamMoveToTrajectory.
type StreamMoveToTrajectory struct {
	// ToTrajectory Request to move the motion group via joint point-to-point to a given location on a planned motion.
	// You must use this endpoint in order to start moving from an arbritrary location of the trajectory.
	// Afterwards, you are able to call [streamMoveForward](streamMoveForward) or [streamMoveBackward](streamMoveBackward) to move along planned motion.
	// Use the [stopExecution](stopExecution) endpoint to stop the motion gracefully.
	ToTrajectory MoveToTrajectoryViaJointPTPRequest `json:"to_trajectory"`
}

// StreamStop defines model for StreamStop.
type StreamStop struct {
	Stop MotionId `json:"stop"`
}

// TcpPose Representing a robot pose in operational space aware of a configured TCP.
type TcpPose struct {
	// CoordinateSystem Unique name of base coordinate system, if empty world is used.
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// Orientation A 3 dimensional Vector with double precision.
	Orientation Vector3d `json:"orientation"`

	// Position A 3 dimensional Vector with double precision.
	Position Vector3d `json:"position"`

	// Tcp Identifier of tcp on controller.
	Tcp string `json:"tcp"`
}

// TcpPoseRequest Request to compute the TCP pose for a single joint position sample.
type TcpPoseRequest struct {
	// CoordinateSystem Unique identifier of the base coordinate system of the calculated pose.
	// Optional. If empty, world is used.
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// JointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointPosition Joints `json:"joint_position"`

	// MotionGroup Unique identifier of the motion-group.
	MotionGroup string `json:"motion_group"`

	// Tcp Specifies the TCP at which the pose is calculated via its unique identifier.
	// Optional. If not provided, the currently active TCP is used.
	Tcp *string `json:"tcp,omitempty"`
}

// Tool Defines the shape of a tool.
//
// A tool is a dictionary of colliders.
//
// All colliders that make up a tool are attached to the flange frame of the motion group.
type Tool map[string]Collider

// ToolGeometry Describes a geometry encapsulating a given tool from a robot.
type ToolGeometry struct {
	// Geometries The shape of the tool to validate against SafetyZones.
	Geometries *[]Geometry `json:"geometries,omitempty"`

	// Tcp Identifier of this tcp.
	Tcp string `json:"tcp"`
}

// TrajectorySample A sample of a trajectory is a single point of the trajectory at a specific location.
type TrajectorySample struct {
	// JointAcceleration This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointAcceleration *Joints `json:"joint_acceleration,omitempty"`

	// JointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointPosition *Joints `json:"joint_position,omitempty"`

	// JointTorques This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointTorques *Joints `json:"joint_torques,omitempty"`

	// JointVelocity This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointVelocity *Joints `json:"joint_velocity,omitempty"`

	// LocationOnTrajectory location on trajectory
	LocationOnTrajectory *float64 `json:"location_on_trajectory,omitempty"`

	// TcpAcceleration [mm/s^2]
	TcpAcceleration *float64 `json:"tcp_acceleration,omitempty"`

	// TcpOrientationAcceleration [rad/s^2]
	TcpOrientationAcceleration *float64 `json:"tcp_orientation_acceleration,omitempty"`

	// TcpOrientationVelocity [rad/s]
	TcpOrientationVelocity *float64 `json:"tcp_orientation_velocity,omitempty"`

	// TcpPose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	TcpPose *Pose `json:"tcp_pose,omitempty"`

	// TcpVelocity [mm/s]
	TcpVelocity *float64 `json:"tcp_velocity,omitempty"`

	// Time [s]
	Time *float64 `json:"time,omitempty"`
}

// UniversalrobotsController The configuration of a physical Universal Robots controller has to contain IP address of the controller.
type UniversalrobotsController struct {
	ControllerIp string                        `json:"controllerIp"`
	Kind         UniversalrobotsControllerKind `json:"kind,omitempty"`
}

// UniversalrobotsControllerKind defines model for UniversalrobotsController.Kind.
type UniversalrobotsControllerKind string

// UpdateProgramMetadataRequest This message is used to update the metadata of a program.
// Only the set fields get updated.
type UpdateProgramMetadataRequest struct {
	Image    *string `json:"image,omitempty"`
	IsHidden *bool   `json:"is_hidden,omitempty"`
	Name     *string `json:"name,omitempty"`
}

// UpdateRecipeMetadataRequest This message is used to update the metadata of a recipe.
// Only the set fields get updated.
type UpdateRecipeMetadataRequest struct {
	IsProduction *bool   `json:"is_production,omitempty"`
	Name         *string `json:"name,omitempty"`
	ProgramId    *string `json:"program_id,omitempty"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Loc  []ValidationError_Loc_Item `json:"loc"`
	Msg  string                     `json:"msg"`
	Type string                     `json:"type"`
}

// ValidationErrorLoc0 defines model for .
type ValidationErrorLoc0 = string

// ValidationErrorLoc1 defines model for .
type ValidationErrorLoc1 = int

// ValidationError_Loc_Item defines model for ValidationError.loc.Item.
type ValidationError_Loc_Item struct {
	union json.RawMessage
}

// Vector3d A 3 dimensional Vector with double precision.
type Vector3d struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
	Z float64 `json:"z"`
}

// Vector3d2 Describes a position in 3D space.
// A three-dimensional vector [x, y, z] with double precision.
type Vector3d2 = []float64

// VersionNumber A generic representation of a version number.
type VersionNumber struct {
	BugfixVersion *uint32 `json:"bugfix_version,omitempty"`

	// BugfixVersionWildcard If bugfix version is a wildcard set to true.
	BugfixVersionWildcard *bool   `json:"bugfix_version_wildcard,omitempty"`
	BuildVersion          *uint32 `json:"build_version,omitempty"`

	// BuildVersionWildcard If build version is a wildcard set to true.
	BuildVersionWildcard *bool   `json:"build_version_wildcard,omitempty"`
	MajorVersion         uint32  `json:"major_version"`
	MinorVersion         *uint32 `json:"minor_version,omitempty"`

	// MinorVersionWildcard If minor version is a wildcard set to true.
	MinorVersionWildcard *bool `json:"minor_version_wildcard,omitempty"`

	// StringVersion A string representation of the version e.g. 1.1.x.x.
	StringVersion *string `json:"string_version,omitempty"`
}

// Versions defines model for Versions.
type Versions struct {
	Versions []VersionsVersion `json:"versions"`
}

// VersionsVersion defines model for Versions_Version.
type VersionsVersion struct {
	// Name The name of the Component.
	Name string `json:"name"`

	// StringVersion The version of the Component.
	StringVersion string `json:"string_version"`
}

// VirtualController The configuration of a virtual robot controller has to contain the manufacturer string,
// an optional joint position string array and either a type or the full JSON configuration.
// The JSON config of a physical controller can be obtained via `/cells/{cell}/controllers/{controller}/virtual-robot-configuration`
type VirtualController struct {
	Json         *string                 `json:"json,omitempty"`
	Kind         VirtualControllerKind   `json:"kind,omitempty"`
	Manufacturer Manufacturer            `json:"manufacturer"`
	Position     *string                 `json:"position,omitempty"`
	Type         *VirtualControllerTypes `json:"type,omitempty"`
}

// VirtualControllerKind defines model for VirtualController.Kind.
type VirtualControllerKind string

// VirtualControllerTypes defines model for VirtualControllerTypes.
type VirtualControllerTypes string

// VirtualRobotConfiguration defines model for VirtualRobotConfiguration.
type VirtualRobotConfiguration struct {
	// Content Content of the configuration file. Copy & paste to the [addRobotController](addRobotController) configuration.json parameter.
	Content string `json:"content"`

	// Name Name of the configuration file generated by the unique identifier of the controller and a time stamp.
	Name string `json:"name"`
}

// YaskawaController The configuration of a physical Yaskawa robot controller has to contain IP address of the controller.
type YaskawaController struct {
	ControllerIp string                `json:"controllerIp"`
	Kind         YaskawaControllerKind `json:"kind,omitempty"`
}

// YaskawaControllerKind defines model for YaskawaController.Kind.
type YaskawaControllerKind string

// PyjectoryDatatypesCoreOrientation defines model for pyjectory__datatypes__core__Orientation.
type PyjectoryDatatypesCoreOrientation = []interface{}

// PyjectoryDatatypesCorePose A pose (position and orientation)
type PyjectoryDatatypesCorePose struct {
	Orientation PyjectoryDatatypesCoreOrientation `json:"orientation"`
	Position    PyjectoryDatatypesCorePosition    `json:"position"`
}

// PyjectoryDatatypesCorePosition defines model for pyjectory__datatypes__core__Position.
type PyjectoryDatatypesCorePosition = []interface{}

// PyjectoryDatatypesSerializerOrientation Rotation vector, defined in [rx, ry, rz] with floating numbers.
// The rotation is represented in vector3 using an axis-angle representation: axis.normalized * angle (angle in radians).
// Must be defined for the first pose of a path. If not defined for the rest of the path,
// the previous orientation will be used.
type PyjectoryDatatypesSerializerOrientation struct {
	Orientation []interface{} `json:"orientation"`
}

// PyjectoryDatatypesSerializerPose Object's position and orientaton, defined in [x, y, z, rx, ry, rz].
// x,y,z are defined in millimeters.
// rx,ry,rz are defined in radians.
type PyjectoryDatatypesSerializerPose struct {
	Pose []interface{} `json:"pose"`
}

// PyjectoryDatatypesSerializerPosition Single point, defined in [x, y, z] with floating numbers. Must be defined.
type PyjectoryDatatypesSerializerPosition struct {
	Position []interface{} `json:"position"`
}

// PyripheryEtcdETCDConfiguration Configuration of the etcd client
//
// This configuration is necessary to add an etcd server as device to the cell.
// The etcd server itself is running in the cell by default.
//
// [etcd](https://etcd.io/) is a distributed, reliable key-value store that can be used
// to store values which can be
// addressed by Wandelscript in advanced Wandelscript programs.
//
// Args:
//
//	identifier: the identifier name for etcd
//	host: The host name.  Default is 'etcd'.
//	port : The port defined in the etcd manifest file. The default is 2379.
type PyripheryEtcdETCDConfiguration struct {
	Host       *string      `json:"host,omitempty"`
	Identifier *string      `json:"identifier,omitempty"`
	Port       *int         `json:"port,omitempty"`
	Type       *interface{} `json:"type,omitempty"`
}

// PyripheryHardwareIsaacIsaacConfiguration The configuration of the Omniservice
type PyripheryHardwareIsaacIsaacConfiguration struct {
	Host       *string            `json:"host,omitempty"`
	Identifier *string            `json:"identifier,omitempty"`
	PrimPaths  *map[string]string `json:"prim_paths,omitempty"`
	Type       *interface{}       `json:"type,omitempty"`
}

// PyripheryOpcuaOPCUAConfiguration Configuration of the OPCUAConnector
//
// Args:
//
//	url: The URL of the OPC UA service
type PyripheryOpcuaOPCUAConfiguration struct {
	Identifier *string      `json:"identifier,omitempty"`
	Type       *interface{} `json:"type,omitempty"`
	Url        *string      `json:"url,omitempty"`
}

// PyripheryPyraeControllerControllerConfiguration Configuration of a Robot Controller.
//
// This will configure the robot controller such that it is controllable through Wandelscript.
//
// This is for advanced users only: it should not be necessary to change this configuration in most use cases.
type PyripheryPyraeControllerControllerConfiguration struct {
	ControllerModelName *string      `json:"controller_model_name,omitempty"`
	Host                *string      `json:"host,omitempty"`
	Identifier          *string      `json:"identifier,omitempty"`
	RaeHost             *string      `json:"rae_host,omitempty"`
	RaePort             *int         `json:"rae_port,omitempty"`
	Type                *interface{} `json:"type,omitempty"`
}

// PyripheryRoboticsConfigurableCollisionSceneConfigurableCollisionSceneConfigurationInput defines model for pyriphery__robotics__configurable_collision_scene__ConfigurableCollisionScene__Configuration-Input.
type PyripheryRoboticsConfigurableCollisionSceneConfigurableCollisionSceneConfigurationInput struct {
	// Identifier A unique identifier for the collision scene.
	Identifier *string `json:"identifier,omitempty"`

	// RobotConfigurations Configurations for robots within the scene. Allow for the specification of collision geometries and
	// other robot-specific settings, identified by robot names.
	RobotConfigurations *map[string]CollisionRobotConfigurationInput `json:"robot_configurations,omitempty"`

	// StaticColliders A collection of static colliders within the scene, identified by their names.
	StaticColliders *map[string]ColliderInput `json:"static_colliders,omitempty"`

	// Type This device is experimental and might experience functional changes in the future.
	//
	// The configuration of the collision scene. This configuration is used to create a collision scene for planning
	// at the start of a program execution. The scene can then be modified by the program.
	//
	// Note that in a cell with multiple robots only sequential robot motions are correctly checked for
	// collisions. Use simultaneous motions of multiple robots at your own risk.
	Type *interface{} `json:"type,omitempty"`
}

// PyripheryRoboticsRobotcellTimerConfiguration defines model for pyriphery__robotics__robotcell__Timer__Configuration.
type PyripheryRoboticsRobotcellTimerConfiguration struct {
	Identifier *string                                           `json:"identifier,omitempty"`
	Type       *PyripheryRoboticsRobotcellTimerConfigurationType `json:"type,omitempty"`
}

// PyripheryRoboticsRobotcellTimerConfigurationType defines model for PyripheryRoboticsRobotcellTimerConfiguration.Type.
type PyripheryRoboticsRobotcellTimerConfigurationType string

// PyripheryRoboticsSimulationRobotWithViewOpen3dConfiguration The configuration of a simulated robot
//
// Args:
//
//	initial_pose: The start pose of the robot, None means it is unknown
type PyripheryRoboticsSimulationRobotWithViewOpen3dConfiguration struct {
	Identifier  *string      `json:"identifier,omitempty"`
	InitialPose *[]float32   `json:"initial_pose,omitempty"`
	Type        *interface{} `json:"type,omitempty"`
}

// PyripheryRoboticsSimulationSimulatedIOConfiguration defines model for pyriphery__robotics__simulation__SimulatedIO__Configuration.
type PyripheryRoboticsSimulationSimulatedIOConfiguration struct {
	Identifier *string      `json:"identifier,omitempty"`
	Type       *interface{} `json:"type,omitempty"`
}

// PyripheryRoboticsSimulationSimulatedOPCUAConfiguration defines model for pyriphery__robotics__simulation__SimulatedOPCUA__Configuration.
type PyripheryRoboticsSimulationSimulatedOPCUAConfiguration struct {
	Identifier *string      `json:"identifier,omitempty"`
	Type       *interface{} `json:"type,omitempty"`
}

// AppID The name of the provided application.
// The name must be unique within the cell and is used as a identifier for addressing the application in all API calls, e.g. when updating the application.
type AppID = string

// CellID defines model for Cell.
type CellID = string

// ColliderID defines model for Collider.
type ColliderID = string

// ControllerID defines model for Controller.
type ControllerID = string

// CoordinateSystem defines model for CoordinateSystem.
type CoordinateSystem = string

// IO defines model for IO.
type IO = string

// Id defines model for Id.
type Id = uint32

// LinkChainID defines model for LinkChain.
type LinkChainID = string

// Motion defines model for Motion.
type Motion = string

// MotionGroup defines model for MotionGroup.
type MotionGroup = string

// PlaybackSpeed defines model for PlaybackSpeed.
type PlaybackSpeed = uint32

// Program Recieved from [listProgramMetadata](listProgramMetadata) or from the response of [createProgram](createProgram).
type Program = string

// Recipe Recieved from [listRecipeMetadata](listRecipeMetadata) or from the response of [createRecipe](createRecipe).
type Recipe = string

// ResponseCoordinateSystem defines model for ResponseCoordinateSystem.
type ResponseCoordinateSystem = string

// ResponseRate defines model for ResponseRate.
type ResponseRate = uint32

// SceneID defines model for Scene.
type SceneID = string

// TCP defines model for TCP.
type TCP = string

// Tcp defines model for Tcp.
type Tcp = string

// CompletionTimeout The maximum time (**in seconds**) spent waiting until the operation is complete.
//
// If the parameter is set, the request will wait for completion until the specified time is up.
// For POST and PUT requests completion means that all resources are running and usable.
// For DELETE completion means that the deletion process is completed.
type CompletionTimeout = int

// ToolID defines model for Tool.
type ToolID = string

// DefaultErrorResponse The `Status` type defines a logical error model that is suitable for different
// programming environments including REST APIs and RPC APIs. It is used by
// [gRPC](https://github.com/grpc). Each `status` message contains three pieces
// of data: error code, error message, and error details. You can find out more
// about this error model and how to work with it in the [API Design
// Guide](https://cloud.google.com/apis/design/errors).
type DefaultErrorResponse = Status

// NotFound defines model for NotFound.
type NotFound = Error

// StreamFreeDriveParams defines parameters for StreamFreeDrive.
type StreamFreeDriveParams struct {
	ResponseRate *uint32 `form:"response_rate,omitempty" json:"response_rate,omitempty"`
}

// ListIODescriptionsParams defines parameters for ListIODescriptions.
type ListIODescriptionsParams struct {
	Ios *[]string `form:"ios,omitempty" json:"ios,omitempty"`
}

// StreamIOValuesParams defines parameters for StreamIOValues.
type StreamIOValuesParams struct {
	Ios *[]string `form:"ios,omitempty" json:"ios,omitempty"`
}

// ListIOValuesParams defines parameters for ListIOValues.
type ListIOValuesParams struct {
	Ios *[]string `form:"ios,omitempty" json:"ios,omitempty"`
}

// SetOutputValuesJSONBody defines parameters for SetOutputValues.
type SetOutputValuesJSONBody = []IOValue

// WaitForIOEventParams defines parameters for WaitForIOEvent.
type WaitForIOEventParams struct {
	Io             string                             `form:"io" json:"io"`
	ComparisonType WaitForIOEventParamsComparisonType `form:"comparison_type" json:"comparison_type"`
	BooleanValue   *bool                              `form:"boolean_value,omitempty" json:"boolean_value,omitempty"`
	IntegerValue   *string                            `form:"integer_value,omitempty" json:"integer_value,omitempty"`
	FloatingValue  *float64                           `form:"floating_value,omitempty" json:"floating_value,omitempty"`
}

// WaitForIOEventParamsComparisonType defines parameters for WaitForIOEvent.
type WaitForIOEventParamsComparisonType string

// SetDefaultModeParams defines parameters for SetDefaultMode.
type SetDefaultModeParams struct {
	Mode SetDefaultModeParamsMode `form:"mode" json:"mode"`
}

// SetDefaultModeParamsMode defines parameters for SetDefaultMode.
type SetDefaultModeParamsMode string

// StreamRobotControllerStateParams defines parameters for StreamRobotControllerState.
type StreamRobotControllerStateParams struct {
	ResponseRate *uint32 `form:"response_rate,omitempty" json:"response_rate,omitempty"`
}

// DeleteVirtualRobotCoordinateSystemParams defines parameters for DeleteVirtualRobotCoordinateSystem.
type DeleteVirtualRobotCoordinateSystemParams struct {
	// DeleteDependent If true, all dependent coordinate systems will be deleted as well.
	DeleteDependent *bool `form:"delete_dependent,omitempty" json:"delete_dependent,omitempty"`
}

// SetVirtualRobotIOValueParams defines parameters for SetVirtualRobotIOValue.
type SetVirtualRobotIOValueParams struct {
	Bool    *bool    `form:"bool,omitempty" json:"bool,omitempty"`
	Integer *string  `form:"integer,omitempty" json:"integer,omitempty"`
	Double  *float64 `form:"double,omitempty" json:"double,omitempty"`
}

// SetMotionGroupBehaviorParams defines parameters for SetMotionGroupBehavior.
type SetMotionGroupBehaviorParams struct {
	Behavior *Behavior `form:"behavior,omitempty" json:"behavior,omitempty"`
}

// SetOperationModeParams defines parameters for SetOperationMode.
type SetOperationModeParams struct {
	Mode SetOperationModeParamsMode `form:"mode" json:"mode"`
}

// SetOperationModeParamsMode defines parameters for SetOperationMode.
type SetOperationModeParamsMode string

// ListCoordinateSystemsParams defines parameters for ListCoordinateSystems.
type ListCoordinateSystemsParams struct {
	RotationType *RotationAngleTypes `form:"rotation_type,omitempty" json:"rotation_type,omitempty"`
}

// GetCoordinateSystemParams defines parameters for GetCoordinateSystem.
type GetCoordinateSystemParams struct {
	RotationType *RotationAngleTypes `form:"rotation_type,omitempty" json:"rotation_type,omitempty"`
}

// CreateDeviceJSONBody defines parameters for CreateDevice.
type CreateDeviceJSONBody = []CreateDeviceJSONBody_Item

// CreateDeviceJSONBody_Item defines parameters for CreateDevice.
type CreateDeviceJSONBody_Item struct {
	union json.RawMessage
}

// DefaultHomeJointsParams defines parameters for DefaultHomeJoints.
type DefaultHomeJointsParams struct {
	VirtualRobotModel string `form:"virtual_robot_model" json:"virtual_robot_model"`
}

// ActivateMotionGroupParams defines parameters for ActivateMotionGroup.
type ActivateMotionGroupParams struct {
	MotionGroup string `form:"motion_group" json:"motion_group"`
}

// ActivateAllMotionGroupsParams defines parameters for ActivateAllMotionGroups.
type ActivateAllMotionGroupsParams struct {
	Controller string `form:"controller" json:"controller"`
}

// GetOptimizerConfigurationParams defines parameters for GetOptimizerConfiguration.
type GetOptimizerConfigurationParams struct {
	Tcp *string `form:"tcp,omitempty" json:"tcp,omitempty"`
}

// GetCurrentMotionGroupStateParams defines parameters for GetCurrentMotionGroupState.
type GetCurrentMotionGroupStateParams struct {
	// Tcp The identifier of the tool center point (TCP) to be used for tcp_pose in response.
	// If not set, the flange pose is returned as tcp_pose.
	Tcp *string `form:"tcp,omitempty" json:"tcp,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the responses should be converted.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `form:"response_coordinate_system,omitempty" json:"response_coordinate_system,omitempty"`
}

// StreamMotionGroupStateParams defines parameters for StreamMotionGroupState.
type StreamMotionGroupStateParams struct {
	// ResponseRate Update rate for the response message in milliseconds (ms). Default is 200 ms.
	// We recommend to use the step rate of the controller or a multiple of the step rate as Nova updates the state in the controller's step rate as well.
	// Minimal response rate is the step rate of controller.
	ResponseRate *ResponseRate `form:"response_rate,omitempty" json:"response_rate,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the cartesian data of the responses should be converted.
	// Default is the world coordinate system.
	ResponseCoordinateSystem *ResponseCoordinateSystem `form:"response_coordinate_system,omitempty" json:"response_coordinate_system,omitempty"`

	// Tcp The identifier of the tool center point (TCP) to be used for tcp_pose in response.
	// If not set, the flange pose is returned as tcp_pose.
	Tcp *TCP `form:"tcp,omitempty" json:"tcp,omitempty"`
}

// ListTcpsParams defines parameters for ListTcps.
type ListTcpsParams struct {
	RotationType *RotationAngleTypes `form:"rotation_type,omitempty" json:"rotation_type,omitempty"`
}

// GetActiveTcpParams defines parameters for GetActiveTcp.
type GetActiveTcpParams struct {
	RotationType *RotationAngleTypes `form:"rotation_type,omitempty" json:"rotation_type,omitempty"`
}

// StreamMoveJSONBody defines parameters for StreamMove.
type StreamMoveJSONBody struct {
	union json.RawMessage
}

// StreamMoveBackwardParams defines parameters for StreamMoveBackward.
type StreamMoveBackwardParams struct {
	// PlaybackSpeedInPercent Set the velocity for executed movements of the motion in percent. A percentage of 100% means that the robot moves as
	// fast as possible without violating the limits. Setting this value does not affect the overall shape of the velocity profile.
	// Everything is slowed down by the same factor. Therefore, this should only be used for teaching and trajectory
	// evaluation purposes. If the process requires a certain velocity, the respective limits should be set when planning the motion.
	// This will not change the velocity override of the controller. The controller velocity override value shall be 100% to ensure
	// controllability of the motion group.
	PlaybackSpeedInPercent PlaybackSpeed `form:"playback_speed_in_percent" json:"playback_speed_in_percent"`

	// ResponseRate Update rate for the response message in milliseconds (ms). Default is 200 ms.
	// We recommend to use the step rate of the controller or a multiple of the step rate as Nova updates the state in the controller's step rate as well.
	// Minimal response rate is the step rate of controller.
	ResponseRate *ResponseRate `form:"response_rate,omitempty" json:"response_rate,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the cartesian data of the responses should be converted.
	// Default is the world coordinate system.
	ResponseCoordinateSystem *ResponseCoordinateSystem `form:"response_coordinate_system,omitempty" json:"response_coordinate_system,omitempty"`

	// StartLocationOnTrajectory Location the motion is requested to start at.
	// The default value is the end of the trajectory.
	// The location is a scalar value that defines a position along a path, typically ranging from 0 to `n`,
	// where `n` denotes the number of motion commands. Each integer value of the location corresponds to a specific motion command,
	// while non-integer values interpolate positions within the segments.
	// The location is calculated from the joint path.
	StartLocationOnTrajectory *float64 `form:"start_location_on_trajectory,omitempty" json:"start_location_on_trajectory,omitempty"`
}

// StreamMoveForwardParams defines parameters for StreamMoveForward.
type StreamMoveForwardParams struct {
	// PlaybackSpeedInPercent Set the velocity for executed movements of the motion in percent. A percentage of 100% means that the robot moves as
	// fast as possible without violating the limits. Setting this value does not affect the overall shape of the velocity profile.
	// Everything is slowed down by the same factor. Therefore, this should only be used for teaching and trajectory
	// evaluation purposes. If the process requires a certain velocity, the respective limits should be set when planning the motion.
	// This will not change the velocity override of the controller. The controller velocity override value shall be 100% to ensure
	// controllability of the motion group.
	PlaybackSpeedInPercent PlaybackSpeed `form:"playback_speed_in_percent" json:"playback_speed_in_percent"`

	// ResponseRate Update rate for the response message in milliseconds (ms). Default is 200 ms.
	// We recommend to use the step rate of the controller or a multiple of the step rate as Nova updates the state in the controller's step rate as well.
	// Minimal response rate is the step rate of controller.
	ResponseRate *ResponseRate `form:"response_rate,omitempty" json:"response_rate,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the cartesian data of the responses should be converted.
	// Default is the world coordinate system.
	ResponseCoordinateSystem *ResponseCoordinateSystem `form:"response_coordinate_system,omitempty" json:"response_coordinate_system,omitempty"`

	// StartLocationOnTrajectory Location the motion is requested to start at.
	// The default value is the begin of the trajectory.
	// The location is a scalar value that defines a position along a path, typically ranging from 0 to `n`,
	// where `n` denotes the number of motion commands. Each integer value of the location corresponds to a specific motion command,
	// while non-integer values interpolate positions within the segments.
	// The location is calculated from the joint path.
	StartLocationOnTrajectory *float64 `form:"start_location_on_trajectory,omitempty" json:"start_location_on_trajectory,omitempty"`
}

// StreamMoveToTrajectoryViaJointPTPParams defines parameters for StreamMoveToTrajectoryViaJointPTP.
type StreamMoveToTrajectoryViaJointPTPParams struct {
	LocationOnTrajectory float64 `form:"location_on_trajectory" json:"location_on_trajectory"`

	// LimitOverrideJointVelocityLimitsJoints The joint velocity limits for the p2p motion to a previously planned motion.
	LimitOverrideJointVelocityLimitsJoints *[]float64 `form:"limit_override.joint_velocity_limits.joints,omitempty" json:"limit_override.joint_velocity_limits.joints,omitempty"`

	// LimitOverrideJointAccelerationLimitsJoints The joint acceleration limits for the p2p motion to a previously planned motion.
	LimitOverrideJointAccelerationLimitsJoints *[]float64 `form:"limit_override.joint_acceleration_limits.joints,omitempty" json:"limit_override.joint_acceleration_limits.joints,omitempty"`

	// LimitOverrideTcpVelocityLimit Maximum allowed TCP velocity in [mm/s].
	LimitOverrideTcpVelocityLimit *float64 `form:"limit_override.tcp_velocity_limit,omitempty" json:"limit_override.tcp_velocity_limit,omitempty"`

	// LimitOverrideTcpAccelerationLimit Maximum allowed TCP acceleration in [mm/s^2].
	LimitOverrideTcpAccelerationLimit *float64 `form:"limit_override.tcp_acceleration_limit,omitempty" json:"limit_override.tcp_acceleration_limit,omitempty"`

	// LimitOverrideTcpOrientationVelocityLimit Maximum allowed TCP rotation velocity in [rad/s].
	LimitOverrideTcpOrientationVelocityLimit *float64 `form:"limit_override.tcp_orientation_velocity_limit,omitempty" json:"limit_override.tcp_orientation_velocity_limit,omitempty"`

	// LimitOverrideTcpOrientationAccelerationLimit Maximum allowed TCP rotation acceleration in [rad/s^2].
	LimitOverrideTcpOrientationAccelerationLimit *float64 `form:"limit_override.tcp_orientation_acceleration_limit,omitempty" json:"limit_override.tcp_orientation_acceleration_limit,omitempty"`
	ResponsesCoordinateSystem                    *string  `form:"responses_coordinate_system,omitempty" json:"responses_coordinate_system,omitempty"`
}

// GetPlannedMotionParams defines parameters for GetPlannedMotion.
type GetPlannedMotionParams struct {
	// SampleTime -| The value of `sample_time` is the time in milliseconds (ms) between each datapoint of the planned motion. Optional. If not provided, the data is returned as it is stored internally and equidistant sampling is not guaranteed.
	SampleTime *uint32 `form:"sample_time,omitempty" json:"sample_time,omitempty"`
}

// GetMotionTrajectoryParams defines parameters for GetMotionTrajectory.
type GetMotionTrajectoryParams struct {
	// SampleTime The value of `sample_time` is the time in milliseconds (ms) between each point in the trajectory.
	SampleTime uint32 `form:"sample_time" json:"sample_time"`

	// ResponsesCoordinateSystem Unique identifier addressing a coordinate system to which the cartesian data of the responses should be converted.
	// Default: world coordinate system.
	ResponsesCoordinateSystem *string `form:"responses_coordinate_system,omitempty" json:"responses_coordinate_system,omitempty"`
}

// GetMotionTrajectorySampleParams defines parameters for GetMotionTrajectorySample.
type GetMotionTrajectorySampleParams struct {
	LocationOnTrajectory *float64 `form:"location_on_trajectory,omitempty" json:"location_on_trajectory,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system in which the cartesian data of the response should be converted to.
	// Default is the world coordinate system.
	ResponseCoordinateSystem *string `form:"response_coordinate_system,omitempty" json:"response_coordinate_system,omitempty"`
}

// CreateProgramsValueJSONBody defines parameters for CreateProgramsValue.
type CreateProgramsValueJSONBody map[string]CreateProgramsValueJSONBody_AdditionalProperties

// CreateProgramsValueJSONBody0 defines parameters for CreateProgramsValue.
type CreateProgramsValueJSONBody0 = float32

// CreateProgramsValueJSONBody1 defines parameters for CreateProgramsValue.
type CreateProgramsValueJSONBody1 = int

// CreateProgramsValueJSONBody2 defines parameters for CreateProgramsValue.
type CreateProgramsValueJSONBody2 = string

// CreateProgramsValueJSONBody3 defines parameters for CreateProgramsValue.
type CreateProgramsValueJSONBody3 = openapi_types.File

// CreateProgramsValueJSONBody_AdditionalProperties defines parameters for CreateProgramsValue.
type CreateProgramsValueJSONBody_AdditionalProperties struct {
	union json.RawMessage
}

// UpdateProgramValueJSONBody defines parameters for UpdateProgramValue.
type UpdateProgramValueJSONBody struct {
	union json.RawMessage
}

// UpdateProgramValueJSONBody0 defines parameters for UpdateProgramValue.
type UpdateProgramValueJSONBody0 = float32

// UpdateProgramValueJSONBody1 defines parameters for UpdateProgramValue.
type UpdateProgramValueJSONBody1 = int

// UpdateProgramValueJSONBody2 defines parameters for UpdateProgramValue.
type UpdateProgramValueJSONBody2 = string

// UpdateProgramValueJSONBody3 defines parameters for UpdateProgramValue.
type UpdateProgramValueJSONBody3 = openapi_types.File

// StoreObjectMultipartBody defines parameters for StoreObject.
type StoreObjectMultipartBody struct {
	AnyValue *interface{} `json:"AnyValue,omitempty"`
}

// StoreObjectParams defines parameters for StoreObject.
type StoreObjectParams struct {
	XMetadata *map[string]string `json:"X-Metadata,omitempty"`
}

// DeleteProgramListParams defines parameters for DeleteProgramList.
type DeleteProgramListParams struct {
	// ProgramIds Recieved from [listProgramMetadata](listProgramMetadata) or from the response of [createProgram](createProgram).
	ProgramIds []string `form:"program_ids" json:"program_ids"`
}

// ListProgramMetadataParams defines parameters for ListProgramMetadata.
type ListProgramMetadataParams struct {
	// ShowHidden If true, hidden programs, where the `is_hidden` flag is active, are included in the list.
	ShowHidden *bool `form:"show_hidden,omitempty" json:"show_hidden,omitempty"`
}

// CreateProgramTextBody defines parameters for CreateProgram.
type CreateProgramTextBody = string

// CreateProgramParams defines parameters for CreateProgram.
type CreateProgramParams struct {
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// UpdateProgramTextBody defines parameters for UpdateProgram.
type UpdateProgramTextBody = string

// DeleteRecipeListParams defines parameters for DeleteRecipeList.
type DeleteRecipeListParams struct {
	// RecipeIds Recieved from [listRecipeMetadata](listRecipeMetadata) or from the response of [createRecipe](createRecipe)
	RecipeIds []string `form:"recipe_ids" json:"recipe_ids"`
}

// CreateRecipeJSONBody defines parameters for CreateRecipe.
type CreateRecipeJSONBody = map[string]interface{}

// CreateRecipeParams defines parameters for CreateRecipe.
type CreateRecipeParams struct {
	// ProgramId The identifier of the program the recipe will be associated with.
	ProgramId string `form:"program_id" json:"program_id"`

	// Name If no inital name is set a default name based on the program and timestamp is created.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// UpdateRecipeJSONBody defines parameters for UpdateRecipe.
type UpdateRecipeJSONBody = map[string]interface{}

// InternalDeployCellParams defines parameters for InternalDeployCell.
type InternalDeployCellParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// InternalDeleteCellParams defines parameters for InternalDeleteCell.
type InternalDeleteCellParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// InternalUpdateCellParams defines parameters for InternalUpdateCell.
type InternalUpdateCellParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// InternalClearAppsParams defines parameters for InternalClearApps.
type InternalClearAppsParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// InternalAddAppParams defines parameters for InternalAddApp.
type InternalAddAppParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// InternalDeleteAppParams defines parameters for InternalDeleteApp.
type InternalDeleteAppParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// InternalUpdateAppParams defines parameters for InternalUpdateApp.
type InternalUpdateAppParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// InternalClearRobotControllersParams defines parameters for InternalClearRobotControllers.
type InternalClearRobotControllersParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// InternalAddRobotControllerParams defines parameters for InternalAddRobotController.
type InternalAddRobotControllerParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// InternalDeleteRobotControllerParams defines parameters for InternalDeleteRobotController.
type InternalDeleteRobotControllerParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// InternalUpdateRobotControllerParams defines parameters for InternalUpdateRobotController.
type InternalUpdateRobotControllerParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// InternalUpdateFoundationServicesParams defines parameters for InternalUpdateFoundationServices.
type InternalUpdateFoundationServicesParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// InternalCheckNovaVersionUpdateParams defines parameters for InternalCheckNovaVersionUpdate.
type InternalCheckNovaVersionUpdateParams struct {
	Channel ReleaseChannel `form:"channel" json:"channel"`
}

// InternalUpdateNovaVersionJSONBody defines parameters for InternalUpdateNovaVersion.
type InternalUpdateNovaVersionJSONBody struct {
	// Channel The channel that defines what a new Wandelbots Nova version is.
	//
	//   * `next` the over all latest version
	//   * `stable` newes patch of the current version
	Channel ReleaseChannel `json:"channel"`
}

// SetOutputValuesJSONRequestBody defines body for SetOutputValues for application/json ContentType.
type SetOutputValuesJSONRequestBody = SetOutputValuesJSONBody

// AddVirtualRobotCoordinateSystemJSONRequestBody defines body for AddVirtualRobotCoordinateSystem for application/json ContentType.
type AddVirtualRobotCoordinateSystemJSONRequestBody = CoordinateSystem

// ExternalJointsStreamJSONRequestBody defines body for ExternalJointsStream for application/json ContentType.
type ExternalJointsStreamJSONRequestBody = ExternalJointStreamDatapoint

// SetMotionGroupStateJSONRequestBody defines body for SetMotionGroupState for application/json ContentType.
type SetMotionGroupStateJSONRequestBody = MotionGroupJoints

// SetVirtualRobotMountingJSONRequestBody defines body for SetVirtualRobotMounting for application/json ContentType.
type SetVirtualRobotMountingJSONRequestBody = CoordinateSystem

// AddVirtualRobotTcpJSONRequestBody defines body for AddVirtualRobotTcp for application/json ContentType.
type AddVirtualRobotTcpJSONRequestBody = RobotTcp

// AddCoordinateSystemJSONRequestBody defines body for AddCoordinateSystem for application/json ContentType.
type AddCoordinateSystemJSONRequestBody = AddRequest

// TransformInCoordinateSystemJSONRequestBody defines body for TransformInCoordinateSystem for application/json ContentType.
type TransformInCoordinateSystemJSONRequestBody = Pose

// CreateDeviceJSONRequestBody defines body for CreateDevice for application/json ContentType.
type CreateDeviceJSONRequestBody = CreateDeviceJSONBody

// JointJoggingJSONRequestBody defines body for JointJogging for application/json ContentType.
type JointJoggingJSONRequestBody = JointJoggingRequest

// DirectionJoggingJSONRequestBody defines body for DirectionJogging for application/json ContentType.
type DirectionJoggingJSONRequestBody = DirectionJoggingRequest

// CalculateAllInverseKinematicJSONRequestBody defines body for CalculateAllInverseKinematic for application/json ContentType.
type CalculateAllInverseKinematicJSONRequestBody = AllJointPositionsRequest

// CalculateInverseKinematicJSONRequestBody defines body for CalculateInverseKinematic for application/json ContentType.
type CalculateInverseKinematicJSONRequestBody = JointPositionRequest

// CalculateForwardKinematicJSONRequestBody defines body for CalculateForwardKinematic for application/json ContentType.
type CalculateForwardKinematicJSONRequestBody = TcpPoseRequest

// PlanTrajectoryJSONRequestBody defines body for PlanTrajectory for application/json ContentType.
type PlanTrajectoryJSONRequestBody = PlanTrajectoryRequest

// PlanMotionJSONRequestBody defines body for PlanMotion for application/json ContentType.
type PlanMotionJSONRequestBody = PlanRequest

// StreamMoveJSONRequestBody defines body for StreamMove for application/json ContentType.
type StreamMoveJSONRequestBody StreamMoveJSONBody

// LoadPlannedMotionJSONRequestBody defines body for LoadPlannedMotion for application/json ContentType.
type LoadPlannedMotionJSONRequestBody = PlannedMotion

// CreateProgramsValueJSONRequestBody defines body for CreateProgramsValue for application/json ContentType.
type CreateProgramsValueJSONRequestBody CreateProgramsValueJSONBody

// UpdateProgramValueJSONRequestBody defines body for UpdateProgramValue for application/json ContentType.
type UpdateProgramValueJSONRequestBody UpdateProgramValueJSONBody

// StoreColliderJSONRequestBody defines body for StoreCollider for application/json ContentType.
type StoreColliderJSONRequestBody = Collider

// StoreCollisionLinkChainJSONRequestBody defines body for StoreCollisionLinkChain for application/json ContentType.
type StoreCollisionLinkChainJSONRequestBody = LinkChain

// StoreCollisionSceneJSONRequestBody defines body for StoreCollisionScene for application/json ContentType.
type StoreCollisionSceneJSONRequestBody = CollisionSceneAssembly

// StoreCollisionToolJSONRequestBody defines body for StoreCollisionTool for application/json ContentType.
type StoreCollisionToolJSONRequestBody = Tool

// StoreObjectMultipartRequestBody defines body for StoreObject for multipart/form-data ContentType.
type StoreObjectMultipartRequestBody StoreObjectMultipartBody

// CreateProgramTextRequestBody defines body for CreateProgram for text/plain ContentType.
type CreateProgramTextRequestBody = CreateProgramTextBody

// UpdateProgramTextRequestBody defines body for UpdateProgram for text/plain ContentType.
type UpdateProgramTextRequestBody = UpdateProgramTextBody

// UpdateProgramMetadataJSONRequestBody defines body for UpdateProgramMetadata for application/json ContentType.
type UpdateProgramMetadataJSONRequestBody = UpdateProgramMetadataRequest

// UploadProgramMetadataImageMultipartRequestBody defines body for UploadProgramMetadataImage for multipart/form-data ContentType.
type UploadProgramMetadataImageMultipartRequestBody = BodyUploadProgramMetadataImage

// CreateRecipeJSONRequestBody defines body for CreateRecipe for application/json ContentType.
type CreateRecipeJSONRequestBody = CreateRecipeJSONBody

// UpdateRecipeJSONRequestBody defines body for UpdateRecipe for application/json ContentType.
type UpdateRecipeJSONRequestBody = UpdateRecipeJSONBody

// UpdateRecipeMetadataJSONRequestBody defines body for UpdateRecipeMetadata for application/json ContentType.
type UpdateRecipeMetadataJSONRequestBody = UpdateRecipeMetadataRequest

// UploadRecipeMetadataImageMultipartRequestBody defines body for UploadRecipeMetadataImage for multipart/form-data ContentType.
type UploadRecipeMetadataImageMultipartRequestBody = BodyUploadRecipeMetadataImage

// InternalDeployCellJSONRequestBody defines body for InternalDeployCell for application/json ContentType.
type InternalDeployCellJSONRequestBody = InternalCell

// InternalUpdateCellJSONRequestBody defines body for InternalUpdateCell for application/json ContentType.
type InternalUpdateCellJSONRequestBody = InternalCell

// InternalAddAppJSONRequestBody defines body for InternalAddApp for application/json ContentType.
type InternalAddAppJSONRequestBody = App

// InternalUpdateAppJSONRequestBody defines body for InternalUpdateApp for application/json ContentType.
type InternalUpdateAppJSONRequestBody = App

// InternalAddRobotControllerJSONRequestBody defines body for InternalAddRobotController for application/json ContentType.
type InternalAddRobotControllerJSONRequestBody = InternalRobotController

// InternalUpdateRobotControllerJSONRequestBody defines body for InternalUpdateRobotController for application/json ContentType.
type InternalUpdateRobotControllerJSONRequestBody = InternalRobotController

// InternalUpdateFoundationServicesJSONRequestBody defines body for InternalUpdateFoundationServices for application/json ContentType.
type InternalUpdateFoundationServicesJSONRequestBody = FoundationServices

// RegisterControllerJSONRequestBody defines body for RegisterController for application/json ContentType.
type RegisterControllerJSONRequestBody = ControllerRequest

// InternalUpdateNovaVersionJSONRequestBody defines body for InternalUpdateNovaVersion for application/json ContentType.
type InternalUpdateNovaVersionJSONRequestBody InternalUpdateNovaVersionJSONBody

// Getter for additional properties for GoogleProtobufAny. Returns the specified
// element and whether it was found
func (a GoogleProtobufAny) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GoogleProtobufAny
func (a *GoogleProtobufAny) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a *GoogleProtobufAny) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["@type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading '@type': %w", err)
		}
		delete(object, "@type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a GoogleProtobufAny) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Type != nil {
		object["@type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsArrayInputArray0 returns the union data inside the ArrayInput_Array_Item as a ArrayInputArray0
func (t ArrayInput_Array_Item) AsArrayInputArray0() (ArrayInputArray0, error) {
	var body ArrayInputArray0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayInputArray0 overwrites any union data inside the ArrayInput_Array_Item as the provided ArrayInputArray0
func (t *ArrayInput_Array_Item) FromArrayInputArray0(v ArrayInputArray0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayInputArray0 performs a merge with any union data inside the ArrayInput_Array_Item, using the provided ArrayInputArray0
func (t *ArrayInput_Array_Item) MergeArrayInputArray0(v ArrayInputArray0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayInputArray1 returns the union data inside the ArrayInput_Array_Item as a ArrayInputArray1
func (t ArrayInput_Array_Item) AsArrayInputArray1() (ArrayInputArray1, error) {
	var body ArrayInputArray1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayInputArray1 overwrites any union data inside the ArrayInput_Array_Item as the provided ArrayInputArray1
func (t *ArrayInput_Array_Item) FromArrayInputArray1(v ArrayInputArray1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayInputArray1 performs a merge with any union data inside the ArrayInput_Array_Item, using the provided ArrayInputArray1
func (t *ArrayInput_Array_Item) MergeArrayInputArray1(v ArrayInputArray1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayInputArray2 returns the union data inside the ArrayInput_Array_Item as a ArrayInputArray2
func (t ArrayInput_Array_Item) AsArrayInputArray2() (ArrayInputArray2, error) {
	var body ArrayInputArray2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayInputArray2 overwrites any union data inside the ArrayInput_Array_Item as the provided ArrayInputArray2
func (t *ArrayInput_Array_Item) FromArrayInputArray2(v ArrayInputArray2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayInputArray2 performs a merge with any union data inside the ArrayInput_Array_Item, using the provided ArrayInputArray2
func (t *ArrayInput_Array_Item) MergeArrayInputArray2(v ArrayInputArray2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayInputArray3 returns the union data inside the ArrayInput_Array_Item as a ArrayInputArray3
func (t ArrayInput_Array_Item) AsArrayInputArray3() (ArrayInputArray3, error) {
	var body ArrayInputArray3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayInputArray3 overwrites any union data inside the ArrayInput_Array_Item as the provided ArrayInputArray3
func (t *ArrayInput_Array_Item) FromArrayInputArray3(v ArrayInputArray3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayInputArray3 performs a merge with any union data inside the ArrayInput_Array_Item, using the provided ArrayInputArray3
func (t *ArrayInput_Array_Item) MergeArrayInputArray3(v ArrayInputArray3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPyjectoryDatatypesSerializerPose returns the union data inside the ArrayInput_Array_Item as a PyjectoryDatatypesSerializerPose
func (t ArrayInput_Array_Item) AsPyjectoryDatatypesSerializerPose() (PyjectoryDatatypesSerializerPose, error) {
	var body PyjectoryDatatypesSerializerPose
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPyjectoryDatatypesSerializerPose overwrites any union data inside the ArrayInput_Array_Item as the provided PyjectoryDatatypesSerializerPose
func (t *ArrayInput_Array_Item) FromPyjectoryDatatypesSerializerPose(v PyjectoryDatatypesSerializerPose) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePyjectoryDatatypesSerializerPose performs a merge with any union data inside the ArrayInput_Array_Item, using the provided PyjectoryDatatypesSerializerPose
func (t *ArrayInput_Array_Item) MergePyjectoryDatatypesSerializerPose(v PyjectoryDatatypesSerializerPose) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPyjectoryDatatypesSerializerPosition returns the union data inside the ArrayInput_Array_Item as a PyjectoryDatatypesSerializerPosition
func (t ArrayInput_Array_Item) AsPyjectoryDatatypesSerializerPosition() (PyjectoryDatatypesSerializerPosition, error) {
	var body PyjectoryDatatypesSerializerPosition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPyjectoryDatatypesSerializerPosition overwrites any union data inside the ArrayInput_Array_Item as the provided PyjectoryDatatypesSerializerPosition
func (t *ArrayInput_Array_Item) FromPyjectoryDatatypesSerializerPosition(v PyjectoryDatatypesSerializerPosition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePyjectoryDatatypesSerializerPosition performs a merge with any union data inside the ArrayInput_Array_Item, using the provided PyjectoryDatatypesSerializerPosition
func (t *ArrayInput_Array_Item) MergePyjectoryDatatypesSerializerPosition(v PyjectoryDatatypesSerializerPosition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPyjectoryDatatypesSerializerOrientation returns the union data inside the ArrayInput_Array_Item as a PyjectoryDatatypesSerializerOrientation
func (t ArrayInput_Array_Item) AsPyjectoryDatatypesSerializerOrientation() (PyjectoryDatatypesSerializerOrientation, error) {
	var body PyjectoryDatatypesSerializerOrientation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPyjectoryDatatypesSerializerOrientation overwrites any union data inside the ArrayInput_Array_Item as the provided PyjectoryDatatypesSerializerOrientation
func (t *ArrayInput_Array_Item) FromPyjectoryDatatypesSerializerOrientation(v PyjectoryDatatypesSerializerOrientation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePyjectoryDatatypesSerializerOrientation performs a merge with any union data inside the ArrayInput_Array_Item, using the provided PyjectoryDatatypesSerializerOrientation
func (t *ArrayInput_Array_Item) MergePyjectoryDatatypesSerializerOrientation(v PyjectoryDatatypesSerializerOrientation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapture returns the union data inside the ArrayInput_Array_Item as a Capture
func (t ArrayInput_Array_Item) AsCapture() (Capture, error) {
	var body Capture
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapture overwrites any union data inside the ArrayInput_Array_Item as the provided Capture
func (t *ArrayInput_Array_Item) FromCapture(v Capture) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapture performs a merge with any union data inside the ArrayInput_Array_Item, using the provided Capture
func (t *ArrayInput_Array_Item) MergeCapture(v Capture) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPointCloud returns the union data inside the ArrayInput_Array_Item as a PointCloud
func (t ArrayInput_Array_Item) AsPointCloud() (PointCloud, error) {
	var body PointCloud
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPointCloud overwrites any union data inside the ArrayInput_Array_Item as the provided PointCloud
func (t *ArrayInput_Array_Item) FromPointCloud(v PointCloud) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePointCloud performs a merge with any union data inside the ArrayInput_Array_Item, using the provided PointCloud
func (t *ArrayInput_Array_Item) MergePointCloud(v PointCloud) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayInput returns the union data inside the ArrayInput_Array_Item as a ArrayInput
func (t ArrayInput_Array_Item) AsArrayInput() (ArrayInput, error) {
	var body ArrayInput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayInput overwrites any union data inside the ArrayInput_Array_Item as the provided ArrayInput
func (t *ArrayInput_Array_Item) FromArrayInput(v ArrayInput) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayInput performs a merge with any union data inside the ArrayInput_Array_Item, using the provided ArrayInput
func (t *ArrayInput_Array_Item) MergeArrayInput(v ArrayInput) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ArrayInput_Array_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ArrayInput_Array_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsArrayOutputArray0 returns the union data inside the ArrayOutput_Array_Item as a ArrayOutputArray0
func (t ArrayOutput_Array_Item) AsArrayOutputArray0() (ArrayOutputArray0, error) {
	var body ArrayOutputArray0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayOutputArray0 overwrites any union data inside the ArrayOutput_Array_Item as the provided ArrayOutputArray0
func (t *ArrayOutput_Array_Item) FromArrayOutputArray0(v ArrayOutputArray0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayOutputArray0 performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided ArrayOutputArray0
func (t *ArrayOutput_Array_Item) MergeArrayOutputArray0(v ArrayOutputArray0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayOutputArray1 returns the union data inside the ArrayOutput_Array_Item as a ArrayOutputArray1
func (t ArrayOutput_Array_Item) AsArrayOutputArray1() (ArrayOutputArray1, error) {
	var body ArrayOutputArray1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayOutputArray1 overwrites any union data inside the ArrayOutput_Array_Item as the provided ArrayOutputArray1
func (t *ArrayOutput_Array_Item) FromArrayOutputArray1(v ArrayOutputArray1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayOutputArray1 performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided ArrayOutputArray1
func (t *ArrayOutput_Array_Item) MergeArrayOutputArray1(v ArrayOutputArray1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayOutputArray2 returns the union data inside the ArrayOutput_Array_Item as a ArrayOutputArray2
func (t ArrayOutput_Array_Item) AsArrayOutputArray2() (ArrayOutputArray2, error) {
	var body ArrayOutputArray2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayOutputArray2 overwrites any union data inside the ArrayOutput_Array_Item as the provided ArrayOutputArray2
func (t *ArrayOutput_Array_Item) FromArrayOutputArray2(v ArrayOutputArray2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayOutputArray2 performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided ArrayOutputArray2
func (t *ArrayOutput_Array_Item) MergeArrayOutputArray2(v ArrayOutputArray2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayOutputArray3 returns the union data inside the ArrayOutput_Array_Item as a ArrayOutputArray3
func (t ArrayOutput_Array_Item) AsArrayOutputArray3() (ArrayOutputArray3, error) {
	var body ArrayOutputArray3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayOutputArray3 overwrites any union data inside the ArrayOutput_Array_Item as the provided ArrayOutputArray3
func (t *ArrayOutput_Array_Item) FromArrayOutputArray3(v ArrayOutputArray3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayOutputArray3 performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided ArrayOutputArray3
func (t *ArrayOutput_Array_Item) MergeArrayOutputArray3(v ArrayOutputArray3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPyjectoryDatatypesSerializerPose returns the union data inside the ArrayOutput_Array_Item as a PyjectoryDatatypesSerializerPose
func (t ArrayOutput_Array_Item) AsPyjectoryDatatypesSerializerPose() (PyjectoryDatatypesSerializerPose, error) {
	var body PyjectoryDatatypesSerializerPose
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPyjectoryDatatypesSerializerPose overwrites any union data inside the ArrayOutput_Array_Item as the provided PyjectoryDatatypesSerializerPose
func (t *ArrayOutput_Array_Item) FromPyjectoryDatatypesSerializerPose(v PyjectoryDatatypesSerializerPose) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePyjectoryDatatypesSerializerPose performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided PyjectoryDatatypesSerializerPose
func (t *ArrayOutput_Array_Item) MergePyjectoryDatatypesSerializerPose(v PyjectoryDatatypesSerializerPose) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPyjectoryDatatypesSerializerPosition returns the union data inside the ArrayOutput_Array_Item as a PyjectoryDatatypesSerializerPosition
func (t ArrayOutput_Array_Item) AsPyjectoryDatatypesSerializerPosition() (PyjectoryDatatypesSerializerPosition, error) {
	var body PyjectoryDatatypesSerializerPosition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPyjectoryDatatypesSerializerPosition overwrites any union data inside the ArrayOutput_Array_Item as the provided PyjectoryDatatypesSerializerPosition
func (t *ArrayOutput_Array_Item) FromPyjectoryDatatypesSerializerPosition(v PyjectoryDatatypesSerializerPosition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePyjectoryDatatypesSerializerPosition performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided PyjectoryDatatypesSerializerPosition
func (t *ArrayOutput_Array_Item) MergePyjectoryDatatypesSerializerPosition(v PyjectoryDatatypesSerializerPosition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPyjectoryDatatypesSerializerOrientation returns the union data inside the ArrayOutput_Array_Item as a PyjectoryDatatypesSerializerOrientation
func (t ArrayOutput_Array_Item) AsPyjectoryDatatypesSerializerOrientation() (PyjectoryDatatypesSerializerOrientation, error) {
	var body PyjectoryDatatypesSerializerOrientation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPyjectoryDatatypesSerializerOrientation overwrites any union data inside the ArrayOutput_Array_Item as the provided PyjectoryDatatypesSerializerOrientation
func (t *ArrayOutput_Array_Item) FromPyjectoryDatatypesSerializerOrientation(v PyjectoryDatatypesSerializerOrientation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePyjectoryDatatypesSerializerOrientation performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided PyjectoryDatatypesSerializerOrientation
func (t *ArrayOutput_Array_Item) MergePyjectoryDatatypesSerializerOrientation(v PyjectoryDatatypesSerializerOrientation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapture returns the union data inside the ArrayOutput_Array_Item as a Capture
func (t ArrayOutput_Array_Item) AsCapture() (Capture, error) {
	var body Capture
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapture overwrites any union data inside the ArrayOutput_Array_Item as the provided Capture
func (t *ArrayOutput_Array_Item) FromCapture(v Capture) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapture performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided Capture
func (t *ArrayOutput_Array_Item) MergeCapture(v Capture) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPointCloud returns the union data inside the ArrayOutput_Array_Item as a PointCloud
func (t ArrayOutput_Array_Item) AsPointCloud() (PointCloud, error) {
	var body PointCloud
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPointCloud overwrites any union data inside the ArrayOutput_Array_Item as the provided PointCloud
func (t *ArrayOutput_Array_Item) FromPointCloud(v PointCloud) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePointCloud performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided PointCloud
func (t *ArrayOutput_Array_Item) MergePointCloud(v PointCloud) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayOutput returns the union data inside the ArrayOutput_Array_Item as a ArrayOutput
func (t ArrayOutput_Array_Item) AsArrayOutput() (ArrayOutput, error) {
	var body ArrayOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayOutput overwrites any union data inside the ArrayOutput_Array_Item as the provided ArrayOutput
func (t *ArrayOutput_Array_Item) FromArrayOutput(v ArrayOutput) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayOutput performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided ArrayOutput
func (t *ArrayOutput_Array_Item) MergeArrayOutput(v ArrayOutput) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ArrayOutput_Array_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ArrayOutput_Array_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSphere2 returns the union data inside the Collider_Shape as a Sphere2
func (t Collider_Shape) AsSphere2() (Sphere2, error) {
	var body Sphere2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSphere2 overwrites any union data inside the Collider_Shape as the provided Sphere2
func (t *Collider_Shape) FromSphere2(v Sphere2) error {
	v.ShapeType = "sphere"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSphere2 performs a merge with any union data inside the Collider_Shape, using the provided Sphere2
func (t *Collider_Shape) MergeSphere2(v Sphere2) error {
	v.ShapeType = "sphere"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBox2 returns the union data inside the Collider_Shape as a Box2
func (t Collider_Shape) AsBox2() (Box2, error) {
	var body Box2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBox2 overwrites any union data inside the Collider_Shape as the provided Box2
func (t *Collider_Shape) FromBox2(v Box2) error {
	v.ShapeType = "box"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBox2 performs a merge with any union data inside the Collider_Shape, using the provided Box2
func (t *Collider_Shape) MergeBox2(v Box2) error {
	v.ShapeType = "box"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRectangle2 returns the union data inside the Collider_Shape as a Rectangle2
func (t Collider_Shape) AsRectangle2() (Rectangle2, error) {
	var body Rectangle2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRectangle2 overwrites any union data inside the Collider_Shape as the provided Rectangle2
func (t *Collider_Shape) FromRectangle2(v Rectangle2) error {
	v.ShapeType = "rectangle"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRectangle2 performs a merge with any union data inside the Collider_Shape, using the provided Rectangle2
func (t *Collider_Shape) MergeRectangle2(v Rectangle2) error {
	v.ShapeType = "rectangle"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlane2 returns the union data inside the Collider_Shape as a Plane2
func (t Collider_Shape) AsPlane2() (Plane2, error) {
	var body Plane2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlane2 overwrites any union data inside the Collider_Shape as the provided Plane2
func (t *Collider_Shape) FromPlane2(v Plane2) error {
	v.ShapeType = "plane"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlane2 performs a merge with any union data inside the Collider_Shape, using the provided Plane2
func (t *Collider_Shape) MergePlane2(v Plane2) error {
	v.ShapeType = "plane"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCylinder2 returns the union data inside the Collider_Shape as a Cylinder2
func (t Collider_Shape) AsCylinder2() (Cylinder2, error) {
	var body Cylinder2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCylinder2 overwrites any union data inside the Collider_Shape as the provided Cylinder2
func (t *Collider_Shape) FromCylinder2(v Cylinder2) error {
	v.ShapeType = "cylinder"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCylinder2 performs a merge with any union data inside the Collider_Shape, using the provided Cylinder2
func (t *Collider_Shape) MergeCylinder2(v Cylinder2) error {
	v.ShapeType = "cylinder"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapsule2 returns the union data inside the Collider_Shape as a Capsule2
func (t Collider_Shape) AsCapsule2() (Capsule2, error) {
	var body Capsule2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapsule2 overwrites any union data inside the Collider_Shape as the provided Capsule2
func (t *Collider_Shape) FromCapsule2(v Capsule2) error {
	v.ShapeType = "capsule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapsule2 performs a merge with any union data inside the Collider_Shape, using the provided Capsule2
func (t *Collider_Shape) MergeCapsule2(v Capsule2) error {
	v.ShapeType = "capsule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRectangularCapsule2 returns the union data inside the Collider_Shape as a RectangularCapsule2
func (t Collider_Shape) AsRectangularCapsule2() (RectangularCapsule2, error) {
	var body RectangularCapsule2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRectangularCapsule2 overwrites any union data inside the Collider_Shape as the provided RectangularCapsule2
func (t *Collider_Shape) FromRectangularCapsule2(v RectangularCapsule2) error {
	v.ShapeType = "rectangular_capsule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRectangularCapsule2 performs a merge with any union data inside the Collider_Shape, using the provided RectangularCapsule2
func (t *Collider_Shape) MergeRectangularCapsule2(v RectangularCapsule2) error {
	v.ShapeType = "rectangular_capsule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConvexHull2 returns the union data inside the Collider_Shape as a ConvexHull2
func (t Collider_Shape) AsConvexHull2() (ConvexHull2, error) {
	var body ConvexHull2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConvexHull2 overwrites any union data inside the Collider_Shape as the provided ConvexHull2
func (t *Collider_Shape) FromConvexHull2(v ConvexHull2) error {
	v.ShapeType = "convex_hull"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConvexHull2 performs a merge with any union data inside the Collider_Shape, using the provided ConvexHull2
func (t *Collider_Shape) MergeConvexHull2(v ConvexHull2) error {
	v.ShapeType = "convex_hull"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Collider_Shape) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"shape_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Collider_Shape) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "box":
		return t.AsBox2()
	case "capsule":
		return t.AsCapsule2()
	case "convex_hull":
		return t.AsConvexHull2()
	case "cylinder":
		return t.AsCylinder2()
	case "plane":
		return t.AsPlane2()
	case "rectangle":
		return t.AsRectangle2()
	case "rectangular_capsule":
		return t.AsRectangularCapsule2()
	case "sphere":
		return t.AsSphere2()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Collider_Shape) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Collider_Shape) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSphere3 returns the union data inside the ColliderInput_Shape as a Sphere3
func (t ColliderInput_Shape) AsSphere3() (Sphere3, error) {
	var body Sphere3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSphere3 overwrites any union data inside the ColliderInput_Shape as the provided Sphere3
func (t *ColliderInput_Shape) FromSphere3(v Sphere3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSphere3 performs a merge with any union data inside the ColliderInput_Shape, using the provided Sphere3
func (t *ColliderInput_Shape) MergeSphere3(v Sphere3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBox3 returns the union data inside the ColliderInput_Shape as a Box3
func (t ColliderInput_Shape) AsBox3() (Box3, error) {
	var body Box3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBox3 overwrites any union data inside the ColliderInput_Shape as the provided Box3
func (t *ColliderInput_Shape) FromBox3(v Box3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBox3 performs a merge with any union data inside the ColliderInput_Shape, using the provided Box3
func (t *ColliderInput_Shape) MergeBox3(v Box3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRectangle3 returns the union data inside the ColliderInput_Shape as a Rectangle3
func (t ColliderInput_Shape) AsRectangle3() (Rectangle3, error) {
	var body Rectangle3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRectangle3 overwrites any union data inside the ColliderInput_Shape as the provided Rectangle3
func (t *ColliderInput_Shape) FromRectangle3(v Rectangle3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRectangle3 performs a merge with any union data inside the ColliderInput_Shape, using the provided Rectangle3
func (t *ColliderInput_Shape) MergeRectangle3(v Rectangle3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlane3 returns the union data inside the ColliderInput_Shape as a Plane3
func (t ColliderInput_Shape) AsPlane3() (Plane3, error) {
	var body Plane3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlane3 overwrites any union data inside the ColliderInput_Shape as the provided Plane3
func (t *ColliderInput_Shape) FromPlane3(v Plane3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlane3 performs a merge with any union data inside the ColliderInput_Shape, using the provided Plane3
func (t *ColliderInput_Shape) MergePlane3(v Plane3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCylinder3 returns the union data inside the ColliderInput_Shape as a Cylinder3
func (t ColliderInput_Shape) AsCylinder3() (Cylinder3, error) {
	var body Cylinder3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCylinder3 overwrites any union data inside the ColliderInput_Shape as the provided Cylinder3
func (t *ColliderInput_Shape) FromCylinder3(v Cylinder3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCylinder3 performs a merge with any union data inside the ColliderInput_Shape, using the provided Cylinder3
func (t *ColliderInput_Shape) MergeCylinder3(v Cylinder3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapsule3 returns the union data inside the ColliderInput_Shape as a Capsule3
func (t ColliderInput_Shape) AsCapsule3() (Capsule3, error) {
	var body Capsule3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapsule3 overwrites any union data inside the ColliderInput_Shape as the provided Capsule3
func (t *ColliderInput_Shape) FromCapsule3(v Capsule3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapsule3 performs a merge with any union data inside the ColliderInput_Shape, using the provided Capsule3
func (t *ColliderInput_Shape) MergeCapsule3(v Capsule3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRectangularCapsule3 returns the union data inside the ColliderInput_Shape as a RectangularCapsule3
func (t ColliderInput_Shape) AsRectangularCapsule3() (RectangularCapsule3, error) {
	var body RectangularCapsule3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRectangularCapsule3 overwrites any union data inside the ColliderInput_Shape as the provided RectangularCapsule3
func (t *ColliderInput_Shape) FromRectangularCapsule3(v RectangularCapsule3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRectangularCapsule3 performs a merge with any union data inside the ColliderInput_Shape, using the provided RectangularCapsule3
func (t *ColliderInput_Shape) MergeRectangularCapsule3(v RectangularCapsule3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConvexHull3 returns the union data inside the ColliderInput_Shape as a ConvexHull3
func (t ColliderInput_Shape) AsConvexHull3() (ConvexHull3, error) {
	var body ConvexHull3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConvexHull3 overwrites any union data inside the ColliderInput_Shape as the provided ConvexHull3
func (t *ColliderInput_Shape) FromConvexHull3(v ConvexHull3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConvexHull3 performs a merge with any union data inside the ColliderInput_Shape, using the provided ConvexHull3
func (t *ColliderInput_Shape) MergeConvexHull3(v ConvexHull3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ColliderInput_Shape) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ColliderInput_Shape) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAbbController returns the union data inside the InternalControllerConfig as a AbbController
func (t InternalControllerConfig) AsAbbController() (AbbController, error) {
	var body AbbController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbbController overwrites any union data inside the InternalControllerConfig as the provided AbbController
func (t *InternalControllerConfig) FromAbbController(v AbbController) error {
	v.Kind = "AbbController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbbController performs a merge with any union data inside the InternalControllerConfig, using the provided AbbController
func (t *InternalControllerConfig) MergeAbbController(v AbbController) error {
	v.Kind = "AbbController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInternalAbbController returns the union data inside the InternalControllerConfig as a InternalAbbController
func (t InternalControllerConfig) AsInternalAbbController() (InternalAbbController, error) {
	var body InternalAbbController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInternalAbbController overwrites any union data inside the InternalControllerConfig as the provided InternalAbbController
func (t *InternalControllerConfig) FromInternalAbbController(v InternalAbbController) error {
	v.Kind = "InternalAbbController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInternalAbbController performs a merge with any union data inside the InternalControllerConfig, using the provided InternalAbbController
func (t *InternalControllerConfig) MergeInternalAbbController(v InternalAbbController) error {
	v.Kind = "InternalAbbController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFanucController returns the union data inside the InternalControllerConfig as a FanucController
func (t InternalControllerConfig) AsFanucController() (FanucController, error) {
	var body FanucController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFanucController overwrites any union data inside the InternalControllerConfig as the provided FanucController
func (t *InternalControllerConfig) FromFanucController(v FanucController) error {
	v.Kind = "FanucController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFanucController performs a merge with any union data inside the InternalControllerConfig, using the provided FanucController
func (t *InternalControllerConfig) MergeFanucController(v FanucController) error {
	v.Kind = "FanucController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInternalFanucController returns the union data inside the InternalControllerConfig as a InternalFanucController
func (t InternalControllerConfig) AsInternalFanucController() (InternalFanucController, error) {
	var body InternalFanucController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInternalFanucController overwrites any union data inside the InternalControllerConfig as the provided InternalFanucController
func (t *InternalControllerConfig) FromInternalFanucController(v InternalFanucController) error {
	v.Kind = "InternalFanucController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInternalFanucController performs a merge with any union data inside the InternalControllerConfig, using the provided InternalFanucController
func (t *InternalControllerConfig) MergeInternalFanucController(v InternalFanucController) error {
	v.Kind = "InternalFanucController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKukaController returns the union data inside the InternalControllerConfig as a KukaController
func (t InternalControllerConfig) AsKukaController() (KukaController, error) {
	var body KukaController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKukaController overwrites any union data inside the InternalControllerConfig as the provided KukaController
func (t *InternalControllerConfig) FromKukaController(v KukaController) error {
	v.Kind = "KukaController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKukaController performs a merge with any union data inside the InternalControllerConfig, using the provided KukaController
func (t *InternalControllerConfig) MergeKukaController(v KukaController) error {
	v.Kind = "KukaController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInternalKukaController returns the union data inside the InternalControllerConfig as a InternalKukaController
func (t InternalControllerConfig) AsInternalKukaController() (InternalKukaController, error) {
	var body InternalKukaController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInternalKukaController overwrites any union data inside the InternalControllerConfig as the provided InternalKukaController
func (t *InternalControllerConfig) FromInternalKukaController(v InternalKukaController) error {
	v.Kind = "InternalKukaController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInternalKukaController performs a merge with any union data inside the InternalControllerConfig, using the provided InternalKukaController
func (t *InternalControllerConfig) MergeInternalKukaController(v InternalKukaController) error {
	v.Kind = "InternalKukaController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUniversalrobotsController returns the union data inside the InternalControllerConfig as a UniversalrobotsController
func (t InternalControllerConfig) AsUniversalrobotsController() (UniversalrobotsController, error) {
	var body UniversalrobotsController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUniversalrobotsController overwrites any union data inside the InternalControllerConfig as the provided UniversalrobotsController
func (t *InternalControllerConfig) FromUniversalrobotsController(v UniversalrobotsController) error {
	v.Kind = "UniversalrobotsController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUniversalrobotsController performs a merge with any union data inside the InternalControllerConfig, using the provided UniversalrobotsController
func (t *InternalControllerConfig) MergeUniversalrobotsController(v UniversalrobotsController) error {
	v.Kind = "UniversalrobotsController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualController returns the union data inside the InternalControllerConfig as a VirtualController
func (t InternalControllerConfig) AsVirtualController() (VirtualController, error) {
	var body VirtualController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualController overwrites any union data inside the InternalControllerConfig as the provided VirtualController
func (t *InternalControllerConfig) FromVirtualController(v VirtualController) error {
	v.Kind = "VirtualController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualController performs a merge with any union data inside the InternalControllerConfig, using the provided VirtualController
func (t *InternalControllerConfig) MergeVirtualController(v VirtualController) error {
	v.Kind = "VirtualController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInternalVirtualController returns the union data inside the InternalControllerConfig as a InternalVirtualController
func (t InternalControllerConfig) AsInternalVirtualController() (InternalVirtualController, error) {
	var body InternalVirtualController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInternalVirtualController overwrites any union data inside the InternalControllerConfig as the provided InternalVirtualController
func (t *InternalControllerConfig) FromInternalVirtualController(v InternalVirtualController) error {
	v.Kind = "InternalVirtualController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInternalVirtualController performs a merge with any union data inside the InternalControllerConfig, using the provided InternalVirtualController
func (t *InternalControllerConfig) MergeInternalVirtualController(v InternalVirtualController) error {
	v.Kind = "InternalVirtualController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsYaskawaController returns the union data inside the InternalControllerConfig as a YaskawaController
func (t InternalControllerConfig) AsYaskawaController() (YaskawaController, error) {
	var body YaskawaController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromYaskawaController overwrites any union data inside the InternalControllerConfig as the provided YaskawaController
func (t *InternalControllerConfig) FromYaskawaController(v YaskawaController) error {
	v.Kind = "YaskawaController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeYaskawaController performs a merge with any union data inside the InternalControllerConfig, using the provided YaskawaController
func (t *InternalControllerConfig) MergeYaskawaController(v YaskawaController) error {
	v.Kind = "YaskawaController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InternalControllerConfig) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"kind"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t InternalControllerConfig) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "AbbController":
		return t.AsAbbController()
	case "FanucController":
		return t.AsFanucController()
	case "InternalAbbController":
		return t.AsInternalAbbController()
	case "InternalFanucController":
		return t.AsInternalFanucController()
	case "InternalKukaController":
		return t.AsInternalKukaController()
	case "InternalVirtualController":
		return t.AsInternalVirtualController()
	case "KukaController":
		return t.AsKukaController()
	case "UniversalrobotsController":
		return t.AsUniversalrobotsController()
	case "VirtualController":
		return t.AsVirtualController()
	case "YaskawaController":
		return t.AsYaskawaController()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t InternalControllerConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InternalControllerConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBlendingAuto returns the union data inside the MotionCommand_Blending as a BlendingAuto
func (t MotionCommand_Blending) AsBlendingAuto() (BlendingAuto, error) {
	var body BlendingAuto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlendingAuto overwrites any union data inside the MotionCommand_Blending as the provided BlendingAuto
func (t *MotionCommand_Blending) FromBlendingAuto(v BlendingAuto) error {
	v.BlendingName = "BlendingAuto"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlendingAuto performs a merge with any union data inside the MotionCommand_Blending, using the provided BlendingAuto
func (t *MotionCommand_Blending) MergeBlendingAuto(v BlendingAuto) error {
	v.BlendingName = "BlendingAuto"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlendingPosition returns the union data inside the MotionCommand_Blending as a BlendingPosition
func (t MotionCommand_Blending) AsBlendingPosition() (BlendingPosition, error) {
	var body BlendingPosition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlendingPosition overwrites any union data inside the MotionCommand_Blending as the provided BlendingPosition
func (t *MotionCommand_Blending) FromBlendingPosition(v BlendingPosition) error {
	v.BlendingName = "BlendingPosition"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlendingPosition performs a merge with any union data inside the MotionCommand_Blending, using the provided BlendingPosition
func (t *MotionCommand_Blending) MergeBlendingPosition(v BlendingPosition) error {
	v.BlendingName = "BlendingPosition"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MotionCommand_Blending) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"blending_name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MotionCommand_Blending) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BlendingAuto":
		return t.AsBlendingAuto()
	case "BlendingPosition":
		return t.AsBlendingPosition()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MotionCommand_Blending) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MotionCommand_Blending) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPathCartesianPTP returns the union data inside the MotionCommand_Path as a PathCartesianPTP
func (t MotionCommand_Path) AsPathCartesianPTP() (PathCartesianPTP, error) {
	var body PathCartesianPTP
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathCartesianPTP overwrites any union data inside the MotionCommand_Path as the provided PathCartesianPTP
func (t *MotionCommand_Path) FromPathCartesianPTP(v PathCartesianPTP) error {
	v.PathDefinitionName = "PathCartesianPTP"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathCartesianPTP performs a merge with any union data inside the MotionCommand_Path, using the provided PathCartesianPTP
func (t *MotionCommand_Path) MergePathCartesianPTP(v PathCartesianPTP) error {
	v.PathDefinitionName = "PathCartesianPTP"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPathCubicSpline returns the union data inside the MotionCommand_Path as a PathCubicSpline
func (t MotionCommand_Path) AsPathCubicSpline() (PathCubicSpline, error) {
	var body PathCubicSpline
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathCubicSpline overwrites any union data inside the MotionCommand_Path as the provided PathCubicSpline
func (t *MotionCommand_Path) FromPathCubicSpline(v PathCubicSpline) error {
	v.PathDefinitionName = "PathCubicSpline"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathCubicSpline performs a merge with any union data inside the MotionCommand_Path, using the provided PathCubicSpline
func (t *MotionCommand_Path) MergePathCubicSpline(v PathCubicSpline) error {
	v.PathDefinitionName = "PathCubicSpline"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPathLine returns the union data inside the MotionCommand_Path as a PathLine
func (t MotionCommand_Path) AsPathLine() (PathLine, error) {
	var body PathLine
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathLine overwrites any union data inside the MotionCommand_Path as the provided PathLine
func (t *MotionCommand_Path) FromPathLine(v PathLine) error {
	v.PathDefinitionName = "PathLine"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathLine performs a merge with any union data inside the MotionCommand_Path, using the provided PathLine
func (t *MotionCommand_Path) MergePathLine(v PathLine) error {
	v.PathDefinitionName = "PathLine"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPathCircle returns the union data inside the MotionCommand_Path as a PathCircle
func (t MotionCommand_Path) AsPathCircle() (PathCircle, error) {
	var body PathCircle
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathCircle overwrites any union data inside the MotionCommand_Path as the provided PathCircle
func (t *MotionCommand_Path) FromPathCircle(v PathCircle) error {
	v.PathDefinitionName = "PathCircle"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathCircle performs a merge with any union data inside the MotionCommand_Path, using the provided PathCircle
func (t *MotionCommand_Path) MergePathCircle(v PathCircle) error {
	v.PathDefinitionName = "PathCircle"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPathJointPTP returns the union data inside the MotionCommand_Path as a PathJointPTP
func (t MotionCommand_Path) AsPathJointPTP() (PathJointPTP, error) {
	var body PathJointPTP
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathJointPTP overwrites any union data inside the MotionCommand_Path as the provided PathJointPTP
func (t *MotionCommand_Path) FromPathJointPTP(v PathJointPTP) error {
	v.PathDefinitionName = "PathJointPTP"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathJointPTP performs a merge with any union data inside the MotionCommand_Path, using the provided PathJointPTP
func (t *MotionCommand_Path) MergePathJointPTP(v PathJointPTP) error {
	v.PathDefinitionName = "PathJointPTP"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MotionCommand_Path) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"path_definition_name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MotionCommand_Path) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "PathCartesianPTP":
		return t.AsPathCartesianPTP()
	case "PathCircle":
		return t.AsPathCircle()
	case "PathCubicSpline":
		return t.AsPathCubicSpline()
	case "PathJointPTP":
		return t.AsPathJointPTP()
	case "PathLine":
		return t.AsPathLine()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MotionCommand_Path) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MotionCommand_Path) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFeedbackOutOfWorkspace returns the union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as a FeedbackOutOfWorkspace
func (t PlanTrajectoryFailedResponse_ErrorFeedback) AsFeedbackOutOfWorkspace() (FeedbackOutOfWorkspace, error) {
	var body FeedbackOutOfWorkspace
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeedbackOutOfWorkspace overwrites any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as the provided FeedbackOutOfWorkspace
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) FromFeedbackOutOfWorkspace(v FeedbackOutOfWorkspace) error {
	v.ErrorFeedbackName = "FeedbackOutOfWorkspace"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeedbackOutOfWorkspace performs a merge with any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback, using the provided FeedbackOutOfWorkspace
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) MergeFeedbackOutOfWorkspace(v FeedbackOutOfWorkspace) error {
	v.ErrorFeedbackName = "FeedbackOutOfWorkspace"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeedbackSingularity returns the union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as a FeedbackSingularity
func (t PlanTrajectoryFailedResponse_ErrorFeedback) AsFeedbackSingularity() (FeedbackSingularity, error) {
	var body FeedbackSingularity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeedbackSingularity overwrites any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as the provided FeedbackSingularity
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) FromFeedbackSingularity(v FeedbackSingularity) error {
	v.ErrorFeedbackName = "FeedbackSingularity"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeedbackSingularity performs a merge with any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback, using the provided FeedbackSingularity
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) MergeFeedbackSingularity(v FeedbackSingularity) error {
	v.ErrorFeedbackName = "FeedbackSingularity"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeedbackJointLimitExceeded returns the union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as a FeedbackJointLimitExceeded
func (t PlanTrajectoryFailedResponse_ErrorFeedback) AsFeedbackJointLimitExceeded() (FeedbackJointLimitExceeded, error) {
	var body FeedbackJointLimitExceeded
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeedbackJointLimitExceeded overwrites any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as the provided FeedbackJointLimitExceeded
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) FromFeedbackJointLimitExceeded(v FeedbackJointLimitExceeded) error {
	v.ErrorFeedbackName = "FeedbackJointLimitExceeded"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeedbackJointLimitExceeded performs a merge with any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback, using the provided FeedbackJointLimitExceeded
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) MergeFeedbackJointLimitExceeded(v FeedbackJointLimitExceeded) error {
	v.ErrorFeedbackName = "FeedbackJointLimitExceeded"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeedbackCollision returns the union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as a FeedbackCollision
func (t PlanTrajectoryFailedResponse_ErrorFeedback) AsFeedbackCollision() (FeedbackCollision, error) {
	var body FeedbackCollision
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeedbackCollision overwrites any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as the provided FeedbackCollision
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) FromFeedbackCollision(v FeedbackCollision) error {
	v.ErrorFeedbackName = "FeedbackCollision"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeedbackCollision performs a merge with any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback, using the provided FeedbackCollision
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) MergeFeedbackCollision(v FeedbackCollision) error {
	v.ErrorFeedbackName = "FeedbackCollision"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlanTrajectoryFailedResponse_ErrorFeedback) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"error_feedback_name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlanTrajectoryFailedResponse_ErrorFeedback) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FeedbackCollision":
		return t.AsFeedbackCollision()
	case "FeedbackJointLimitExceeded":
		return t.AsFeedbackJointLimitExceeded()
	case "FeedbackOutOfWorkspace":
		return t.AsFeedbackOutOfWorkspace()
	case "FeedbackSingularity":
		return t.AsFeedbackSingularity()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlanTrajectoryFailedResponse_ErrorFeedback) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlanTrajectoryFailedResponse_ErrorFeedback) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJointTrajectory returns the union data inside the PlanTrajectoryResponse_Response as a JointTrajectory
func (t PlanTrajectoryResponse_Response) AsJointTrajectory() (JointTrajectory, error) {
	var body JointTrajectory
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJointTrajectory overwrites any union data inside the PlanTrajectoryResponse_Response as the provided JointTrajectory
func (t *PlanTrajectoryResponse_Response) FromJointTrajectory(v JointTrajectory) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJointTrajectory performs a merge with any union data inside the PlanTrajectoryResponse_Response, using the provided JointTrajectory
func (t *PlanTrajectoryResponse_Response) MergeJointTrajectory(v JointTrajectory) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlanTrajectoryFailedResponse returns the union data inside the PlanTrajectoryResponse_Response as a PlanTrajectoryFailedResponse
func (t PlanTrajectoryResponse_Response) AsPlanTrajectoryFailedResponse() (PlanTrajectoryFailedResponse, error) {
	var body PlanTrajectoryFailedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlanTrajectoryFailedResponse overwrites any union data inside the PlanTrajectoryResponse_Response as the provided PlanTrajectoryFailedResponse
func (t *PlanTrajectoryResponse_Response) FromPlanTrajectoryFailedResponse(v PlanTrajectoryFailedResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlanTrajectoryFailedResponse performs a merge with any union data inside the PlanTrajectoryResponse_Response, using the provided PlanTrajectoryFailedResponse
func (t *PlanTrajectoryResponse_Response) MergePlanTrajectoryFailedResponse(v PlanTrajectoryFailedResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlanTrajectoryResponse_Response) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlanTrajectoryResponse_Response) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsValidationErrorLoc0 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc0
func (t ValidationError_Loc_Item) AsValidationErrorLoc0() (ValidationErrorLoc0, error) {
	var body ValidationErrorLoc0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc0 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) FromValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc0 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsValidationErrorLoc1 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc1
func (t ValidationError_Loc_Item) AsValidationErrorLoc1() (ValidationErrorLoc1, error) {
	var body ValidationErrorLoc1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc1 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) FromValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc1 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ValidationError_Loc_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListControllers request
	ListControllers(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSupportedModes request
	GetSupportedModes(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamFreeDrive request
	StreamFreeDrive(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIODescriptions request
	ListIODescriptions(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamIOValues request
	StreamIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIOValues request
	ListIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOutputValuesWithBody request with any body
	SetOutputValuesWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetOutputValues(ctx context.Context, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WaitForIOEvent request
	WaitForIOEvent(ctx context.Context, cellID CellID, controllerID ControllerID, params *WaitForIOEventParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMode request
	GetMode(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDefaultMode request
	SetDefaultMode(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamModeChange request
	StreamModeChange(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentRobotControllerState request
	GetCurrentRobotControllerState(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamRobotControllerState request
	StreamRobotControllerState(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVirtualRobotCoordinateSystems request
	ListVirtualRobotCoordinateSystems(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddVirtualRobotCoordinateSystemWithBody request with any body
	AddVirtualRobotCoordinateSystemWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddVirtualRobotCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, body AddVirtualRobotCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualRobotCoordinateSystem request
	DeleteVirtualRobotCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystem CoordinateSystem, params *DeleteVirtualRobotCoordinateSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCycleTime request
	GetCycleTime(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEStop request
	GetEStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PushEStop request
	PushEStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReleaseEStop request
	ReleaseEStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIOs request
	ListIOs(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualRobotIOValue request
	GetVirtualRobotIOValue(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetVirtualRobotIOValue request
	SetVirtualRobotIOValue(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, params *SetVirtualRobotIOValueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExternalJointsStreamWithBody request with any body
	ExternalJointsStreamWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExternalJointsStream(ctx context.Context, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroupState request
	GetMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMotionGroupStateWithBody request with any body
	SetMotionGroupStateWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetMotionGroupStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroupBehavior request
	GetMotionGroupBehavior(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMotionGroupBehavior request
	SetMotionGroupBehavior(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, params *SetMotionGroupBehaviorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualRobotMounting request
	GetVirtualRobotMounting(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetVirtualRobotMountingWithBody request with any body
	SetVirtualRobotMountingWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetVirtualRobotMounting(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetVirtualRobotMountingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVirtualRobotTcps request
	ListVirtualRobotTcps(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddVirtualRobotTcpWithBody request with any body
	AddVirtualRobotTcpWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddVirtualRobotTcp(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body AddVirtualRobotTcpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualRobotTcp request
	DeleteVirtualRobotTcp(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, tcp Tcp, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroups request
	GetMotionGroups(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOperationMode request
	GetOperationMode(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOperationMode request
	SetOperationMode(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetOperationModeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualRobotConfiguration request
	GetVirtualRobotConfiguration(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCoordinateSystems request
	ListCoordinateSystems(ctx context.Context, cellID CellID, params *ListCoordinateSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddCoordinateSystemWithBody request with any body
	AddCoordinateSystemWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddCoordinateSystem(ctx context.Context, cellID CellID, body AddCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCoordinateSystem request
	DeleteCoordinateSystem(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoordinateSystem request
	GetCoordinateSystem(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, params *GetCoordinateSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransformInCoordinateSystemWithBody request with any body
	TransformInCoordinateSystemWithBody(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransformInCoordinateSystem(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, body TransformInCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearDevices request
	ClearDevices(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDeviceWithBody request with any body
	CreateDeviceWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDevice(ctx context.Context, cellID CellID, body CreateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDevice request
	DeleteDevice(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDevice request
	GetDevice(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DefaultHomeJoints request
	DefaultHomeJoints(ctx context.Context, cellID CellID, params *DefaultHomeJointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMotionGroups request
	ListMotionGroups(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateMotionGroup request
	ActivateMotionGroup(ctx context.Context, cellID CellID, params *ActivateMotionGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateAllMotionGroups request
	ActivateAllMotionGroups(ctx context.Context, cellID CellID, params *ActivateAllMotionGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JointJoggingWithBody request with any body
	JointJoggingWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JointJogging(ctx context.Context, cellID CellID, body JointJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectionJoggingWithBody request with any body
	DirectionJoggingWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectionJogging(ctx context.Context, cellID CellID, body DirectionJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeactivateMotionGroup request
	DeactivateMotionGroup(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInfoCapabilities request
	GetInfoCapabilities(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJoggingCapabilities request
	GetJoggingCapabilities(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKinematicCapabilities request
	GetKinematicCapabilities(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CalculateAllInverseKinematicWithBody request with any body
	CalculateAllInverseKinematicWithBody(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CalculateAllInverseKinematic(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateAllInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CalculateInverseKinematicWithBody request with any body
	CalculateInverseKinematicWithBody(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CalculateInverseKinematic(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CalculateForwardKinematicWithBody request with any body
	CalculateForwardKinematicWithBody(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CalculateForwardKinematic(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateForwardKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMounting request
	GetMounting(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptimizerConfiguration request
	GetOptimizerConfiguration(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetOptimizerConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPayloads request
	ListPayloads(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivePayload request
	GetActivePayload(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSafetySetup request
	GetSafetySetup(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroupSpecification request
	GetMotionGroupSpecification(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentMotionGroupState request
	GetCurrentMotionGroupState(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetCurrentMotionGroupStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamMotionGroupState request
	StreamMotionGroupState(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *StreamMotionGroupStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopJogging request
	StopJogging(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTcps request
	ListTcps(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *ListTcpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActiveTcp request
	GetActiveTcp(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetActiveTcpParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlanTrajectoryWithBody request with any body
	PlanTrajectoryWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PlanTrajectory(ctx context.Context, cellID CellID, body PlanTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAllMotions request
	DeleteAllMotions(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMotions request
	ListMotions(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlanMotionWithBody request with any body
	PlanMotionWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PlanMotion(ctx context.Context, cellID CellID, body PlanMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamMoveWithBody request with any body
	StreamMoveWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StreamMove(ctx context.Context, cellID CellID, body StreamMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMotion request
	DeleteMotion(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamMoveBackward request
	StreamMoveBackward(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveBackwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamMoveForward request
	StreamMoveForward(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamMoveToTrajectoryViaJointPTP request
	StreamMoveToTrajectoryViaJointPTP(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveToTrajectoryViaJointPTPParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlannedMotion request
	GetPlannedMotion(ctx context.Context, cellID CellID, motion Motion, params *GetPlannedMotionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopExecution request
	StopExecution(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionTrajectory request
	GetMotionTrajectory(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionTrajectorySample request
	GetMotionTrajectorySample(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectorySampleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadPlannedMotionWithBody request with any body
	LoadPlannedMotionWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoadPlannedMotion(ctx context.Context, cellID CellID, body LoadPlannedMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearProgramsValues request
	ClearProgramsValues(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProgramsValueWithBody request with any body
	CreateProgramsValueWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProgramsValue(ctx context.Context, cellID CellID, body CreateProgramsValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProgramValue request
	DeleteProgramValue(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgramValue request
	GetProgramValue(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProgramValueWithBody request with any body
	UpdateProgramValueWithBody(ctx context.Context, cellID CellID, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProgramValue(ctx context.Context, cellID CellID, key string, body UpdateProgramValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStoredColliders request
	ListStoredColliders(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoredCollider request
	DeleteStoredCollider(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoredCollider request
	GetStoredCollider(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreColliderWithBody request with any body
	StoreColliderWithBody(ctx context.Context, cellID CellID, colliderID ColliderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCollider(ctx context.Context, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCollisionLinkChains request
	ListCollisionLinkChains(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoredCollisionLinkChain request
	DeleteStoredCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoredCollisionLinkChain request
	GetStoredCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreCollisionLinkChainWithBody request with any body
	StoreCollisionLinkChainWithBody(ctx context.Context, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStoredCollisionScenes request
	ListStoredCollisionScenes(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoredCollisionScene request
	DeleteStoredCollisionScene(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoredCollisionScene request
	GetStoredCollisionScene(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreCollisionSceneWithBody request with any body
	StoreCollisionSceneWithBody(ctx context.Context, cellID CellID, sceneID SceneID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCollisionScene(ctx context.Context, cellID CellID, sceneID SceneID, body StoreCollisionSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStoredCollisionTools request
	ListStoredCollisionTools(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoredCollisionTool request
	DeleteStoredCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoredCollisionTool request
	GetStoredCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreCollisionToolWithBody request with any body
	StoreCollisionToolWithBody(ctx context.Context, cellID CellID, toolID ToolID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearAllObjects request
	ClearAllObjects(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllObjectKeys request
	ListAllObjectKeys(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObject request
	DeleteObject(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObject request
	GetObject(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObjectMetadata request
	GetObjectMetadata(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreObjectWithBody request with any body
	StoreObjectWithBody(ctx context.Context, cellID CellID, key Key, params *StoreObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProgramList request
	DeleteProgramList(ctx context.Context, cellID CellID, params *DeleteProgramListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProgramMetadata request
	ListProgramMetadata(ctx context.Context, cellID CellID, params *ListProgramMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProgramWithBody request with any body
	CreateProgramWithBody(ctx context.Context, cellID CellID, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProgramWithTextBody(ctx context.Context, cellID CellID, params *CreateProgramParams, body CreateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProgram request
	DeleteProgram(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgram request
	GetProgram(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProgramWithBody request with any body
	UpdateProgramWithBody(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProgramWithTextBody(ctx context.Context, cellID CellID, program Program, body UpdateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgramMetadata request
	GetProgramMetadata(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProgramMetadataWithBody request with any body
	UpdateProgramMetadataWithBody(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProgramMetadata(ctx context.Context, cellID CellID, program Program, body UpdateProgramMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadProgramMetadataImageWithBody request with any body
	UploadProgramMetadataImageWithBody(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecipeList request
	DeleteRecipeList(ctx context.Context, cellID CellID, params *DeleteRecipeListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRecipeMetadata request
	ListRecipeMetadata(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRecipeWithBody request with any body
	CreateRecipeWithBody(ctx context.Context, cellID CellID, params *CreateRecipeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRecipe(ctx context.Context, cellID CellID, params *CreateRecipeParams, body CreateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecipe request
	DeleteRecipe(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecipe request
	GetRecipe(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRecipeWithBody request with any body
	UpdateRecipeWithBody(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecipe(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecipeMetadata request
	GetRecipeMetadata(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRecipeMetadataWithBody request with any body
	UpdateRecipeMetadataWithBody(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecipeMetadata(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadRecipeMetadataImageWithBody request with any body
	UploadRecipeMetadataImageWithBody(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalListCells request
	InternalListCells(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeployCellWithBody request with any body
	InternalDeployCellWithBody(ctx context.Context, params *InternalDeployCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalDeployCell(ctx context.Context, params *InternalDeployCellParams, body InternalDeployCellJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteCell request
	InternalDeleteCell(ctx context.Context, cellID CellID, params *InternalDeleteCellParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetCell request
	InternalGetCell(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalUpdateCellWithBody request with any body
	InternalUpdateCellWithBody(ctx context.Context, cellID CellID, params *InternalUpdateCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalUpdateCell(ctx context.Context, cellID CellID, params *InternalUpdateCellParams, body InternalUpdateCellJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalClearApps request
	InternalClearApps(ctx context.Context, cellID CellID, params *InternalClearAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalListApps request
	InternalListApps(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalAddAppWithBody request with any body
	InternalAddAppWithBody(ctx context.Context, cellID CellID, params *InternalAddAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalAddApp(ctx context.Context, cellID CellID, params *InternalAddAppParams, body InternalAddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteApp request
	InternalDeleteApp(ctx context.Context, cellID CellID, appID AppID, params *InternalDeleteAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetApp request
	InternalGetApp(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalUpdateAppWithBody request with any body
	InternalUpdateAppWithBody(ctx context.Context, cellID CellID, appID AppID, params *InternalUpdateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalUpdateApp(ctx context.Context, cellID CellID, appID AppID, params *InternalUpdateAppParams, body InternalUpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetAppStatus request
	InternalGetAppStatus(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalClearRobotControllers request
	InternalClearRobotControllers(ctx context.Context, cellID CellID, params *InternalClearRobotControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalListRobotControllers request
	InternalListRobotControllers(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalAddRobotControllerWithBody request with any body
	InternalAddRobotControllerWithBody(ctx context.Context, cellID CellID, params *InternalAddRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalAddRobotController(ctx context.Context, cellID CellID, params *InternalAddRobotControllerParams, body InternalAddRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteRobotController request
	InternalDeleteRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, params *InternalDeleteRobotControllerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetRobotController request
	InternalGetRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalUpdateRobotControllerWithBody request with any body
	InternalUpdateRobotControllerWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, params *InternalUpdateRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalUpdateRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, params *InternalUpdateRobotControllerParams, body InternalUpdateRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetRobotControllerStatus request
	InternalGetRobotControllerStatus(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetFoundationServices request
	InternalGetFoundationServices(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalUpdateFoundationServicesWithBody request with any body
	InternalUpdateFoundationServicesWithBody(ctx context.Context, cellID CellID, params *InternalUpdateFoundationServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalUpdateFoundationServices(ctx context.Context, cellID CellID, params *InternalUpdateFoundationServicesParams, body InternalUpdateFoundationServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDescription request
	GetDescription(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterControllerWithBody request with any body
	RegisterControllerWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterController(ctx context.Context, cellID CellID, body RegisterControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteController request
	DeleteController(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListController request
	ListController(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRaeVersion request
	GetRaeVersion(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetCellStatus request
	InternalGetCellStatus(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetDiagnosePackage request
	InternalGetDiagnosePackage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetSystemStatus request
	InternalGetSystemStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalCheckNovaVersionUpdate request
	InternalCheckNovaVersionUpdate(ctx context.Context, params *InternalCheckNovaVersionUpdateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalUpdateNovaVersionWithBody request with any body
	InternalUpdateNovaVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalUpdateNovaVersion(ctx context.Context, body InternalUpdateNovaVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetSystemVersion request
	InternalGetSystemVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListControllers(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListControllersRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSupportedModes(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSupportedModesRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamFreeDrive(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamFreeDriveRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIODescriptions(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIODescriptionsRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamIOValuesRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIOValuesRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOutputValuesWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOutputValuesRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOutputValues(ctx context.Context, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOutputValuesRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WaitForIOEvent(ctx context.Context, cellID CellID, controllerID ControllerID, params *WaitForIOEventParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWaitForIOEventRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMode(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModeRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultMode(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultModeRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamModeChange(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamModeChangeRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentRobotControllerState(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentRobotControllerStateRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamRobotControllerState(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamRobotControllerStateRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVirtualRobotCoordinateSystems(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVirtualRobotCoordinateSystemsRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualRobotCoordinateSystemWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualRobotCoordinateSystemRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualRobotCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, body AddVirtualRobotCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualRobotCoordinateSystemRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualRobotCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystem CoordinateSystem, params *DeleteVirtualRobotCoordinateSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualRobotCoordinateSystemRequest(c.Server, cellID, controllerID, coordinateSystem, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCycleTime(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCycleTimeRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEStopRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PushEStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPushEStopRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseEStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseEStopRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIOs(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIOsRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualRobotIOValue(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualRobotIOValueRequest(c.Server, cellID, controllerID, io)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetVirtualRobotIOValue(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, params *SetVirtualRobotIOValueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetVirtualRobotIOValueRequest(c.Server, cellID, controllerID, io, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalJointsStreamWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalJointsStreamRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalJointsStream(ctx context.Context, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalJointsStreamRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupStateRequest(c.Server, cellID, controllerID, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMotionGroupStateWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMotionGroupStateRequestWithBody(c.Server, cellID, controllerID, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetMotionGroupStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMotionGroupStateRequest(c.Server, cellID, controllerID, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroupBehavior(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupBehaviorRequest(c.Server, cellID, controllerID, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMotionGroupBehavior(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, params *SetMotionGroupBehaviorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMotionGroupBehaviorRequest(c.Server, cellID, controllerID, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualRobotMounting(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualRobotMountingRequest(c.Server, cellID, controllerID, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetVirtualRobotMountingWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetVirtualRobotMountingRequestWithBody(c.Server, cellID, controllerID, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetVirtualRobotMounting(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetVirtualRobotMountingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetVirtualRobotMountingRequest(c.Server, cellID, controllerID, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVirtualRobotTcps(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVirtualRobotTcpsRequest(c.Server, cellID, controllerID, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualRobotTcpWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualRobotTcpRequestWithBody(c.Server, cellID, controllerID, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualRobotTcp(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body AddVirtualRobotTcpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualRobotTcpRequest(c.Server, cellID, controllerID, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualRobotTcp(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, tcp Tcp, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualRobotTcpRequest(c.Server, cellID, controllerID, id, tcp)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroups(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupsRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOperationMode(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOperationModeRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOperationMode(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetOperationModeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOperationModeRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualRobotConfiguration(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualRobotConfigurationRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCoordinateSystems(ctx context.Context, cellID CellID, params *ListCoordinateSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCoordinateSystemsRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCoordinateSystemWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCoordinateSystemRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCoordinateSystem(ctx context.Context, cellID CellID, body AddCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCoordinateSystemRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCoordinateSystem(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCoordinateSystemRequest(c.Server, cellID, coordinateSystem)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoordinateSystem(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, params *GetCoordinateSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoordinateSystemRequest(c.Server, cellID, coordinateSystem, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransformInCoordinateSystemWithBody(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransformInCoordinateSystemRequestWithBody(c.Server, cellID, coordinateSystem, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransformInCoordinateSystem(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, body TransformInCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransformInCoordinateSystemRequest(c.Server, cellID, coordinateSystem, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearDevices(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearDevicesRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeviceWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeviceRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDevice(ctx context.Context, cellID CellID, body CreateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeviceRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDevice(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeviceRequest(c.Server, cellID, identifier)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDevice(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeviceRequest(c.Server, cellID, identifier)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DefaultHomeJoints(ctx context.Context, cellID CellID, params *DefaultHomeJointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDefaultHomeJointsRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMotionGroups(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMotionGroupsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateMotionGroup(ctx context.Context, cellID CellID, params *ActivateMotionGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateMotionGroupRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateAllMotionGroups(ctx context.Context, cellID CellID, params *ActivateAllMotionGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateAllMotionGroupsRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JointJoggingWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJointJoggingRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JointJogging(ctx context.Context, cellID CellID, body JointJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJointJoggingRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectionJoggingWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectionJoggingRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectionJogging(ctx context.Context, cellID CellID, body DirectionJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectionJoggingRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeactivateMotionGroup(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeactivateMotionGroupRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInfoCapabilities(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInfoCapabilitiesRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJoggingCapabilities(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJoggingCapabilitiesRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKinematicCapabilities(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKinematicCapabilitiesRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculateAllInverseKinematicWithBody(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculateAllInverseKinematicRequestWithBody(c.Server, cellID, motionGroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculateAllInverseKinematic(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateAllInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculateAllInverseKinematicRequest(c.Server, cellID, motionGroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculateInverseKinematicWithBody(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculateInverseKinematicRequestWithBody(c.Server, cellID, motionGroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculateInverseKinematic(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculateInverseKinematicRequest(c.Server, cellID, motionGroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculateForwardKinematicWithBody(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculateForwardKinematicRequestWithBody(c.Server, cellID, motionGroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculateForwardKinematic(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateForwardKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculateForwardKinematicRequest(c.Server, cellID, motionGroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMounting(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMountingRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptimizerConfiguration(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetOptimizerConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptimizerConfigurationRequest(c.Server, cellID, motionGroup, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPayloads(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPayloadsRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivePayload(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivePayloadRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSafetySetup(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSafetySetupRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroupSpecification(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupSpecificationRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentMotionGroupState(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetCurrentMotionGroupStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentMotionGroupStateRequest(c.Server, cellID, motionGroup, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMotionGroupState(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *StreamMotionGroupStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMotionGroupStateRequest(c.Server, cellID, motionGroup, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopJogging(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopJoggingRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTcps(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *ListTcpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTcpsRequest(c.Server, cellID, motionGroup, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActiveTcp(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetActiveTcpParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActiveTcpRequest(c.Server, cellID, motionGroup, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanTrajectoryWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanTrajectoryRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanTrajectory(ctx context.Context, cellID CellID, body PlanTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanTrajectoryRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAllMotions(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllMotionsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMotions(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMotionsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanMotionWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanMotionRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanMotion(ctx context.Context, cellID CellID, body PlanMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanMotionRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMoveWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMoveRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMove(ctx context.Context, cellID CellID, body StreamMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMoveRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMotion(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMotionRequest(c.Server, cellID, motion)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMoveBackward(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveBackwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMoveBackwardRequest(c.Server, cellID, motion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMoveForward(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMoveForwardRequest(c.Server, cellID, motion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMoveToTrajectoryViaJointPTP(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveToTrajectoryViaJointPTPParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMoveToTrajectoryViaJointPTPRequest(c.Server, cellID, motion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlannedMotion(ctx context.Context, cellID CellID, motion Motion, params *GetPlannedMotionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlannedMotionRequest(c.Server, cellID, motion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopExecution(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopExecutionRequest(c.Server, cellID, motion)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionTrajectory(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionTrajectoryRequest(c.Server, cellID, motion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionTrajectorySample(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectorySampleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionTrajectorySampleRequest(c.Server, cellID, motion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadPlannedMotionWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadPlannedMotionRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadPlannedMotion(ctx context.Context, cellID CellID, body LoadPlannedMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadPlannedMotionRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearProgramsValues(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearProgramsValuesRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramsValueWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramsValueRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramsValue(ctx context.Context, cellID CellID, body CreateProgramsValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramsValueRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProgramValue(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProgramValueRequest(c.Server, cellID, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgramValue(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramValueRequest(c.Server, cellID, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramValueWithBody(ctx context.Context, cellID CellID, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramValueRequestWithBody(c.Server, cellID, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramValue(ctx context.Context, cellID CellID, key string, body UpdateProgramValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramValueRequest(c.Server, cellID, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStoredColliders(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStoredCollidersRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoredCollider(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoredColliderRequest(c.Server, cellID, colliderID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoredCollider(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoredColliderRequest(c.Server, cellID, colliderID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreColliderWithBody(ctx context.Context, cellID CellID, colliderID ColliderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreColliderRequestWithBody(c.Server, cellID, colliderID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollider(ctx context.Context, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreColliderRequest(c.Server, cellID, colliderID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCollisionLinkChains(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCollisionLinkChainsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoredCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoredCollisionLinkChainRequest(c.Server, cellID, linkChainID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoredCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoredCollisionLinkChainRequest(c.Server, cellID, linkChainID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionLinkChainWithBody(ctx context.Context, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionLinkChainRequestWithBody(c.Server, cellID, linkChainID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionLinkChainRequest(c.Server, cellID, linkChainID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStoredCollisionScenes(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStoredCollisionScenesRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoredCollisionScene(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoredCollisionSceneRequest(c.Server, cellID, sceneID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoredCollisionScene(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoredCollisionSceneRequest(c.Server, cellID, sceneID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionSceneWithBody(ctx context.Context, cellID CellID, sceneID SceneID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionSceneRequestWithBody(c.Server, cellID, sceneID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionScene(ctx context.Context, cellID CellID, sceneID SceneID, body StoreCollisionSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionSceneRequest(c.Server, cellID, sceneID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStoredCollisionTools(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStoredCollisionToolsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoredCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoredCollisionToolRequest(c.Server, cellID, toolID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoredCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoredCollisionToolRequest(c.Server, cellID, toolID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionToolWithBody(ctx context.Context, cellID CellID, toolID ToolID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionToolRequestWithBody(c.Server, cellID, toolID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionToolRequest(c.Server, cellID, toolID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearAllObjects(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearAllObjectsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllObjectKeys(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllObjectKeysRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObject(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectRequest(c.Server, cellID, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObject(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectRequest(c.Server, cellID, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObjectMetadata(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectMetadataRequest(c.Server, cellID, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreObjectWithBody(ctx context.Context, cellID CellID, key Key, params *StoreObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreObjectRequestWithBody(c.Server, cellID, key, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProgramList(ctx context.Context, cellID CellID, params *DeleteProgramListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProgramListRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProgramMetadata(ctx context.Context, cellID CellID, params *ListProgramMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProgramMetadataRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramWithBody(ctx context.Context, cellID CellID, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramWithTextBody(ctx context.Context, cellID CellID, params *CreateProgramParams, body CreateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramRequestWithTextBody(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProgram(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProgramRequest(c.Server, cellID, program)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgram(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramRequest(c.Server, cellID, program)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramWithBody(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramRequestWithBody(c.Server, cellID, program, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramWithTextBody(ctx context.Context, cellID CellID, program Program, body UpdateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramRequestWithTextBody(c.Server, cellID, program, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgramMetadata(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramMetadataRequest(c.Server, cellID, program)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramMetadataWithBody(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramMetadataRequestWithBody(c.Server, cellID, program, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramMetadata(ctx context.Context, cellID CellID, program Program, body UpdateProgramMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramMetadataRequest(c.Server, cellID, program, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadProgramMetadataImageWithBody(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadProgramMetadataImageRequestWithBody(c.Server, cellID, program, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecipeList(ctx context.Context, cellID CellID, params *DeleteRecipeListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecipeListRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRecipeMetadata(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRecipeMetadataRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRecipeWithBody(ctx context.Context, cellID CellID, params *CreateRecipeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRecipeRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRecipe(ctx context.Context, cellID CellID, params *CreateRecipeParams, body CreateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRecipeRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecipe(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecipeRequest(c.Server, cellID, recipe)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecipe(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecipeRequest(c.Server, cellID, recipe)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecipeWithBody(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecipeRequestWithBody(c.Server, cellID, recipe, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecipe(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecipeRequest(c.Server, cellID, recipe, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecipeMetadata(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecipeMetadataRequest(c.Server, cellID, recipe)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecipeMetadataWithBody(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecipeMetadataRequestWithBody(c.Server, cellID, recipe, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecipeMetadata(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecipeMetadataRequest(c.Server, cellID, recipe, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadRecipeMetadataImageWithBody(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadRecipeMetadataImageRequestWithBody(c.Server, cellID, recipe, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalListCells(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalListCellsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeployCellWithBody(ctx context.Context, params *InternalDeployCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeployCellRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeployCell(ctx context.Context, params *InternalDeployCellParams, body InternalDeployCellJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeployCellRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteCell(ctx context.Context, cellID CellID, params *InternalDeleteCellParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteCellRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetCell(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetCellRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalUpdateCellWithBody(ctx context.Context, cellID CellID, params *InternalUpdateCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalUpdateCellRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalUpdateCell(ctx context.Context, cellID CellID, params *InternalUpdateCellParams, body InternalUpdateCellJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalUpdateCellRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalClearApps(ctx context.Context, cellID CellID, params *InternalClearAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalClearAppsRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalListApps(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalListAppsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalAddAppWithBody(ctx context.Context, cellID CellID, params *InternalAddAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalAddAppRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalAddApp(ctx context.Context, cellID CellID, params *InternalAddAppParams, body InternalAddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalAddAppRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteApp(ctx context.Context, cellID CellID, appID AppID, params *InternalDeleteAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteAppRequest(c.Server, cellID, appID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetApp(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetAppRequest(c.Server, cellID, appID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalUpdateAppWithBody(ctx context.Context, cellID CellID, appID AppID, params *InternalUpdateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalUpdateAppRequestWithBody(c.Server, cellID, appID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalUpdateApp(ctx context.Context, cellID CellID, appID AppID, params *InternalUpdateAppParams, body InternalUpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalUpdateAppRequest(c.Server, cellID, appID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetAppStatus(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetAppStatusRequest(c.Server, cellID, appID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalClearRobotControllers(ctx context.Context, cellID CellID, params *InternalClearRobotControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalClearRobotControllersRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalListRobotControllers(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalListRobotControllersRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalAddRobotControllerWithBody(ctx context.Context, cellID CellID, params *InternalAddRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalAddRobotControllerRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalAddRobotController(ctx context.Context, cellID CellID, params *InternalAddRobotControllerParams, body InternalAddRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalAddRobotControllerRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, params *InternalDeleteRobotControllerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteRobotControllerRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetRobotControllerRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalUpdateRobotControllerWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, params *InternalUpdateRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalUpdateRobotControllerRequestWithBody(c.Server, cellID, controllerID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalUpdateRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, params *InternalUpdateRobotControllerParams, body InternalUpdateRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalUpdateRobotControllerRequest(c.Server, cellID, controllerID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetRobotControllerStatus(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetRobotControllerStatusRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetFoundationServices(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetFoundationServicesRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalUpdateFoundationServicesWithBody(ctx context.Context, cellID CellID, params *InternalUpdateFoundationServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalUpdateFoundationServicesRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalUpdateFoundationServices(ctx context.Context, cellID CellID, params *InternalUpdateFoundationServicesParams, body InternalUpdateFoundationServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalUpdateFoundationServicesRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDescription(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDescriptionRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterControllerWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterControllerRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterController(ctx context.Context, cellID CellID, body RegisterControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterControllerRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteController(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteControllerRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListController(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListControllerRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRaeVersion(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRaeVersionRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetCellStatus(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetCellStatusRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetDiagnosePackage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetDiagnosePackageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetSystemStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetSystemStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalCheckNovaVersionUpdate(ctx context.Context, params *InternalCheckNovaVersionUpdateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalCheckNovaVersionUpdateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalUpdateNovaVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalUpdateNovaVersionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalUpdateNovaVersion(ctx context.Context, body InternalUpdateNovaVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalUpdateNovaVersionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetSystemVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetSystemVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListControllersRequest generates requests for ListControllers
func NewListControllersRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSupportedModesRequest generates requests for GetSupportedModes
func NewGetSupportedModesRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/controller-capabilities", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamFreeDriveRequest generates requests for StreamFreeDrive
func NewStreamFreeDriveRequest(server string, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/free-drive-stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIODescriptionsRequest generates requests for ListIODescriptions
func NewListIODescriptionsRequest(server string, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/description", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ios", runtime.ParamLocationQuery, *params.Ios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamIOValuesRequest generates requests for StreamIOValues
func NewStreamIOValuesRequest(server string, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ios", runtime.ParamLocationQuery, *params.Ios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIOValuesRequest generates requests for ListIOValues
func NewListIOValuesRequest(server string, cellID CellID, controllerID ControllerID, params *ListIOValuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/values", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ios", runtime.ParamLocationQuery, *params.Ios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetOutputValuesRequest calls the generic SetOutputValues builder with application/json body
func NewSetOutputValuesRequest(server string, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetOutputValuesRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewSetOutputValuesRequestWithBody generates requests for SetOutputValues with any type of body
func NewSetOutputValuesRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/values", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWaitForIOEventRequest generates requests for WaitForIOEvent
func NewWaitForIOEventRequest(server string, cellID CellID, controllerID ControllerID, params *WaitForIOEventParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/wait-for", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "io", runtime.ParamLocationQuery, params.Io); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "comparison_type", runtime.ParamLocationQuery, params.ComparisonType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.BooleanValue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "boolean_value", runtime.ParamLocationQuery, *params.BooleanValue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntegerValue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integer_value", runtime.ParamLocationQuery, *params.IntegerValue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FloatingValue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "floating_value", runtime.ParamLocationQuery, *params.FloatingValue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModeRequest generates requests for GetMode
func NewGetModeRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/mode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDefaultModeRequest generates requests for SetDefaultMode
func NewSetDefaultModeRequest(server string, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/mode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamModeChangeRequest generates requests for StreamModeChange
func NewStreamModeChangeRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/mode-stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentRobotControllerStateRequest generates requests for GetCurrentRobotControllerState
func NewGetCurrentRobotControllerStateRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/state", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamRobotControllerStateRequest generates requests for StreamRobotControllerState
func NewStreamRobotControllerStateRequest(server string, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/state-stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVirtualRobotCoordinateSystemsRequest generates requests for ListVirtualRobotCoordinateSystems
func NewListVirtualRobotCoordinateSystemsRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/coordinate-systems", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddVirtualRobotCoordinateSystemRequest calls the generic AddVirtualRobotCoordinateSystem builder with application/json body
func NewAddVirtualRobotCoordinateSystemRequest(server string, cellID CellID, controllerID ControllerID, body AddVirtualRobotCoordinateSystemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddVirtualRobotCoordinateSystemRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewAddVirtualRobotCoordinateSystemRequestWithBody generates requests for AddVirtualRobotCoordinateSystem with any type of body
func NewAddVirtualRobotCoordinateSystemRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/coordinate-systems", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVirtualRobotCoordinateSystemRequest generates requests for DeleteVirtualRobotCoordinateSystem
func NewDeleteVirtualRobotCoordinateSystemRequest(server string, cellID CellID, controllerID ControllerID, coordinateSystem CoordinateSystem, params *DeleteVirtualRobotCoordinateSystemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "coordinate-system", runtime.ParamLocationPath, coordinateSystem)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/coordinate-systems/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteDependent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_dependent", runtime.ParamLocationQuery, *params.DeleteDependent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCycleTimeRequest generates requests for GetCycleTime
func NewGetCycleTimeRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/cycle-time", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEStopRequest generates requests for GetEStop
func NewGetEStopRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/estop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPushEStopRequest generates requests for PushEStop
func NewPushEStopRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/estop/push", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReleaseEStopRequest generates requests for ReleaseEStop
func NewReleaseEStopRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/estop/release", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIOsRequest generates requests for ListIOs
func NewListIOsRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/ios", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualRobotIOValueRequest generates requests for GetVirtualRobotIOValue
func NewGetVirtualRobotIOValueRequest(server string, cellID CellID, controllerID ControllerID, io IO) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "io", runtime.ParamLocationPath, io)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/ios/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetVirtualRobotIOValueRequest generates requests for SetVirtualRobotIOValue
func NewSetVirtualRobotIOValueRequest(server string, cellID CellID, controllerID ControllerID, io IO, params *SetVirtualRobotIOValueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "io", runtime.ParamLocationPath, io)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/ios/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Bool != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bool", runtime.ParamLocationQuery, *params.Bool); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Integer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integer", runtime.ParamLocationQuery, *params.Integer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Double != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "double", runtime.ParamLocationQuery, *params.Double); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExternalJointsStreamRequest calls the generic ExternalJointsStream builder with application/json body
func NewExternalJointsStreamRequest(server string, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExternalJointsStreamRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewExternalJointsStreamRequestWithBody generates requests for ExternalJointsStream with any type of body
func NewExternalJointsStreamRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/externalJointsStream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMotionGroupStateRequest generates requests for GetMotionGroupState
func NewGetMotionGroupStateRequest(server string, cellID CellID, controllerID ControllerID, id Id) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMotionGroupStateRequest calls the generic SetMotionGroupState builder with application/json body
func NewSetMotionGroupStateRequest(server string, cellID CellID, controllerID ControllerID, id Id, body SetMotionGroupStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMotionGroupStateRequestWithBody(server, cellID, controllerID, id, "application/json", bodyReader)
}

// NewSetMotionGroupStateRequestWithBody generates requests for SetMotionGroupState with any type of body
func NewSetMotionGroupStateRequestWithBody(server string, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMotionGroupBehaviorRequest generates requests for GetMotionGroupBehavior
func NewGetMotionGroupBehaviorRequest(server string, cellID CellID, controllerID ControllerID, id Id) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/behavior", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMotionGroupBehaviorRequest generates requests for SetMotionGroupBehavior
func NewSetMotionGroupBehaviorRequest(server string, cellID CellID, controllerID ControllerID, id Id, params *SetMotionGroupBehaviorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/behavior", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Behavior != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "behavior", runtime.ParamLocationQuery, *params.Behavior); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualRobotMountingRequest generates requests for GetVirtualRobotMounting
func NewGetVirtualRobotMountingRequest(server string, cellID CellID, controllerID ControllerID, id Id) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/mounting", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetVirtualRobotMountingRequest calls the generic SetVirtualRobotMounting builder with application/json body
func NewSetVirtualRobotMountingRequest(server string, cellID CellID, controllerID ControllerID, id Id, body SetVirtualRobotMountingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetVirtualRobotMountingRequestWithBody(server, cellID, controllerID, id, "application/json", bodyReader)
}

// NewSetVirtualRobotMountingRequestWithBody generates requests for SetVirtualRobotMounting with any type of body
func NewSetVirtualRobotMountingRequestWithBody(server string, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/mounting", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVirtualRobotTcpsRequest generates requests for ListVirtualRobotTcps
func NewListVirtualRobotTcpsRequest(server string, cellID CellID, controllerID ControllerID, id Id) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/tcps", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddVirtualRobotTcpRequest calls the generic AddVirtualRobotTcp builder with application/json body
func NewAddVirtualRobotTcpRequest(server string, cellID CellID, controllerID ControllerID, id Id, body AddVirtualRobotTcpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddVirtualRobotTcpRequestWithBody(server, cellID, controllerID, id, "application/json", bodyReader)
}

// NewAddVirtualRobotTcpRequestWithBody generates requests for AddVirtualRobotTcp with any type of body
func NewAddVirtualRobotTcpRequestWithBody(server string, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/tcps", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVirtualRobotTcpRequest generates requests for DeleteVirtualRobotTcp
func NewDeleteVirtualRobotTcpRequest(server string, cellID CellID, controllerID ControllerID, id Id, tcp Tcp) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "tcp", runtime.ParamLocationPath, tcp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/tcps/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMotionGroupsRequest generates requests for GetMotionGroups
func NewGetMotionGroupsRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motiongroups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOperationModeRequest generates requests for GetOperationMode
func NewGetOperationModeRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/operationmode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetOperationModeRequest generates requests for SetOperationMode
func NewSetOperationModeRequest(server string, cellID CellID, controllerID ControllerID, params *SetOperationModeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/operationmode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualRobotConfigurationRequest generates requests for GetVirtualRobotConfiguration
func NewGetVirtualRobotConfigurationRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/virtual-robot-configuration", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCoordinateSystemsRequest generates requests for ListCoordinateSystems
func NewListCoordinateSystemsRequest(server string, cellID CellID, params *ListCoordinateSystemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/coordinate-systems", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rotation_type", runtime.ParamLocationQuery, *params.RotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddCoordinateSystemRequest calls the generic AddCoordinateSystem builder with application/json body
func NewAddCoordinateSystemRequest(server string, cellID CellID, body AddCoordinateSystemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddCoordinateSystemRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewAddCoordinateSystemRequestWithBody generates requests for AddCoordinateSystem with any type of body
func NewAddCoordinateSystemRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/coordinate-systems", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCoordinateSystemRequest generates requests for DeleteCoordinateSystem
func NewDeleteCoordinateSystemRequest(server string, cellID CellID, coordinateSystem CoordinateSystem) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "coordinate-system", runtime.ParamLocationPath, coordinateSystem)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/coordinate-systems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoordinateSystemRequest generates requests for GetCoordinateSystem
func NewGetCoordinateSystemRequest(server string, cellID CellID, coordinateSystem CoordinateSystem, params *GetCoordinateSystemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "coordinate-system", runtime.ParamLocationPath, coordinateSystem)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/coordinate-systems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rotation_type", runtime.ParamLocationQuery, *params.RotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransformInCoordinateSystemRequest calls the generic TransformInCoordinateSystem builder with application/json body
func NewTransformInCoordinateSystemRequest(server string, cellID CellID, coordinateSystem CoordinateSystem, body TransformInCoordinateSystemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTransformInCoordinateSystemRequestWithBody(server, cellID, coordinateSystem, "application/json", bodyReader)
}

// NewTransformInCoordinateSystemRequestWithBody generates requests for TransformInCoordinateSystem with any type of body
func NewTransformInCoordinateSystemRequestWithBody(server string, cellID CellID, coordinateSystem CoordinateSystem, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "coordinate-system", runtime.ParamLocationPath, coordinateSystem)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/coordinate-systems/%s/transform", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearDevicesRequest generates requests for ClearDevices
func NewClearDevicesRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/devices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDeviceRequest calls the generic CreateDevice builder with application/json body
func NewCreateDeviceRequest(server string, cellID CellID, body CreateDeviceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDeviceRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewCreateDeviceRequestWithBody generates requests for CreateDevice with any type of body
func NewCreateDeviceRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/devices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDeviceRequest generates requests for DeleteDevice
func NewDeleteDeviceRequest(server string, cellID CellID, identifier string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "identifier", runtime.ParamLocationPath, identifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/devices/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeviceRequest generates requests for GetDevice
func NewGetDeviceRequest(server string, cellID CellID, identifier string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "identifier", runtime.ParamLocationPath, identifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/devices/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDefaultHomeJointsRequest generates requests for DefaultHomeJoints
func NewDefaultHomeJointsRequest(server string, cellID CellID, params *DefaultHomeJointsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/homejoints", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "virtual_robot_model", runtime.ParamLocationQuery, params.VirtualRobotModel); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMotionGroupsRequest generates requests for ListMotionGroups
func NewListMotionGroupsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivateMotionGroupRequest generates requests for ActivateMotionGroup
func NewActivateMotionGroupRequest(server string, cellID CellID, params *ActivateMotionGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "motion_group", runtime.ParamLocationQuery, params.MotionGroup); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivateAllMotionGroupsRequest generates requests for ActivateAllMotionGroups
func NewActivateAllMotionGroupsRequest(server string, cellID CellID, params *ActivateAllMotionGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/all", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "controller", runtime.ParamLocationQuery, params.Controller); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJointJoggingRequest calls the generic JointJogging builder with application/json body
func NewJointJoggingRequest(server string, cellID CellID, body JointJoggingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJointJoggingRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewJointJoggingRequestWithBody generates requests for JointJogging with any type of body
func NewJointJoggingRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/move-joint", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectionJoggingRequest calls the generic DirectionJogging builder with application/json body
func NewDirectionJoggingRequest(server string, cellID CellID, body DirectionJoggingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectionJoggingRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewDirectionJoggingRequestWithBody generates requests for DirectionJogging with any type of body
func NewDirectionJoggingRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/move-tcp", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeactivateMotionGroupRequest generates requests for DeactivateMotionGroup
func NewDeactivateMotionGroupRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInfoCapabilitiesRequest generates requests for GetInfoCapabilities
func NewGetInfoCapabilitiesRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/info-capabilities", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJoggingCapabilitiesRequest generates requests for GetJoggingCapabilities
func NewGetJoggingCapabilitiesRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/jogging-capabilities", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKinematicCapabilitiesRequest generates requests for GetKinematicCapabilities
func NewGetKinematicCapabilitiesRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/kinematic-capabilities", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCalculateAllInverseKinematicRequest calls the generic CalculateAllInverseKinematic builder with application/json body
func NewCalculateAllInverseKinematicRequest(server string, cellID CellID, motionGroup MotionGroup, body CalculateAllInverseKinematicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCalculateAllInverseKinematicRequestWithBody(server, cellID, motionGroup, "application/json", bodyReader)
}

// NewCalculateAllInverseKinematicRequestWithBody generates requests for CalculateAllInverseKinematic with any type of body
func NewCalculateAllInverseKinematicRequestWithBody(server string, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/kinematic/calculate-all-joint-positions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCalculateInverseKinematicRequest calls the generic CalculateInverseKinematic builder with application/json body
func NewCalculateInverseKinematicRequest(server string, cellID CellID, motionGroup MotionGroup, body CalculateInverseKinematicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCalculateInverseKinematicRequestWithBody(server, cellID, motionGroup, "application/json", bodyReader)
}

// NewCalculateInverseKinematicRequestWithBody generates requests for CalculateInverseKinematic with any type of body
func NewCalculateInverseKinematicRequestWithBody(server string, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/kinematic/calculate-joint-position", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCalculateForwardKinematicRequest calls the generic CalculateForwardKinematic builder with application/json body
func NewCalculateForwardKinematicRequest(server string, cellID CellID, motionGroup MotionGroup, body CalculateForwardKinematicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCalculateForwardKinematicRequestWithBody(server, cellID, motionGroup, "application/json", bodyReader)
}

// NewCalculateForwardKinematicRequestWithBody generates requests for CalculateForwardKinematic with any type of body
func NewCalculateForwardKinematicRequestWithBody(server string, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/kinematic/calculate-tcp-pose", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMountingRequest generates requests for GetMounting
func NewGetMountingRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/mounting", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptimizerConfigurationRequest generates requests for GetOptimizerConfiguration
func NewGetOptimizerConfigurationRequest(server string, cellID CellID, motionGroup MotionGroup, params *GetOptimizerConfigurationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/optimizer-setup", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tcp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tcp", runtime.ParamLocationQuery, *params.Tcp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPayloadsRequest generates requests for ListPayloads
func NewListPayloadsRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/payloads", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivePayloadRequest generates requests for GetActivePayload
func NewGetActivePayloadRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/payloads/current", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSafetySetupRequest generates requests for GetSafetySetup
func NewGetSafetySetupRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/safety-setup", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMotionGroupSpecificationRequest generates requests for GetMotionGroupSpecification
func NewGetMotionGroupSpecificationRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/specification", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentMotionGroupStateRequest generates requests for GetCurrentMotionGroupState
func NewGetCurrentMotionGroupStateRequest(server string, cellID CellID, motionGroup MotionGroup, params *GetCurrentMotionGroupStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/state", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tcp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tcp", runtime.ParamLocationQuery, *params.Tcp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponseCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_coordinate_system", runtime.ParamLocationQuery, *params.ResponseCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamMotionGroupStateRequest generates requests for StreamMotionGroupState
func NewStreamMotionGroupStateRequest(server string, cellID CellID, motionGroup MotionGroup, params *StreamMotionGroupStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/state-stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponseCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_coordinate_system", runtime.ParamLocationQuery, *params.ResponseCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tcp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tcp", runtime.ParamLocationQuery, *params.Tcp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopJoggingRequest generates requests for StopJogging
func NewStopJoggingRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/stop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTcpsRequest generates requests for ListTcps
func NewListTcpsRequest(server string, cellID CellID, motionGroup MotionGroup, params *ListTcpsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/tcps", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rotation_type", runtime.ParamLocationQuery, *params.RotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActiveTcpRequest generates requests for GetActiveTcp
func NewGetActiveTcpRequest(server string, cellID CellID, motionGroup MotionGroup, params *GetActiveTcpParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/tcps/current", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rotation_type", runtime.ParamLocationQuery, *params.RotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlanTrajectoryRequest calls the generic PlanTrajectory builder with application/json body
func NewPlanTrajectoryRequest(server string, cellID CellID, body PlanTrajectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPlanTrajectoryRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewPlanTrajectoryRequestWithBody generates requests for PlanTrajectory with any type of body
func NewPlanTrajectoryRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-planning/plan-trajectory", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAllMotionsRequest generates requests for DeleteAllMotions
func NewDeleteAllMotionsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMotionsRequest generates requests for ListMotions
func NewListMotionsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlanMotionRequest calls the generic PlanMotion builder with application/json body
func NewPlanMotionRequest(server string, cellID CellID, body PlanMotionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPlanMotionRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewPlanMotionRequestWithBody generates requests for PlanMotion with any type of body
func NewPlanMotionRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStreamMoveRequest calls the generic StreamMove builder with application/json body
func NewStreamMoveRequest(server string, cellID CellID, body StreamMoveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStreamMoveRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewStreamMoveRequestWithBody generates requests for StreamMove with any type of body
func NewStreamMoveRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/streammove", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMotionRequest generates requests for DeleteMotion
func NewDeleteMotionRequest(server string, cellID CellID, motion Motion) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/delete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamMoveBackwardRequest generates requests for StreamMoveBackward
func NewStreamMoveBackwardRequest(server string, cellID CellID, motion Motion, params *StreamMoveBackwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/executebackward", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playback_speed_in_percent", runtime.ParamLocationQuery, params.PlaybackSpeedInPercent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponseCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_coordinate_system", runtime.ParamLocationQuery, *params.ResponseCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartLocationOnTrajectory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_location_on_trajectory", runtime.ParamLocationQuery, *params.StartLocationOnTrajectory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamMoveForwardRequest generates requests for StreamMoveForward
func NewStreamMoveForwardRequest(server string, cellID CellID, motion Motion, params *StreamMoveForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/executeforward", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playback_speed_in_percent", runtime.ParamLocationQuery, params.PlaybackSpeedInPercent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponseCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_coordinate_system", runtime.ParamLocationQuery, *params.ResponseCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartLocationOnTrajectory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_location_on_trajectory", runtime.ParamLocationQuery, *params.StartLocationOnTrajectory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamMoveToTrajectoryViaJointPTPRequest generates requests for StreamMoveToTrajectoryViaJointPTP
func NewStreamMoveToTrajectoryViaJointPTPRequest(server string, cellID CellID, motion Motion, params *StreamMoveToTrajectoryViaJointPTPParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/executetotrajectory", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location_on_trajectory", runtime.ParamLocationQuery, params.LocationOnTrajectory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.LimitOverrideJointVelocityLimitsJoints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_override.joint_velocity_limits.joints", runtime.ParamLocationQuery, *params.LimitOverrideJointVelocityLimitsJoints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitOverrideJointAccelerationLimitsJoints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_override.joint_acceleration_limits.joints", runtime.ParamLocationQuery, *params.LimitOverrideJointAccelerationLimitsJoints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitOverrideTcpVelocityLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_override.tcp_velocity_limit", runtime.ParamLocationQuery, *params.LimitOverrideTcpVelocityLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitOverrideTcpAccelerationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_override.tcp_acceleration_limit", runtime.ParamLocationQuery, *params.LimitOverrideTcpAccelerationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitOverrideTcpOrientationVelocityLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_override.tcp_orientation_velocity_limit", runtime.ParamLocationQuery, *params.LimitOverrideTcpOrientationVelocityLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitOverrideTcpOrientationAccelerationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_override.tcp_orientation_acceleration_limit", runtime.ParamLocationQuery, *params.LimitOverrideTcpOrientationAccelerationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponsesCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "responses_coordinate_system", runtime.ParamLocationQuery, *params.ResponsesCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlannedMotionRequest generates requests for GetPlannedMotion
func NewGetPlannedMotionRequest(server string, cellID CellID, motion Motion, params *GetPlannedMotionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/planned-motion", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SampleTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sample_time", runtime.ParamLocationQuery, *params.SampleTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopExecutionRequest generates requests for StopExecution
func NewStopExecutionRequest(server string, cellID CellID, motion Motion) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/stop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMotionTrajectoryRequest generates requests for GetMotionTrajectory
func NewGetMotionTrajectoryRequest(server string, cellID CellID, motion Motion, params *GetMotionTrajectoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/trajectory", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sample_time", runtime.ParamLocationQuery, params.SampleTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResponsesCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "responses_coordinate_system", runtime.ParamLocationQuery, *params.ResponsesCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMotionTrajectorySampleRequest generates requests for GetMotionTrajectorySample
func NewGetMotionTrajectorySampleRequest(server string, cellID CellID, motion Motion, params *GetMotionTrajectorySampleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/trajectorysample", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LocationOnTrajectory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location_on_trajectory", runtime.ParamLocationQuery, *params.LocationOnTrajectory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponseCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_coordinate_system", runtime.ParamLocationQuery, *params.ResponseCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadPlannedMotionRequest calls the generic LoadPlannedMotion builder with application/json body
func NewLoadPlannedMotionRequest(server string, cellID CellID, body LoadPlannedMotionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoadPlannedMotionRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewLoadPlannedMotionRequestWithBody generates requests for LoadPlannedMotion with any type of body
func NewLoadPlannedMotionRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/planned-motions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearProgramsValuesRequest generates requests for ClearProgramsValues
func NewClearProgramsValuesRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/programs/values", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProgramsValueRequest calls the generic CreateProgramsValue builder with application/json body
func NewCreateProgramsValueRequest(server string, cellID CellID, body CreateProgramsValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProgramsValueRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewCreateProgramsValueRequestWithBody generates requests for CreateProgramsValue with any type of body
func NewCreateProgramsValueRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/programs/values", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProgramValueRequest generates requests for DeleteProgramValue
func NewDeleteProgramValueRequest(server string, cellID CellID, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/programs/values/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramValueRequest generates requests for GetProgramValue
func NewGetProgramValueRequest(server string, cellID CellID, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/programs/values/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProgramValueRequest calls the generic UpdateProgramValue builder with application/json body
func NewUpdateProgramValueRequest(server string, cellID CellID, key string, body UpdateProgramValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProgramValueRequestWithBody(server, cellID, key, "application/json", bodyReader)
}

// NewUpdateProgramValueRequestWithBody generates requests for UpdateProgramValue with any type of body
func NewUpdateProgramValueRequestWithBody(server string, cellID CellID, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/programs/values/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListStoredCollidersRequest generates requests for ListStoredColliders
func NewListStoredCollidersRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/colliders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStoredColliderRequest generates requests for DeleteStoredCollider
func NewDeleteStoredColliderRequest(server string, cellID CellID, colliderID ColliderID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collider", runtime.ParamLocationPath, colliderID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/colliders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoredColliderRequest generates requests for GetStoredCollider
func NewGetStoredColliderRequest(server string, cellID CellID, colliderID ColliderID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collider", runtime.ParamLocationPath, colliderID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/colliders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreColliderRequest calls the generic StoreCollider builder with application/json body
func NewStoreColliderRequest(server string, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreColliderRequestWithBody(server, cellID, colliderID, "application/json", bodyReader)
}

// NewStoreColliderRequestWithBody generates requests for StoreCollider with any type of body
func NewStoreColliderRequestWithBody(server string, cellID CellID, colliderID ColliderID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collider", runtime.ParamLocationPath, colliderID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/colliders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCollisionLinkChainsRequest generates requests for ListCollisionLinkChains
func NewListCollisionLinkChainsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/link-chains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStoredCollisionLinkChainRequest generates requests for DeleteStoredCollisionLinkChain
func NewDeleteStoredCollisionLinkChainRequest(server string, cellID CellID, linkChainID LinkChainID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "link-chain", runtime.ParamLocationPath, linkChainID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/link-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoredCollisionLinkChainRequest generates requests for GetStoredCollisionLinkChain
func NewGetStoredCollisionLinkChainRequest(server string, cellID CellID, linkChainID LinkChainID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "link-chain", runtime.ParamLocationPath, linkChainID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/link-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreCollisionLinkChainRequest calls the generic StoreCollisionLinkChain builder with application/json body
func NewStoreCollisionLinkChainRequest(server string, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreCollisionLinkChainRequestWithBody(server, cellID, linkChainID, "application/json", bodyReader)
}

// NewStoreCollisionLinkChainRequestWithBody generates requests for StoreCollisionLinkChain with any type of body
func NewStoreCollisionLinkChainRequestWithBody(server string, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "link-chain", runtime.ParamLocationPath, linkChainID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/link-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListStoredCollisionScenesRequest generates requests for ListStoredCollisionScenes
func NewListStoredCollisionScenesRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/scenes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStoredCollisionSceneRequest generates requests for DeleteStoredCollisionScene
func NewDeleteStoredCollisionSceneRequest(server string, cellID CellID, sceneID SceneID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scene", runtime.ParamLocationPath, sceneID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/scenes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoredCollisionSceneRequest generates requests for GetStoredCollisionScene
func NewGetStoredCollisionSceneRequest(server string, cellID CellID, sceneID SceneID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scene", runtime.ParamLocationPath, sceneID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/scenes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreCollisionSceneRequest calls the generic StoreCollisionScene builder with application/json body
func NewStoreCollisionSceneRequest(server string, cellID CellID, sceneID SceneID, body StoreCollisionSceneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreCollisionSceneRequestWithBody(server, cellID, sceneID, "application/json", bodyReader)
}

// NewStoreCollisionSceneRequestWithBody generates requests for StoreCollisionScene with any type of body
func NewStoreCollisionSceneRequestWithBody(server string, cellID CellID, sceneID SceneID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scene", runtime.ParamLocationPath, sceneID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/scenes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListStoredCollisionToolsRequest generates requests for ListStoredCollisionTools
func NewListStoredCollisionToolsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/tools", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStoredCollisionToolRequest generates requests for DeleteStoredCollisionTool
func NewDeleteStoredCollisionToolRequest(server string, cellID CellID, toolID ToolID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tool", runtime.ParamLocationPath, toolID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/tools/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoredCollisionToolRequest generates requests for GetStoredCollisionTool
func NewGetStoredCollisionToolRequest(server string, cellID CellID, toolID ToolID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tool", runtime.ParamLocationPath, toolID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/tools/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreCollisionToolRequest calls the generic StoreCollisionTool builder with application/json body
func NewStoreCollisionToolRequest(server string, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreCollisionToolRequestWithBody(server, cellID, toolID, "application/json", bodyReader)
}

// NewStoreCollisionToolRequestWithBody generates requests for StoreCollisionTool with any type of body
func NewStoreCollisionToolRequestWithBody(server string, cellID CellID, toolID ToolID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tool", runtime.ParamLocationPath, toolID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/tools/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearAllObjectsRequest generates requests for ClearAllObjects
func NewClearAllObjectsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllObjectKeysRequest generates requests for ListAllObjectKeys
func NewListAllObjectKeysRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteObjectRequest generates requests for DeleteObject
func NewDeleteObjectRequest(server string, cellID CellID, key Key) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetObjectRequest generates requests for GetObject
func NewGetObjectRequest(server string, cellID CellID, key Key) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetObjectMetadataRequest generates requests for GetObjectMetadata
func NewGetObjectMetadataRequest(server string, cellID CellID, key Key) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreObjectRequestWithBody generates requests for StoreObject with any type of body
func NewStoreObjectRequestWithBody(server string, cellID CellID, key Key, params *StoreObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XMetadata != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Metadata", runtime.ParamLocationHeader, *params.XMetadata)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Metadata", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteProgramListRequest generates requests for DeleteProgramList
func NewDeleteProgramListRequest(server string, cellID CellID, params *DeleteProgramListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "program_ids", runtime.ParamLocationQuery, params.ProgramIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProgramMetadataRequest generates requests for ListProgramMetadata
func NewListProgramMetadataRequest(server string, cellID CellID, params *ListProgramMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_hidden", runtime.ParamLocationQuery, *params.ShowHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProgramRequestWithTextBody calls the generic CreateProgram builder with text/plain body
func NewCreateProgramRequestWithTextBody(server string, cellID CellID, params *CreateProgramParams, body CreateProgramTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewCreateProgramRequestWithBody(server, cellID, params, "text/plain", bodyReader)
}

// NewCreateProgramRequestWithBody generates requests for CreateProgram with any type of body
func NewCreateProgramRequestWithBody(server string, cellID CellID, params *CreateProgramParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProgramRequest generates requests for DeleteProgram
func NewDeleteProgramRequest(server string, cellID CellID, program Program) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "program", runtime.ParamLocationPath, program)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramRequest generates requests for GetProgram
func NewGetProgramRequest(server string, cellID CellID, program Program) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "program", runtime.ParamLocationPath, program)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProgramRequestWithTextBody calls the generic UpdateProgram builder with text/plain body
func NewUpdateProgramRequestWithTextBody(server string, cellID CellID, program Program, body UpdateProgramTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewUpdateProgramRequestWithBody(server, cellID, program, "text/plain", bodyReader)
}

// NewUpdateProgramRequestWithBody generates requests for UpdateProgram with any type of body
func NewUpdateProgramRequestWithBody(server string, cellID CellID, program Program, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "program", runtime.ParamLocationPath, program)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProgramMetadataRequest generates requests for GetProgramMetadata
func NewGetProgramMetadataRequest(server string, cellID CellID, program Program) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "program", runtime.ParamLocationPath, program)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs/%s/metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProgramMetadataRequest calls the generic UpdateProgramMetadata builder with application/json body
func NewUpdateProgramMetadataRequest(server string, cellID CellID, program Program, body UpdateProgramMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProgramMetadataRequestWithBody(server, cellID, program, "application/json", bodyReader)
}

// NewUpdateProgramMetadataRequestWithBody generates requests for UpdateProgramMetadata with any type of body
func NewUpdateProgramMetadataRequestWithBody(server string, cellID CellID, program Program, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "program", runtime.ParamLocationPath, program)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs/%s/metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadProgramMetadataImageRequestWithBody generates requests for UploadProgramMetadataImage with any type of body
func NewUploadProgramMetadataImageRequestWithBody(server string, cellID CellID, program Program, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "program", runtime.ParamLocationPath, program)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs/%s/metadata/image", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRecipeListRequest generates requests for DeleteRecipeList
func NewDeleteRecipeListRequest(server string, cellID CellID, params *DeleteRecipeListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recipe_ids", runtime.ParamLocationQuery, params.RecipeIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRecipeMetadataRequest generates requests for ListRecipeMetadata
func NewListRecipeMetadataRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRecipeRequest calls the generic CreateRecipe builder with application/json body
func NewCreateRecipeRequest(server string, cellID CellID, params *CreateRecipeParams, body CreateRecipeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRecipeRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewCreateRecipeRequestWithBody generates requests for CreateRecipe with any type of body
func NewCreateRecipeRequestWithBody(server string, cellID CellID, params *CreateRecipeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "program_id", runtime.ParamLocationQuery, params.ProgramId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRecipeRequest generates requests for DeleteRecipe
func NewDeleteRecipeRequest(server string, cellID CellID, recipe Recipe) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recipe", runtime.ParamLocationPath, recipe)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecipeRequest generates requests for GetRecipe
func NewGetRecipeRequest(server string, cellID CellID, recipe Recipe) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recipe", runtime.ParamLocationPath, recipe)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRecipeRequest calls the generic UpdateRecipe builder with application/json body
func NewUpdateRecipeRequest(server string, cellID CellID, recipe Recipe, body UpdateRecipeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRecipeRequestWithBody(server, cellID, recipe, "application/json", bodyReader)
}

// NewUpdateRecipeRequestWithBody generates requests for UpdateRecipe with any type of body
func NewUpdateRecipeRequestWithBody(server string, cellID CellID, recipe Recipe, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recipe", runtime.ParamLocationPath, recipe)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRecipeMetadataRequest generates requests for GetRecipeMetadata
func NewGetRecipeMetadataRequest(server string, cellID CellID, recipe Recipe) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recipe", runtime.ParamLocationPath, recipe)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes/%s/metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRecipeMetadataRequest calls the generic UpdateRecipeMetadata builder with application/json body
func NewUpdateRecipeMetadataRequest(server string, cellID CellID, recipe Recipe, body UpdateRecipeMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRecipeMetadataRequestWithBody(server, cellID, recipe, "application/json", bodyReader)
}

// NewUpdateRecipeMetadataRequestWithBody generates requests for UpdateRecipeMetadata with any type of body
func NewUpdateRecipeMetadataRequestWithBody(server string, cellID CellID, recipe Recipe, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recipe", runtime.ParamLocationPath, recipe)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes/%s/metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadRecipeMetadataImageRequestWithBody generates requests for UploadRecipeMetadataImage with any type of body
func NewUploadRecipeMetadataImageRequestWithBody(server string, cellID CellID, recipe Recipe, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recipe", runtime.ParamLocationPath, recipe)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes/%s/metadata/image", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalListCellsRequest generates requests for InternalListCells
func NewInternalListCellsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalDeployCellRequest calls the generic InternalDeployCell builder with application/json body
func NewInternalDeployCellRequest(server string, params *InternalDeployCellParams, body InternalDeployCellJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalDeployCellRequestWithBody(server, params, "application/json", bodyReader)
}

// NewInternalDeployCellRequestWithBody generates requests for InternalDeployCell with any type of body
func NewInternalDeployCellRequestWithBody(server string, params *InternalDeployCellParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalDeleteCellRequest generates requests for InternalDeleteCell
func NewInternalDeleteCellRequest(server string, cellID CellID, params *InternalDeleteCellParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalGetCellRequest generates requests for InternalGetCell
func NewInternalGetCellRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalUpdateCellRequest calls the generic InternalUpdateCell builder with application/json body
func NewInternalUpdateCellRequest(server string, cellID CellID, params *InternalUpdateCellParams, body InternalUpdateCellJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalUpdateCellRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewInternalUpdateCellRequestWithBody generates requests for InternalUpdateCell with any type of body
func NewInternalUpdateCellRequestWithBody(server string, cellID CellID, params *InternalUpdateCellParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalClearAppsRequest generates requests for InternalClearApps
func NewInternalClearAppsRequest(server string, cellID CellID, params *InternalClearAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalListAppsRequest generates requests for InternalListApps
func NewInternalListAppsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalAddAppRequest calls the generic InternalAddApp builder with application/json body
func NewInternalAddAppRequest(server string, cellID CellID, params *InternalAddAppParams, body InternalAddAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalAddAppRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewInternalAddAppRequestWithBody generates requests for InternalAddApp with any type of body
func NewInternalAddAppRequestWithBody(server string, cellID CellID, params *InternalAddAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalDeleteAppRequest generates requests for InternalDeleteApp
func NewInternalDeleteAppRequest(server string, cellID CellID, appID AppID, params *InternalDeleteAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, appID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalGetAppRequest generates requests for InternalGetApp
func NewInternalGetAppRequest(server string, cellID CellID, appID AppID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, appID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalUpdateAppRequest calls the generic InternalUpdateApp builder with application/json body
func NewInternalUpdateAppRequest(server string, cellID CellID, appID AppID, params *InternalUpdateAppParams, body InternalUpdateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalUpdateAppRequestWithBody(server, cellID, appID, params, "application/json", bodyReader)
}

// NewInternalUpdateAppRequestWithBody generates requests for InternalUpdateApp with any type of body
func NewInternalUpdateAppRequestWithBody(server string, cellID CellID, appID AppID, params *InternalUpdateAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, appID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalGetAppStatusRequest generates requests for InternalGetAppStatus
func NewInternalGetAppStatusRequest(server string, cellID CellID, appID AppID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, appID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/apps/%s/status", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalClearRobotControllersRequest generates requests for InternalClearRobotControllers
func NewInternalClearRobotControllersRequest(server string, cellID CellID, params *InternalClearRobotControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalListRobotControllersRequest generates requests for InternalListRobotControllers
func NewInternalListRobotControllersRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalAddRobotControllerRequest calls the generic InternalAddRobotController builder with application/json body
func NewInternalAddRobotControllerRequest(server string, cellID CellID, params *InternalAddRobotControllerParams, body InternalAddRobotControllerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalAddRobotControllerRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewInternalAddRobotControllerRequestWithBody generates requests for InternalAddRobotController with any type of body
func NewInternalAddRobotControllerRequestWithBody(server string, cellID CellID, params *InternalAddRobotControllerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalDeleteRobotControllerRequest generates requests for InternalDeleteRobotController
func NewInternalDeleteRobotControllerRequest(server string, cellID CellID, controllerID ControllerID, params *InternalDeleteRobotControllerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/controllers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalGetRobotControllerRequest generates requests for InternalGetRobotController
func NewInternalGetRobotControllerRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/controllers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalUpdateRobotControllerRequest calls the generic InternalUpdateRobotController builder with application/json body
func NewInternalUpdateRobotControllerRequest(server string, cellID CellID, controllerID ControllerID, params *InternalUpdateRobotControllerParams, body InternalUpdateRobotControllerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalUpdateRobotControllerRequestWithBody(server, cellID, controllerID, params, "application/json", bodyReader)
}

// NewInternalUpdateRobotControllerRequestWithBody generates requests for InternalUpdateRobotController with any type of body
func NewInternalUpdateRobotControllerRequestWithBody(server string, cellID CellID, controllerID ControllerID, params *InternalUpdateRobotControllerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/controllers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalGetRobotControllerStatusRequest generates requests for InternalGetRobotControllerStatus
func NewInternalGetRobotControllerStatusRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/controllers/%s/status", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalGetFoundationServicesRequest generates requests for InternalGetFoundationServices
func NewInternalGetFoundationServicesRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/foundation-services", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalUpdateFoundationServicesRequest calls the generic InternalUpdateFoundationServices builder with application/json body
func NewInternalUpdateFoundationServicesRequest(server string, cellID CellID, params *InternalUpdateFoundationServicesParams, body InternalUpdateFoundationServicesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalUpdateFoundationServicesRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewInternalUpdateFoundationServicesRequestWithBody generates requests for InternalUpdateFoundationServices with any type of body
func NewInternalUpdateFoundationServicesRequestWithBody(server string, cellID CellID, params *InternalUpdateFoundationServicesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/foundation-services", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDescriptionRequest generates requests for GetDescription
func NewGetDescriptionRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/rae/capabilities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterControllerRequest calls the generic RegisterController builder with application/json body
func NewRegisterControllerRequest(server string, cellID CellID, body RegisterControllerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterControllerRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewRegisterControllerRequestWithBody generates requests for RegisterController with any type of body
func NewRegisterControllerRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/rae/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteControllerRequest generates requests for DeleteController
func NewDeleteControllerRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/rae/controllers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListControllerRequest generates requests for ListController
func NewListControllerRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/rae/controllers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRaeVersionRequest generates requests for GetRaeVersion
func NewGetRaeVersionRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/rae/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalGetCellStatusRequest generates requests for InternalGetCellStatus
func NewInternalGetCellStatusRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/cells/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalGetDiagnosePackageRequest generates requests for InternalGetDiagnosePackage
func NewInternalGetDiagnosePackageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/system/diagnosis-package/zip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalGetSystemStatusRequest generates requests for InternalGetSystemStatus
func NewInternalGetSystemStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/system/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalCheckNovaVersionUpdateRequest generates requests for InternalCheckNovaVersionUpdate
func NewInternalCheckNovaVersionUpdateRequest(server string, params *InternalCheckNovaVersionUpdateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/system/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel", runtime.ParamLocationQuery, params.Channel); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalUpdateNovaVersionRequest calls the generic InternalUpdateNovaVersion builder with application/json body
func NewInternalUpdateNovaVersionRequest(server string, body InternalUpdateNovaVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalUpdateNovaVersionRequestWithBody(server, "application/json", bodyReader)
}

// NewInternalUpdateNovaVersionRequestWithBody generates requests for InternalUpdateNovaVersion with any type of body
func NewInternalUpdateNovaVersionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/system/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalGetSystemVersionRequest generates requests for InternalGetSystemVersion
func NewInternalGetSystemVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/internal/system/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListControllersWithResponse request
	ListControllersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListControllersResp, error)

	// GetSupportedModesWithResponse request
	GetSupportedModesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetSupportedModesResp, error)

	// StreamFreeDriveWithResponse request
	StreamFreeDriveWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams, reqEditors ...RequestEditorFn) (*StreamFreeDriveResp, error)

	// ListIODescriptionsWithResponse request
	ListIODescriptionsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams, reqEditors ...RequestEditorFn) (*ListIODescriptionsResp, error)

	// StreamIOValuesWithResponse request
	StreamIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams, reqEditors ...RequestEditorFn) (*StreamIOValuesResp, error)

	// ListIOValuesWithResponse request
	ListIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOValuesParams, reqEditors ...RequestEditorFn) (*ListIOValuesResp, error)

	// SetOutputValuesWithBodyWithResponse request with any body
	SetOutputValuesWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOutputValuesResp, error)

	SetOutputValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOutputValuesResp, error)

	// WaitForIOEventWithResponse request
	WaitForIOEventWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *WaitForIOEventParams, reqEditors ...RequestEditorFn) (*WaitForIOEventResp, error)

	// GetModeWithResponse request
	GetModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetModeResp, error)

	// SetDefaultModeWithResponse request
	SetDefaultModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams, reqEditors ...RequestEditorFn) (*SetDefaultModeResp, error)

	// StreamModeChangeWithResponse request
	StreamModeChangeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*StreamModeChangeResp, error)

	// GetCurrentRobotControllerStateWithResponse request
	GetCurrentRobotControllerStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetCurrentRobotControllerStateResp, error)

	// StreamRobotControllerStateWithResponse request
	StreamRobotControllerStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams, reqEditors ...RequestEditorFn) (*StreamRobotControllerStateResp, error)

	// ListVirtualRobotCoordinateSystemsWithResponse request
	ListVirtualRobotCoordinateSystemsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListVirtualRobotCoordinateSystemsResp, error)

	// AddVirtualRobotCoordinateSystemWithBodyWithResponse request with any body
	AddVirtualRobotCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualRobotCoordinateSystemResp, error)

	AddVirtualRobotCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body AddVirtualRobotCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualRobotCoordinateSystemResp, error)

	// DeleteVirtualRobotCoordinateSystemWithResponse request
	DeleteVirtualRobotCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystem CoordinateSystem, params *DeleteVirtualRobotCoordinateSystemParams, reqEditors ...RequestEditorFn) (*DeleteVirtualRobotCoordinateSystemResp, error)

	// GetCycleTimeWithResponse request
	GetCycleTimeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetCycleTimeResp, error)

	// GetEStopWithResponse request
	GetEStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetEStopResp, error)

	// PushEStopWithResponse request
	PushEStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*PushEStopResp, error)

	// ReleaseEStopWithResponse request
	ReleaseEStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ReleaseEStopResp, error)

	// ListIOsWithResponse request
	ListIOsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListIOsResp, error)

	// GetVirtualRobotIOValueWithResponse request
	GetVirtualRobotIOValueWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, reqEditors ...RequestEditorFn) (*GetVirtualRobotIOValueResp, error)

	// SetVirtualRobotIOValueWithResponse request
	SetVirtualRobotIOValueWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, params *SetVirtualRobotIOValueParams, reqEditors ...RequestEditorFn) (*SetVirtualRobotIOValueResp, error)

	// ExternalJointsStreamWithBodyWithResponse request with any body
	ExternalJointsStreamWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExternalJointsStreamResp, error)

	ExternalJointsStreamWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*ExternalJointsStreamResp, error)

	// GetMotionGroupStateWithResponse request
	GetMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*GetMotionGroupStateResp, error)

	// SetMotionGroupStateWithBodyWithResponse request with any body
	SetMotionGroupStateWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMotionGroupStateResp, error)

	SetMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetMotionGroupStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMotionGroupStateResp, error)

	// GetMotionGroupBehaviorWithResponse request
	GetMotionGroupBehaviorWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*GetMotionGroupBehaviorResp, error)

	// SetMotionGroupBehaviorWithResponse request
	SetMotionGroupBehaviorWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, params *SetMotionGroupBehaviorParams, reqEditors ...RequestEditorFn) (*SetMotionGroupBehaviorResp, error)

	// GetVirtualRobotMountingWithResponse request
	GetVirtualRobotMountingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*GetVirtualRobotMountingResp, error)

	// SetVirtualRobotMountingWithBodyWithResponse request with any body
	SetVirtualRobotMountingWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetVirtualRobotMountingResp, error)

	SetVirtualRobotMountingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetVirtualRobotMountingJSONRequestBody, reqEditors ...RequestEditorFn) (*SetVirtualRobotMountingResp, error)

	// ListVirtualRobotTcpsWithResponse request
	ListVirtualRobotTcpsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*ListVirtualRobotTcpsResp, error)

	// AddVirtualRobotTcpWithBodyWithResponse request with any body
	AddVirtualRobotTcpWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualRobotTcpResp, error)

	AddVirtualRobotTcpWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body AddVirtualRobotTcpJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualRobotTcpResp, error)

	// DeleteVirtualRobotTcpWithResponse request
	DeleteVirtualRobotTcpWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, tcp Tcp, reqEditors ...RequestEditorFn) (*DeleteVirtualRobotTcpResp, error)

	// GetMotionGroupsWithResponse request
	GetMotionGroupsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetMotionGroupsResp, error)

	// GetOperationModeWithResponse request
	GetOperationModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetOperationModeResp, error)

	// SetOperationModeWithResponse request
	SetOperationModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetOperationModeParams, reqEditors ...RequestEditorFn) (*SetOperationModeResp, error)

	// GetVirtualRobotConfigurationWithResponse request
	GetVirtualRobotConfigurationWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetVirtualRobotConfigurationResp, error)

	// ListCoordinateSystemsWithResponse request
	ListCoordinateSystemsWithResponse(ctx context.Context, cellID CellID, params *ListCoordinateSystemsParams, reqEditors ...RequestEditorFn) (*ListCoordinateSystemsResp, error)

	// AddCoordinateSystemWithBodyWithResponse request with any body
	AddCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCoordinateSystemResp, error)

	AddCoordinateSystemWithResponse(ctx context.Context, cellID CellID, body AddCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCoordinateSystemResp, error)

	// DeleteCoordinateSystemWithResponse request
	DeleteCoordinateSystemWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, reqEditors ...RequestEditorFn) (*DeleteCoordinateSystemResp, error)

	// GetCoordinateSystemWithResponse request
	GetCoordinateSystemWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, params *GetCoordinateSystemParams, reqEditors ...RequestEditorFn) (*GetCoordinateSystemResp, error)

	// TransformInCoordinateSystemWithBodyWithResponse request with any body
	TransformInCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransformInCoordinateSystemResp, error)

	TransformInCoordinateSystemWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, body TransformInCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*TransformInCoordinateSystemResp, error)

	// ClearDevicesWithResponse request
	ClearDevicesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearDevicesResp, error)

	// CreateDeviceWithBodyWithResponse request with any body
	CreateDeviceWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeviceResp, error)

	CreateDeviceWithResponse(ctx context.Context, cellID CellID, body CreateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeviceResp, error)

	// DeleteDeviceWithResponse request
	DeleteDeviceWithResponse(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*DeleteDeviceResp, error)

	// GetDeviceWithResponse request
	GetDeviceWithResponse(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*GetDeviceResp, error)

	// DefaultHomeJointsWithResponse request
	DefaultHomeJointsWithResponse(ctx context.Context, cellID CellID, params *DefaultHomeJointsParams, reqEditors ...RequestEditorFn) (*DefaultHomeJointsResp, error)

	// ListMotionGroupsWithResponse request
	ListMotionGroupsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListMotionGroupsResp, error)

	// ActivateMotionGroupWithResponse request
	ActivateMotionGroupWithResponse(ctx context.Context, cellID CellID, params *ActivateMotionGroupParams, reqEditors ...RequestEditorFn) (*ActivateMotionGroupResp, error)

	// ActivateAllMotionGroupsWithResponse request
	ActivateAllMotionGroupsWithResponse(ctx context.Context, cellID CellID, params *ActivateAllMotionGroupsParams, reqEditors ...RequestEditorFn) (*ActivateAllMotionGroupsResp, error)

	// JointJoggingWithBodyWithResponse request with any body
	JointJoggingWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JointJoggingResp, error)

	JointJoggingWithResponse(ctx context.Context, cellID CellID, body JointJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*JointJoggingResp, error)

	// DirectionJoggingWithBodyWithResponse request with any body
	DirectionJoggingWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectionJoggingResp, error)

	DirectionJoggingWithResponse(ctx context.Context, cellID CellID, body DirectionJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectionJoggingResp, error)

	// DeactivateMotionGroupWithResponse request
	DeactivateMotionGroupWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*DeactivateMotionGroupResp, error)

	// GetInfoCapabilitiesWithResponse request
	GetInfoCapabilitiesWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetInfoCapabilitiesResp, error)

	// GetJoggingCapabilitiesWithResponse request
	GetJoggingCapabilitiesWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetJoggingCapabilitiesResp, error)

	// GetKinematicCapabilitiesWithResponse request
	GetKinematicCapabilitiesWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetKinematicCapabilitiesResp, error)

	// CalculateAllInverseKinematicWithBodyWithResponse request with any body
	CalculateAllInverseKinematicWithBodyWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculateAllInverseKinematicResp, error)

	CalculateAllInverseKinematicWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateAllInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculateAllInverseKinematicResp, error)

	// CalculateInverseKinematicWithBodyWithResponse request with any body
	CalculateInverseKinematicWithBodyWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculateInverseKinematicResp, error)

	CalculateInverseKinematicWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculateInverseKinematicResp, error)

	// CalculateForwardKinematicWithBodyWithResponse request with any body
	CalculateForwardKinematicWithBodyWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculateForwardKinematicResp, error)

	CalculateForwardKinematicWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateForwardKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculateForwardKinematicResp, error)

	// GetMountingWithResponse request
	GetMountingWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetMountingResp, error)

	// GetOptimizerConfigurationWithResponse request
	GetOptimizerConfigurationWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetOptimizerConfigurationParams, reqEditors ...RequestEditorFn) (*GetOptimizerConfigurationResp, error)

	// ListPayloadsWithResponse request
	ListPayloadsWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*ListPayloadsResp, error)

	// GetActivePayloadWithResponse request
	GetActivePayloadWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetActivePayloadResp, error)

	// GetSafetySetupWithResponse request
	GetSafetySetupWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetSafetySetupResp, error)

	// GetMotionGroupSpecificationWithResponse request
	GetMotionGroupSpecificationWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetMotionGroupSpecificationResp, error)

	// GetCurrentMotionGroupStateWithResponse request
	GetCurrentMotionGroupStateWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetCurrentMotionGroupStateParams, reqEditors ...RequestEditorFn) (*GetCurrentMotionGroupStateResp, error)

	// StreamMotionGroupStateWithResponse request
	StreamMotionGroupStateWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *StreamMotionGroupStateParams, reqEditors ...RequestEditorFn) (*StreamMotionGroupStateResp, error)

	// StopJoggingWithResponse request
	StopJoggingWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*StopJoggingResp, error)

	// ListTcpsWithResponse request
	ListTcpsWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *ListTcpsParams, reqEditors ...RequestEditorFn) (*ListTcpsResp, error)

	// GetActiveTcpWithResponse request
	GetActiveTcpWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetActiveTcpParams, reqEditors ...RequestEditorFn) (*GetActiveTcpResp, error)

	// PlanTrajectoryWithBodyWithResponse request with any body
	PlanTrajectoryWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanTrajectoryResp, error)

	PlanTrajectoryWithResponse(ctx context.Context, cellID CellID, body PlanTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanTrajectoryResp, error)

	// DeleteAllMotionsWithResponse request
	DeleteAllMotionsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*DeleteAllMotionsResp, error)

	// ListMotionsWithResponse request
	ListMotionsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListMotionsResp, error)

	// PlanMotionWithBodyWithResponse request with any body
	PlanMotionWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanMotionResp, error)

	PlanMotionWithResponse(ctx context.Context, cellID CellID, body PlanMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanMotionResp, error)

	// StreamMoveWithBodyWithResponse request with any body
	StreamMoveWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StreamMoveResp, error)

	StreamMoveWithResponse(ctx context.Context, cellID CellID, body StreamMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*StreamMoveResp, error)

	// DeleteMotionWithResponse request
	DeleteMotionWithResponse(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*DeleteMotionResp, error)

	// StreamMoveBackwardWithResponse request
	StreamMoveBackwardWithResponse(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveBackwardParams, reqEditors ...RequestEditorFn) (*StreamMoveBackwardResp, error)

	// StreamMoveForwardWithResponse request
	StreamMoveForwardWithResponse(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveForwardParams, reqEditors ...RequestEditorFn) (*StreamMoveForwardResp, error)

	// StreamMoveToTrajectoryViaJointPTPWithResponse request
	StreamMoveToTrajectoryViaJointPTPWithResponse(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveToTrajectoryViaJointPTPParams, reqEditors ...RequestEditorFn) (*StreamMoveToTrajectoryViaJointPTPResp, error)

	// GetPlannedMotionWithResponse request
	GetPlannedMotionWithResponse(ctx context.Context, cellID CellID, motion Motion, params *GetPlannedMotionParams, reqEditors ...RequestEditorFn) (*GetPlannedMotionResp, error)

	// StopExecutionWithResponse request
	StopExecutionWithResponse(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*StopExecutionResp, error)

	// GetMotionTrajectoryWithResponse request
	GetMotionTrajectoryWithResponse(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectoryParams, reqEditors ...RequestEditorFn) (*GetMotionTrajectoryResp, error)

	// GetMotionTrajectorySampleWithResponse request
	GetMotionTrajectorySampleWithResponse(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectorySampleParams, reqEditors ...RequestEditorFn) (*GetMotionTrajectorySampleResp, error)

	// LoadPlannedMotionWithBodyWithResponse request with any body
	LoadPlannedMotionWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoadPlannedMotionResp, error)

	LoadPlannedMotionWithResponse(ctx context.Context, cellID CellID, body LoadPlannedMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*LoadPlannedMotionResp, error)

	// ClearProgramsValuesWithResponse request
	ClearProgramsValuesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearProgramsValuesResp, error)

	// CreateProgramsValueWithBodyWithResponse request with any body
	CreateProgramsValueWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramsValueResp, error)

	CreateProgramsValueWithResponse(ctx context.Context, cellID CellID, body CreateProgramsValueJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramsValueResp, error)

	// DeleteProgramValueWithResponse request
	DeleteProgramValueWithResponse(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*DeleteProgramValueResp, error)

	// GetProgramValueWithResponse request
	GetProgramValueWithResponse(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*GetProgramValueResp, error)

	// UpdateProgramValueWithBodyWithResponse request with any body
	UpdateProgramValueWithBodyWithResponse(ctx context.Context, cellID CellID, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramValueResp, error)

	UpdateProgramValueWithResponse(ctx context.Context, cellID CellID, key string, body UpdateProgramValueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramValueResp, error)

	// ListStoredCollidersWithResponse request
	ListStoredCollidersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollidersResp, error)

	// DeleteStoredColliderWithResponse request
	DeleteStoredColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*DeleteStoredColliderResp, error)

	// GetStoredColliderWithResponse request
	GetStoredColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*GetStoredColliderResp, error)

	// StoreColliderWithBodyWithResponse request with any body
	StoreColliderWithBodyWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreColliderResp, error)

	StoreColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreColliderResp, error)

	// ListCollisionLinkChainsWithResponse request
	ListCollisionLinkChainsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListCollisionLinkChainsResp, error)

	// DeleteStoredCollisionLinkChainWithResponse request
	DeleteStoredCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionLinkChainResp, error)

	// GetStoredCollisionLinkChainWithResponse request
	GetStoredCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*GetStoredCollisionLinkChainResp, error)

	// StoreCollisionLinkChainWithBodyWithResponse request with any body
	StoreCollisionLinkChainWithBodyWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionLinkChainResp, error)

	StoreCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionLinkChainResp, error)

	// ListStoredCollisionScenesWithResponse request
	ListStoredCollisionScenesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollisionScenesResp, error)

	// DeleteStoredCollisionSceneWithResponse request
	DeleteStoredCollisionSceneWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionSceneResp, error)

	// GetStoredCollisionSceneWithResponse request
	GetStoredCollisionSceneWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*GetStoredCollisionSceneResp, error)

	// StoreCollisionSceneWithBodyWithResponse request with any body
	StoreCollisionSceneWithBodyWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionSceneResp, error)

	StoreCollisionSceneWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, body StoreCollisionSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionSceneResp, error)

	// ListStoredCollisionToolsWithResponse request
	ListStoredCollisionToolsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollisionToolsResp, error)

	// DeleteStoredCollisionToolWithResponse request
	DeleteStoredCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionToolResp, error)

	// GetStoredCollisionToolWithResponse request
	GetStoredCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*GetStoredCollisionToolResp, error)

	// StoreCollisionToolWithBodyWithResponse request with any body
	StoreCollisionToolWithBodyWithResponse(ctx context.Context, cellID CellID, toolID ToolID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionToolResp, error)

	StoreCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionToolResp, error)

	// ClearAllObjectsWithResponse request
	ClearAllObjectsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearAllObjectsResp, error)

	// ListAllObjectKeysWithResponse request
	ListAllObjectKeysWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListAllObjectKeysResp, error)

	// DeleteObjectWithResponse request
	DeleteObjectWithResponse(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*DeleteObjectResp, error)

	// GetObjectWithResponse request
	GetObjectWithResponse(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*GetObjectResp, error)

	// GetObjectMetadataWithResponse request
	GetObjectMetadataWithResponse(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*GetObjectMetadataResp, error)

	// StoreObjectWithBodyWithResponse request with any body
	StoreObjectWithBodyWithResponse(ctx context.Context, cellID CellID, key Key, params *StoreObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreObjectResp, error)

	// DeleteProgramListWithResponse request
	DeleteProgramListWithResponse(ctx context.Context, cellID CellID, params *DeleteProgramListParams, reqEditors ...RequestEditorFn) (*DeleteProgramListResp, error)

	// ListProgramMetadataWithResponse request
	ListProgramMetadataWithResponse(ctx context.Context, cellID CellID, params *ListProgramMetadataParams, reqEditors ...RequestEditorFn) (*ListProgramMetadataResp, error)

	// CreateProgramWithBodyWithResponse request with any body
	CreateProgramWithBodyWithResponse(ctx context.Context, cellID CellID, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramResp, error)

	CreateProgramWithTextBodyWithResponse(ctx context.Context, cellID CellID, params *CreateProgramParams, body CreateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramResp, error)

	// DeleteProgramWithResponse request
	DeleteProgramWithResponse(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*DeleteProgramResp, error)

	// GetProgramWithResponse request
	GetProgramWithResponse(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*GetProgramResp, error)

	// UpdateProgramWithBodyWithResponse request with any body
	UpdateProgramWithBodyWithResponse(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramResp, error)

	UpdateProgramWithTextBodyWithResponse(ctx context.Context, cellID CellID, program Program, body UpdateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramResp, error)

	// GetProgramMetadataWithResponse request
	GetProgramMetadataWithResponse(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*GetProgramMetadataResp, error)

	// UpdateProgramMetadataWithBodyWithResponse request with any body
	UpdateProgramMetadataWithBodyWithResponse(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramMetadataResp, error)

	UpdateProgramMetadataWithResponse(ctx context.Context, cellID CellID, program Program, body UpdateProgramMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramMetadataResp, error)

	// UploadProgramMetadataImageWithBodyWithResponse request with any body
	UploadProgramMetadataImageWithBodyWithResponse(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadProgramMetadataImageResp, error)

	// DeleteRecipeListWithResponse request
	DeleteRecipeListWithResponse(ctx context.Context, cellID CellID, params *DeleteRecipeListParams, reqEditors ...RequestEditorFn) (*DeleteRecipeListResp, error)

	// ListRecipeMetadataWithResponse request
	ListRecipeMetadataWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListRecipeMetadataResp, error)

	// CreateRecipeWithBodyWithResponse request with any body
	CreateRecipeWithBodyWithResponse(ctx context.Context, cellID CellID, params *CreateRecipeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRecipeResp, error)

	CreateRecipeWithResponse(ctx context.Context, cellID CellID, params *CreateRecipeParams, body CreateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRecipeResp, error)

	// DeleteRecipeWithResponse request
	DeleteRecipeWithResponse(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*DeleteRecipeResp, error)

	// GetRecipeWithResponse request
	GetRecipeWithResponse(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*GetRecipeResp, error)

	// UpdateRecipeWithBodyWithResponse request with any body
	UpdateRecipeWithBodyWithResponse(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecipeResp, error)

	UpdateRecipeWithResponse(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecipeResp, error)

	// GetRecipeMetadataWithResponse request
	GetRecipeMetadataWithResponse(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*GetRecipeMetadataResp, error)

	// UpdateRecipeMetadataWithBodyWithResponse request with any body
	UpdateRecipeMetadataWithBodyWithResponse(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecipeMetadataResp, error)

	UpdateRecipeMetadataWithResponse(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecipeMetadataResp, error)

	// UploadRecipeMetadataImageWithBodyWithResponse request with any body
	UploadRecipeMetadataImageWithBodyWithResponse(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadRecipeMetadataImageResp, error)

	// InternalListCellsWithResponse request
	InternalListCellsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InternalListCellsResp, error)

	// InternalDeployCellWithBodyWithResponse request with any body
	InternalDeployCellWithBodyWithResponse(ctx context.Context, params *InternalDeployCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalDeployCellResp, error)

	InternalDeployCellWithResponse(ctx context.Context, params *InternalDeployCellParams, body InternalDeployCellJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalDeployCellResp, error)

	// InternalDeleteCellWithResponse request
	InternalDeleteCellWithResponse(ctx context.Context, cellID CellID, params *InternalDeleteCellParams, reqEditors ...RequestEditorFn) (*InternalDeleteCellResp, error)

	// InternalGetCellWithResponse request
	InternalGetCellWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*InternalGetCellResp, error)

	// InternalUpdateCellWithBodyWithResponse request with any body
	InternalUpdateCellWithBodyWithResponse(ctx context.Context, cellID CellID, params *InternalUpdateCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalUpdateCellResp, error)

	InternalUpdateCellWithResponse(ctx context.Context, cellID CellID, params *InternalUpdateCellParams, body InternalUpdateCellJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalUpdateCellResp, error)

	// InternalClearAppsWithResponse request
	InternalClearAppsWithResponse(ctx context.Context, cellID CellID, params *InternalClearAppsParams, reqEditors ...RequestEditorFn) (*InternalClearAppsResp, error)

	// InternalListAppsWithResponse request
	InternalListAppsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*InternalListAppsResp, error)

	// InternalAddAppWithBodyWithResponse request with any body
	InternalAddAppWithBodyWithResponse(ctx context.Context, cellID CellID, params *InternalAddAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalAddAppResp, error)

	InternalAddAppWithResponse(ctx context.Context, cellID CellID, params *InternalAddAppParams, body InternalAddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalAddAppResp, error)

	// InternalDeleteAppWithResponse request
	InternalDeleteAppWithResponse(ctx context.Context, cellID CellID, appID AppID, params *InternalDeleteAppParams, reqEditors ...RequestEditorFn) (*InternalDeleteAppResp, error)

	// InternalGetAppWithResponse request
	InternalGetAppWithResponse(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*InternalGetAppResp, error)

	// InternalUpdateAppWithBodyWithResponse request with any body
	InternalUpdateAppWithBodyWithResponse(ctx context.Context, cellID CellID, appID AppID, params *InternalUpdateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalUpdateAppResp, error)

	InternalUpdateAppWithResponse(ctx context.Context, cellID CellID, appID AppID, params *InternalUpdateAppParams, body InternalUpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalUpdateAppResp, error)

	// InternalGetAppStatusWithResponse request
	InternalGetAppStatusWithResponse(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*InternalGetAppStatusResp, error)

	// InternalClearRobotControllersWithResponse request
	InternalClearRobotControllersWithResponse(ctx context.Context, cellID CellID, params *InternalClearRobotControllersParams, reqEditors ...RequestEditorFn) (*InternalClearRobotControllersResp, error)

	// InternalListRobotControllersWithResponse request
	InternalListRobotControllersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*InternalListRobotControllersResp, error)

	// InternalAddRobotControllerWithBodyWithResponse request with any body
	InternalAddRobotControllerWithBodyWithResponse(ctx context.Context, cellID CellID, params *InternalAddRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalAddRobotControllerResp, error)

	InternalAddRobotControllerWithResponse(ctx context.Context, cellID CellID, params *InternalAddRobotControllerParams, body InternalAddRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalAddRobotControllerResp, error)

	// InternalDeleteRobotControllerWithResponse request
	InternalDeleteRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *InternalDeleteRobotControllerParams, reqEditors ...RequestEditorFn) (*InternalDeleteRobotControllerResp, error)

	// InternalGetRobotControllerWithResponse request
	InternalGetRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*InternalGetRobotControllerResp, error)

	// InternalUpdateRobotControllerWithBodyWithResponse request with any body
	InternalUpdateRobotControllerWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *InternalUpdateRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalUpdateRobotControllerResp, error)

	InternalUpdateRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *InternalUpdateRobotControllerParams, body InternalUpdateRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalUpdateRobotControllerResp, error)

	// InternalGetRobotControllerStatusWithResponse request
	InternalGetRobotControllerStatusWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*InternalGetRobotControllerStatusResp, error)

	// InternalGetFoundationServicesWithResponse request
	InternalGetFoundationServicesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*InternalGetFoundationServicesResp, error)

	// InternalUpdateFoundationServicesWithBodyWithResponse request with any body
	InternalUpdateFoundationServicesWithBodyWithResponse(ctx context.Context, cellID CellID, params *InternalUpdateFoundationServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalUpdateFoundationServicesResp, error)

	InternalUpdateFoundationServicesWithResponse(ctx context.Context, cellID CellID, params *InternalUpdateFoundationServicesParams, body InternalUpdateFoundationServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalUpdateFoundationServicesResp, error)

	// GetDescriptionWithResponse request
	GetDescriptionWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetDescriptionResp, error)

	// RegisterControllerWithBodyWithResponse request with any body
	RegisterControllerWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterControllerResp, error)

	RegisterControllerWithResponse(ctx context.Context, cellID CellID, body RegisterControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterControllerResp, error)

	// DeleteControllerWithResponse request
	DeleteControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*DeleteControllerResp, error)

	// ListControllerWithResponse request
	ListControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListControllerResp, error)

	// GetRaeVersionWithResponse request
	GetRaeVersionWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetRaeVersionResp, error)

	// InternalGetCellStatusWithResponse request
	InternalGetCellStatusWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*InternalGetCellStatusResp, error)

	// InternalGetDiagnosePackageWithResponse request
	InternalGetDiagnosePackageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InternalGetDiagnosePackageResp, error)

	// InternalGetSystemStatusWithResponse request
	InternalGetSystemStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InternalGetSystemStatusResp, error)

	// InternalCheckNovaVersionUpdateWithResponse request
	InternalCheckNovaVersionUpdateWithResponse(ctx context.Context, params *InternalCheckNovaVersionUpdateParams, reqEditors ...RequestEditorFn) (*InternalCheckNovaVersionUpdateResp, error)

	// InternalUpdateNovaVersionWithBodyWithResponse request with any body
	InternalUpdateNovaVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalUpdateNovaVersionResp, error)

	InternalUpdateNovaVersionWithResponse(ctx context.Context, body InternalUpdateNovaVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalUpdateNovaVersionResp, error)

	// InternalGetSystemVersionWithResponse request
	InternalGetSystemVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InternalGetSystemVersionResp, error)
}

type ListControllersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ControllerInstanceList
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListControllersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListControllersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSupportedModesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ControllerCapabilities
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSupportedModesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSupportedModesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamFreeDriveResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotControllerState
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamFreeDriveResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamFreeDriveResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIODescriptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIODescriptionsResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListIODescriptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIODescriptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamIOValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIOValuesResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamIOValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamIOValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIOValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIOValuesResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListIOValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIOValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOutputValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetOutputValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOutputValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WaitForIOEventResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r WaitForIOEventResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WaitForIOEventResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetModeResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetModeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDefaultModeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetDefaultModeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDefaultModeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamModeChangeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModeChangeResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamModeChangeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamModeChangeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentRobotControllerStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotControllerState
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCurrentRobotControllerStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentRobotControllerStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamRobotControllerStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotControllerState
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamRobotControllerStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamRobotControllerStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVirtualRobotCoordinateSystemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystems
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListVirtualRobotCoordinateSystemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVirtualRobotCoordinateSystemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddVirtualRobotCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r AddVirtualRobotCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddVirtualRobotCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualRobotCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualRobotCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualRobotCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCycleTimeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CycleTime
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCycleTimeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCycleTimeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEStopResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Flag
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetEStopResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEStopResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PushEStopResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r PushEStopResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PushEStopResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReleaseEStopResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ReleaseEStopResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReleaseEStopResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIOsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IOs
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListIOsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIOsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualRobotIOValueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IO
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVirtualRobotIOValueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualRobotIOValueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetVirtualRobotIOValueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetVirtualRobotIOValueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetVirtualRobotIOValueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExternalJointsStreamResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupJoints
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExternalJointsStreamResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExternalJointsStreamResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupJoints
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMotionGroupStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetMotionGroupStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMotionGroupStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupBehaviorResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupBehaviorGetter
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupBehaviorResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupBehaviorResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMotionGroupBehaviorResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetMotionGroupBehaviorResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMotionGroupBehaviorResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualRobotMountingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystem
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVirtualRobotMountingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualRobotMountingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetVirtualRobotMountingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystem
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetVirtualRobotMountingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetVirtualRobotMountingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVirtualRobotTcpsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotTcps
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListVirtualRobotTcpsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVirtualRobotTcpsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddVirtualRobotTcpResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r AddVirtualRobotTcpResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddVirtualRobotTcpResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualRobotTcpResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualRobotTcpResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualRobotTcpResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupInfos
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOperationModeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OpMode
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetOperationModeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOperationModeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOperationModeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetOperationModeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOperationModeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualRobotConfigurationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VirtualRobotConfiguration
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVirtualRobotConfigurationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualRobotConfigurationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCoordinateSystemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListCoordinateSystemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCoordinateSystemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystem
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r AddCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystem
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransformInCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pose
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r TransformInCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransformInCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearDevicesResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearDevicesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearDevicesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeviceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateDeviceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeviceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeviceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteDeviceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeviceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeviceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetDeviceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeviceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DefaultHomeJointsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Joints
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DefaultHomeJointsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DefaultHomeJointsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMotionGroupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupInstanceList
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListMotionGroupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMotionGroupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateMotionGroupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupInstance
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ActivateMotionGroupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateMotionGroupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateAllMotionGroupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupInstanceList
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ActivateAllMotionGroupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateAllMotionGroupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JointJoggingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JoggingResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r JointJoggingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JointJoggingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectionJoggingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JoggingResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DirectionJoggingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectionJoggingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeactivateMotionGroupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeactivateMotionGroupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeactivateMotionGroupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInfoCapabilitiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InfoServiceCapabilities
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetInfoCapabilitiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInfoCapabilitiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJoggingCapabilitiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JoggingServiceCapabilities
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetJoggingCapabilitiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJoggingCapabilitiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKinematicCapabilitiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KinematicServiceCapabilities
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetKinematicCapabilitiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKinematicCapabilitiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CalculateAllInverseKinematicResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllJointPositionsResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r CalculateAllInverseKinematicResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CalculateAllInverseKinematicResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CalculateInverseKinematicResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Joints
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r CalculateInverseKinematicResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CalculateInverseKinematicResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CalculateForwardKinematicResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pose
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r CalculateForwardKinematicResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CalculateForwardKinematicResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMountingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Mounting
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMountingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMountingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptimizerConfigurationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OptimizerSetup
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetOptimizerConfigurationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptimizerConfigurationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPayloadsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPayloadsResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListPayloadsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPayloadsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivePayloadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Payload
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetActivePayloadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivePayloadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSafetySetupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SafetySetup
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSafetySetupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSafetySetupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupSpecificationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupSpecification
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupSpecificationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupSpecificationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentMotionGroupStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupStateResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCurrentMotionGroupStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentMotionGroupStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamMotionGroupStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupStateResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamMotionGroupStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamMotionGroupStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopJoggingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StopJoggingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopJoggingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTcpsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTcpsResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListTcpsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTcpsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActiveTcpResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotTcp
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetActiveTcpResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActiveTcpResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlanTrajectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlanTrajectoryResponse
}

// Status returns HTTPResponse.Status
func (r PlanTrajectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlanTrajectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllMotionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAllMotionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllMotionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMotionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionIdsListResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListMotionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMotionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlanMotionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlanResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r PlanMotionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlanMotionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamMoveResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamMoveResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamMoveResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamMoveResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMotionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteMotionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMotionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamMoveBackwardResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamMoveResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamMoveBackwardResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamMoveBackwardResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamMoveForwardResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamMoveResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamMoveForwardResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamMoveForwardResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamMoveToTrajectoryViaJointPTPResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamMoveResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamMoveToTrajectoryViaJointPTPResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamMoveToTrajectoryViaJointPTPResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlannedMotionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlannedMotion
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPlannedMotionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlannedMotionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopExecutionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StopExecutionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopExecutionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionTrajectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTrajectoryResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMotionTrajectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionTrajectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionTrajectorySampleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTrajectorySampleResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMotionTrajectorySampleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionTrajectorySampleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadPlannedMotionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlanResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r LoadPlannedMotionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadPlannedMotionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearProgramsValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearProgramsValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearProgramsValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProgramsValueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateProgramsValueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProgramsValueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProgramValueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteProgramValueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProgramValueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramValueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON422 *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetProgramValueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramValueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProgramValueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateProgramValueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProgramValueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStoredCollidersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ColliderDictionary
}

// Status returns HTTPResponse.Status
func (r ListStoredCollidersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStoredCollidersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoredColliderResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteStoredColliderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoredColliderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoredColliderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collider
}

// Status returns HTTPResponse.Status
func (r GetStoredColliderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoredColliderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreColliderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collider
}

// Status returns HTTPResponse.Status
func (r StoreColliderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreColliderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCollisionLinkChainsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]LinkChain
}

// Status returns HTTPResponse.Status
func (r ListCollisionLinkChainsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCollisionLinkChainsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoredCollisionLinkChainResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteStoredCollisionLinkChainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoredCollisionLinkChainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoredCollisionLinkChainResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkChain
}

// Status returns HTTPResponse.Status
func (r GetStoredCollisionLinkChainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoredCollisionLinkChainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreCollisionLinkChainResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkChain
}

// Status returns HTTPResponse.Status
func (r StoreCollisionLinkChainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreCollisionLinkChainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStoredCollisionScenesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]CollisionScene
}

// Status returns HTTPResponse.Status
func (r ListStoredCollisionScenesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStoredCollisionScenesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoredCollisionSceneResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteStoredCollisionSceneResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoredCollisionSceneResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoredCollisionSceneResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollisionScene
}

// Status returns HTTPResponse.Status
func (r GetStoredCollisionSceneResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoredCollisionSceneResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreCollisionSceneResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollisionScene
}

// Status returns HTTPResponse.Status
func (r StoreCollisionSceneResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreCollisionSceneResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStoredCollisionToolsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]Tool
}

// Status returns HTTPResponse.Status
func (r ListStoredCollisionToolsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStoredCollisionToolsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoredCollisionToolResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteStoredCollisionToolResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoredCollisionToolResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoredCollisionToolResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tool
}

// Status returns HTTPResponse.Status
func (r GetStoredCollisionToolResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoredCollisionToolResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreCollisionToolResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tool
}

// Status returns HTTPResponse.Status
func (r StoreCollisionToolResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreCollisionToolResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearAllObjectsResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearAllObjectsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearAllObjectsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllObjectKeysResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Key
}

// Status returns HTTPResponse.Status
func (r ListAllObjectKeysResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllObjectKeysResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteObjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetObjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetObjectMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreObjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StoreObjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreObjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProgramListResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProgramMetadataResponse
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteProgramListResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProgramListResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProgramMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProgramMetadataResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListProgramMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProgramMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProgramResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateProgramResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProgramResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProgramResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteProgramResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProgramResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetProgramResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProgramResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateProgramResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProgramResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetProgramMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProgramMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateProgramMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProgramMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadProgramMetadataImageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UploadProgramMetadataImageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadProgramMetadataImageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecipeListResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRecipeMetadataResponse
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteRecipeListResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecipeListResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRecipeMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRecipeMetadataResponse
}

// Status returns HTTPResponse.Status
func (r ListRecipeMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecipeMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRecipeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateRecipeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRecipeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecipeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteRecipeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecipeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecipeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetRecipeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecipeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRecipeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateRecipeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRecipeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecipeMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetRecipeMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecipeMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRecipeMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateRecipeMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRecipeMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadRecipeMetadataImageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UploadRecipeMetadataImageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadRecipeMetadataImageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalListCellsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameList
}

// Status returns HTTPResponse.Status
func (r InternalListCellsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalListCellsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeployCellResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InternalDeployCellResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeployCellResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteCellResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalDeleteCellResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteCellResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetCellResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InternalCell
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalGetCellResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetCellResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalUpdateCellResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalUpdateCellResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalUpdateCellResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalClearAppsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalClearAppsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalClearAppsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalListAppsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameList
}

// Status returns HTTPResponse.Status
func (r InternalListAppsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalListAppsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalAddAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InternalAddAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalAddAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalDeleteAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalGetAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalUpdateAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalUpdateAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalUpdateAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetAppStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceStatusList
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalGetAppStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetAppStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalClearRobotControllersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalClearRobotControllersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalClearRobotControllersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalListRobotControllersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameList
}

// Status returns HTTPResponse.Status
func (r InternalListRobotControllersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalListRobotControllersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalAddRobotControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalAddRobotControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalAddRobotControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteRobotControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalDeleteRobotControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteRobotControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetRobotControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InternalRobotController
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalGetRobotControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetRobotControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalUpdateRobotControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalUpdateRobotControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalUpdateRobotControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetRobotControllerStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceStatusList
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalGetRobotControllerStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetRobotControllerStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetFoundationServicesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FoundationServices
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalGetFoundationServicesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetFoundationServicesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalUpdateFoundationServicesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalUpdateFoundationServicesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalUpdateFoundationServicesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDescriptionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Description
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetDescriptionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDescriptionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ControllerInstance
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r RegisterControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ControllerInstance
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRaeVersionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Versions
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetRaeVersionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRaeVersionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetCellStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceStatusList
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r InternalGetCellStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetCellStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetDiagnosePackageResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InternalGetDiagnosePackageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetDiagnosePackageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetSystemStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceStatusList
}

// Status returns HTTPResponse.Status
func (r InternalGetSystemStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetSystemStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalCheckNovaVersionUpdateResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InternalCheckNovaVersionUpdateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalCheckNovaVersionUpdateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalUpdateNovaVersionResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InternalUpdateNovaVersionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalUpdateNovaVersionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetSystemVersionResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InternalGetSystemVersionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetSystemVersionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListControllersWithResponse request returning *ListControllersResp
func (c *ClientWithResponses) ListControllersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListControllersResp, error) {
	rsp, err := c.ListControllers(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListControllersResp(rsp)
}

// GetSupportedModesWithResponse request returning *GetSupportedModesResp
func (c *ClientWithResponses) GetSupportedModesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetSupportedModesResp, error) {
	rsp, err := c.GetSupportedModes(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSupportedModesResp(rsp)
}

// StreamFreeDriveWithResponse request returning *StreamFreeDriveResp
func (c *ClientWithResponses) StreamFreeDriveWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams, reqEditors ...RequestEditorFn) (*StreamFreeDriveResp, error) {
	rsp, err := c.StreamFreeDrive(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamFreeDriveResp(rsp)
}

// ListIODescriptionsWithResponse request returning *ListIODescriptionsResp
func (c *ClientWithResponses) ListIODescriptionsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams, reqEditors ...RequestEditorFn) (*ListIODescriptionsResp, error) {
	rsp, err := c.ListIODescriptions(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIODescriptionsResp(rsp)
}

// StreamIOValuesWithResponse request returning *StreamIOValuesResp
func (c *ClientWithResponses) StreamIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams, reqEditors ...RequestEditorFn) (*StreamIOValuesResp, error) {
	rsp, err := c.StreamIOValues(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamIOValuesResp(rsp)
}

// ListIOValuesWithResponse request returning *ListIOValuesResp
func (c *ClientWithResponses) ListIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOValuesParams, reqEditors ...RequestEditorFn) (*ListIOValuesResp, error) {
	rsp, err := c.ListIOValues(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIOValuesResp(rsp)
}

// SetOutputValuesWithBodyWithResponse request with arbitrary body returning *SetOutputValuesResp
func (c *ClientWithResponses) SetOutputValuesWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOutputValuesResp, error) {
	rsp, err := c.SetOutputValuesWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOutputValuesResp(rsp)
}

func (c *ClientWithResponses) SetOutputValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOutputValuesResp, error) {
	rsp, err := c.SetOutputValues(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOutputValuesResp(rsp)
}

// WaitForIOEventWithResponse request returning *WaitForIOEventResp
func (c *ClientWithResponses) WaitForIOEventWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *WaitForIOEventParams, reqEditors ...RequestEditorFn) (*WaitForIOEventResp, error) {
	rsp, err := c.WaitForIOEvent(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWaitForIOEventResp(rsp)
}

// GetModeWithResponse request returning *GetModeResp
func (c *ClientWithResponses) GetModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetModeResp, error) {
	rsp, err := c.GetMode(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModeResp(rsp)
}

// SetDefaultModeWithResponse request returning *SetDefaultModeResp
func (c *ClientWithResponses) SetDefaultModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams, reqEditors ...RequestEditorFn) (*SetDefaultModeResp, error) {
	rsp, err := c.SetDefaultMode(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultModeResp(rsp)
}

// StreamModeChangeWithResponse request returning *StreamModeChangeResp
func (c *ClientWithResponses) StreamModeChangeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*StreamModeChangeResp, error) {
	rsp, err := c.StreamModeChange(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamModeChangeResp(rsp)
}

// GetCurrentRobotControllerStateWithResponse request returning *GetCurrentRobotControllerStateResp
func (c *ClientWithResponses) GetCurrentRobotControllerStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetCurrentRobotControllerStateResp, error) {
	rsp, err := c.GetCurrentRobotControllerState(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentRobotControllerStateResp(rsp)
}

// StreamRobotControllerStateWithResponse request returning *StreamRobotControllerStateResp
func (c *ClientWithResponses) StreamRobotControllerStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams, reqEditors ...RequestEditorFn) (*StreamRobotControllerStateResp, error) {
	rsp, err := c.StreamRobotControllerState(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamRobotControllerStateResp(rsp)
}

// ListVirtualRobotCoordinateSystemsWithResponse request returning *ListVirtualRobotCoordinateSystemsResp
func (c *ClientWithResponses) ListVirtualRobotCoordinateSystemsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListVirtualRobotCoordinateSystemsResp, error) {
	rsp, err := c.ListVirtualRobotCoordinateSystems(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVirtualRobotCoordinateSystemsResp(rsp)
}

// AddVirtualRobotCoordinateSystemWithBodyWithResponse request with arbitrary body returning *AddVirtualRobotCoordinateSystemResp
func (c *ClientWithResponses) AddVirtualRobotCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualRobotCoordinateSystemResp, error) {
	rsp, err := c.AddVirtualRobotCoordinateSystemWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualRobotCoordinateSystemResp(rsp)
}

func (c *ClientWithResponses) AddVirtualRobotCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body AddVirtualRobotCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualRobotCoordinateSystemResp, error) {
	rsp, err := c.AddVirtualRobotCoordinateSystem(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualRobotCoordinateSystemResp(rsp)
}

// DeleteVirtualRobotCoordinateSystemWithResponse request returning *DeleteVirtualRobotCoordinateSystemResp
func (c *ClientWithResponses) DeleteVirtualRobotCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystem CoordinateSystem, params *DeleteVirtualRobotCoordinateSystemParams, reqEditors ...RequestEditorFn) (*DeleteVirtualRobotCoordinateSystemResp, error) {
	rsp, err := c.DeleteVirtualRobotCoordinateSystem(ctx, cellID, controllerID, coordinateSystem, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualRobotCoordinateSystemResp(rsp)
}

// GetCycleTimeWithResponse request returning *GetCycleTimeResp
func (c *ClientWithResponses) GetCycleTimeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetCycleTimeResp, error) {
	rsp, err := c.GetCycleTime(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCycleTimeResp(rsp)
}

// GetEStopWithResponse request returning *GetEStopResp
func (c *ClientWithResponses) GetEStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetEStopResp, error) {
	rsp, err := c.GetEStop(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEStopResp(rsp)
}

// PushEStopWithResponse request returning *PushEStopResp
func (c *ClientWithResponses) PushEStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*PushEStopResp, error) {
	rsp, err := c.PushEStop(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePushEStopResp(rsp)
}

// ReleaseEStopWithResponse request returning *ReleaseEStopResp
func (c *ClientWithResponses) ReleaseEStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ReleaseEStopResp, error) {
	rsp, err := c.ReleaseEStop(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseEStopResp(rsp)
}

// ListIOsWithResponse request returning *ListIOsResp
func (c *ClientWithResponses) ListIOsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListIOsResp, error) {
	rsp, err := c.ListIOs(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIOsResp(rsp)
}

// GetVirtualRobotIOValueWithResponse request returning *GetVirtualRobotIOValueResp
func (c *ClientWithResponses) GetVirtualRobotIOValueWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, reqEditors ...RequestEditorFn) (*GetVirtualRobotIOValueResp, error) {
	rsp, err := c.GetVirtualRobotIOValue(ctx, cellID, controllerID, io, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualRobotIOValueResp(rsp)
}

// SetVirtualRobotIOValueWithResponse request returning *SetVirtualRobotIOValueResp
func (c *ClientWithResponses) SetVirtualRobotIOValueWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, params *SetVirtualRobotIOValueParams, reqEditors ...RequestEditorFn) (*SetVirtualRobotIOValueResp, error) {
	rsp, err := c.SetVirtualRobotIOValue(ctx, cellID, controllerID, io, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetVirtualRobotIOValueResp(rsp)
}

// ExternalJointsStreamWithBodyWithResponse request with arbitrary body returning *ExternalJointsStreamResp
func (c *ClientWithResponses) ExternalJointsStreamWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExternalJointsStreamResp, error) {
	rsp, err := c.ExternalJointsStreamWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalJointsStreamResp(rsp)
}

func (c *ClientWithResponses) ExternalJointsStreamWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*ExternalJointsStreamResp, error) {
	rsp, err := c.ExternalJointsStream(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalJointsStreamResp(rsp)
}

// GetMotionGroupStateWithResponse request returning *GetMotionGroupStateResp
func (c *ClientWithResponses) GetMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*GetMotionGroupStateResp, error) {
	rsp, err := c.GetMotionGroupState(ctx, cellID, controllerID, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupStateResp(rsp)
}

// SetMotionGroupStateWithBodyWithResponse request with arbitrary body returning *SetMotionGroupStateResp
func (c *ClientWithResponses) SetMotionGroupStateWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMotionGroupStateResp, error) {
	rsp, err := c.SetMotionGroupStateWithBody(ctx, cellID, controllerID, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMotionGroupStateResp(rsp)
}

func (c *ClientWithResponses) SetMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetMotionGroupStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMotionGroupStateResp, error) {
	rsp, err := c.SetMotionGroupState(ctx, cellID, controllerID, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMotionGroupStateResp(rsp)
}

// GetMotionGroupBehaviorWithResponse request returning *GetMotionGroupBehaviorResp
func (c *ClientWithResponses) GetMotionGroupBehaviorWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*GetMotionGroupBehaviorResp, error) {
	rsp, err := c.GetMotionGroupBehavior(ctx, cellID, controllerID, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupBehaviorResp(rsp)
}

// SetMotionGroupBehaviorWithResponse request returning *SetMotionGroupBehaviorResp
func (c *ClientWithResponses) SetMotionGroupBehaviorWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, params *SetMotionGroupBehaviorParams, reqEditors ...RequestEditorFn) (*SetMotionGroupBehaviorResp, error) {
	rsp, err := c.SetMotionGroupBehavior(ctx, cellID, controllerID, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMotionGroupBehaviorResp(rsp)
}

// GetVirtualRobotMountingWithResponse request returning *GetVirtualRobotMountingResp
func (c *ClientWithResponses) GetVirtualRobotMountingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*GetVirtualRobotMountingResp, error) {
	rsp, err := c.GetVirtualRobotMounting(ctx, cellID, controllerID, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualRobotMountingResp(rsp)
}

// SetVirtualRobotMountingWithBodyWithResponse request with arbitrary body returning *SetVirtualRobotMountingResp
func (c *ClientWithResponses) SetVirtualRobotMountingWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetVirtualRobotMountingResp, error) {
	rsp, err := c.SetVirtualRobotMountingWithBody(ctx, cellID, controllerID, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetVirtualRobotMountingResp(rsp)
}

func (c *ClientWithResponses) SetVirtualRobotMountingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetVirtualRobotMountingJSONRequestBody, reqEditors ...RequestEditorFn) (*SetVirtualRobotMountingResp, error) {
	rsp, err := c.SetVirtualRobotMounting(ctx, cellID, controllerID, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetVirtualRobotMountingResp(rsp)
}

// ListVirtualRobotTcpsWithResponse request returning *ListVirtualRobotTcpsResp
func (c *ClientWithResponses) ListVirtualRobotTcpsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*ListVirtualRobotTcpsResp, error) {
	rsp, err := c.ListVirtualRobotTcps(ctx, cellID, controllerID, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVirtualRobotTcpsResp(rsp)
}

// AddVirtualRobotTcpWithBodyWithResponse request with arbitrary body returning *AddVirtualRobotTcpResp
func (c *ClientWithResponses) AddVirtualRobotTcpWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualRobotTcpResp, error) {
	rsp, err := c.AddVirtualRobotTcpWithBody(ctx, cellID, controllerID, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualRobotTcpResp(rsp)
}

func (c *ClientWithResponses) AddVirtualRobotTcpWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body AddVirtualRobotTcpJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualRobotTcpResp, error) {
	rsp, err := c.AddVirtualRobotTcp(ctx, cellID, controllerID, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualRobotTcpResp(rsp)
}

// DeleteVirtualRobotTcpWithResponse request returning *DeleteVirtualRobotTcpResp
func (c *ClientWithResponses) DeleteVirtualRobotTcpWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, tcp Tcp, reqEditors ...RequestEditorFn) (*DeleteVirtualRobotTcpResp, error) {
	rsp, err := c.DeleteVirtualRobotTcp(ctx, cellID, controllerID, id, tcp, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualRobotTcpResp(rsp)
}

// GetMotionGroupsWithResponse request returning *GetMotionGroupsResp
func (c *ClientWithResponses) GetMotionGroupsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetMotionGroupsResp, error) {
	rsp, err := c.GetMotionGroups(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupsResp(rsp)
}

// GetOperationModeWithResponse request returning *GetOperationModeResp
func (c *ClientWithResponses) GetOperationModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetOperationModeResp, error) {
	rsp, err := c.GetOperationMode(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOperationModeResp(rsp)
}

// SetOperationModeWithResponse request returning *SetOperationModeResp
func (c *ClientWithResponses) SetOperationModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetOperationModeParams, reqEditors ...RequestEditorFn) (*SetOperationModeResp, error) {
	rsp, err := c.SetOperationMode(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOperationModeResp(rsp)
}

// GetVirtualRobotConfigurationWithResponse request returning *GetVirtualRobotConfigurationResp
func (c *ClientWithResponses) GetVirtualRobotConfigurationWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetVirtualRobotConfigurationResp, error) {
	rsp, err := c.GetVirtualRobotConfiguration(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualRobotConfigurationResp(rsp)
}

// ListCoordinateSystemsWithResponse request returning *ListCoordinateSystemsResp
func (c *ClientWithResponses) ListCoordinateSystemsWithResponse(ctx context.Context, cellID CellID, params *ListCoordinateSystemsParams, reqEditors ...RequestEditorFn) (*ListCoordinateSystemsResp, error) {
	rsp, err := c.ListCoordinateSystems(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCoordinateSystemsResp(rsp)
}

// AddCoordinateSystemWithBodyWithResponse request with arbitrary body returning *AddCoordinateSystemResp
func (c *ClientWithResponses) AddCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCoordinateSystemResp, error) {
	rsp, err := c.AddCoordinateSystemWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCoordinateSystemResp(rsp)
}

func (c *ClientWithResponses) AddCoordinateSystemWithResponse(ctx context.Context, cellID CellID, body AddCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCoordinateSystemResp, error) {
	rsp, err := c.AddCoordinateSystem(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCoordinateSystemResp(rsp)
}

// DeleteCoordinateSystemWithResponse request returning *DeleteCoordinateSystemResp
func (c *ClientWithResponses) DeleteCoordinateSystemWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, reqEditors ...RequestEditorFn) (*DeleteCoordinateSystemResp, error) {
	rsp, err := c.DeleteCoordinateSystem(ctx, cellID, coordinateSystem, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCoordinateSystemResp(rsp)
}

// GetCoordinateSystemWithResponse request returning *GetCoordinateSystemResp
func (c *ClientWithResponses) GetCoordinateSystemWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, params *GetCoordinateSystemParams, reqEditors ...RequestEditorFn) (*GetCoordinateSystemResp, error) {
	rsp, err := c.GetCoordinateSystem(ctx, cellID, coordinateSystem, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoordinateSystemResp(rsp)
}

// TransformInCoordinateSystemWithBodyWithResponse request with arbitrary body returning *TransformInCoordinateSystemResp
func (c *ClientWithResponses) TransformInCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransformInCoordinateSystemResp, error) {
	rsp, err := c.TransformInCoordinateSystemWithBody(ctx, cellID, coordinateSystem, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransformInCoordinateSystemResp(rsp)
}

func (c *ClientWithResponses) TransformInCoordinateSystemWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, body TransformInCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*TransformInCoordinateSystemResp, error) {
	rsp, err := c.TransformInCoordinateSystem(ctx, cellID, coordinateSystem, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransformInCoordinateSystemResp(rsp)
}

// ClearDevicesWithResponse request returning *ClearDevicesResp
func (c *ClientWithResponses) ClearDevicesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearDevicesResp, error) {
	rsp, err := c.ClearDevices(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearDevicesResp(rsp)
}

// CreateDeviceWithBodyWithResponse request with arbitrary body returning *CreateDeviceResp
func (c *ClientWithResponses) CreateDeviceWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeviceResp, error) {
	rsp, err := c.CreateDeviceWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeviceResp(rsp)
}

func (c *ClientWithResponses) CreateDeviceWithResponse(ctx context.Context, cellID CellID, body CreateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeviceResp, error) {
	rsp, err := c.CreateDevice(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeviceResp(rsp)
}

// DeleteDeviceWithResponse request returning *DeleteDeviceResp
func (c *ClientWithResponses) DeleteDeviceWithResponse(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*DeleteDeviceResp, error) {
	rsp, err := c.DeleteDevice(ctx, cellID, identifier, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeviceResp(rsp)
}

// GetDeviceWithResponse request returning *GetDeviceResp
func (c *ClientWithResponses) GetDeviceWithResponse(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*GetDeviceResp, error) {
	rsp, err := c.GetDevice(ctx, cellID, identifier, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeviceResp(rsp)
}

// DefaultHomeJointsWithResponse request returning *DefaultHomeJointsResp
func (c *ClientWithResponses) DefaultHomeJointsWithResponse(ctx context.Context, cellID CellID, params *DefaultHomeJointsParams, reqEditors ...RequestEditorFn) (*DefaultHomeJointsResp, error) {
	rsp, err := c.DefaultHomeJoints(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDefaultHomeJointsResp(rsp)
}

// ListMotionGroupsWithResponse request returning *ListMotionGroupsResp
func (c *ClientWithResponses) ListMotionGroupsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListMotionGroupsResp, error) {
	rsp, err := c.ListMotionGroups(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMotionGroupsResp(rsp)
}

// ActivateMotionGroupWithResponse request returning *ActivateMotionGroupResp
func (c *ClientWithResponses) ActivateMotionGroupWithResponse(ctx context.Context, cellID CellID, params *ActivateMotionGroupParams, reqEditors ...RequestEditorFn) (*ActivateMotionGroupResp, error) {
	rsp, err := c.ActivateMotionGroup(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateMotionGroupResp(rsp)
}

// ActivateAllMotionGroupsWithResponse request returning *ActivateAllMotionGroupsResp
func (c *ClientWithResponses) ActivateAllMotionGroupsWithResponse(ctx context.Context, cellID CellID, params *ActivateAllMotionGroupsParams, reqEditors ...RequestEditorFn) (*ActivateAllMotionGroupsResp, error) {
	rsp, err := c.ActivateAllMotionGroups(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateAllMotionGroupsResp(rsp)
}

// JointJoggingWithBodyWithResponse request with arbitrary body returning *JointJoggingResp
func (c *ClientWithResponses) JointJoggingWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JointJoggingResp, error) {
	rsp, err := c.JointJoggingWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJointJoggingResp(rsp)
}

func (c *ClientWithResponses) JointJoggingWithResponse(ctx context.Context, cellID CellID, body JointJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*JointJoggingResp, error) {
	rsp, err := c.JointJogging(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJointJoggingResp(rsp)
}

// DirectionJoggingWithBodyWithResponse request with arbitrary body returning *DirectionJoggingResp
func (c *ClientWithResponses) DirectionJoggingWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectionJoggingResp, error) {
	rsp, err := c.DirectionJoggingWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectionJoggingResp(rsp)
}

func (c *ClientWithResponses) DirectionJoggingWithResponse(ctx context.Context, cellID CellID, body DirectionJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectionJoggingResp, error) {
	rsp, err := c.DirectionJogging(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectionJoggingResp(rsp)
}

// DeactivateMotionGroupWithResponse request returning *DeactivateMotionGroupResp
func (c *ClientWithResponses) DeactivateMotionGroupWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*DeactivateMotionGroupResp, error) {
	rsp, err := c.DeactivateMotionGroup(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeactivateMotionGroupResp(rsp)
}

// GetInfoCapabilitiesWithResponse request returning *GetInfoCapabilitiesResp
func (c *ClientWithResponses) GetInfoCapabilitiesWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetInfoCapabilitiesResp, error) {
	rsp, err := c.GetInfoCapabilities(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInfoCapabilitiesResp(rsp)
}

// GetJoggingCapabilitiesWithResponse request returning *GetJoggingCapabilitiesResp
func (c *ClientWithResponses) GetJoggingCapabilitiesWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetJoggingCapabilitiesResp, error) {
	rsp, err := c.GetJoggingCapabilities(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJoggingCapabilitiesResp(rsp)
}

// GetKinematicCapabilitiesWithResponse request returning *GetKinematicCapabilitiesResp
func (c *ClientWithResponses) GetKinematicCapabilitiesWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetKinematicCapabilitiesResp, error) {
	rsp, err := c.GetKinematicCapabilities(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKinematicCapabilitiesResp(rsp)
}

// CalculateAllInverseKinematicWithBodyWithResponse request with arbitrary body returning *CalculateAllInverseKinematicResp
func (c *ClientWithResponses) CalculateAllInverseKinematicWithBodyWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculateAllInverseKinematicResp, error) {
	rsp, err := c.CalculateAllInverseKinematicWithBody(ctx, cellID, motionGroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculateAllInverseKinematicResp(rsp)
}

func (c *ClientWithResponses) CalculateAllInverseKinematicWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateAllInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculateAllInverseKinematicResp, error) {
	rsp, err := c.CalculateAllInverseKinematic(ctx, cellID, motionGroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculateAllInverseKinematicResp(rsp)
}

// CalculateInverseKinematicWithBodyWithResponse request with arbitrary body returning *CalculateInverseKinematicResp
func (c *ClientWithResponses) CalculateInverseKinematicWithBodyWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculateInverseKinematicResp, error) {
	rsp, err := c.CalculateInverseKinematicWithBody(ctx, cellID, motionGroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculateInverseKinematicResp(rsp)
}

func (c *ClientWithResponses) CalculateInverseKinematicWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculateInverseKinematicResp, error) {
	rsp, err := c.CalculateInverseKinematic(ctx, cellID, motionGroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculateInverseKinematicResp(rsp)
}

// CalculateForwardKinematicWithBodyWithResponse request with arbitrary body returning *CalculateForwardKinematicResp
func (c *ClientWithResponses) CalculateForwardKinematicWithBodyWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculateForwardKinematicResp, error) {
	rsp, err := c.CalculateForwardKinematicWithBody(ctx, cellID, motionGroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculateForwardKinematicResp(rsp)
}

func (c *ClientWithResponses) CalculateForwardKinematicWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateForwardKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculateForwardKinematicResp, error) {
	rsp, err := c.CalculateForwardKinematic(ctx, cellID, motionGroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculateForwardKinematicResp(rsp)
}

// GetMountingWithResponse request returning *GetMountingResp
func (c *ClientWithResponses) GetMountingWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetMountingResp, error) {
	rsp, err := c.GetMounting(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMountingResp(rsp)
}

// GetOptimizerConfigurationWithResponse request returning *GetOptimizerConfigurationResp
func (c *ClientWithResponses) GetOptimizerConfigurationWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetOptimizerConfigurationParams, reqEditors ...RequestEditorFn) (*GetOptimizerConfigurationResp, error) {
	rsp, err := c.GetOptimizerConfiguration(ctx, cellID, motionGroup, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptimizerConfigurationResp(rsp)
}

// ListPayloadsWithResponse request returning *ListPayloadsResp
func (c *ClientWithResponses) ListPayloadsWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*ListPayloadsResp, error) {
	rsp, err := c.ListPayloads(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPayloadsResp(rsp)
}

// GetActivePayloadWithResponse request returning *GetActivePayloadResp
func (c *ClientWithResponses) GetActivePayloadWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetActivePayloadResp, error) {
	rsp, err := c.GetActivePayload(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivePayloadResp(rsp)
}

// GetSafetySetupWithResponse request returning *GetSafetySetupResp
func (c *ClientWithResponses) GetSafetySetupWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetSafetySetupResp, error) {
	rsp, err := c.GetSafetySetup(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSafetySetupResp(rsp)
}

// GetMotionGroupSpecificationWithResponse request returning *GetMotionGroupSpecificationResp
func (c *ClientWithResponses) GetMotionGroupSpecificationWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetMotionGroupSpecificationResp, error) {
	rsp, err := c.GetMotionGroupSpecification(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupSpecificationResp(rsp)
}

// GetCurrentMotionGroupStateWithResponse request returning *GetCurrentMotionGroupStateResp
func (c *ClientWithResponses) GetCurrentMotionGroupStateWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetCurrentMotionGroupStateParams, reqEditors ...RequestEditorFn) (*GetCurrentMotionGroupStateResp, error) {
	rsp, err := c.GetCurrentMotionGroupState(ctx, cellID, motionGroup, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentMotionGroupStateResp(rsp)
}

// StreamMotionGroupStateWithResponse request returning *StreamMotionGroupStateResp
func (c *ClientWithResponses) StreamMotionGroupStateWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *StreamMotionGroupStateParams, reqEditors ...RequestEditorFn) (*StreamMotionGroupStateResp, error) {
	rsp, err := c.StreamMotionGroupState(ctx, cellID, motionGroup, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMotionGroupStateResp(rsp)
}

// StopJoggingWithResponse request returning *StopJoggingResp
func (c *ClientWithResponses) StopJoggingWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*StopJoggingResp, error) {
	rsp, err := c.StopJogging(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopJoggingResp(rsp)
}

// ListTcpsWithResponse request returning *ListTcpsResp
func (c *ClientWithResponses) ListTcpsWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *ListTcpsParams, reqEditors ...RequestEditorFn) (*ListTcpsResp, error) {
	rsp, err := c.ListTcps(ctx, cellID, motionGroup, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTcpsResp(rsp)
}

// GetActiveTcpWithResponse request returning *GetActiveTcpResp
func (c *ClientWithResponses) GetActiveTcpWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetActiveTcpParams, reqEditors ...RequestEditorFn) (*GetActiveTcpResp, error) {
	rsp, err := c.GetActiveTcp(ctx, cellID, motionGroup, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActiveTcpResp(rsp)
}

// PlanTrajectoryWithBodyWithResponse request with arbitrary body returning *PlanTrajectoryResp
func (c *ClientWithResponses) PlanTrajectoryWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanTrajectoryResp, error) {
	rsp, err := c.PlanTrajectoryWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanTrajectoryResp(rsp)
}

func (c *ClientWithResponses) PlanTrajectoryWithResponse(ctx context.Context, cellID CellID, body PlanTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanTrajectoryResp, error) {
	rsp, err := c.PlanTrajectory(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanTrajectoryResp(rsp)
}

// DeleteAllMotionsWithResponse request returning *DeleteAllMotionsResp
func (c *ClientWithResponses) DeleteAllMotionsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*DeleteAllMotionsResp, error) {
	rsp, err := c.DeleteAllMotions(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllMotionsResp(rsp)
}

// ListMotionsWithResponse request returning *ListMotionsResp
func (c *ClientWithResponses) ListMotionsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListMotionsResp, error) {
	rsp, err := c.ListMotions(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMotionsResp(rsp)
}

// PlanMotionWithBodyWithResponse request with arbitrary body returning *PlanMotionResp
func (c *ClientWithResponses) PlanMotionWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanMotionResp, error) {
	rsp, err := c.PlanMotionWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanMotionResp(rsp)
}

func (c *ClientWithResponses) PlanMotionWithResponse(ctx context.Context, cellID CellID, body PlanMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanMotionResp, error) {
	rsp, err := c.PlanMotion(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanMotionResp(rsp)
}

// StreamMoveWithBodyWithResponse request with arbitrary body returning *StreamMoveResp
func (c *ClientWithResponses) StreamMoveWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StreamMoveResp, error) {
	rsp, err := c.StreamMoveWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMoveResp(rsp)
}

func (c *ClientWithResponses) StreamMoveWithResponse(ctx context.Context, cellID CellID, body StreamMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*StreamMoveResp, error) {
	rsp, err := c.StreamMove(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMoveResp(rsp)
}

// DeleteMotionWithResponse request returning *DeleteMotionResp
func (c *ClientWithResponses) DeleteMotionWithResponse(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*DeleteMotionResp, error) {
	rsp, err := c.DeleteMotion(ctx, cellID, motion, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMotionResp(rsp)
}

// StreamMoveBackwardWithResponse request returning *StreamMoveBackwardResp
func (c *ClientWithResponses) StreamMoveBackwardWithResponse(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveBackwardParams, reqEditors ...RequestEditorFn) (*StreamMoveBackwardResp, error) {
	rsp, err := c.StreamMoveBackward(ctx, cellID, motion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMoveBackwardResp(rsp)
}

// StreamMoveForwardWithResponse request returning *StreamMoveForwardResp
func (c *ClientWithResponses) StreamMoveForwardWithResponse(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveForwardParams, reqEditors ...RequestEditorFn) (*StreamMoveForwardResp, error) {
	rsp, err := c.StreamMoveForward(ctx, cellID, motion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMoveForwardResp(rsp)
}

// StreamMoveToTrajectoryViaJointPTPWithResponse request returning *StreamMoveToTrajectoryViaJointPTPResp
func (c *ClientWithResponses) StreamMoveToTrajectoryViaJointPTPWithResponse(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveToTrajectoryViaJointPTPParams, reqEditors ...RequestEditorFn) (*StreamMoveToTrajectoryViaJointPTPResp, error) {
	rsp, err := c.StreamMoveToTrajectoryViaJointPTP(ctx, cellID, motion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMoveToTrajectoryViaJointPTPResp(rsp)
}

// GetPlannedMotionWithResponse request returning *GetPlannedMotionResp
func (c *ClientWithResponses) GetPlannedMotionWithResponse(ctx context.Context, cellID CellID, motion Motion, params *GetPlannedMotionParams, reqEditors ...RequestEditorFn) (*GetPlannedMotionResp, error) {
	rsp, err := c.GetPlannedMotion(ctx, cellID, motion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlannedMotionResp(rsp)
}

// StopExecutionWithResponse request returning *StopExecutionResp
func (c *ClientWithResponses) StopExecutionWithResponse(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*StopExecutionResp, error) {
	rsp, err := c.StopExecution(ctx, cellID, motion, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopExecutionResp(rsp)
}

// GetMotionTrajectoryWithResponse request returning *GetMotionTrajectoryResp
func (c *ClientWithResponses) GetMotionTrajectoryWithResponse(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectoryParams, reqEditors ...RequestEditorFn) (*GetMotionTrajectoryResp, error) {
	rsp, err := c.GetMotionTrajectory(ctx, cellID, motion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionTrajectoryResp(rsp)
}

// GetMotionTrajectorySampleWithResponse request returning *GetMotionTrajectorySampleResp
func (c *ClientWithResponses) GetMotionTrajectorySampleWithResponse(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectorySampleParams, reqEditors ...RequestEditorFn) (*GetMotionTrajectorySampleResp, error) {
	rsp, err := c.GetMotionTrajectorySample(ctx, cellID, motion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionTrajectorySampleResp(rsp)
}

// LoadPlannedMotionWithBodyWithResponse request with arbitrary body returning *LoadPlannedMotionResp
func (c *ClientWithResponses) LoadPlannedMotionWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoadPlannedMotionResp, error) {
	rsp, err := c.LoadPlannedMotionWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadPlannedMotionResp(rsp)
}

func (c *ClientWithResponses) LoadPlannedMotionWithResponse(ctx context.Context, cellID CellID, body LoadPlannedMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*LoadPlannedMotionResp, error) {
	rsp, err := c.LoadPlannedMotion(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadPlannedMotionResp(rsp)
}

// ClearProgramsValuesWithResponse request returning *ClearProgramsValuesResp
func (c *ClientWithResponses) ClearProgramsValuesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearProgramsValuesResp, error) {
	rsp, err := c.ClearProgramsValues(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearProgramsValuesResp(rsp)
}

// CreateProgramsValueWithBodyWithResponse request with arbitrary body returning *CreateProgramsValueResp
func (c *ClientWithResponses) CreateProgramsValueWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramsValueResp, error) {
	rsp, err := c.CreateProgramsValueWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramsValueResp(rsp)
}

func (c *ClientWithResponses) CreateProgramsValueWithResponse(ctx context.Context, cellID CellID, body CreateProgramsValueJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramsValueResp, error) {
	rsp, err := c.CreateProgramsValue(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramsValueResp(rsp)
}

// DeleteProgramValueWithResponse request returning *DeleteProgramValueResp
func (c *ClientWithResponses) DeleteProgramValueWithResponse(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*DeleteProgramValueResp, error) {
	rsp, err := c.DeleteProgramValue(ctx, cellID, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProgramValueResp(rsp)
}

// GetProgramValueWithResponse request returning *GetProgramValueResp
func (c *ClientWithResponses) GetProgramValueWithResponse(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*GetProgramValueResp, error) {
	rsp, err := c.GetProgramValue(ctx, cellID, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramValueResp(rsp)
}

// UpdateProgramValueWithBodyWithResponse request with arbitrary body returning *UpdateProgramValueResp
func (c *ClientWithResponses) UpdateProgramValueWithBodyWithResponse(ctx context.Context, cellID CellID, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramValueResp, error) {
	rsp, err := c.UpdateProgramValueWithBody(ctx, cellID, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramValueResp(rsp)
}

func (c *ClientWithResponses) UpdateProgramValueWithResponse(ctx context.Context, cellID CellID, key string, body UpdateProgramValueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramValueResp, error) {
	rsp, err := c.UpdateProgramValue(ctx, cellID, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramValueResp(rsp)
}

// ListStoredCollidersWithResponse request returning *ListStoredCollidersResp
func (c *ClientWithResponses) ListStoredCollidersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollidersResp, error) {
	rsp, err := c.ListStoredColliders(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStoredCollidersResp(rsp)
}

// DeleteStoredColliderWithResponse request returning *DeleteStoredColliderResp
func (c *ClientWithResponses) DeleteStoredColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*DeleteStoredColliderResp, error) {
	rsp, err := c.DeleteStoredCollider(ctx, cellID, colliderID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoredColliderResp(rsp)
}

// GetStoredColliderWithResponse request returning *GetStoredColliderResp
func (c *ClientWithResponses) GetStoredColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*GetStoredColliderResp, error) {
	rsp, err := c.GetStoredCollider(ctx, cellID, colliderID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoredColliderResp(rsp)
}

// StoreColliderWithBodyWithResponse request with arbitrary body returning *StoreColliderResp
func (c *ClientWithResponses) StoreColliderWithBodyWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreColliderResp, error) {
	rsp, err := c.StoreColliderWithBody(ctx, cellID, colliderID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreColliderResp(rsp)
}

func (c *ClientWithResponses) StoreColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreColliderResp, error) {
	rsp, err := c.StoreCollider(ctx, cellID, colliderID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreColliderResp(rsp)
}

// ListCollisionLinkChainsWithResponse request returning *ListCollisionLinkChainsResp
func (c *ClientWithResponses) ListCollisionLinkChainsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListCollisionLinkChainsResp, error) {
	rsp, err := c.ListCollisionLinkChains(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCollisionLinkChainsResp(rsp)
}

// DeleteStoredCollisionLinkChainWithResponse request returning *DeleteStoredCollisionLinkChainResp
func (c *ClientWithResponses) DeleteStoredCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionLinkChainResp, error) {
	rsp, err := c.DeleteStoredCollisionLinkChain(ctx, cellID, linkChainID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoredCollisionLinkChainResp(rsp)
}

// GetStoredCollisionLinkChainWithResponse request returning *GetStoredCollisionLinkChainResp
func (c *ClientWithResponses) GetStoredCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*GetStoredCollisionLinkChainResp, error) {
	rsp, err := c.GetStoredCollisionLinkChain(ctx, cellID, linkChainID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoredCollisionLinkChainResp(rsp)
}

// StoreCollisionLinkChainWithBodyWithResponse request with arbitrary body returning *StoreCollisionLinkChainResp
func (c *ClientWithResponses) StoreCollisionLinkChainWithBodyWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionLinkChainResp, error) {
	rsp, err := c.StoreCollisionLinkChainWithBody(ctx, cellID, linkChainID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionLinkChainResp(rsp)
}

func (c *ClientWithResponses) StoreCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionLinkChainResp, error) {
	rsp, err := c.StoreCollisionLinkChain(ctx, cellID, linkChainID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionLinkChainResp(rsp)
}

// ListStoredCollisionScenesWithResponse request returning *ListStoredCollisionScenesResp
func (c *ClientWithResponses) ListStoredCollisionScenesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollisionScenesResp, error) {
	rsp, err := c.ListStoredCollisionScenes(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStoredCollisionScenesResp(rsp)
}

// DeleteStoredCollisionSceneWithResponse request returning *DeleteStoredCollisionSceneResp
func (c *ClientWithResponses) DeleteStoredCollisionSceneWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionSceneResp, error) {
	rsp, err := c.DeleteStoredCollisionScene(ctx, cellID, sceneID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoredCollisionSceneResp(rsp)
}

// GetStoredCollisionSceneWithResponse request returning *GetStoredCollisionSceneResp
func (c *ClientWithResponses) GetStoredCollisionSceneWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*GetStoredCollisionSceneResp, error) {
	rsp, err := c.GetStoredCollisionScene(ctx, cellID, sceneID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoredCollisionSceneResp(rsp)
}

// StoreCollisionSceneWithBodyWithResponse request with arbitrary body returning *StoreCollisionSceneResp
func (c *ClientWithResponses) StoreCollisionSceneWithBodyWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionSceneResp, error) {
	rsp, err := c.StoreCollisionSceneWithBody(ctx, cellID, sceneID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionSceneResp(rsp)
}

func (c *ClientWithResponses) StoreCollisionSceneWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, body StoreCollisionSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionSceneResp, error) {
	rsp, err := c.StoreCollisionScene(ctx, cellID, sceneID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionSceneResp(rsp)
}

// ListStoredCollisionToolsWithResponse request returning *ListStoredCollisionToolsResp
func (c *ClientWithResponses) ListStoredCollisionToolsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollisionToolsResp, error) {
	rsp, err := c.ListStoredCollisionTools(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStoredCollisionToolsResp(rsp)
}

// DeleteStoredCollisionToolWithResponse request returning *DeleteStoredCollisionToolResp
func (c *ClientWithResponses) DeleteStoredCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionToolResp, error) {
	rsp, err := c.DeleteStoredCollisionTool(ctx, cellID, toolID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoredCollisionToolResp(rsp)
}

// GetStoredCollisionToolWithResponse request returning *GetStoredCollisionToolResp
func (c *ClientWithResponses) GetStoredCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*GetStoredCollisionToolResp, error) {
	rsp, err := c.GetStoredCollisionTool(ctx, cellID, toolID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoredCollisionToolResp(rsp)
}

// StoreCollisionToolWithBodyWithResponse request with arbitrary body returning *StoreCollisionToolResp
func (c *ClientWithResponses) StoreCollisionToolWithBodyWithResponse(ctx context.Context, cellID CellID, toolID ToolID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionToolResp, error) {
	rsp, err := c.StoreCollisionToolWithBody(ctx, cellID, toolID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionToolResp(rsp)
}

func (c *ClientWithResponses) StoreCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionToolResp, error) {
	rsp, err := c.StoreCollisionTool(ctx, cellID, toolID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionToolResp(rsp)
}

// ClearAllObjectsWithResponse request returning *ClearAllObjectsResp
func (c *ClientWithResponses) ClearAllObjectsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearAllObjectsResp, error) {
	rsp, err := c.ClearAllObjects(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearAllObjectsResp(rsp)
}

// ListAllObjectKeysWithResponse request returning *ListAllObjectKeysResp
func (c *ClientWithResponses) ListAllObjectKeysWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListAllObjectKeysResp, error) {
	rsp, err := c.ListAllObjectKeys(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllObjectKeysResp(rsp)
}

// DeleteObjectWithResponse request returning *DeleteObjectResp
func (c *ClientWithResponses) DeleteObjectWithResponse(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*DeleteObjectResp, error) {
	rsp, err := c.DeleteObject(ctx, cellID, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectResp(rsp)
}

// GetObjectWithResponse request returning *GetObjectResp
func (c *ClientWithResponses) GetObjectWithResponse(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*GetObjectResp, error) {
	rsp, err := c.GetObject(ctx, cellID, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectResp(rsp)
}

// GetObjectMetadataWithResponse request returning *GetObjectMetadataResp
func (c *ClientWithResponses) GetObjectMetadataWithResponse(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*GetObjectMetadataResp, error) {
	rsp, err := c.GetObjectMetadata(ctx, cellID, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectMetadataResp(rsp)
}

// StoreObjectWithBodyWithResponse request with arbitrary body returning *StoreObjectResp
func (c *ClientWithResponses) StoreObjectWithBodyWithResponse(ctx context.Context, cellID CellID, key Key, params *StoreObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreObjectResp, error) {
	rsp, err := c.StoreObjectWithBody(ctx, cellID, key, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreObjectResp(rsp)
}

// DeleteProgramListWithResponse request returning *DeleteProgramListResp
func (c *ClientWithResponses) DeleteProgramListWithResponse(ctx context.Context, cellID CellID, params *DeleteProgramListParams, reqEditors ...RequestEditorFn) (*DeleteProgramListResp, error) {
	rsp, err := c.DeleteProgramList(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProgramListResp(rsp)
}

// ListProgramMetadataWithResponse request returning *ListProgramMetadataResp
func (c *ClientWithResponses) ListProgramMetadataWithResponse(ctx context.Context, cellID CellID, params *ListProgramMetadataParams, reqEditors ...RequestEditorFn) (*ListProgramMetadataResp, error) {
	rsp, err := c.ListProgramMetadata(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProgramMetadataResp(rsp)
}

// CreateProgramWithBodyWithResponse request with arbitrary body returning *CreateProgramResp
func (c *ClientWithResponses) CreateProgramWithBodyWithResponse(ctx context.Context, cellID CellID, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramResp, error) {
	rsp, err := c.CreateProgramWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramResp(rsp)
}

func (c *ClientWithResponses) CreateProgramWithTextBodyWithResponse(ctx context.Context, cellID CellID, params *CreateProgramParams, body CreateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramResp, error) {
	rsp, err := c.CreateProgramWithTextBody(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramResp(rsp)
}

// DeleteProgramWithResponse request returning *DeleteProgramResp
func (c *ClientWithResponses) DeleteProgramWithResponse(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*DeleteProgramResp, error) {
	rsp, err := c.DeleteProgram(ctx, cellID, program, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProgramResp(rsp)
}

// GetProgramWithResponse request returning *GetProgramResp
func (c *ClientWithResponses) GetProgramWithResponse(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*GetProgramResp, error) {
	rsp, err := c.GetProgram(ctx, cellID, program, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramResp(rsp)
}

// UpdateProgramWithBodyWithResponse request with arbitrary body returning *UpdateProgramResp
func (c *ClientWithResponses) UpdateProgramWithBodyWithResponse(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramResp, error) {
	rsp, err := c.UpdateProgramWithBody(ctx, cellID, program, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramResp(rsp)
}

func (c *ClientWithResponses) UpdateProgramWithTextBodyWithResponse(ctx context.Context, cellID CellID, program Program, body UpdateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramResp, error) {
	rsp, err := c.UpdateProgramWithTextBody(ctx, cellID, program, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramResp(rsp)
}

// GetProgramMetadataWithResponse request returning *GetProgramMetadataResp
func (c *ClientWithResponses) GetProgramMetadataWithResponse(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*GetProgramMetadataResp, error) {
	rsp, err := c.GetProgramMetadata(ctx, cellID, program, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramMetadataResp(rsp)
}

// UpdateProgramMetadataWithBodyWithResponse request with arbitrary body returning *UpdateProgramMetadataResp
func (c *ClientWithResponses) UpdateProgramMetadataWithBodyWithResponse(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramMetadataResp, error) {
	rsp, err := c.UpdateProgramMetadataWithBody(ctx, cellID, program, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramMetadataResp(rsp)
}

func (c *ClientWithResponses) UpdateProgramMetadataWithResponse(ctx context.Context, cellID CellID, program Program, body UpdateProgramMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramMetadataResp, error) {
	rsp, err := c.UpdateProgramMetadata(ctx, cellID, program, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramMetadataResp(rsp)
}

// UploadProgramMetadataImageWithBodyWithResponse request with arbitrary body returning *UploadProgramMetadataImageResp
func (c *ClientWithResponses) UploadProgramMetadataImageWithBodyWithResponse(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadProgramMetadataImageResp, error) {
	rsp, err := c.UploadProgramMetadataImageWithBody(ctx, cellID, program, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadProgramMetadataImageResp(rsp)
}

// DeleteRecipeListWithResponse request returning *DeleteRecipeListResp
func (c *ClientWithResponses) DeleteRecipeListWithResponse(ctx context.Context, cellID CellID, params *DeleteRecipeListParams, reqEditors ...RequestEditorFn) (*DeleteRecipeListResp, error) {
	rsp, err := c.DeleteRecipeList(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecipeListResp(rsp)
}

// ListRecipeMetadataWithResponse request returning *ListRecipeMetadataResp
func (c *ClientWithResponses) ListRecipeMetadataWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListRecipeMetadataResp, error) {
	rsp, err := c.ListRecipeMetadata(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRecipeMetadataResp(rsp)
}

// CreateRecipeWithBodyWithResponse request with arbitrary body returning *CreateRecipeResp
func (c *ClientWithResponses) CreateRecipeWithBodyWithResponse(ctx context.Context, cellID CellID, params *CreateRecipeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRecipeResp, error) {
	rsp, err := c.CreateRecipeWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRecipeResp(rsp)
}

func (c *ClientWithResponses) CreateRecipeWithResponse(ctx context.Context, cellID CellID, params *CreateRecipeParams, body CreateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRecipeResp, error) {
	rsp, err := c.CreateRecipe(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRecipeResp(rsp)
}

// DeleteRecipeWithResponse request returning *DeleteRecipeResp
func (c *ClientWithResponses) DeleteRecipeWithResponse(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*DeleteRecipeResp, error) {
	rsp, err := c.DeleteRecipe(ctx, cellID, recipe, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecipeResp(rsp)
}

// GetRecipeWithResponse request returning *GetRecipeResp
func (c *ClientWithResponses) GetRecipeWithResponse(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*GetRecipeResp, error) {
	rsp, err := c.GetRecipe(ctx, cellID, recipe, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecipeResp(rsp)
}

// UpdateRecipeWithBodyWithResponse request with arbitrary body returning *UpdateRecipeResp
func (c *ClientWithResponses) UpdateRecipeWithBodyWithResponse(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecipeResp, error) {
	rsp, err := c.UpdateRecipeWithBody(ctx, cellID, recipe, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecipeResp(rsp)
}

func (c *ClientWithResponses) UpdateRecipeWithResponse(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecipeResp, error) {
	rsp, err := c.UpdateRecipe(ctx, cellID, recipe, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecipeResp(rsp)
}

// GetRecipeMetadataWithResponse request returning *GetRecipeMetadataResp
func (c *ClientWithResponses) GetRecipeMetadataWithResponse(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*GetRecipeMetadataResp, error) {
	rsp, err := c.GetRecipeMetadata(ctx, cellID, recipe, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecipeMetadataResp(rsp)
}

// UpdateRecipeMetadataWithBodyWithResponse request with arbitrary body returning *UpdateRecipeMetadataResp
func (c *ClientWithResponses) UpdateRecipeMetadataWithBodyWithResponse(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecipeMetadataResp, error) {
	rsp, err := c.UpdateRecipeMetadataWithBody(ctx, cellID, recipe, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecipeMetadataResp(rsp)
}

func (c *ClientWithResponses) UpdateRecipeMetadataWithResponse(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecipeMetadataResp, error) {
	rsp, err := c.UpdateRecipeMetadata(ctx, cellID, recipe, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecipeMetadataResp(rsp)
}

// UploadRecipeMetadataImageWithBodyWithResponse request with arbitrary body returning *UploadRecipeMetadataImageResp
func (c *ClientWithResponses) UploadRecipeMetadataImageWithBodyWithResponse(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadRecipeMetadataImageResp, error) {
	rsp, err := c.UploadRecipeMetadataImageWithBody(ctx, cellID, recipe, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadRecipeMetadataImageResp(rsp)
}

// InternalListCellsWithResponse request returning *InternalListCellsResp
func (c *ClientWithResponses) InternalListCellsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InternalListCellsResp, error) {
	rsp, err := c.InternalListCells(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalListCellsResp(rsp)
}

// InternalDeployCellWithBodyWithResponse request with arbitrary body returning *InternalDeployCellResp
func (c *ClientWithResponses) InternalDeployCellWithBodyWithResponse(ctx context.Context, params *InternalDeployCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalDeployCellResp, error) {
	rsp, err := c.InternalDeployCellWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeployCellResp(rsp)
}

func (c *ClientWithResponses) InternalDeployCellWithResponse(ctx context.Context, params *InternalDeployCellParams, body InternalDeployCellJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalDeployCellResp, error) {
	rsp, err := c.InternalDeployCell(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeployCellResp(rsp)
}

// InternalDeleteCellWithResponse request returning *InternalDeleteCellResp
func (c *ClientWithResponses) InternalDeleteCellWithResponse(ctx context.Context, cellID CellID, params *InternalDeleteCellParams, reqEditors ...RequestEditorFn) (*InternalDeleteCellResp, error) {
	rsp, err := c.InternalDeleteCell(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteCellResp(rsp)
}

// InternalGetCellWithResponse request returning *InternalGetCellResp
func (c *ClientWithResponses) InternalGetCellWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*InternalGetCellResp, error) {
	rsp, err := c.InternalGetCell(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetCellResp(rsp)
}

// InternalUpdateCellWithBodyWithResponse request with arbitrary body returning *InternalUpdateCellResp
func (c *ClientWithResponses) InternalUpdateCellWithBodyWithResponse(ctx context.Context, cellID CellID, params *InternalUpdateCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalUpdateCellResp, error) {
	rsp, err := c.InternalUpdateCellWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalUpdateCellResp(rsp)
}

func (c *ClientWithResponses) InternalUpdateCellWithResponse(ctx context.Context, cellID CellID, params *InternalUpdateCellParams, body InternalUpdateCellJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalUpdateCellResp, error) {
	rsp, err := c.InternalUpdateCell(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalUpdateCellResp(rsp)
}

// InternalClearAppsWithResponse request returning *InternalClearAppsResp
func (c *ClientWithResponses) InternalClearAppsWithResponse(ctx context.Context, cellID CellID, params *InternalClearAppsParams, reqEditors ...RequestEditorFn) (*InternalClearAppsResp, error) {
	rsp, err := c.InternalClearApps(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalClearAppsResp(rsp)
}

// InternalListAppsWithResponse request returning *InternalListAppsResp
func (c *ClientWithResponses) InternalListAppsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*InternalListAppsResp, error) {
	rsp, err := c.InternalListApps(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalListAppsResp(rsp)
}

// InternalAddAppWithBodyWithResponse request with arbitrary body returning *InternalAddAppResp
func (c *ClientWithResponses) InternalAddAppWithBodyWithResponse(ctx context.Context, cellID CellID, params *InternalAddAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalAddAppResp, error) {
	rsp, err := c.InternalAddAppWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalAddAppResp(rsp)
}

func (c *ClientWithResponses) InternalAddAppWithResponse(ctx context.Context, cellID CellID, params *InternalAddAppParams, body InternalAddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalAddAppResp, error) {
	rsp, err := c.InternalAddApp(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalAddAppResp(rsp)
}

// InternalDeleteAppWithResponse request returning *InternalDeleteAppResp
func (c *ClientWithResponses) InternalDeleteAppWithResponse(ctx context.Context, cellID CellID, appID AppID, params *InternalDeleteAppParams, reqEditors ...RequestEditorFn) (*InternalDeleteAppResp, error) {
	rsp, err := c.InternalDeleteApp(ctx, cellID, appID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteAppResp(rsp)
}

// InternalGetAppWithResponse request returning *InternalGetAppResp
func (c *ClientWithResponses) InternalGetAppWithResponse(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*InternalGetAppResp, error) {
	rsp, err := c.InternalGetApp(ctx, cellID, appID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetAppResp(rsp)
}

// InternalUpdateAppWithBodyWithResponse request with arbitrary body returning *InternalUpdateAppResp
func (c *ClientWithResponses) InternalUpdateAppWithBodyWithResponse(ctx context.Context, cellID CellID, appID AppID, params *InternalUpdateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalUpdateAppResp, error) {
	rsp, err := c.InternalUpdateAppWithBody(ctx, cellID, appID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalUpdateAppResp(rsp)
}

func (c *ClientWithResponses) InternalUpdateAppWithResponse(ctx context.Context, cellID CellID, appID AppID, params *InternalUpdateAppParams, body InternalUpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalUpdateAppResp, error) {
	rsp, err := c.InternalUpdateApp(ctx, cellID, appID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalUpdateAppResp(rsp)
}

// InternalGetAppStatusWithResponse request returning *InternalGetAppStatusResp
func (c *ClientWithResponses) InternalGetAppStatusWithResponse(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*InternalGetAppStatusResp, error) {
	rsp, err := c.InternalGetAppStatus(ctx, cellID, appID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetAppStatusResp(rsp)
}

// InternalClearRobotControllersWithResponse request returning *InternalClearRobotControllersResp
func (c *ClientWithResponses) InternalClearRobotControllersWithResponse(ctx context.Context, cellID CellID, params *InternalClearRobotControllersParams, reqEditors ...RequestEditorFn) (*InternalClearRobotControllersResp, error) {
	rsp, err := c.InternalClearRobotControllers(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalClearRobotControllersResp(rsp)
}

// InternalListRobotControllersWithResponse request returning *InternalListRobotControllersResp
func (c *ClientWithResponses) InternalListRobotControllersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*InternalListRobotControllersResp, error) {
	rsp, err := c.InternalListRobotControllers(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalListRobotControllersResp(rsp)
}

// InternalAddRobotControllerWithBodyWithResponse request with arbitrary body returning *InternalAddRobotControllerResp
func (c *ClientWithResponses) InternalAddRobotControllerWithBodyWithResponse(ctx context.Context, cellID CellID, params *InternalAddRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalAddRobotControllerResp, error) {
	rsp, err := c.InternalAddRobotControllerWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalAddRobotControllerResp(rsp)
}

func (c *ClientWithResponses) InternalAddRobotControllerWithResponse(ctx context.Context, cellID CellID, params *InternalAddRobotControllerParams, body InternalAddRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalAddRobotControllerResp, error) {
	rsp, err := c.InternalAddRobotController(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalAddRobotControllerResp(rsp)
}

// InternalDeleteRobotControllerWithResponse request returning *InternalDeleteRobotControllerResp
func (c *ClientWithResponses) InternalDeleteRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *InternalDeleteRobotControllerParams, reqEditors ...RequestEditorFn) (*InternalDeleteRobotControllerResp, error) {
	rsp, err := c.InternalDeleteRobotController(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteRobotControllerResp(rsp)
}

// InternalGetRobotControllerWithResponse request returning *InternalGetRobotControllerResp
func (c *ClientWithResponses) InternalGetRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*InternalGetRobotControllerResp, error) {
	rsp, err := c.InternalGetRobotController(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetRobotControllerResp(rsp)
}

// InternalUpdateRobotControllerWithBodyWithResponse request with arbitrary body returning *InternalUpdateRobotControllerResp
func (c *ClientWithResponses) InternalUpdateRobotControllerWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *InternalUpdateRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalUpdateRobotControllerResp, error) {
	rsp, err := c.InternalUpdateRobotControllerWithBody(ctx, cellID, controllerID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalUpdateRobotControllerResp(rsp)
}

func (c *ClientWithResponses) InternalUpdateRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *InternalUpdateRobotControllerParams, body InternalUpdateRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalUpdateRobotControllerResp, error) {
	rsp, err := c.InternalUpdateRobotController(ctx, cellID, controllerID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalUpdateRobotControllerResp(rsp)
}

// InternalGetRobotControllerStatusWithResponse request returning *InternalGetRobotControllerStatusResp
func (c *ClientWithResponses) InternalGetRobotControllerStatusWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*InternalGetRobotControllerStatusResp, error) {
	rsp, err := c.InternalGetRobotControllerStatus(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetRobotControllerStatusResp(rsp)
}

// InternalGetFoundationServicesWithResponse request returning *InternalGetFoundationServicesResp
func (c *ClientWithResponses) InternalGetFoundationServicesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*InternalGetFoundationServicesResp, error) {
	rsp, err := c.InternalGetFoundationServices(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetFoundationServicesResp(rsp)
}

// InternalUpdateFoundationServicesWithBodyWithResponse request with arbitrary body returning *InternalUpdateFoundationServicesResp
func (c *ClientWithResponses) InternalUpdateFoundationServicesWithBodyWithResponse(ctx context.Context, cellID CellID, params *InternalUpdateFoundationServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalUpdateFoundationServicesResp, error) {
	rsp, err := c.InternalUpdateFoundationServicesWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalUpdateFoundationServicesResp(rsp)
}

func (c *ClientWithResponses) InternalUpdateFoundationServicesWithResponse(ctx context.Context, cellID CellID, params *InternalUpdateFoundationServicesParams, body InternalUpdateFoundationServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalUpdateFoundationServicesResp, error) {
	rsp, err := c.InternalUpdateFoundationServices(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalUpdateFoundationServicesResp(rsp)
}

// GetDescriptionWithResponse request returning *GetDescriptionResp
func (c *ClientWithResponses) GetDescriptionWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetDescriptionResp, error) {
	rsp, err := c.GetDescription(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDescriptionResp(rsp)
}

// RegisterControllerWithBodyWithResponse request with arbitrary body returning *RegisterControllerResp
func (c *ClientWithResponses) RegisterControllerWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterControllerResp, error) {
	rsp, err := c.RegisterControllerWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterControllerResp(rsp)
}

func (c *ClientWithResponses) RegisterControllerWithResponse(ctx context.Context, cellID CellID, body RegisterControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterControllerResp, error) {
	rsp, err := c.RegisterController(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterControllerResp(rsp)
}

// DeleteControllerWithResponse request returning *DeleteControllerResp
func (c *ClientWithResponses) DeleteControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*DeleteControllerResp, error) {
	rsp, err := c.DeleteController(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteControllerResp(rsp)
}

// ListControllerWithResponse request returning *ListControllerResp
func (c *ClientWithResponses) ListControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListControllerResp, error) {
	rsp, err := c.ListController(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListControllerResp(rsp)
}

// GetRaeVersionWithResponse request returning *GetRaeVersionResp
func (c *ClientWithResponses) GetRaeVersionWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetRaeVersionResp, error) {
	rsp, err := c.GetRaeVersion(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRaeVersionResp(rsp)
}

// InternalGetCellStatusWithResponse request returning *InternalGetCellStatusResp
func (c *ClientWithResponses) InternalGetCellStatusWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*InternalGetCellStatusResp, error) {
	rsp, err := c.InternalGetCellStatus(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetCellStatusResp(rsp)
}

// InternalGetDiagnosePackageWithResponse request returning *InternalGetDiagnosePackageResp
func (c *ClientWithResponses) InternalGetDiagnosePackageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InternalGetDiagnosePackageResp, error) {
	rsp, err := c.InternalGetDiagnosePackage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetDiagnosePackageResp(rsp)
}

// InternalGetSystemStatusWithResponse request returning *InternalGetSystemStatusResp
func (c *ClientWithResponses) InternalGetSystemStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InternalGetSystemStatusResp, error) {
	rsp, err := c.InternalGetSystemStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetSystemStatusResp(rsp)
}

// InternalCheckNovaVersionUpdateWithResponse request returning *InternalCheckNovaVersionUpdateResp
func (c *ClientWithResponses) InternalCheckNovaVersionUpdateWithResponse(ctx context.Context, params *InternalCheckNovaVersionUpdateParams, reqEditors ...RequestEditorFn) (*InternalCheckNovaVersionUpdateResp, error) {
	rsp, err := c.InternalCheckNovaVersionUpdate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalCheckNovaVersionUpdateResp(rsp)
}

// InternalUpdateNovaVersionWithBodyWithResponse request with arbitrary body returning *InternalUpdateNovaVersionResp
func (c *ClientWithResponses) InternalUpdateNovaVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalUpdateNovaVersionResp, error) {
	rsp, err := c.InternalUpdateNovaVersionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalUpdateNovaVersionResp(rsp)
}

func (c *ClientWithResponses) InternalUpdateNovaVersionWithResponse(ctx context.Context, body InternalUpdateNovaVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalUpdateNovaVersionResp, error) {
	rsp, err := c.InternalUpdateNovaVersion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalUpdateNovaVersionResp(rsp)
}

// InternalGetSystemVersionWithResponse request returning *InternalGetSystemVersionResp
func (c *ClientWithResponses) InternalGetSystemVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InternalGetSystemVersionResp, error) {
	rsp, err := c.InternalGetSystemVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetSystemVersionResp(rsp)
}

// ParseListControllersResp parses an HTTP response from a ListControllersWithResponse call
func ParseListControllersResp(rsp *http.Response) (*ListControllersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListControllersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ControllerInstanceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSupportedModesResp parses an HTTP response from a GetSupportedModesWithResponse call
func ParseGetSupportedModesResp(rsp *http.Response) (*GetSupportedModesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSupportedModesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ControllerCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamFreeDriveResp parses an HTTP response from a StreamFreeDriveWithResponse call
func ParseStreamFreeDriveResp(rsp *http.Response) (*StreamFreeDriveResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamFreeDriveResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotControllerState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIODescriptionsResp parses an HTTP response from a ListIODescriptionsWithResponse call
func ParseListIODescriptionsResp(rsp *http.Response) (*ListIODescriptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIODescriptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIODescriptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamIOValuesResp parses an HTTP response from a StreamIOValuesWithResponse call
func ParseStreamIOValuesResp(rsp *http.Response) (*StreamIOValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamIOValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIOValuesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIOValuesResp parses an HTTP response from a ListIOValuesWithResponse call
func ParseListIOValuesResp(rsp *http.Response) (*ListIOValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIOValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIOValuesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetOutputValuesResp parses an HTTP response from a SetOutputValuesWithResponse call
func ParseSetOutputValuesResp(rsp *http.Response) (*SetOutputValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOutputValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseWaitForIOEventResp parses an HTTP response from a WaitForIOEventWithResponse call
func ParseWaitForIOEventResp(rsp *http.Response) (*WaitForIOEventResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WaitForIOEventResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetModeResp parses an HTTP response from a GetModeWithResponse call
func ParseGetModeResp(rsp *http.Response) (*GetModeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetModeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetDefaultModeResp parses an HTTP response from a SetDefaultModeWithResponse call
func ParseSetDefaultModeResp(rsp *http.Response) (*SetDefaultModeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDefaultModeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamModeChangeResp parses an HTTP response from a StreamModeChangeWithResponse call
func ParseStreamModeChangeResp(rsp *http.Response) (*StreamModeChangeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamModeChangeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModeChangeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCurrentRobotControllerStateResp parses an HTTP response from a GetCurrentRobotControllerStateWithResponse call
func ParseGetCurrentRobotControllerStateResp(rsp *http.Response) (*GetCurrentRobotControllerStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentRobotControllerStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotControllerState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamRobotControllerStateResp parses an HTTP response from a StreamRobotControllerStateWithResponse call
func ParseStreamRobotControllerStateResp(rsp *http.Response) (*StreamRobotControllerStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamRobotControllerStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotControllerState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListVirtualRobotCoordinateSystemsResp parses an HTTP response from a ListVirtualRobotCoordinateSystemsWithResponse call
func ParseListVirtualRobotCoordinateSystemsResp(rsp *http.Response) (*ListVirtualRobotCoordinateSystemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVirtualRobotCoordinateSystemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddVirtualRobotCoordinateSystemResp parses an HTTP response from a AddVirtualRobotCoordinateSystemWithResponse call
func ParseAddVirtualRobotCoordinateSystemResp(rsp *http.Response) (*AddVirtualRobotCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddVirtualRobotCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVirtualRobotCoordinateSystemResp parses an HTTP response from a DeleteVirtualRobotCoordinateSystemWithResponse call
func ParseDeleteVirtualRobotCoordinateSystemResp(rsp *http.Response) (*DeleteVirtualRobotCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualRobotCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCycleTimeResp parses an HTTP response from a GetCycleTimeWithResponse call
func ParseGetCycleTimeResp(rsp *http.Response) (*GetCycleTimeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCycleTimeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CycleTime
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEStopResp parses an HTTP response from a GetEStopWithResponse call
func ParseGetEStopResp(rsp *http.Response) (*GetEStopResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEStopResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Flag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePushEStopResp parses an HTTP response from a PushEStopWithResponse call
func ParsePushEStopResp(rsp *http.Response) (*PushEStopResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PushEStopResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReleaseEStopResp parses an HTTP response from a ReleaseEStopWithResponse call
func ParseReleaseEStopResp(rsp *http.Response) (*ReleaseEStopResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReleaseEStopResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIOsResp parses an HTTP response from a ListIOsWithResponse call
func ParseListIOsResp(rsp *http.Response) (*ListIOsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIOsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IOs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualRobotIOValueResp parses an HTTP response from a GetVirtualRobotIOValueWithResponse call
func ParseGetVirtualRobotIOValueResp(rsp *http.Response) (*GetVirtualRobotIOValueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualRobotIOValueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetVirtualRobotIOValueResp parses an HTTP response from a SetVirtualRobotIOValueWithResponse call
func ParseSetVirtualRobotIOValueResp(rsp *http.Response) (*SetVirtualRobotIOValueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetVirtualRobotIOValueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExternalJointsStreamResp parses an HTTP response from a ExternalJointsStreamWithResponse call
func ParseExternalJointsStreamResp(rsp *http.Response) (*ExternalJointsStreamResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExternalJointsStreamResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupJoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMotionGroupStateResp parses an HTTP response from a GetMotionGroupStateWithResponse call
func ParseGetMotionGroupStateResp(rsp *http.Response) (*GetMotionGroupStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupJoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetMotionGroupStateResp parses an HTTP response from a SetMotionGroupStateWithResponse call
func ParseSetMotionGroupStateResp(rsp *http.Response) (*SetMotionGroupStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMotionGroupStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMotionGroupBehaviorResp parses an HTTP response from a GetMotionGroupBehaviorWithResponse call
func ParseGetMotionGroupBehaviorResp(rsp *http.Response) (*GetMotionGroupBehaviorResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupBehaviorResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupBehaviorGetter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetMotionGroupBehaviorResp parses an HTTP response from a SetMotionGroupBehaviorWithResponse call
func ParseSetMotionGroupBehaviorResp(rsp *http.Response) (*SetMotionGroupBehaviorResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMotionGroupBehaviorResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualRobotMountingResp parses an HTTP response from a GetVirtualRobotMountingWithResponse call
func ParseGetVirtualRobotMountingResp(rsp *http.Response) (*GetVirtualRobotMountingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualRobotMountingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetVirtualRobotMountingResp parses an HTTP response from a SetVirtualRobotMountingWithResponse call
func ParseSetVirtualRobotMountingResp(rsp *http.Response) (*SetVirtualRobotMountingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetVirtualRobotMountingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListVirtualRobotTcpsResp parses an HTTP response from a ListVirtualRobotTcpsWithResponse call
func ParseListVirtualRobotTcpsResp(rsp *http.Response) (*ListVirtualRobotTcpsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVirtualRobotTcpsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotTcps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddVirtualRobotTcpResp parses an HTTP response from a AddVirtualRobotTcpWithResponse call
func ParseAddVirtualRobotTcpResp(rsp *http.Response) (*AddVirtualRobotTcpResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddVirtualRobotTcpResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVirtualRobotTcpResp parses an HTTP response from a DeleteVirtualRobotTcpWithResponse call
func ParseDeleteVirtualRobotTcpResp(rsp *http.Response) (*DeleteVirtualRobotTcpResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualRobotTcpResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMotionGroupsResp parses an HTTP response from a GetMotionGroupsWithResponse call
func ParseGetMotionGroupsResp(rsp *http.Response) (*GetMotionGroupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupInfos
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOperationModeResp parses an HTTP response from a GetOperationModeWithResponse call
func ParseGetOperationModeResp(rsp *http.Response) (*GetOperationModeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOperationModeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OpMode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetOperationModeResp parses an HTTP response from a SetOperationModeWithResponse call
func ParseSetOperationModeResp(rsp *http.Response) (*SetOperationModeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOperationModeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualRobotConfigurationResp parses an HTTP response from a GetVirtualRobotConfigurationWithResponse call
func ParseGetVirtualRobotConfigurationResp(rsp *http.Response) (*GetVirtualRobotConfigurationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualRobotConfigurationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VirtualRobotConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCoordinateSystemsResp parses an HTTP response from a ListCoordinateSystemsWithResponse call
func ParseListCoordinateSystemsResp(rsp *http.Response) (*ListCoordinateSystemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCoordinateSystemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddCoordinateSystemResp parses an HTTP response from a AddCoordinateSystemWithResponse call
func ParseAddCoordinateSystemResp(rsp *http.Response) (*AddCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCoordinateSystemResp parses an HTTP response from a DeleteCoordinateSystemWithResponse call
func ParseDeleteCoordinateSystemResp(rsp *http.Response) (*DeleteCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCoordinateSystemResp parses an HTTP response from a GetCoordinateSystemWithResponse call
func ParseGetCoordinateSystemResp(rsp *http.Response) (*GetCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTransformInCoordinateSystemResp parses an HTTP response from a TransformInCoordinateSystemWithResponse call
func ParseTransformInCoordinateSystemResp(rsp *http.Response) (*TransformInCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransformInCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pose
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseClearDevicesResp parses an HTTP response from a ClearDevicesWithResponse call
func ParseClearDevicesResp(rsp *http.Response) (*ClearDevicesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearDevicesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateDeviceResp parses an HTTP response from a CreateDeviceWithResponse call
func ParseCreateDeviceResp(rsp *http.Response) (*CreateDeviceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeviceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteDeviceResp parses an HTTP response from a DeleteDeviceWithResponse call
func ParseDeleteDeviceResp(rsp *http.Response) (*DeleteDeviceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeviceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetDeviceResp parses an HTTP response from a GetDeviceWithResponse call
func ParseGetDeviceResp(rsp *http.Response) (*GetDeviceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeviceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDefaultHomeJointsResp parses an HTTP response from a DefaultHomeJointsWithResponse call
func ParseDefaultHomeJointsResp(rsp *http.Response) (*DefaultHomeJointsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DefaultHomeJointsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Joints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMotionGroupsResp parses an HTTP response from a ListMotionGroupsWithResponse call
func ParseListMotionGroupsResp(rsp *http.Response) (*ListMotionGroupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMotionGroupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupInstanceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseActivateMotionGroupResp parses an HTTP response from a ActivateMotionGroupWithResponse call
func ParseActivateMotionGroupResp(rsp *http.Response) (*ActivateMotionGroupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateMotionGroupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseActivateAllMotionGroupsResp parses an HTTP response from a ActivateAllMotionGroupsWithResponse call
func ParseActivateAllMotionGroupsResp(rsp *http.Response) (*ActivateAllMotionGroupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateAllMotionGroupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupInstanceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseJointJoggingResp parses an HTTP response from a JointJoggingWithResponse call
func ParseJointJoggingResp(rsp *http.Response) (*JointJoggingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JointJoggingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JoggingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDirectionJoggingResp parses an HTTP response from a DirectionJoggingWithResponse call
func ParseDirectionJoggingResp(rsp *http.Response) (*DirectionJoggingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectionJoggingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JoggingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeactivateMotionGroupResp parses an HTTP response from a DeactivateMotionGroupWithResponse call
func ParseDeactivateMotionGroupResp(rsp *http.Response) (*DeactivateMotionGroupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeactivateMotionGroupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInfoCapabilitiesResp parses an HTTP response from a GetInfoCapabilitiesWithResponse call
func ParseGetInfoCapabilitiesResp(rsp *http.Response) (*GetInfoCapabilitiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInfoCapabilitiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InfoServiceCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetJoggingCapabilitiesResp parses an HTTP response from a GetJoggingCapabilitiesWithResponse call
func ParseGetJoggingCapabilitiesResp(rsp *http.Response) (*GetJoggingCapabilitiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJoggingCapabilitiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JoggingServiceCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKinematicCapabilitiesResp parses an HTTP response from a GetKinematicCapabilitiesWithResponse call
func ParseGetKinematicCapabilitiesResp(rsp *http.Response) (*GetKinematicCapabilitiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKinematicCapabilitiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KinematicServiceCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCalculateAllInverseKinematicResp parses an HTTP response from a CalculateAllInverseKinematicWithResponse call
func ParseCalculateAllInverseKinematicResp(rsp *http.Response) (*CalculateAllInverseKinematicResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CalculateAllInverseKinematicResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllJointPositionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCalculateInverseKinematicResp parses an HTTP response from a CalculateInverseKinematicWithResponse call
func ParseCalculateInverseKinematicResp(rsp *http.Response) (*CalculateInverseKinematicResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CalculateInverseKinematicResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Joints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCalculateForwardKinematicResp parses an HTTP response from a CalculateForwardKinematicWithResponse call
func ParseCalculateForwardKinematicResp(rsp *http.Response) (*CalculateForwardKinematicResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CalculateForwardKinematicResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pose
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMountingResp parses an HTTP response from a GetMountingWithResponse call
func ParseGetMountingResp(rsp *http.Response) (*GetMountingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMountingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Mounting
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOptimizerConfigurationResp parses an HTTP response from a GetOptimizerConfigurationWithResponse call
func ParseGetOptimizerConfigurationResp(rsp *http.Response) (*GetOptimizerConfigurationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptimizerConfigurationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OptimizerSetup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPayloadsResp parses an HTTP response from a ListPayloadsWithResponse call
func ParseListPayloadsResp(rsp *http.Response) (*ListPayloadsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPayloadsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPayloadsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetActivePayloadResp parses an HTTP response from a GetActivePayloadWithResponse call
func ParseGetActivePayloadResp(rsp *http.Response) (*GetActivePayloadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivePayloadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Payload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSafetySetupResp parses an HTTP response from a GetSafetySetupWithResponse call
func ParseGetSafetySetupResp(rsp *http.Response) (*GetSafetySetupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSafetySetupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SafetySetup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMotionGroupSpecificationResp parses an HTTP response from a GetMotionGroupSpecificationWithResponse call
func ParseGetMotionGroupSpecificationResp(rsp *http.Response) (*GetMotionGroupSpecificationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupSpecificationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupSpecification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCurrentMotionGroupStateResp parses an HTTP response from a GetCurrentMotionGroupStateWithResponse call
func ParseGetCurrentMotionGroupStateResp(rsp *http.Response) (*GetCurrentMotionGroupStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentMotionGroupStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupStateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamMotionGroupStateResp parses an HTTP response from a StreamMotionGroupStateWithResponse call
func ParseStreamMotionGroupStateResp(rsp *http.Response) (*StreamMotionGroupStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamMotionGroupStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupStateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStopJoggingResp parses an HTTP response from a StopJoggingWithResponse call
func ParseStopJoggingResp(rsp *http.Response) (*StopJoggingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopJoggingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTcpsResp parses an HTTP response from a ListTcpsWithResponse call
func ParseListTcpsResp(rsp *http.Response) (*ListTcpsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTcpsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTcpsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetActiveTcpResp parses an HTTP response from a GetActiveTcpWithResponse call
func ParseGetActiveTcpResp(rsp *http.Response) (*GetActiveTcpResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActiveTcpResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotTcp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePlanTrajectoryResp parses an HTTP response from a PlanTrajectoryWithResponse call
func ParsePlanTrajectoryResp(rsp *http.Response) (*PlanTrajectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlanTrajectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanTrajectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAllMotionsResp parses an HTTP response from a DeleteAllMotionsWithResponse call
func ParseDeleteAllMotionsResp(rsp *http.Response) (*DeleteAllMotionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllMotionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMotionsResp parses an HTTP response from a ListMotionsWithResponse call
func ParseListMotionsResp(rsp *http.Response) (*ListMotionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMotionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionIdsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePlanMotionResp parses an HTTP response from a PlanMotionWithResponse call
func ParsePlanMotionResp(rsp *http.Response) (*PlanMotionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlanMotionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamMoveResp parses an HTTP response from a StreamMoveWithResponse call
func ParseStreamMoveResp(rsp *http.Response) (*StreamMoveResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamMoveResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamMoveResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMotionResp parses an HTTP response from a DeleteMotionWithResponse call
func ParseDeleteMotionResp(rsp *http.Response) (*DeleteMotionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMotionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamMoveBackwardResp parses an HTTP response from a StreamMoveBackwardWithResponse call
func ParseStreamMoveBackwardResp(rsp *http.Response) (*StreamMoveBackwardResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamMoveBackwardResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamMoveResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamMoveForwardResp parses an HTTP response from a StreamMoveForwardWithResponse call
func ParseStreamMoveForwardResp(rsp *http.Response) (*StreamMoveForwardResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamMoveForwardResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamMoveResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamMoveToTrajectoryViaJointPTPResp parses an HTTP response from a StreamMoveToTrajectoryViaJointPTPWithResponse call
func ParseStreamMoveToTrajectoryViaJointPTPResp(rsp *http.Response) (*StreamMoveToTrajectoryViaJointPTPResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamMoveToTrajectoryViaJointPTPResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamMoveResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPlannedMotionResp parses an HTTP response from a GetPlannedMotionWithResponse call
func ParseGetPlannedMotionResp(rsp *http.Response) (*GetPlannedMotionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlannedMotionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlannedMotion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStopExecutionResp parses an HTTP response from a StopExecutionWithResponse call
func ParseStopExecutionResp(rsp *http.Response) (*StopExecutionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopExecutionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMotionTrajectoryResp parses an HTTP response from a GetMotionTrajectoryWithResponse call
func ParseGetMotionTrajectoryResp(rsp *http.Response) (*GetMotionTrajectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionTrajectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTrajectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMotionTrajectorySampleResp parses an HTTP response from a GetMotionTrajectorySampleWithResponse call
func ParseGetMotionTrajectorySampleResp(rsp *http.Response) (*GetMotionTrajectorySampleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionTrajectorySampleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTrajectorySampleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLoadPlannedMotionResp parses an HTTP response from a LoadPlannedMotionWithResponse call
func ParseLoadPlannedMotionResp(rsp *http.Response) (*LoadPlannedMotionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadPlannedMotionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseClearProgramsValuesResp parses an HTTP response from a ClearProgramsValuesWithResponse call
func ParseClearProgramsValuesResp(rsp *http.Response) (*ClearProgramsValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearProgramsValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateProgramsValueResp parses an HTTP response from a CreateProgramsValueWithResponse call
func ParseCreateProgramsValueResp(rsp *http.Response) (*CreateProgramsValueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProgramsValueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteProgramValueResp parses an HTTP response from a DeleteProgramValueWithResponse call
func ParseDeleteProgramValueResp(rsp *http.Response) (*DeleteProgramValueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProgramValueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetProgramValueResp parses an HTTP response from a GetProgramValueWithResponse call
func ParseGetProgramValueResp(rsp *http.Response) (*GetProgramValueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramValueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateProgramValueResp parses an HTTP response from a UpdateProgramValueWithResponse call
func ParseUpdateProgramValueResp(rsp *http.Response) (*UpdateProgramValueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProgramValueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListStoredCollidersResp parses an HTTP response from a ListStoredCollidersWithResponse call
func ParseListStoredCollidersResp(rsp *http.Response) (*ListStoredCollidersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStoredCollidersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ColliderDictionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStoredColliderResp parses an HTTP response from a DeleteStoredColliderWithResponse call
func ParseDeleteStoredColliderResp(rsp *http.Response) (*DeleteStoredColliderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoredColliderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStoredColliderResp parses an HTTP response from a GetStoredColliderWithResponse call
func ParseGetStoredColliderResp(rsp *http.Response) (*GetStoredColliderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoredColliderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreColliderResp parses an HTTP response from a StoreColliderWithResponse call
func ParseStoreColliderResp(rsp *http.Response) (*StoreColliderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreColliderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCollisionLinkChainsResp parses an HTTP response from a ListCollisionLinkChainsWithResponse call
func ParseListCollisionLinkChainsResp(rsp *http.Response) (*ListCollisionLinkChainsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCollisionLinkChainsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]LinkChain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStoredCollisionLinkChainResp parses an HTTP response from a DeleteStoredCollisionLinkChainWithResponse call
func ParseDeleteStoredCollisionLinkChainResp(rsp *http.Response) (*DeleteStoredCollisionLinkChainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoredCollisionLinkChainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStoredCollisionLinkChainResp parses an HTTP response from a GetStoredCollisionLinkChainWithResponse call
func ParseGetStoredCollisionLinkChainResp(rsp *http.Response) (*GetStoredCollisionLinkChainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoredCollisionLinkChainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkChain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreCollisionLinkChainResp parses an HTTP response from a StoreCollisionLinkChainWithResponse call
func ParseStoreCollisionLinkChainResp(rsp *http.Response) (*StoreCollisionLinkChainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreCollisionLinkChainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkChain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListStoredCollisionScenesResp parses an HTTP response from a ListStoredCollisionScenesWithResponse call
func ParseListStoredCollisionScenesResp(rsp *http.Response) (*ListStoredCollisionScenesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStoredCollisionScenesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]CollisionScene
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStoredCollisionSceneResp parses an HTTP response from a DeleteStoredCollisionSceneWithResponse call
func ParseDeleteStoredCollisionSceneResp(rsp *http.Response) (*DeleteStoredCollisionSceneResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoredCollisionSceneResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStoredCollisionSceneResp parses an HTTP response from a GetStoredCollisionSceneWithResponse call
func ParseGetStoredCollisionSceneResp(rsp *http.Response) (*GetStoredCollisionSceneResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoredCollisionSceneResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollisionScene
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreCollisionSceneResp parses an HTTP response from a StoreCollisionSceneWithResponse call
func ParseStoreCollisionSceneResp(rsp *http.Response) (*StoreCollisionSceneResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreCollisionSceneResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollisionScene
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListStoredCollisionToolsResp parses an HTTP response from a ListStoredCollisionToolsWithResponse call
func ParseListStoredCollisionToolsResp(rsp *http.Response) (*ListStoredCollisionToolsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStoredCollisionToolsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]Tool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStoredCollisionToolResp parses an HTTP response from a DeleteStoredCollisionToolWithResponse call
func ParseDeleteStoredCollisionToolResp(rsp *http.Response) (*DeleteStoredCollisionToolResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoredCollisionToolResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStoredCollisionToolResp parses an HTTP response from a GetStoredCollisionToolWithResponse call
func ParseGetStoredCollisionToolResp(rsp *http.Response) (*GetStoredCollisionToolResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoredCollisionToolResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreCollisionToolResp parses an HTTP response from a StoreCollisionToolWithResponse call
func ParseStoreCollisionToolResp(rsp *http.Response) (*StoreCollisionToolResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreCollisionToolResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClearAllObjectsResp parses an HTTP response from a ClearAllObjectsWithResponse call
func ParseClearAllObjectsResp(rsp *http.Response) (*ClearAllObjectsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearAllObjectsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListAllObjectKeysResp parses an HTTP response from a ListAllObjectKeysWithResponse call
func ParseListAllObjectKeysResp(rsp *http.Response) (*ListAllObjectKeysResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllObjectKeysResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteObjectResp parses an HTTP response from a DeleteObjectWithResponse call
func ParseDeleteObjectResp(rsp *http.Response) (*DeleteObjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetObjectResp parses an HTTP response from a GetObjectWithResponse call
func ParseGetObjectResp(rsp *http.Response) (*GetObjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetObjectMetadataResp parses an HTTP response from a GetObjectMetadataWithResponse call
func ParseGetObjectMetadataResp(rsp *http.Response) (*GetObjectMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObjectMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStoreObjectResp parses an HTTP response from a StoreObjectWithResponse call
func ParseStoreObjectResp(rsp *http.Response) (*StoreObjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreObjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteProgramListResp parses an HTTP response from a DeleteProgramListWithResponse call
func ParseDeleteProgramListResp(rsp *http.Response) (*DeleteProgramListResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProgramListResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProgramMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 404:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseListProgramMetadataResp parses an HTTP response from a ListProgramMetadataWithResponse call
func ParseListProgramMetadataResp(rsp *http.Response) (*ListProgramMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProgramMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProgramMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateProgramResp parses an HTTP response from a CreateProgramWithResponse call
func ParseCreateProgramResp(rsp *http.Response) (*CreateProgramResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProgramResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 404:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseDeleteProgramResp parses an HTTP response from a DeleteProgramWithResponse call
func ParseDeleteProgramResp(rsp *http.Response) (*DeleteProgramResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProgramResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 404:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetProgramResp parses an HTTP response from a GetProgramWithResponse call
func ParseGetProgramResp(rsp *http.Response) (*GetProgramResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 404:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseUpdateProgramResp parses an HTTP response from a UpdateProgramWithResponse call
func ParseUpdateProgramResp(rsp *http.Response) (*UpdateProgramResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProgramResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 404:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetProgramMetadataResp parses an HTTP response from a GetProgramMetadataWithResponse call
func ParseGetProgramMetadataResp(rsp *http.Response) (*GetProgramMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateProgramMetadataResp parses an HTTP response from a UpdateProgramMetadataWithResponse call
func ParseUpdateProgramMetadataResp(rsp *http.Response) (*UpdateProgramMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProgramMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUploadProgramMetadataImageResp parses an HTTP response from a UploadProgramMetadataImageWithResponse call
func ParseUploadProgramMetadataImageResp(rsp *http.Response) (*UploadProgramMetadataImageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadProgramMetadataImageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteRecipeListResp parses an HTTP response from a DeleteRecipeListWithResponse call
func ParseDeleteRecipeListResp(rsp *http.Response) (*DeleteRecipeListResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecipeListResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRecipeMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListRecipeMetadataResp parses an HTTP response from a ListRecipeMetadataWithResponse call
func ParseListRecipeMetadataResp(rsp *http.Response) (*ListRecipeMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRecipeMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRecipeMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRecipeResp parses an HTTP response from a CreateRecipeWithResponse call
func ParseCreateRecipeResp(rsp *http.Response) (*CreateRecipeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRecipeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteRecipeResp parses an HTTP response from a DeleteRecipeWithResponse call
func ParseDeleteRecipeResp(rsp *http.Response) (*DeleteRecipeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecipeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetRecipeResp parses an HTTP response from a GetRecipeWithResponse call
func ParseGetRecipeResp(rsp *http.Response) (*GetRecipeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecipeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateRecipeResp parses an HTTP response from a UpdateRecipeWithResponse call
func ParseUpdateRecipeResp(rsp *http.Response) (*UpdateRecipeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRecipeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetRecipeMetadataResp parses an HTTP response from a GetRecipeMetadataWithResponse call
func ParseGetRecipeMetadataResp(rsp *http.Response) (*GetRecipeMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecipeMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateRecipeMetadataResp parses an HTTP response from a UpdateRecipeMetadataWithResponse call
func ParseUpdateRecipeMetadataResp(rsp *http.Response) (*UpdateRecipeMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRecipeMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUploadRecipeMetadataImageResp parses an HTTP response from a UploadRecipeMetadataImageWithResponse call
func ParseUploadRecipeMetadataImageResp(rsp *http.Response) (*UploadRecipeMetadataImageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadRecipeMetadataImageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseInternalListCellsResp parses an HTTP response from a InternalListCellsWithResponse call
func ParseInternalListCellsResp(rsp *http.Response) (*InternalListCellsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalListCellsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInternalDeployCellResp parses an HTTP response from a InternalDeployCellWithResponse call
func ParseInternalDeployCellResp(rsp *http.Response) (*InternalDeployCellResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalDeployCellResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInternalDeleteCellResp parses an HTTP response from a InternalDeleteCellWithResponse call
func ParseInternalDeleteCellResp(rsp *http.Response) (*InternalDeleteCellResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteCellResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalGetCellResp parses an HTTP response from a InternalGetCellWithResponse call
func ParseInternalGetCellResp(rsp *http.Response) (*InternalGetCellResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalGetCellResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InternalCell
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalUpdateCellResp parses an HTTP response from a InternalUpdateCellWithResponse call
func ParseInternalUpdateCellResp(rsp *http.Response) (*InternalUpdateCellResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalUpdateCellResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalClearAppsResp parses an HTTP response from a InternalClearAppsWithResponse call
func ParseInternalClearAppsResp(rsp *http.Response) (*InternalClearAppsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalClearAppsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalListAppsResp parses an HTTP response from a InternalListAppsWithResponse call
func ParseInternalListAppsResp(rsp *http.Response) (*InternalListAppsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalListAppsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInternalAddAppResp parses an HTTP response from a InternalAddAppWithResponse call
func ParseInternalAddAppResp(rsp *http.Response) (*InternalAddAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalAddAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInternalDeleteAppResp parses an HTTP response from a InternalDeleteAppWithResponse call
func ParseInternalDeleteAppResp(rsp *http.Response) (*InternalDeleteAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalGetAppResp parses an HTTP response from a InternalGetAppWithResponse call
func ParseInternalGetAppResp(rsp *http.Response) (*InternalGetAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalGetAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalUpdateAppResp parses an HTTP response from a InternalUpdateAppWithResponse call
func ParseInternalUpdateAppResp(rsp *http.Response) (*InternalUpdateAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalUpdateAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalGetAppStatusResp parses an HTTP response from a InternalGetAppStatusWithResponse call
func ParseInternalGetAppStatusResp(rsp *http.Response) (*InternalGetAppStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalGetAppStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalClearRobotControllersResp parses an HTTP response from a InternalClearRobotControllersWithResponse call
func ParseInternalClearRobotControllersResp(rsp *http.Response) (*InternalClearRobotControllersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalClearRobotControllersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalListRobotControllersResp parses an HTTP response from a InternalListRobotControllersWithResponse call
func ParseInternalListRobotControllersResp(rsp *http.Response) (*InternalListRobotControllersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalListRobotControllersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInternalAddRobotControllerResp parses an HTTP response from a InternalAddRobotControllerWithResponse call
func ParseInternalAddRobotControllerResp(rsp *http.Response) (*InternalAddRobotControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalAddRobotControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalDeleteRobotControllerResp parses an HTTP response from a InternalDeleteRobotControllerWithResponse call
func ParseInternalDeleteRobotControllerResp(rsp *http.Response) (*InternalDeleteRobotControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteRobotControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalGetRobotControllerResp parses an HTTP response from a InternalGetRobotControllerWithResponse call
func ParseInternalGetRobotControllerResp(rsp *http.Response) (*InternalGetRobotControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalGetRobotControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InternalRobotController
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalUpdateRobotControllerResp parses an HTTP response from a InternalUpdateRobotControllerWithResponse call
func ParseInternalUpdateRobotControllerResp(rsp *http.Response) (*InternalUpdateRobotControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalUpdateRobotControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalGetRobotControllerStatusResp parses an HTTP response from a InternalGetRobotControllerStatusWithResponse call
func ParseInternalGetRobotControllerStatusResp(rsp *http.Response) (*InternalGetRobotControllerStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalGetRobotControllerStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalGetFoundationServicesResp parses an HTTP response from a InternalGetFoundationServicesWithResponse call
func ParseInternalGetFoundationServicesResp(rsp *http.Response) (*InternalGetFoundationServicesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalGetFoundationServicesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FoundationServices
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalUpdateFoundationServicesResp parses an HTTP response from a InternalUpdateFoundationServicesWithResponse call
func ParseInternalUpdateFoundationServicesResp(rsp *http.Response) (*InternalUpdateFoundationServicesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalUpdateFoundationServicesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDescriptionResp parses an HTTP response from a GetDescriptionWithResponse call
func ParseGetDescriptionResp(rsp *http.Response) (*GetDescriptionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDescriptionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Description
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRegisterControllerResp parses an HTTP response from a RegisterControllerWithResponse call
func ParseRegisterControllerResp(rsp *http.Response) (*RegisterControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ControllerInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteControllerResp parses an HTTP response from a DeleteControllerWithResponse call
func ParseDeleteControllerResp(rsp *http.Response) (*DeleteControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListControllerResp parses an HTTP response from a ListControllerWithResponse call
func ParseListControllerResp(rsp *http.Response) (*ListControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ControllerInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRaeVersionResp parses an HTTP response from a GetRaeVersionWithResponse call
func ParseGetRaeVersionResp(rsp *http.Response) (*GetRaeVersionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRaeVersionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Versions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalGetCellStatusResp parses an HTTP response from a InternalGetCellStatusWithResponse call
func ParseInternalGetCellStatusResp(rsp *http.Response) (*InternalGetCellStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalGetCellStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInternalGetDiagnosePackageResp parses an HTTP response from a InternalGetDiagnosePackageWithResponse call
func ParseInternalGetDiagnosePackageResp(rsp *http.Response) (*InternalGetDiagnosePackageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalGetDiagnosePackageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInternalGetSystemStatusResp parses an HTTP response from a InternalGetSystemStatusWithResponse call
func ParseInternalGetSystemStatusResp(rsp *http.Response) (*InternalGetSystemStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalGetSystemStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInternalCheckNovaVersionUpdateResp parses an HTTP response from a InternalCheckNovaVersionUpdateWithResponse call
func ParseInternalCheckNovaVersionUpdateResp(rsp *http.Response) (*InternalCheckNovaVersionUpdateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalCheckNovaVersionUpdateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInternalUpdateNovaVersionResp parses an HTTP response from a InternalUpdateNovaVersionWithResponse call
func ParseInternalUpdateNovaVersionResp(rsp *http.Response) (*InternalUpdateNovaVersionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalUpdateNovaVersionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInternalGetSystemVersionResp parses an HTTP response from a InternalGetSystemVersionWithResponse call
func ParseInternalGetSystemVersionResp(rsp *http.Response) (*InternalGetSystemVersionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InternalGetSystemVersionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
