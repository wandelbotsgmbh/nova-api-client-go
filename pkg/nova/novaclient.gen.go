// Package nova provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package nova

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes  = "BasicAuth.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AbbControllerKind.
const (
	AbbControllerKindAbbController AbbControllerKind = "AbbController"
)

// Defines values for Behavior.
const (
	BEHAVIORAUTOMATIC                       Behavior = "BEHAVIOR_AUTOMATIC"
	BEHAVIORAUTOMATICNOTCOMPLYWITHCYCLETIME Behavior = "BEHAVIOR_AUTOMATIC_NOT_COMPLY_WITH_CYCLETIME"
	BEHAVIOREXTERNALSOURCE                  Behavior = "BEHAVIOR_EXTERNAL_SOURCE"
)

// Defines values for BoxType.
const (
	TYPEFULL   BoxType = "TYPE_FULL"
	TYPEHOLLOW BoxType = "TYPE_HOLLOW"
)

// Defines values for Box2BoxType.
const (
	Box2BoxTypeFULL   Box2BoxType = "FULL"
	Box2BoxTypeHOLLOW Box2BoxType = "HOLLOW"
)

// Defines values for Box3ShapeType.
const (
	Box3ShapeTypeBox Box3ShapeType = "box"
)

// Defines values for Box3Type.
const (
	Box3TypeFULL   Box3Type = "FULL"
	Box3TypeHOLLOW Box3Type = "HOLLOW"
)

// Defines values for Capsule3ShapeType.
const (
	Capsule3ShapeTypeCapsule Capsule3ShapeType = "capsule"
)

// Defines values for Comparator.
const (
	COMPARATOREQUALS       Comparator = "COMPARATOR_EQUALS"
	COMPARATORGREATER      Comparator = "COMPARATOR_GREATER"
	COMPARATORGREATEREQUAL Comparator = "COMPARATOR_GREATER_EQUAL"
	COMPARATORLESS         Comparator = "COMPARATOR_LESS"
	COMPARATORLESSEQUAL    Comparator = "COMPARATOR_LESS_EQUAL"
	COMPARATORNOTEQUALS    Comparator = "COMPARATOR_NOT_EQUALS"
	COMPARATORUNKNOWN      Comparator = "COMPARATOR_UNKNOWN"
)

// Defines values for ConvexHull3ShapeType.
const (
	ConvexHull3ShapeTypeConvexHull ConvexHull3ShapeType = "convex_hull"
)

// Defines values for Cylinder3ShapeType.
const (
	Cylinder3ShapeTypeCylinder Cylinder3ShapeType = "cylinder"
)

// Defines values for Direction.
const (
	DIRECTIONBACKWARD Direction = "DIRECTION_BACKWARD"
	DIRECTIONFORWARD  Direction = "DIRECTION_FORWARD"
)

// Defines values for FanucControllerKind.
const (
	FanucControllerKindFanucController FanucControllerKind = "FanucController"
)

// Defines values for IODescriptionType.
const (
	IOTYPEINPUT  IODescriptionType = "IO_TYPE_INPUT"
	IOTYPEOUTPUT IODescriptionType = "IO_TYPE_OUTPUT"
)

// Defines values for IODescriptionUnit.
const (
	UNITAMPERE      IODescriptionUnit = "UNIT_AMPERE"
	UNITCELSIUS     IODescriptionUnit = "UNIT_CELSIUS"
	UNITHERTZ       IODescriptionUnit = "UNIT_HERTZ"
	UNITKELVIN      IODescriptionUnit = "UNIT_KELVIN"
	UNITKILOGRAM    IODescriptionUnit = "UNIT_KILOGRAM"
	UNITMETER       IODescriptionUnit = "UNIT_METER"
	UNITNEWTON      IODescriptionUnit = "UNIT_NEWTON"
	UNITNEWTONMETER IODescriptionUnit = "UNIT_NEWTON_METER"
	UNITNONE        IODescriptionUnit = "UNIT_NONE"
	UNITVOLT        IODescriptionUnit = "UNIT_VOLT"
)

// Defines values for IODescriptionValueType.
const (
	IOVALUEANALOGFLOATING IODescriptionValueType = "IO_VALUE_ANALOG_FLOATING"
	IOVALUEANALOGINTEGER  IODescriptionValueType = "IO_VALUE_ANALOG_INTEGER"
	IOVALUEDIGITAL        IODescriptionValueType = "IO_VALUE_DIGITAL"
)

// Defines values for JoggingResponseMovementState.
const (
	MOVEMENTSTATEERROR             JoggingResponseMovementState = "MOVEMENT_STATE_ERROR"
	MOVEMENTSTATEJOINTLIMITREACHED JoggingResponseMovementState = "MOVEMENT_STATE_JOINT_LIMIT_REACHED"
	MOVEMENTSTATEMOVING            JoggingResponseMovementState = "MOVEMENT_STATE_MOVING"
	MOVEMENTSTATESTOPBYREQUEST     JoggingResponseMovementState = "MOVEMENT_STATE_STOP_BY_REQUEST"
	MOVEMENTSTATESTOPFORFORCELIMIT JoggingResponseMovementState = "MOVEMENT_STATE_STOP_FOR_FORCE_LIMIT"
	MOVEMENTSTATESTOPFORIO         JoggingResponseMovementState = "MOVEMENT_STATE_STOP_FOR_IO"
	MOVEMENTSTATEUNKNOWN           JoggingResponseMovementState = "MOVEMENT_STATE_UNKNOWN"
)

// Defines values for JointLimitJoint.
const (
	JointLimitJointJOINTNAMEAXIS1       JointLimitJoint = "JOINTNAME_AXIS_1"
	JointLimitJointJOINTNAMEAXIS10      JointLimitJoint = "JOINTNAME_AXIS_10"
	JointLimitJointJOINTNAMEAXIS11      JointLimitJoint = "JOINTNAME_AXIS_11"
	JointLimitJointJOINTNAMEAXIS12      JointLimitJoint = "JOINTNAME_AXIS_12"
	JointLimitJointJOINTNAMEAXIS2       JointLimitJoint = "JOINTNAME_AXIS_2"
	JointLimitJointJOINTNAMEAXIS3       JointLimitJoint = "JOINTNAME_AXIS_3"
	JointLimitJointJOINTNAMEAXIS4       JointLimitJoint = "JOINTNAME_AXIS_4"
	JointLimitJointJOINTNAMEAXIS5       JointLimitJoint = "JOINTNAME_AXIS_5"
	JointLimitJointJOINTNAMEAXIS6       JointLimitJoint = "JOINTNAME_AXIS_6"
	JointLimitJointJOINTNAMEAXIS7       JointLimitJoint = "JOINTNAME_AXIS_7"
	JointLimitJointJOINTNAMEAXIS8       JointLimitJoint = "JOINTNAME_AXIS_8"
	JointLimitJointJOINTNAMEAXIS9       JointLimitJoint = "JOINTNAME_AXIS_9"
	JointLimitJointJOINTNAMEAXISINVALID JointLimitJoint = "JOINTNAME_AXIS_INVALID"
)

// Defines values for KukaControllerKind.
const (
	KukaControllerKindKukaController KukaControllerKind = "KukaController"
)

// Defines values for LicenseStatusEnum.
const (
	EXPIRED         LicenseStatusEnum = "EXPIRED"
	GRACEPERIODOVER LicenseStatusEnum = "GRACE_PERIOD_OVER"
	NOTFOUND        LicenseStatusEnum = "NOT_FOUND"
	OK              LicenseStatusEnum = "OK"
	SUSPENDED       LicenseStatusEnum = "SUSPENDED"
)

// Defines values for Manufacturer.
const (
	Abb             Manufacturer = "abb"
	Fanuc           Manufacturer = "fanuc"
	Kuka            Manufacturer = "kuka"
	Universalrobots Manufacturer = "universalrobots"
	Yaskawa         Manufacturer = "yaskawa"
)

// Defines values for OpModeMode.
const (
	OpModeModeOPERATIONMODEAUTO   OpModeMode = "OPERATION_MODE_AUTO"
	OpModeModeOPERATIONMODEMANUAL OpModeMode = "OPERATION_MODE_MANUAL"
)

// Defines values for Plane3ShapeType.
const (
	Plane3ShapeTypePlane Plane3ShapeType = "plane"
)

// Defines values for Rectangle3ShapeType.
const (
	Rectangle3ShapeTypeRectangle Rectangle3ShapeType = "rectangle"
)

// Defines values for RectangularCapsule3ShapeType.
const (
	RectangularCapsule3ShapeTypeRectangularCapsule RectangularCapsule3ShapeType = "rectangular_capsule"
)

// Defines values for ReleaseChannel.
const (
	Next   ReleaseChannel = "next"
	Stable ReleaseChannel = "stable"
)

// Defines values for RobotControllerStateOperationMode.
const (
	RobotControllerStateOperationModeOPERATIONMODEAUTO         RobotControllerStateOperationMode = "OPERATION_MODE_AUTO"
	RobotControllerStateOperationModeOPERATIONMODEDISCONNECTED RobotControllerStateOperationMode = "OPERATION_MODE_DISCONNECTED"
	RobotControllerStateOperationModeOPERATIONMODEMANUAL       RobotControllerStateOperationMode = "OPERATION_MODE_MANUAL"
	RobotControllerStateOperationModeOPERATIONMODEMANUALT1     RobotControllerStateOperationMode = "OPERATION_MODE_MANUAL_T1"
	RobotControllerStateOperationModeOPERATIONMODEMANUALT2     RobotControllerStateOperationMode = "OPERATION_MODE_MANUAL_T2"
	RobotControllerStateOperationModeOPERATIONMODENOCONTROLLER RobotControllerStateOperationMode = "OPERATION_MODE_NO_CONTROLLER"
	RobotControllerStateOperationModeOPERATIONMODEPENDING      RobotControllerStateOperationMode = "OPERATION_MODE_PENDING"
	RobotControllerStateOperationModeOPERATIONMODEPOWERON      RobotControllerStateOperationMode = "OPERATION_MODE_POWER_ON"
	RobotControllerStateOperationModeOPERATIONMODERECOVERY     RobotControllerStateOperationMode = "OPERATION_MODE_RECOVERY"
	RobotControllerStateOperationModeOPERATIONMODEUNKNOWN      RobotControllerStateOperationMode = "OPERATION_MODE_UNKNOWN"
)

// Defines values for RobotControllerStateSafetyState.
const (
	SAFETYSTATECONFIRMSAFETY       RobotControllerStateSafetyState = "SAFETY_STATE_CONFIRM_SAFETY"
	SAFETYSTATEDEVICEEMERGENCYSTOP RobotControllerStateSafetyState = "SAFETY_STATE_DEVICE_EMERGENCY_STOP"
	SAFETYSTATEFAULT               RobotControllerStateSafetyState = "SAFETY_STATE_FAULT"
	SAFETYSTATEMASTERING           RobotControllerStateSafetyState = "SAFETY_STATE_MASTERING"
	SAFETYSTATENORMAL              RobotControllerStateSafetyState = "SAFETY_STATE_NORMAL"
	SAFETYSTATEOPERATORSAFETY      RobotControllerStateSafetyState = "SAFETY_STATE_OPERATOR_SAFETY"
	SAFETYSTATEPROTECTIVESTOP      RobotControllerStateSafetyState = "SAFETY_STATE_PROTECTIVE_STOP"
	SAFETYSTATERECOVERY            RobotControllerStateSafetyState = "SAFETY_STATE_RECOVERY"
	SAFETYSTATEREDUCED             RobotControllerStateSafetyState = "SAFETY_STATE_REDUCED"
	SAFETYSTATEROBOTEMERGENCYSTOP  RobotControllerStateSafetyState = "SAFETY_STATE_ROBOT_EMERGENCY_STOP"
	SAFETYSTATESTOP                RobotControllerStateSafetyState = "SAFETY_STATE_STOP"
	SAFETYSTATESTOP0               RobotControllerStateSafetyState = "SAFETY_STATE_STOP_0"
	SAFETYSTATESTOP1               RobotControllerStateSafetyState = "SAFETY_STATE_STOP_1"
	SAFETYSTATESTOP2               RobotControllerStateSafetyState = "SAFETY_STATE_STOP_2"
	SAFETYSTATEUNKNOWN             RobotControllerStateSafetyState = "SAFETY_STATE_UNKNOWN"
	SAFETYSTATEVIOLATION           RobotControllerStateSafetyState = "SAFETY_STATE_VIOLATION"
)

// Defines values for RobotSystemMode.
const (
	ROBOTSYSTEMMODECONTROL    RobotSystemMode = "ROBOT_SYSTEM_MODE_CONTROL"
	ROBOTSYSTEMMODEDISCONNECT RobotSystemMode = "ROBOT_SYSTEM_MODE_DISCONNECT"
	ROBOTSYSTEMMODEFREEDRIVE  RobotSystemMode = "ROBOT_SYSTEM_MODE_FREE_DRIVE"
	ROBOTSYSTEMMODEMONITOR    RobotSystemMode = "ROBOT_SYSTEM_MODE_MONITOR"
	ROBOTSYSTEMMODEUNDEFINED  RobotSystemMode = "ROBOT_SYSTEM_MODE_UNDEFINED"
)

// Defines values for RotationAngleTypes.
const (
	EULERANGLESEXTRINSICXYX RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_XYX"
	EULERANGLESEXTRINSICXYZ RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_XYZ"
	EULERANGLESEXTRINSICXZX RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_XZX"
	EULERANGLESEXTRINSICXZY RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_XZY"
	EULERANGLESEXTRINSICYXY RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_YXY"
	EULERANGLESEXTRINSICYXZ RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_YXZ"
	EULERANGLESEXTRINSICYZX RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_YZX"
	EULERANGLESEXTRINSICYZY RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_YZY"
	EULERANGLESEXTRINSICZXY RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_ZXY"
	EULERANGLESEXTRINSICZXZ RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_ZXZ"
	EULERANGLESEXTRINSICZYX RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_ZYX"
	EULERANGLESEXTRINSICZYZ RotationAngleTypes = "EULER_ANGLES_EXTRINSIC_ZYZ"
	EULERANGLESINTRINSICXYX RotationAngleTypes = "EULER_ANGLES_INTRINSIC_XYX"
	EULERANGLESINTRINSICXYZ RotationAngleTypes = "EULER_ANGLES_INTRINSIC_XYZ"
	EULERANGLESINTRINSICXZX RotationAngleTypes = "EULER_ANGLES_INTRINSIC_XZX"
	EULERANGLESINTRINSICXZY RotationAngleTypes = "EULER_ANGLES_INTRINSIC_XZY"
	EULERANGLESINTRINSICYXY RotationAngleTypes = "EULER_ANGLES_INTRINSIC_YXY"
	EULERANGLESINTRINSICYXZ RotationAngleTypes = "EULER_ANGLES_INTRINSIC_YXZ"
	EULERANGLESINTRINSICYZX RotationAngleTypes = "EULER_ANGLES_INTRINSIC_YZX"
	EULERANGLESINTRINSICYZY RotationAngleTypes = "EULER_ANGLES_INTRINSIC_YZY"
	EULERANGLESINTRINSICZXY RotationAngleTypes = "EULER_ANGLES_INTRINSIC_ZXY"
	EULERANGLESINTRINSICZXZ RotationAngleTypes = "EULER_ANGLES_INTRINSIC_ZXZ"
	EULERANGLESINTRINSICZYX RotationAngleTypes = "EULER_ANGLES_INTRINSIC_ZYX"
	EULERANGLESINTRINSICZYZ RotationAngleTypes = "EULER_ANGLES_INTRINSIC_ZYZ"
	QUATERNION              RotationAngleTypes = "QUATERNION"
	ROTATIONVECTOR          RotationAngleTypes = "ROTATION_VECTOR"
)

// Defines values for SafetySetupSafetySettingsSafetyState.
const (
	SAFETYINVALID SafetySetupSafetySettingsSafetyState = "SAFETY_INVALID"
	SAFETYNORMAL  SafetySetupSafetySettingsSafetyState = "SAFETY_NORMAL"
	SAFETYREDUCED SafetySetupSafetySettingsSafetyState = "SAFETY_REDUCED"
)

// Defines values for ServiceStatusPhase.
const (
	ServiceStatusPhaseCompleted         ServiceStatusPhase = "Completed"
	ServiceStatusPhaseContainerCreating ServiceStatusPhase = "ContainerCreating"
	ServiceStatusPhaseCrashLoopBackOff  ServiceStatusPhase = "CrashLoopBackOff"
	ServiceStatusPhaseError             ServiceStatusPhase = "Error"
	ServiceStatusPhaseEvicted           ServiceStatusPhase = "Evicted"
	ServiceStatusPhaseImagePullBackOff  ServiceStatusPhase = "ImagePullBackOff"
	ServiceStatusPhaseInitialized       ServiceStatusPhase = "Initialized"
	ServiceStatusPhaseNoReady           ServiceStatusPhase = "NoReady"
	ServiceStatusPhaseOOMKilled         ServiceStatusPhase = "OOMKilled"
	ServiceStatusPhasePending           ServiceStatusPhase = "Pending"
	ServiceStatusPhasePodInitializing   ServiceStatusPhase = "PodInitializing"
	ServiceStatusPhaseRunning           ServiceStatusPhase = "Running"
	ServiceStatusPhaseTerminating       ServiceStatusPhase = "Terminating"
	ServiceStatusPhaseUnknown           ServiceStatusPhase = "Unknown"
)

// Defines values for ServiceStatusSeverity.
const (
	ERROR   ServiceStatusSeverity = "ERROR"
	INFO    ServiceStatusSeverity = "INFO"
	WARNING ServiceStatusSeverity = "WARNING"
)

// Defines values for SingleJointLimitJoint.
const (
	SingleJointLimitJointJOINTNAMEAXIS1       SingleJointLimitJoint = "JOINTNAME_AXIS_1"
	SingleJointLimitJointJOINTNAMEAXIS10      SingleJointLimitJoint = "JOINTNAME_AXIS_10"
	SingleJointLimitJointJOINTNAMEAXIS11      SingleJointLimitJoint = "JOINTNAME_AXIS_11"
	SingleJointLimitJointJOINTNAMEAXIS12      SingleJointLimitJoint = "JOINTNAME_AXIS_12"
	SingleJointLimitJointJOINTNAMEAXIS2       SingleJointLimitJoint = "JOINTNAME_AXIS_2"
	SingleJointLimitJointJOINTNAMEAXIS3       SingleJointLimitJoint = "JOINTNAME_AXIS_3"
	SingleJointLimitJointJOINTNAMEAXIS4       SingleJointLimitJoint = "JOINTNAME_AXIS_4"
	SingleJointLimitJointJOINTNAMEAXIS5       SingleJointLimitJoint = "JOINTNAME_AXIS_5"
	SingleJointLimitJointJOINTNAMEAXIS6       SingleJointLimitJoint = "JOINTNAME_AXIS_6"
	SingleJointLimitJointJOINTNAMEAXIS7       SingleJointLimitJoint = "JOINTNAME_AXIS_7"
	SingleJointLimitJointJOINTNAMEAXIS8       SingleJointLimitJoint = "JOINTNAME_AXIS_8"
	SingleJointLimitJointJOINTNAMEAXIS9       SingleJointLimitJoint = "JOINTNAME_AXIS_9"
	SingleJointLimitJointJOINTNAMEAXISINVALID SingleJointLimitJoint = "JOINTNAME_AXIS_INVALID"
)

// Defines values for SingularitySingularityType.
const (
	SINGULARITYTYPEELBOW    SingularitySingularityType = "SINGULARITY_TYPE_ELBOW"
	SINGULARITYTYPESHOULDER SingularitySingularityType = "SINGULARITY_TYPE_SHOULDER"
	SINGULARITYTYPEUNKNOWN  SingularitySingularityType = "SINGULARITY_TYPE_UNKNOWN"
	SINGULARITYTYPEWRIST    SingularitySingularityType = "SINGULARITY_TYPE_WRIST"
)

// Defines values for SingularityTypeEnum.
const (
	ELBOW    SingularityTypeEnum = "ELBOW"
	SHOULDER SingularityTypeEnum = "SHOULDER"
	WRIST    SingularityTypeEnum = "WRIST"
)

// Defines values for Sphere3ShapeType.
const (
	Sphere3ShapeTypeSphere Sphere3ShapeType = "sphere"
)

// Defines values for StandstillReason.
const (
	REASONMOTIONENDED      StandstillReason = "REASON_MOTION_ENDED"
	REASONPAUSEDONIO       StandstillReason = "REASON_PAUSED_ON_IO"
	REASONUSERPAUSEDMOTION StandstillReason = "REASON_USER_PAUSED_MOTION"
	REASONWAITINGFORIO     StandstillReason = "REASON_WAITING_FOR_IO"
)

// Defines values for StopResponseStopCode.
const (
	STOPCODEERROR             StopResponseStopCode = "STOP_CODE_ERROR"
	STOPCODEFORCELIMIT        StopResponseStopCode = "STOP_CODE_FORCE_LIMIT"
	STOPCODEIO                StopResponseStopCode = "STOP_CODE_IO"
	STOPCODEJOINTLIMITREACHED StopResponseStopCode = "STOP_CODE_JOINT_LIMIT_REACHED"
	STOPCODEPATHEND           StopResponseStopCode = "STOP_CODE_PATH_END"
	STOPCODEUNKNOWN           StopResponseStopCode = "STOP_CODE_UNKNOWN"
	STOPCODEUSERREQUEST       StopResponseStopCode = "STOP_CODE_USER_REQUEST"
)

// Defines values for UniversalrobotsControllerKind.
const (
	UniversalrobotsControllerKindUniversalrobotsController UniversalrobotsControllerKind = "UniversalrobotsController"
)

// Defines values for VirtualControllerKind.
const (
	VirtualControllerKindVirtualController VirtualControllerKind = "VirtualController"
)

// Defines values for VirtualControllerTypes.
const (
	AbbIrb101003715       VirtualControllerTypes = "abb-irb1010_037_15"
	AbbIrb110004754       VirtualControllerTypes = "abb-irb1100_0475_4"
	AbbIrb11000584        VirtualControllerTypes = "abb-irb1100_058_4"
	AbbIrb12007           VirtualControllerTypes = "abb-irb1200_7"
	AbbIrb130011510       VirtualControllerTypes = "abb-irb1300_115_10"
	FanucArcMate100iD     VirtualControllerTypes = "fanuc-arc_mate_100iD"
	FanucArcMate120iD     VirtualControllerTypes = "fanuc-arc_mate_120iD"
	FanucArcMate120iD35   VirtualControllerTypes = "fanuc-arc_mate_120iD35"
	FanucCr35ib           VirtualControllerTypes = "fanuc-cr35ib"
	FanucCr7ia            VirtualControllerTypes = "fanuc-cr7ia"
	FanucCr7ial           VirtualControllerTypes = "fanuc-cr7ial"
	FanucCrx10ia          VirtualControllerTypes = "fanuc-crx10ia"
	FanucCrx10ial         VirtualControllerTypes = "fanuc-crx10ial"
	FanucCrx20ial         VirtualControllerTypes = "fanuc-crx20ial"
	FanucCrx25ia          VirtualControllerTypes = "fanuc-crx25ia"
	FanucLrMate200iD      VirtualControllerTypes = "fanuc-lr_mate_200iD"
	FanucLrMate200iD4S    VirtualControllerTypes = "fanuc-lr_mate_200iD4S"
	FanucLrMate200iD7L    VirtualControllerTypes = "fanuc-lr_mate_200iD7L"
	FanucM10iD12          VirtualControllerTypes = "fanuc-m10iD12"
	FanucM20iD25          VirtualControllerTypes = "fanuc-m20iD25"
	FanucM20iD35          VirtualControllerTypes = "fanuc-m20iD35"
	FanucR2000ic125l      VirtualControllerTypes = "fanuc-r2000ic125l"
	KukaKr10R1100         VirtualControllerTypes = "kuka-kr10_r1100"
	KukaKr10R11002        VirtualControllerTypes = "kuka-kr10_r1100_2"
	KukaKr10R900          VirtualControllerTypes = "kuka-kr10_r900"
	KukaKr10R9002         VirtualControllerTypes = "kuka-kr10_r900_2"
	KukaKr120R27002       VirtualControllerTypes = "kuka-kr120_r2700_2"
	KukaKr1502            VirtualControllerTypes = "kuka-kr150_2"
	KukaKr16R16102        VirtualControllerTypes = "kuka-kr16_r1610_2"
	KukaKr16R20102        VirtualControllerTypes = "kuka-kr16_r2010_2"
	KukaKr20R1810         VirtualControllerTypes = "kuka-kr20_r1810"
	KukaKr20R18102        VirtualControllerTypes = "kuka-kr20_r1810_2"
	KukaKr210R27002       VirtualControllerTypes = "kuka-kr210_r2700_2"
	KukaKr210R31002       VirtualControllerTypes = "kuka-kr210_r3100_2"
	KukaKr210R33002       VirtualControllerTypes = "kuka-kr210_r3300_2"
	KukaKr240R2700        VirtualControllerTypes = "kuka-kr240_r2700"
	KukaKr250R27002       VirtualControllerTypes = "kuka-kr250_r2700_2"
	KukaKr360L2403        VirtualControllerTypes = "kuka-kr360_l240_3"
	KukaKr4R600           VirtualControllerTypes = "kuka-kr4_r600"
	KukaKr500L3403        VirtualControllerTypes = "kuka-kr500_l340_3"
	KukaKr50R2500         VirtualControllerTypes = "kuka-kr50_r2500"
	KukaKr6R7002          VirtualControllerTypes = "kuka-kr6_r700_2"
	KukaKr6R700Sixx       VirtualControllerTypes = "kuka-kr6_r700_sixx"
	KukaKr6R9002          VirtualControllerTypes = "kuka-kr6_r900_2"
	UniversalrobotsUr10cb VirtualControllerTypes = "universalrobots-ur10cb"
	UniversalrobotsUr10e  VirtualControllerTypes = "universalrobots-ur10e"
	UniversalrobotsUr16e  VirtualControllerTypes = "universalrobots-ur16e"
	UniversalrobotsUr20e  VirtualControllerTypes = "universalrobots-ur20e"
	UniversalrobotsUr3e   VirtualControllerTypes = "universalrobots-ur3e"
	UniversalrobotsUr5cb  VirtualControllerTypes = "universalrobots-ur5cb"
	UniversalrobotsUr5e   VirtualControllerTypes = "universalrobots-ur5e"
	YaskawaAr1440         VirtualControllerTypes = "yaskawa-ar1440"
	YaskawaAr1730         VirtualControllerTypes = "yaskawa-ar1730"
	YaskawaAr2010         VirtualControllerTypes = "yaskawa-ar2010"
	YaskawaAr3120         VirtualControllerTypes = "yaskawa-ar3120"
	YaskawaAr700          VirtualControllerTypes = "yaskawa-ar700"
	YaskawaAr900          VirtualControllerTypes = "yaskawa-ar900"
	YaskawaGp12           VirtualControllerTypes = "yaskawa-gp12"
	YaskawaGp20hl         VirtualControllerTypes = "yaskawa-gp20hl"
	YaskawaGp25           VirtualControllerTypes = "yaskawa-gp25"
	YaskawaGp2512         VirtualControllerTypes = "yaskawa-gp25_12"
	YaskawaGp50           VirtualControllerTypes = "yaskawa-gp50"
	YaskawaGp7            VirtualControllerTypes = "yaskawa-gp7"
	YaskawaGp8            VirtualControllerTypes = "yaskawa-gp8"
	YaskawaGp88           VirtualControllerTypes = "yaskawa-gp88"
	YaskawaHc10dtp        VirtualControllerTypes = "yaskawa-hc10dtp"
)

// Defines values for YaskawaControllerKind.
const (
	YaskawaControllerKindYaskawaController YaskawaControllerKind = "YaskawaController"
)

// Defines values for PyripheryRoboticsRobotcellTimerConfigurationType.
const (
	SimulatedTimer PyripheryRoboticsRobotcellTimerConfigurationType = "simulated_timer"
	Timer          PyripheryRoboticsRobotcellTimerConfigurationType = "timer"
)

// Defines values for TriggerType.
const (
	OpcuaNodeValue TriggerType = "opcua_node_value"
)

// Defines values for MotionGroupModel.
const (
	MotionGroupModelABB1200077           MotionGroupModel = "ABB_1200_07_7"
	MotionGroupModelABB1200583           MotionGroupModel = "ABB_120_058_3"
	MotionGroupModelABB130011510         MotionGroupModel = "ABB_1300_115_10"
	MotionGroupModelABB14001445          MotionGroupModel = "ABB_1400_144_5"
	MotionGroupModelABB1400816           MotionGroupModel = "ABB_140_081_6"
	MotionGroupModelABB1520ID154         MotionGroupModel = "ABB_1520ID_15_4"
	MotionGroupModelABB1600126           MotionGroupModel = "ABB_1600_12_6"
	MotionGroupModelABB1660ID1554        MotionGroupModel = "ABB_1660ID_155_4"
	MotionGroupModelFANUCARCMate100iD    MotionGroupModel = "FANUC_ARC_Mate_100iD"
	MotionGroupModelFANUCARCMate100iD10L MotionGroupModel = "FANUC_ARC_Mate_100iD10L"
	MotionGroupModelFANUCARCMate100iD8L  MotionGroupModel = "FANUC_ARC_Mate_100iD8L"
	MotionGroupModelFANUCARCMate120iD    MotionGroupModel = "FANUC_ARC_Mate_120iD"
	MotionGroupModelFANUCARCMate120iD12L MotionGroupModel = "FANUC_ARC_Mate_120iD12L"
	MotionGroupModelFANUCARCMate50iD     MotionGroupModel = "FANUC_ARC_Mate_50iD"
	MotionGroupModelFANUCARCMate50iD7L   MotionGroupModel = "FANUC_ARC_Mate_50iD7L"
	MotionGroupModelFANUCCR14iAL         MotionGroupModel = "FANUC_CR14iAL"
	MotionGroupModelFANUCCR15iA          MotionGroupModel = "FANUC_CR15iA"
	MotionGroupModelFANUCCR35iA          MotionGroupModel = "FANUC_CR35iA"
	MotionGroupModelFANUCCR35iB          MotionGroupModel = "FANUC_CR35iB"
	MotionGroupModelFANUCCR4iA           MotionGroupModel = "FANUC_CR4iA"
	MotionGroupModelFANUCCR7iA           MotionGroupModel = "FANUC_CR7iA"
	MotionGroupModelFANUCCR7iAL          MotionGroupModel = "FANUC_CR7iAL"
	MotionGroupModelFANUCCRX10iA         MotionGroupModel = "FANUC_CRX10iA"
	MotionGroupModelFANUCCRX10iAL        MotionGroupModel = "FANUC_CRX10iAL"
	MotionGroupModelFANUCCRX20iAL        MotionGroupModel = "FANUC_CRX20iAL"
	MotionGroupModelFANUCCRX25iA         MotionGroupModel = "FANUC_CRX25iA"
	MotionGroupModelFANUCCRX5iA          MotionGroupModel = "FANUC_CRX5iA"
	MotionGroupModelFANUCLRMate200iD     MotionGroupModel = "FANUC_LR_Mate_200iD"
	MotionGroupModelFANUCLRMate200iD4S   MotionGroupModel = "FANUC_LR_Mate_200iD4S"
	MotionGroupModelFANUCLRMate200iD7L   MotionGroupModel = "FANUC_LR_Mate_200iD7L"
	MotionGroupModelFANUCM10iD10L        MotionGroupModel = "FANUC_M10iD10L"
	MotionGroupModelFANUCM10iD12         MotionGroupModel = "FANUC_M10iD12"
	MotionGroupModelFANUCM10iD16S        MotionGroupModel = "FANUC_M10iD16S"
	MotionGroupModelFANUCM10iD8L         MotionGroupModel = "FANUC_M10iD8L"
	MotionGroupModelFANUCM20iB25         MotionGroupModel = "FANUC_M20iB25"
	MotionGroupModelFANUCM20iB25C        MotionGroupModel = "FANUC_M20iB25C"
	MotionGroupModelFANUCM20iB35S        MotionGroupModel = "FANUC_M20iB35S"
	MotionGroupModelFANUCM20iD12L        MotionGroupModel = "FANUC_M20iD12L"
	MotionGroupModelFANUCM20iD25         MotionGroupModel = "FANUC_M20iD25"
	MotionGroupModelFANUCM20iD35         MotionGroupModel = "FANUC_M20iD35"
	MotionGroupModelKUKAKR10R1100        MotionGroupModel = "KUKA_KR10_R1100"
	MotionGroupModelKUKAKR10R11002       MotionGroupModel = "KUKA_KR10_R1100_2"
	MotionGroupModelKUKAKR10R900         MotionGroupModel = "KUKA_KR10_R900"
	MotionGroupModelKUKAKR10R9002        MotionGroupModel = "KUKA_KR10_R900_2"
	MotionGroupModelKUKAKR120R2700       MotionGroupModel = "KUKA_KR120_R2700"
	MotionGroupModelKUKAKR120R27002      MotionGroupModel = "KUKA_KR120_R2700_2"
	MotionGroupModelKUKAKR120R31002      MotionGroupModel = "KUKA_KR120_R3100_2"
	MotionGroupModelKUKAKR16R1610        MotionGroupModel = "KUKA_KR16_R1610"
	MotionGroupModelKUKAKR16R16102       MotionGroupModel = "KUKA_KR16_R1610_2"
	MotionGroupModelKUKAKR16R2010        MotionGroupModel = "KUKA_KR16_R2010"
	MotionGroupModelKUKAKR16R20102       MotionGroupModel = "KUKA_KR16_R2010_2"
	MotionGroupModelKUKAKR20R1810        MotionGroupModel = "KUKA_KR20_R1810"
	MotionGroupModelKUKAKR20R18102       MotionGroupModel = "KUKA_KR20_R1810_2"
	MotionGroupModelKUKAKR210R2700       MotionGroupModel = "KUKA_KR210_R2700"
	MotionGroupModelKUKAKR210R27002      MotionGroupModel = "KUKA_KR210_R2700_2"
	MotionGroupModelKUKAKR210R3100       MotionGroupModel = "KUKA_KR210_R3100"
	MotionGroupModelKUKAKR210R31002      MotionGroupModel = "KUKA_KR210_R3100_2"
	MotionGroupModelKUKAKR210R3300       MotionGroupModel = "KUKA_KR210_R3300"
	MotionGroupModelKUKAKR210R33002      MotionGroupModel = "KUKA_KR210_R3300_2"
	MotionGroupModelKUKAKR250R27002      MotionGroupModel = "KUKA_KR250_R2700_2"
	MotionGroupModelKUKAKR270R2700       MotionGroupModel = "KUKA_KR270_R2700"
	MotionGroupModelKUKAKR270R3100       MotionGroupModel = "KUKA_KR270_R3100"
	MotionGroupModelKUKAKR270R31002      MotionGroupModel = "KUKA_KR270_R3100_2"
	MotionGroupModelKUKAKR360R2830       MotionGroupModel = "KUKA_KR360_R2830"
	MotionGroupModelKUKAKR4R600          MotionGroupModel = "KUKA_KR4_R600"
	MotionGroupModelKUKAKR50R2500        MotionGroupModel = "KUKA_KR50_R2500"
	MotionGroupModelKUKAKR6R700          MotionGroupModel = "KUKA_KR6_R700"
	MotionGroupModelKUKAKR6R7002         MotionGroupModel = "KUKA_KR6_R700_2"
	MotionGroupModelKUKAKR6R900          MotionGroupModel = "KUKA_KR6_R900"
	MotionGroupModelKUKAKR6R9002         MotionGroupModel = "KUKA_KR6_R900_2"
	MotionGroupModelUniversalRobotsUR10  MotionGroupModel = "UniversalRobots_UR10"
	MotionGroupModelUniversalRobotsUR10e MotionGroupModel = "UniversalRobots_UR10e"
	MotionGroupModelUniversalRobotsUR16e MotionGroupModel = "UniversalRobots_UR16e"
	MotionGroupModelUniversalRobotsUR20e MotionGroupModel = "UniversalRobots_UR20e"
	MotionGroupModelUniversalRobotsUR3   MotionGroupModel = "UniversalRobots_UR3"
	MotionGroupModelUniversalRobotsUR3e  MotionGroupModel = "UniversalRobots_UR3e"
	MotionGroupModelUniversalRobotsUR5   MotionGroupModel = "UniversalRobots_UR5"
	MotionGroupModelUniversalRobotsUR5e  MotionGroupModel = "UniversalRobots_UR5e"
	MotionGroupModelYaskawaAR1440        MotionGroupModel = "Yaskawa_AR1440"
	MotionGroupModelYaskawaAR1440E       MotionGroupModel = "Yaskawa_AR1440E"
	MotionGroupModelYaskawaAR1730        MotionGroupModel = "Yaskawa_AR1730"
	MotionGroupModelYaskawaAR2010        MotionGroupModel = "Yaskawa_AR2010"
	MotionGroupModelYaskawaAR3120        MotionGroupModel = "Yaskawa_AR3120"
	MotionGroupModelYaskawaAR700         MotionGroupModel = "Yaskawa_AR700"
	MotionGroupModelYaskawaAR900         MotionGroupModel = "Yaskawa_AR900"
	MotionGroupModelYaskawaGP110         MotionGroupModel = "Yaskawa_GP110"
	MotionGroupModelYaskawaGP110B        MotionGroupModel = "Yaskawa_GP110B"
	MotionGroupModelYaskawaGP110H        MotionGroupModel = "Yaskawa_GP110H"
	MotionGroupModelYaskawaGP12          MotionGroupModel = "Yaskawa_GP12"
	MotionGroupModelYaskawaGP165R        MotionGroupModel = "Yaskawa_GP165R"
	MotionGroupModelYaskawaGP180         MotionGroupModel = "Yaskawa_GP180"
	MotionGroupModelYaskawaGP180120      MotionGroupModel = "Yaskawa_GP180_120"
	MotionGroupModelYaskawaGP180H        MotionGroupModel = "Yaskawa_GP180H"
	MotionGroupModelYaskawaGP200R        MotionGroupModel = "Yaskawa_GP200R"
	MotionGroupModelYaskawaGP200S        MotionGroupModel = "Yaskawa_GP200S"
	MotionGroupModelYaskawaGP20HL        MotionGroupModel = "Yaskawa_GP20HL"
	MotionGroupModelYaskawaGP215         MotionGroupModel = "Yaskawa_GP215"
	MotionGroupModelYaskawaGP225         MotionGroupModel = "Yaskawa_GP225"
	MotionGroupModelYaskawaGP225H        MotionGroupModel = "Yaskawa_GP225H"
	MotionGroupModelYaskawaGP25          MotionGroupModel = "Yaskawa_GP25"
	MotionGroupModelYaskawaGP250         MotionGroupModel = "Yaskawa_GP250"
	MotionGroupModelYaskawaGP2512        MotionGroupModel = "Yaskawa_GP25_12"
	MotionGroupModelYaskawaGP25SV        MotionGroupModel = "Yaskawa_GP25SV"
	MotionGroupModelYaskawaGP280         MotionGroupModel = "Yaskawa_GP280"
	MotionGroupModelYaskawaGP280L        MotionGroupModel = "Yaskawa_GP280L"
	MotionGroupModelYaskawaGP300R        MotionGroupModel = "Yaskawa_GP300R"
	MotionGroupModelYaskawaGP35L         MotionGroupModel = "Yaskawa_GP35L"
	MotionGroupModelYaskawaGP4           MotionGroupModel = "Yaskawa_GP4"
	MotionGroupModelYaskawaGP400         MotionGroupModel = "Yaskawa_GP400"
	MotionGroupModelYaskawaGP400R        MotionGroupModel = "Yaskawa_GP400R"
	MotionGroupModelYaskawaGP50          MotionGroupModel = "Yaskawa_GP50"
	MotionGroupModelYaskawaGP600         MotionGroupModel = "Yaskawa_GP600"
	MotionGroupModelYaskawaGP7           MotionGroupModel = "Yaskawa_GP7"
	MotionGroupModelYaskawaGP70L         MotionGroupModel = "Yaskawa_GP70L"
	MotionGroupModelYaskawaGP8           MotionGroupModel = "Yaskawa_GP8"
	MotionGroupModelYaskawaGP88          MotionGroupModel = "Yaskawa_GP88"
	MotionGroupModelYaskawaGP8L          MotionGroupModel = "Yaskawa_GP8L"
	MotionGroupModelYaskawaHC10          MotionGroupModel = "Yaskawa_HC10"
	MotionGroupModelYaskawaHC10DTP       MotionGroupModel = "Yaskawa_HC10DTP"
	MotionGroupModelYaskawaHC20DTP       MotionGroupModel = "Yaskawa_HC20DTP"
	MotionGroupModelYaskawaHC30PL        MotionGroupModel = "Yaskawa_HC30PL"
	MotionGroupModelYaskawaTURN1         MotionGroupModel = "Yaskawa_TURN1"
	MotionGroupModelYaskawaTURN2         MotionGroupModel = "Yaskawa_TURN2"
	MotionGroupModelYaskawaTURN3         MotionGroupModel = "Yaskawa_TURN3"
)

// Defines values for WaitForIOEventParamsComparisonType.
const (
	COMPARISONTYPEEQUAL   WaitForIOEventParamsComparisonType = "COMPARISON_TYPE_EQUAL"
	COMPARISONTYPEGREATER WaitForIOEventParamsComparisonType = "COMPARISON_TYPE_GREATER"
	COMPARISONTYPELESS    WaitForIOEventParamsComparisonType = "COMPARISON_TYPE_LESS"
)

// Defines values for SetDefaultModeParamsMode.
const (
	MODECONTROL SetDefaultModeParamsMode = "MODE_CONTROL"
	MODEMONITOR SetDefaultModeParamsMode = "MODE_MONITOR"
)

// Defines values for SetOperationModeParamsMode.
const (
	OPERATIONMODEAUTO   SetOperationModeParamsMode = "OPERATION_MODE_AUTO"
	OPERATIONMODEMANUAL SetOperationModeParamsMode = "OPERATION_MODE_MANUAL"
)

// Defines values for GetDefaultLinkChainParamsMotionGroupModel.
const (
	GetDefaultLinkChainParamsMotionGroupModelABB1200077           GetDefaultLinkChainParamsMotionGroupModel = "ABB_1200_07_7"
	GetDefaultLinkChainParamsMotionGroupModelABB1200583           GetDefaultLinkChainParamsMotionGroupModel = "ABB_120_058_3"
	GetDefaultLinkChainParamsMotionGroupModelABB130011510         GetDefaultLinkChainParamsMotionGroupModel = "ABB_1300_115_10"
	GetDefaultLinkChainParamsMotionGroupModelABB14001445          GetDefaultLinkChainParamsMotionGroupModel = "ABB_1400_144_5"
	GetDefaultLinkChainParamsMotionGroupModelABB1400816           GetDefaultLinkChainParamsMotionGroupModel = "ABB_140_081_6"
	GetDefaultLinkChainParamsMotionGroupModelABB1520ID154         GetDefaultLinkChainParamsMotionGroupModel = "ABB_1520ID_15_4"
	GetDefaultLinkChainParamsMotionGroupModelABB1600126           GetDefaultLinkChainParamsMotionGroupModel = "ABB_1600_12_6"
	GetDefaultLinkChainParamsMotionGroupModelABB1660ID1554        GetDefaultLinkChainParamsMotionGroupModel = "ABB_1660ID_155_4"
	GetDefaultLinkChainParamsMotionGroupModelFANUCARCMate100iD    GetDefaultLinkChainParamsMotionGroupModel = "FANUC_ARC_Mate_100iD"
	GetDefaultLinkChainParamsMotionGroupModelFANUCARCMate100iD10L GetDefaultLinkChainParamsMotionGroupModel = "FANUC_ARC_Mate_100iD10L"
	GetDefaultLinkChainParamsMotionGroupModelFANUCARCMate100iD8L  GetDefaultLinkChainParamsMotionGroupModel = "FANUC_ARC_Mate_100iD8L"
	GetDefaultLinkChainParamsMotionGroupModelFANUCARCMate120iD    GetDefaultLinkChainParamsMotionGroupModel = "FANUC_ARC_Mate_120iD"
	GetDefaultLinkChainParamsMotionGroupModelFANUCARCMate120iD12L GetDefaultLinkChainParamsMotionGroupModel = "FANUC_ARC_Mate_120iD12L"
	GetDefaultLinkChainParamsMotionGroupModelFANUCARCMate50iD     GetDefaultLinkChainParamsMotionGroupModel = "FANUC_ARC_Mate_50iD"
	GetDefaultLinkChainParamsMotionGroupModelFANUCARCMate50iD7L   GetDefaultLinkChainParamsMotionGroupModel = "FANUC_ARC_Mate_50iD7L"
	GetDefaultLinkChainParamsMotionGroupModelFANUCCR14iAL         GetDefaultLinkChainParamsMotionGroupModel = "FANUC_CR14iAL"
	GetDefaultLinkChainParamsMotionGroupModelFANUCCR15iA          GetDefaultLinkChainParamsMotionGroupModel = "FANUC_CR15iA"
	GetDefaultLinkChainParamsMotionGroupModelFANUCCR35iA          GetDefaultLinkChainParamsMotionGroupModel = "FANUC_CR35iA"
	GetDefaultLinkChainParamsMotionGroupModelFANUCCR35iB          GetDefaultLinkChainParamsMotionGroupModel = "FANUC_CR35iB"
	GetDefaultLinkChainParamsMotionGroupModelFANUCCR4iA           GetDefaultLinkChainParamsMotionGroupModel = "FANUC_CR4iA"
	GetDefaultLinkChainParamsMotionGroupModelFANUCCR7iA           GetDefaultLinkChainParamsMotionGroupModel = "FANUC_CR7iA"
	GetDefaultLinkChainParamsMotionGroupModelFANUCCR7iAL          GetDefaultLinkChainParamsMotionGroupModel = "FANUC_CR7iAL"
	GetDefaultLinkChainParamsMotionGroupModelFANUCCRX10iA         GetDefaultLinkChainParamsMotionGroupModel = "FANUC_CRX10iA"
	GetDefaultLinkChainParamsMotionGroupModelFANUCCRX10iAL        GetDefaultLinkChainParamsMotionGroupModel = "FANUC_CRX10iAL"
	GetDefaultLinkChainParamsMotionGroupModelFANUCCRX20iAL        GetDefaultLinkChainParamsMotionGroupModel = "FANUC_CRX20iAL"
	GetDefaultLinkChainParamsMotionGroupModelFANUCCRX25iA         GetDefaultLinkChainParamsMotionGroupModel = "FANUC_CRX25iA"
	GetDefaultLinkChainParamsMotionGroupModelFANUCCRX5iA          GetDefaultLinkChainParamsMotionGroupModel = "FANUC_CRX5iA"
	GetDefaultLinkChainParamsMotionGroupModelFANUCLRMate200iD     GetDefaultLinkChainParamsMotionGroupModel = "FANUC_LR_Mate_200iD"
	GetDefaultLinkChainParamsMotionGroupModelFANUCLRMate200iD4S   GetDefaultLinkChainParamsMotionGroupModel = "FANUC_LR_Mate_200iD4S"
	GetDefaultLinkChainParamsMotionGroupModelFANUCLRMate200iD7L   GetDefaultLinkChainParamsMotionGroupModel = "FANUC_LR_Mate_200iD7L"
	GetDefaultLinkChainParamsMotionGroupModelFANUCM10iD10L        GetDefaultLinkChainParamsMotionGroupModel = "FANUC_M10iD10L"
	GetDefaultLinkChainParamsMotionGroupModelFANUCM10iD12         GetDefaultLinkChainParamsMotionGroupModel = "FANUC_M10iD12"
	GetDefaultLinkChainParamsMotionGroupModelFANUCM10iD16S        GetDefaultLinkChainParamsMotionGroupModel = "FANUC_M10iD16S"
	GetDefaultLinkChainParamsMotionGroupModelFANUCM10iD8L         GetDefaultLinkChainParamsMotionGroupModel = "FANUC_M10iD8L"
	GetDefaultLinkChainParamsMotionGroupModelFANUCM20iB25         GetDefaultLinkChainParamsMotionGroupModel = "FANUC_M20iB25"
	GetDefaultLinkChainParamsMotionGroupModelFANUCM20iB25C        GetDefaultLinkChainParamsMotionGroupModel = "FANUC_M20iB25C"
	GetDefaultLinkChainParamsMotionGroupModelFANUCM20iB35S        GetDefaultLinkChainParamsMotionGroupModel = "FANUC_M20iB35S"
	GetDefaultLinkChainParamsMotionGroupModelFANUCM20iD12L        GetDefaultLinkChainParamsMotionGroupModel = "FANUC_M20iD12L"
	GetDefaultLinkChainParamsMotionGroupModelFANUCM20iD25         GetDefaultLinkChainParamsMotionGroupModel = "FANUC_M20iD25"
	GetDefaultLinkChainParamsMotionGroupModelFANUCM20iD35         GetDefaultLinkChainParamsMotionGroupModel = "FANUC_M20iD35"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR10R1100        GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR10_R1100"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR10R11002       GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR10_R1100_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR10R900         GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR10_R900"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR10R9002        GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR10_R900_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR120R2700       GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR120_R2700"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR120R27002      GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR120_R2700_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR120R31002      GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR120_R3100_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR16R1610        GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR16_R1610"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR16R16102       GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR16_R1610_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR16R2010        GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR16_R2010"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR16R20102       GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR16_R2010_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR20R1810        GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR20_R1810"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR20R18102       GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR20_R1810_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR210R2700       GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR210_R2700"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR210R27002      GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR210_R2700_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR210R3100       GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR210_R3100"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR210R31002      GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR210_R3100_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR210R3300       GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR210_R3300"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR210R33002      GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR210_R3300_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR250R27002      GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR250_R2700_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR270R2700       GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR270_R2700"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR270R3100       GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR270_R3100"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR270R31002      GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR270_R3100_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR360R2830       GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR360_R2830"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR4R600          GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR4_R600"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR50R2500        GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR50_R2500"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR6R700          GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR6_R700"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR6R7002         GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR6_R700_2"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR6R900          GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR6_R900"
	GetDefaultLinkChainParamsMotionGroupModelKUKAKR6R9002         GetDefaultLinkChainParamsMotionGroupModel = "KUKA_KR6_R900_2"
	GetDefaultLinkChainParamsMotionGroupModelUniversalRobotsUR10  GetDefaultLinkChainParamsMotionGroupModel = "UniversalRobots_UR10"
	GetDefaultLinkChainParamsMotionGroupModelUniversalRobotsUR10e GetDefaultLinkChainParamsMotionGroupModel = "UniversalRobots_UR10e"
	GetDefaultLinkChainParamsMotionGroupModelUniversalRobotsUR16e GetDefaultLinkChainParamsMotionGroupModel = "UniversalRobots_UR16e"
	GetDefaultLinkChainParamsMotionGroupModelUniversalRobotsUR20e GetDefaultLinkChainParamsMotionGroupModel = "UniversalRobots_UR20e"
	GetDefaultLinkChainParamsMotionGroupModelUniversalRobotsUR3   GetDefaultLinkChainParamsMotionGroupModel = "UniversalRobots_UR3"
	GetDefaultLinkChainParamsMotionGroupModelUniversalRobotsUR3e  GetDefaultLinkChainParamsMotionGroupModel = "UniversalRobots_UR3e"
	GetDefaultLinkChainParamsMotionGroupModelUniversalRobotsUR5   GetDefaultLinkChainParamsMotionGroupModel = "UniversalRobots_UR5"
	GetDefaultLinkChainParamsMotionGroupModelUniversalRobotsUR5e  GetDefaultLinkChainParamsMotionGroupModel = "UniversalRobots_UR5e"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaAR1440        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_AR1440"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaAR1440E       GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_AR1440E"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaAR1730        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_AR1730"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaAR2010        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_AR2010"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaAR3120        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_AR3120"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaAR700         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_AR700"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaAR900         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_AR900"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP110         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP110"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP110B        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP110B"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP110H        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP110H"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP12          GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP12"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP165R        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP165R"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP180         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP180"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP180120      GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP180_120"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP180H        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP180H"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP200R        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP200R"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP200S        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP200S"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP20HL        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP20HL"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP215         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP215"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP225         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP225"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP225H        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP225H"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP25          GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP25"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP250         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP250"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP2512        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP25_12"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP25SV        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP25SV"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP280         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP280"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP280L        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP280L"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP300R        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP300R"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP35L         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP35L"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP4           GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP4"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP400         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP400"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP400R        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP400R"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP50          GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP50"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP600         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP600"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP7           GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP7"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP70L         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP70L"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP8           GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP8"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP88          GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP88"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaGP8L          GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_GP8L"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaHC10          GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_HC10"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaHC10DTP       GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_HC10DTP"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaHC20DTP       GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_HC20DTP"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaHC30PL        GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_HC30PL"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaTURN1         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_TURN1"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaTURN2         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_TURN2"
	GetDefaultLinkChainParamsMotionGroupModelYaskawaTURN3         GetDefaultLinkChainParamsMotionGroupModel = "Yaskawa_TURN3"
)

// AbbController The configuration of a physical ABB robot controller has to contain IP address.
// Additionally an EGM server configuration has to be specified in order to control the robot.
// Deploying the server is a functionality of this API.
type AbbController struct {
	ControllerIp string `json:"controllerIp"`

	// ControllerPort Default values: 80, 443. If custom value is set, field is required.
	ControllerPort int `json:"controllerPort"`

	// EgmServer The EGM server runs inside of the cell, thus its IP must be in the same network as the 'controllerIp'
	EgmServer struct {
		Ip   string `json:"ip"`
		Port int    `json:"port"`
	} `json:"egmServer"`
	Kind AbbControllerKind `json:"kind,omitempty"`
}

// AbbControllerKind defines model for AbbController.Kind.
type AbbControllerKind string

// AddRequest This message is used to add a coordinate system with a pose including a position offset in [mm] and a rotational offset in rotation vector notation.
type AddRequest struct {
	// Name Human readable name of this coordinate system, e.g. to simplify recognition.
	Name *string `json:"name,omitempty"`

	// Offset Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	Offset Pose `json:"offset"`
}

// AllJointPositionsRequest Request to calculate the joint positions of a motion group in order to move its TCP to a specific pose (Inverse Kinematic Solutions).
type AllJointPositionsRequest struct {
	// MotionGroup Identifier of the motion-group.
	MotionGroup string `json:"motion_group"`

	// TcpPose Representing a robot pose in operational space aware of a configured TCP.
	TcpPose TcpPose `json:"tcp_pose"`
}

// AllJointPositionsResponse A list of Joint Positions. If any of them is applied to the motion-group, its TCP will be at the specified pose.
type AllJointPositionsResponse struct {
	// JointPositions Joint position in [rad].
	JointPositions *[]Joints `json:"joint_positions,omitempty"`
}

// App An App is defined by a webserver, packed inside a container, serving a web-application.
type App struct {
	// AppIcon The path of the icon for the App (/$cell/$name/$appIcon).
	AppIcon string `json:"appIcon"`

	// ContainerImage A user provided, custom container image and the required credentials to pull it from a registry.
	ContainerImage ContainerImage `json:"containerImage"`

	// Environment A list of environment variables with name and their value.
	// These can be used to configure the containerized application, and turn features on or off.
	Environment *ContainerEnvironment `json:"environment,omitempty"`

	// Name The name of the provided application.
	// The name must be unique within the cell and is used as a identifier for addressing the application in all API calls
	// , e.g. when updating the application.
	//
	// It also defines where the application is reachable (/$cell/$name).
	Name string `json:"name"`

	// Port The port the containerized webserver is listening on.
	Port *int `json:"port,omitempty"`

	// Resources Additional resources that the application requires.
	Resources *ContainerResources `json:"resources,omitempty"`

	// Storage The path and capacity of a volume that retains data across application restarts.
	// The maximal requestable capacity is 300Mi.
	// If you need more capacity consider using [storeObject](storeObject).
	Storage *ContainerStorage `json:"storage,omitempty"`
}

// ArrayInput defines model for Array-Input.
type ArrayInput struct {
	Array []ArrayInput_Array_Item `json:"array"`
}

// ArrayInputArray0 defines model for .
type ArrayInputArray0 = float32

// ArrayInputArray1 defines model for .
type ArrayInputArray1 = int

// ArrayInputArray2 defines model for .
type ArrayInputArray2 = string

// ArrayInputArray3 defines model for .
type ArrayInputArray3 = openapi_types.File

// ArrayInput_Array_Item defines model for Array-Input.array.Item.
type ArrayInput_Array_Item struct {
	union json.RawMessage
}

// ArrayOutput defines model for Array-Output.
type ArrayOutput struct {
	Array []ArrayOutput_Array_Item `json:"array"`
}

// ArrayOutputArray0 defines model for .
type ArrayOutputArray0 = float32

// ArrayOutputArray1 defines model for .
type ArrayOutputArray1 = int

// ArrayOutputArray2 defines model for .
type ArrayOutputArray2 = string

// ArrayOutputArray3 defines model for .
type ArrayOutputArray3 = openapi_types.File

// ArrayOutput_Array_Item defines model for Array-Output.array.Item.
type ArrayOutput_Array_Item struct {
	union json.RawMessage
}

// Behavior ## BEHAVIOR_AUTOMATIC
// This is the default behavior.
// The motion group instantly takes any commanded joint configuration as actual joint state.
// Configures the compliance of the virtual robot with the normal ControllerState cycle time. If set, the virtual robot will act like a physical one, e.g. with a cycle time of 8ms to respond to a new joint state command.
// ## BEHAVIOR_AUTOMATIC_NOT_COMPLY_WITH_CYCLETIME
// Configures the compliance of the virtual robot with the normal ControllerState cycle time. If set, the robot will respond as fast as possible, limited only by software execution speed. Because of that the execution of a movement requires less time than with BEHAVIOR_AUTOMATIC.
// ## BEHAVIOR_EXTERNAL_SOURCE
// The external client is the only source of actual joint state changes.
// This mode is used to enable third party software indicating the current joint state via [externalJointsStream](externalJointsStream).
type Behavior string

// BinaryObject Any value encoded as a binary string.
type BinaryObject = openapi_types.File

// BlendingAuto defines model for BlendingAuto.
type BlendingAuto struct {
	BlendingName string `json:"blending_name"`

	// MinVelocityInPercent Auto-blending is used to keep a constant velocity when blending between two motion commands.
	// It changes the TCP path around the target point of the motion command.
	// The value represents the percentage of the original velocity.
	MinVelocityInPercent *uint32 `json:"min_velocity_in_percent,omitempty"`
}

// BlendingPosition defines model for BlendingPosition.
type BlendingPosition struct {
	BlendingName string `json:"blending_name"`

	// PositionZoneRadius Specifies the maximum radius in [mm] around the motion command's target point
	// where the TCP path can be altered to blend the motion command into the following one.
	// If auto-blending blends too much of the resulting trajectory, use position-blending to restrict the blending zone radius.
	PositionZoneRadius *float64 `json:"position_zone_radius,omitempty"`
}

// BodyUploadProgramMetadataImage defines model for Body_uploadProgramMetadataImage.
type BodyUploadProgramMetadataImage struct {
	File openapi_types.File `json:"file"`
}

// BodyUploadRecipeMetadataImage defines model for Body_uploadRecipeMetadataImage.
type BodyUploadRecipeMetadataImage struct {
	File openapi_types.File `json:"file"`
}

// Box Defines a cuboid shape centered around an origin.
type Box struct {
	// SizeX The dimension in x direction in [mm].
	SizeX float64 `json:"size_x"`

	// SizeY The dimension in y direction in [mm].
	SizeY float64 `json:"size_y"`

	// SizeZ The dimension in z direction in [mm].
	SizeZ float64 `json:"size_z"`

	// Type The type defines if the box is hollow or not.
	Type BoxType `json:"type"`
}

// BoxType The type defines if the box is hollow or not.
type BoxType string

// Box2 Defines a cuboid shape centred around an origin.
//
// If a margin is applied to the box type full, it is added to all size values. The shape will keep its edges.
// The hollow box type consists of thin boxes that make up its walls.
// If a margin is applied to the box type hollow, its size values are reduced by the margin.
type Box2 struct {
	// BoxType The box type defines if the box is hollow or full.
	BoxType   Box2BoxType `json:"box_type"`
	ShapeType string      `json:"shape_type"`

	// SizeX The dimension in x-direction in [mm].
	SizeX float64 `json:"size_x"`

	// SizeY The dimension in y-direction in [mm].
	SizeY float64 `json:"size_y"`

	// SizeZ The dimension in z-direction in [mm].
	SizeZ float64 `json:"size_z"`
}

// Box2BoxType The box type defines if the box is hollow or full.
type Box2BoxType string

// Box3 Centered around origin.
//
// If margin is applied to full box, it is added to all sizes (shape still has edges).
// Hollow box is represented by thin boxes that make up its walls.
// If margin is applied to hollow box, its sizes are reduced by the margin.
type Box3 struct {
	ShapeType Box3ShapeType `json:"shape_type"`
	SizeX     float32       `json:"size_x"`
	SizeY     float32       `json:"size_y"`
	SizeZ     float32       `json:"size_z"`
	Type      Box3Type      `json:"type"`
}

// Box3ShapeType defines model for Box3.ShapeType.
type Box3ShapeType string

// Box3Type defines model for Box3.Type.
type Box3Type string

// Capacity The amount of requested storage capacity.
type Capacity = string

// Capsule Defines a cylinder like shape with 2 semi-spheres on top and bottom.
type Capsule struct {
	// CylinderHeight The height of the inner cylinder in [mm].
	CylinderHeight float64 `json:"cylinder_height"`

	// Radius The radius of the cylinder and semi-spheres in [mm].
	Radius float64 `json:"radius"`
}

// Capsule2 Defines a cylindrical shape with 2 semi-spheres on the top and bottom.
// Centred around origin, symmetric around z-axis.
type Capsule2 struct {
	// CylinderHeight The height of the inner cylinder in [mm].
	CylinderHeight float64 `json:"cylinder_height"`

	// Radius The radius of the cylinder and semi-spheres in [mm].
	Radius    float64 `json:"radius"`
	ShapeType string  `json:"shape_type"`
}

// Capsule3 Centered around origin, symmetric around z-axis.
type Capsule3 struct {
	CylinderHeight float32           `json:"cylinder_height"`
	Radius         float32           `json:"radius"`
	ShapeType      Capsule3ShapeType `json:"shape_type"`
}

// Capsule3ShapeType defines model for Capsule3.ShapeType.
type Capsule3ShapeType string

// Capture defines model for Capture.
type Capture struct {
	Image string `json:"image"`
}

// Cell To create a robot cell, only a valid name is required.
// Once created, a robot cell provides access to the Wandelbots NOVA foundation services.
// The configuration can be customized, e.g. robot controllers, also within apps.
type Cell struct {
	Apps        *[]App             `json:"apps,omitempty"`
	Controllers *[]RobotController `json:"controllers,omitempty"`

	// Name A unique name for the cell used as an identifier for addressing the cell in all API calls.
	// It must be a valid k8s label name as defined by [RFC 1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-label-names).
	Name CellName `json:"name"`
}

// CellName A unique name for the cell used as an identifier for addressing the cell in all API calls.
// It must be a valid k8s label name as defined by [RFC 1123](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-label-names).
type CellName = string

// Circle defines model for Circle.
type Circle struct {
	// TargetPose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	TargetPose Pose `json:"target_pose"`

	// ViaPose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	ViaPose Pose `json:"via_pose"`
}

// Collider Defines a collider with a single shape.
//
// A collider is an object that is used for collision detection.
// It defines the `shape` that is attached with the offset of `pose` to a reference frame.
//
// Use colliders to:
// - Define the shape of a workpiece. The reference frame is the scene origin.
// - Define the shape of a link in a motion group. The reference frame is the link coordinate system.
// - Define the shape of a tool. The reference frame is the flange coordinate system.
type Collider struct {
	// Margin Increases the shape's size in all dimensions. Applied in [mm]. Can be used to keep a safe distance to the shape.
	Margin *float32 `json:"margin,omitempty"`

	// Pose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	Pose  *Pose2         `json:"pose,omitempty"`
	Shape Collider_Shape `json:"shape"`
}

// Collider_Shape defines model for Collider.Shape.
type Collider_Shape struct {
	union json.RawMessage
}

// ColliderInput Defines a collider with a single shape.
//
// Pose describes where the shape of the collider is positioned.
type ColliderInput struct {
	// Margin Increases the shape's size in all dimensions. Applied in [mm]. Can be used to keep a safe distance to the shape.
	Margin *float32 `json:"margin,omitempty"`

	// Pose A pose (position and orientation)
	Pose  PyjectoryDatatypesCorePose `json:"pose"`
	Shape ColliderInput_Shape        `json:"shape"`
}

// ColliderInput_Shape defines model for ColliderInput.Shape.
type ColliderInput_Shape struct {
	union json.RawMessage
}

// ColliderDictionary A collection of identifiable colliders.
type ColliderDictionary map[string]Collider

// Collision defines model for Collision.
type Collision struct {
	IdOfA     *string `json:"id_of_a,omitempty"`
	IdOfB     *string `json:"id_of_b,omitempty"`
	IdOfWorld *string `json:"id_of_world,omitempty"`

	// NormalWorldOnB Describes a position in 3D space.
	// A three-dimensional vector [x, y, z] with double precision.
	NormalWorldOnB *Vector3d2        `json:"normal_world_on_b,omitempty"`
	PositionOnA    *CollisionContact `json:"position_on_a,omitempty"`
	PositionOnB    *CollisionContact `json:"position_on_b,omitempty"`
}

// CollisionContact defines model for CollisionContact.
type CollisionContact struct {
	// Local Describes a position in 3D space.
	// A three-dimensional vector [x, y, z] with double precision.
	Local *Vector3d2 `json:"local,omitempty"`

	// World Describes a position in 3D space.
	// A three-dimensional vector [x, y, z] with double precision.
	World *Vector3d2 `json:"world,omitempty"`
}

// CollisionMotionGroup defines model for CollisionMotionGroup.
type CollisionMotionGroup struct {
	// LinkChain A link chain is a kinematic chain of links that is connected via joints.
	// A motion group can be used to control the motion of the joints in a link chain.
	//
	// A link is a group of colliders that is attached to the link reference frame.
	//
	// The reference frame of a link is obtained after applying all sets of Denavit-Hartenberg-parameters from base to (including) the link index.
	//
	// This means that the reference frame of the link is on the rotation axis of the next joint in the kinematic chain.
	// Example: For a motion group with 2 joints, the collider reference frame (CRF) for link 1 is on the rotation axis of joint 2. The chain looks like:
	// - Origin >> Mounting >> Base >> (CRF Base) Joint 0 >> Link 0 >> (CRF Link 0) Joint 1 >> Link 1 >> (CRF Link 1) Flange (CRF Tool) >> TCP
	//
	// Adjacent links in the kinematic chain of the motion group are not checked for mutual collision.
	LinkChain *LinkChain `json:"link_chain,omitempty"`

	// Tool Defines the shape of a tool.
	//
	// A tool is a dictionary of colliders.
	//
	// All colliders that make up a tool are attached to the flange frame of the motion group.
	Tool *Tool `json:"tool,omitempty"`
}

// CollisionMotionGroupAssembly defines model for CollisionMotionGroupAssembly.
type CollisionMotionGroupAssembly struct {
	// LinkChain A link chain is a kinematic chain of links that is connected via joints.
	// A motion group can be used to control the motion of the joints in a link chain.
	//
	// A link is a group of colliders that is attached to the link reference frame.
	//
	// The reference frame of a link is obtained after applying all sets of Denavit-Hartenberg-parameters from base to (including) the link index.
	//
	// This means that the reference frame of the link is on the rotation axis of the next joint in the kinematic chain.
	// Example: For a motion group with 2 joints, the collider reference frame (CRF) for link 1 is on the rotation axis of joint 2. The chain looks like:
	// - Origin >> Mounting >> Base >> (CRF Base) Joint 0 >> Link 0 >> (CRF Link 0) Joint 1 >> Link 1 >> (CRF Link 1) Flange (CRF Tool) >> TCP
	//
	// Adjacent links in the kinematic chain of the motion group are not checked for mutual collision.
	LinkChain *LinkChain `json:"link_chain,omitempty"`

	// StoredLinkChain References a stored link chain.
	StoredLinkChain *string `json:"stored_link_chain,omitempty"`

	// StoredTool References a stored tool.
	StoredTool *string `json:"stored_tool,omitempty"`

	// Tool Defines the shape of a tool.
	//
	// A tool is a dictionary of colliders.
	//
	// All colliders that make up a tool are attached to the flange frame of the motion group.
	Tool *Tool `json:"tool,omitempty"`
}

// CollisionMotionGroupAssemblyDictionary Maps a Wandelbots NOVA motion group to its assembly configuration in the collision scene. Key must be a motion group identifier.
//
// A collision motion group defines a motion group in the collision scene.
//
// The motion group is attached to the origin of the scene.
// To relocate the motion group, configure its mounting offset on the physical controller.
// This ensures that the definition of motion commands and collision scenes use the same coordinate system.
// The kinematic chain looks like this:
// - Origin >> Mounting >> Base >> Joint 0 >> Link 0 >> Joint 1 >> […] >> TCP
//
// A `tool` is treated like another link attached to the end (flange) of the kinematic chain.
// All tool colliders are described in the flange frame.
type CollisionMotionGroupAssemblyDictionary map[string]CollisionMotionGroupAssembly

// CollisionMotionGroupDictionary Maps a Wandelbots NOVA motion group to its configuration in the collision scene. Key must be a motion group identifier.
//
// Values are collision motion group objects.
//
// A collision motion group defines a motion group in the collision scene.
//
// The motion group is attached to the origin of the scene.
// To relocate the motion group, configure its mounting offset on the physical controller.
// This ensures that the definition of motion commands and collision scenes use the same coordinate system.
// The kinematic chain looks like this:
// - Origin >> Mounting >> Base >> Joint 0 >> Link 0 >> Joint 1 >> […] >> TCP
//
// A `tool` is treated like another link attached to the end (flange) of the kinematic chain.
// All tool colliders are described in the flange frame.
type CollisionMotionGroupDictionary map[string]CollisionMotionGroup

// CollisionRobotConfigurationInput Configuration of a robot in the collision scene.
//
// Default link shapes are provided for all supported robots. Apply `use_default_link_shapes` with `true`.
//
// `link_attachements` are additional shapes that are attached to the link reference frames.
// The reference frame of the `link_attachements` is obtained after applying all sets of DH-parameters
// from base to (including) the specified index.
// Adjacent links in the kinematic chain of the robot are not checked for collision.
//
// The tool is treated like another link attached to the end (flange) of the chain.
// All tool shapes are described in the flange frame.
type CollisionRobotConfigurationInput struct {
	// LinkAttachements Shapes to attach to link reference frames, additionally to default shapes. The keys are integers representing
	// the link indices, and the values are objects mapping shape names to their collider definitions.
	LinkAttachements *map[string]map[string]ColliderInput `json:"link_attachements,omitempty"`

	// Tool Shapes that make up the tool, attached to the flange frame.
	Tool *map[string]ColliderInput `json:"tool,omitempty"`

	// UseDefaultLinkShapes If `true`, default shapes are used for all links.
	UseDefaultLinkShapes bool `json:"use_default_link_shapes"`
}

// CollisionScene Defines the collision scene.
//
// There are two types of objects in the scene:
//   - `colliders`: Each collider is attached directly to the origin of the scene: Origin >> Collider
//   - `motion-groups`: Each motion group is assigned a kinematic chain of links with a special collider, called tool, attached to the last element.
//     The motion group is attached to the origin of the scene via its mounting: Origin >> Mounting >> Motion Group Base >> […]
type CollisionScene struct {
	// Colliders A collection of identifiable colliders.
	Colliders *ColliderDictionary `json:"colliders,omitempty"`

	// MotionGroups Maps a Wandelbots NOVA motion group to its configuration in the collision scene. Key must be a motion group identifier.
	//
	// Values are collision motion group objects.
	//
	// A collision motion group defines a motion group in the collision scene.
	//
	// The motion group is attached to the origin of the scene.
	// To relocate the motion group, configure its mounting offset on the physical controller.
	// This ensures that the definition of motion commands and collision scenes use the same coordinate system.
	// The kinematic chain looks like this:
	// - Origin >> Mounting >> Base >> Joint 0 >> Link 0 >> Joint 1 >> […] >> TCP
	//
	// A `tool` is treated like another link attached to the end (flange) of the kinematic chain.
	// All tool colliders are described in the flange frame.
	MotionGroups *CollisionMotionGroupDictionary `json:"motion_groups,omitempty"`
}

// CollisionSceneAssembly Defines the collision scene assembly. Merges all referenced and new scene components into a single scene.
//
// Previously added components with identical identifiers are overwritten within the same group.
//
// There is one group for each of the following components:
// - Colliders attached to the origin of the scene,
// - Tool per motion group, and
// - For each link per motion group.
//
// The scene is assembled by adding components in the following order.
// 1. stored_scenes
// 2. scene
// 3. stored_colliders
// 4. colliders
// 5. stored_link_chains and stored_tools (per motion group)
// 6. link_chains and tools (per motion group)
type CollisionSceneAssembly struct {
	// Colliders A collection of identifiable colliders.
	Colliders *ColliderDictionary `json:"colliders,omitempty"`

	// MotionGroups Maps a Wandelbots NOVA motion group to its assembly configuration in the collision scene. Key must be a motion group identifier.
	//
	// A collision motion group defines a motion group in the collision scene.
	//
	// The motion group is attached to the origin of the scene.
	// To relocate the motion group, configure its mounting offset on the physical controller.
	// This ensures that the definition of motion commands and collision scenes use the same coordinate system.
	// The kinematic chain looks like this:
	// - Origin >> Mounting >> Base >> Joint 0 >> Link 0 >> Joint 1 >> […] >> TCP
	//
	// A `tool` is treated like another link attached to the end (flange) of the kinematic chain.
	// All tool colliders are described in the flange frame.
	MotionGroups *CollisionMotionGroupAssemblyDictionary `json:"motion_groups,omitempty"`

	// Scene Defines the collision scene.
	//
	// There are two types of objects in the scene:
	// - `colliders`: Each collider is attached directly to the origin of the scene: Origin >> Collider
	// - `motion-groups`: Each motion group is assigned a kinematic chain of links with a special collider, called tool, attached to the last element.
	//   The motion group is attached to the origin of the scene via its mounting: Origin >> Mounting >> Motion Group Base >> […]
	Scene *CollisionScene `json:"scene,omitempty"`

	// StoredColliders Add stored colliders to the scene via their identifiers.
	// The colliders are added to the the origin of the scene.
	StoredColliders *[]string `json:"stored_colliders,omitempty"`

	// StoredScenes Add stored scenes to the scene via their identifiers.
	// The scenes are merged based on their order in the array.
	// The scene at index zero serves as base.
	// Following scenes overwrite components with identical identifiers, see [Collision Scene Assembly](Collision Scene Assembly).
	StoredScenes *[]string `json:"stored_scenes,omitempty"`
}

// Command A command is a single motion command (line, circle, joint_ptp, cartesian_ptp, cubic_spline) with corresponding settings (limits, blending). The motion commands are a flattened union/oneof type. Only set one of the motion commands per command. A motion command always starts at the end of the previous motion command. Subsequently, a plan request must have start joint configuration to plan a well defined motion.
type Command struct {
	// CartesianPtp Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	CartesianPtp *Pose        `json:"cartesian_ptp,omitempty"`
	Circle       *Circle      `json:"circle,omitempty"`
	CubicSpline  *CubicSpline `json:"cubic_spline,omitempty"`

	// JointPtp This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointPtp *Joints `json:"joint_ptp,omitempty"`

	// Line Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	Line *Pose `json:"line,omitempty"`

	// Settings Settings which can be used to modify the behavior in a command-wise manner.
	Settings *CommandSettings `json:"settings,omitempty"`
}

// CommandSettings Settings which can be used to modify the behavior in a command-wise manner.
type CommandSettings struct {
	// AutoBlending Auto-blending is used to keep a constant velocity when blending between two motion commands.
	// It changes the TCP path around the target point of a motion command.
	// The value represents the percentage of the original velocity.
	//
	// What is blending?
	// Blending alters the geometry of the TCP path at the target point of a motion command
	// to ensure that the velocity does not drop to zero between two motion commands.
	AutoBlending *uint32 `json:"auto_blending,omitempty"`

	// LimitsOverride If a limit is not set, the default value will be used.
	LimitsOverride *LimitsOverride `json:"limits_override,omitempty"`

	// PositionBlending If auto-blending blends too much of the resulting trajectory, position-blending could be used between two motion commands.
	// Specifies the maximum radius in [mm] around the motion command's target point
	// where the geometry of the TCP path is allowed to be changed to blend the current motion command into the next one.
	PositionBlending *float64 `json:"position_blending,omitempty"`
}

// CommandsMissing Error in case no motion commands were provided. Every planning needs to have at least one motion command to describe the path to be followed.
type CommandsMissing = map[string]interface{}

// Comparator Comparator for the comparison of two values.
// The comparator is used to compare two values and return a boolean result.
// The default comparator is unknown.
type Comparator string

// Compound Describes a collision shape compounded from multiple collision objects. All objects are described in the compounds reference frame.
type Compound struct {
	// ChildGeometries A list of geometries sharing the same reference frame.
	ChildGeometries []Geometry `json:"child_geometries"`
}

// ContainerEnvironment A list of environment variables with name and their value.
// These can be used to configure the containerized application, and turn features on or off.
type ContainerEnvironment = []struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// ContainerImage A user provided, custom container image and the required credentials to pull it from a registry.
type ContainerImage struct {
	// Credentials User provided credentials for creating a secret to pull an image from a registry.
	Credentials *ImageCredentials `json:"credentials,omitempty"`

	// Image The location of a container image in the form of `<registry>/<image>:<tag>`.
	Image string `json:"image"`

	// Secrets Known secrets for authentication with the container registry.
	Secrets *[]struct {
		Name string `json:"name"`
	} `json:"secrets,omitempty"`
}

// ContainerResources Additional resources that the application requires.
type ContainerResources struct {
	// IntelGpu Number of GPUs the application requires.
	IntelGpu *int `json:"intel-gpu,omitempty"`
}

// ContainerStorage The path and capacity of a volume that retains data across application restarts.
// The maximal requestable capacity is 300Mi.
// If you need more capacity consider using [storeObject](storeObject).
type ContainerStorage struct {
	// Capacity The amount of requested storage capacity.
	Capacity  Capacity `json:"capacity"`
	MountPath string   `json:"mountPath"`
}

// ControllerCapabilities defines model for ControllerCapabilities.
type ControllerCapabilities struct {
	// SupportControl Can this controller be controlled with NOVA (true) or is it only possible to read data (false).
	SupportControl bool `json:"support_control"`

	// SupportFreedrive Can this controller be moved through freedrive (true), or not (false).
	SupportFreedrive bool `json:"support_freedrive"`
}

// ControllerInstance The data type to describe a robot controller.
type ControllerInstance struct {
	// AllowSoftwareInstallOnController True if the user has actively confirmed that it is allowed
	// to install required communication software onto the robot controller.
	//
	// NOTE: Installing third party software on a robot controller
	// can result in liability issues in regard to the actual certified
	// state of the robot system. Please contact your company's legal responsible before installing third party software.
	AllowSoftwareInstallOnController bool `json:"allow_software_install_on_controller"`

	// Controller The unique identifier to address the robot controller in the cell.
	Controller string `json:"controller"`

	// ErrorDetails If has_error is true, error_details provides detailed background information about the error.
	ErrorDetails *string `json:"error_details,omitempty"`

	// HasError Set to true if there was an error while inspecting this instance,
	// e.g. The robot controller is not reachable due to missing network connection or turned off.
	//
	// The instance remains configured but can't provide information on the robot controller.
	HasError bool `json:"has_error"`

	// Host Resolvable host name or IP address that connects to the robot controller.
	Host string `json:"host"`

	// ModelName The unique identifier to address a robot controller model when configuring the robot controller.
	// Used for evaluation of the robot controller model and to ensure communication with the expected robot controller type.
	ModelName string `json:"model_name"`

	// PhysicalMotionGroups The list of physical connected motion groups as detected by the controller.
	PhysicalMotionGroups []MotionGroupPhysical `json:"physical_motion_groups"`

	// VendorSoftwareVersion A generic representation of a version number.
	VendorSoftwareVersion *VersionNumber `json:"vendor_software_version,omitempty"`
}

// ControllerInstanceList The list of configured robot controllers.
type ControllerInstanceList struct {
	Instances []ControllerInstance `json:"instances"`
}

// ConvexHull Defines a convex hull encapsulating a set of vertices.
type ConvexHull struct {
	// Vertices The list of encapsulated points.
	Vertices []Vector3d `json:"vertices"`
}

// ConvexHull2 Defines a convex hull encapsulating a set of vertices.
type ConvexHull2 struct {
	ShapeType string `json:"shape_type"`

	// Vertices The list of encapsulated points.
	Vertices []Vector3d2 `json:"vertices"`
}

// ConvexHull3 Convex hull around all vertices.
type ConvexHull3 struct {
	ShapeType ConvexHull3ShapeType             `json:"shape_type"`
	Vertices  []PyjectoryDatatypesCorePosition `json:"vertices"`
}

// ConvexHull3ShapeType defines model for ConvexHull3.ShapeType.
type ConvexHull3ShapeType string

// CoordinateSystems defines model for CoordinateSystems.
type CoordinateSystems struct {
	CoordinateSystems []CoordinateSystem `json:"coordinate_systems"`
}

// CubicSpline defines model for CubicSpline.
type CubicSpline struct {
	Parameters []CubicSplineCubicSplineParameter `json:"parameters"`
}

// CubicSplineParameter defines model for CubicSplineParameter.
type CubicSplineParameter struct {
	PathParameter float64 `json:"path_parameter"`

	// Pose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	Pose Pose2 `json:"pose"`
}

// CubicSplineCubicSplineParameter defines model for CubicSpline_CubicSplineParameter.
type CubicSplineCubicSplineParameter struct {
	PathParameter float64 `json:"path_parameter"`

	// Pose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	Pose Pose `json:"pose"`
}

// CycleTime defines model for CycleTime.
type CycleTime struct {
	// CycleTimeMs Cycle time of controller communication in [ms].
	CycleTimeMs uint32 `json:"cycle_time_ms"`
}

// Cylinder Defines a cylindrical shape centered around the z-axis.
type Cylinder struct {
	// Height The height of the cylinder in [mm].
	Height float64 `json:"height"`

	// Radius The radius of the cylinder in [mm].
	Radius float64 `json:"radius"`
}

// Cylinder2 Defines a cylindrical shape.
// Centred around origin, symmetric around z-axis.
//
// If a margin is applied, it is added to radius and height. The shape will keep its edges.
type Cylinder2 struct {
	// Height The height of the cylinder in [mm].
	Height float64 `json:"height"`

	// Radius The radius of the cylinder in [mm].
	Radius    float64 `json:"radius"`
	ShapeType string  `json:"shape_type"`
}

// Cylinder3 Centered around origin, symmetric around z-axis.
//
// If margin is applied, it is added to radius and height (shape still has edges).
type Cylinder3 struct {
	Height    float32            `json:"height"`
	Radius    float32            `json:"radius"`
	ShapeType Cylinder3ShapeType `json:"shape_type"`
}

// Cylinder3ShapeType defines model for Cylinder3.ShapeType.
type Cylinder3ShapeType string

// DHParameter A single set of DH parameters.
type DHParameter struct {
	// A Offset along x-axis in [mm].
	A *float64 `json:"a,omitempty"`

	// Alpha Angle about x-axis in [rad].
	Alpha *float64 `json:"alpha,omitempty"`

	// D Offset along z-axis in [mm].
	D *float64 `json:"d,omitempty"`

	// ReverseRotationDirection True, if rotation direction of joint is reversed.
	ReverseRotationDirection *bool `json:"reverse_rotation_direction,omitempty"`

	// Theta Angle about z-axis in [rad].
	Theta *float64 `json:"theta,omitempty"`
}

// Direction The direction in which the trajectory is executed. Default: Forward.
type Direction string

// DirectionJoggingRequest A request to move a motion group in a cartesian direction.
type DirectionJoggingRequest struct {
	// CoordinateSystem Unique identifier addressing the base coordinate system of position_direction and rotation_direction.
	// If not set, world coordinate system is used.
	// Set coordinate_system to "tool" to select the current tool coordinate system as base.
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// PositionDirection A 3 dimensional Vector with double precision.
	PositionDirection Vector3d `json:"position_direction"`

	// PositionVelocity in (mm/s)
	PositionVelocity float64 `json:"position_velocity"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system in which the responses should be converted.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `json:"response_coordinate_system,omitempty"`

	// ResponseRate Update rate for the response message in ms. If not set 200ms are used.
	ResponseRate *uint32 `json:"response_rate,omitempty"`

	// RotationDirection A 3 dimensional Vector with double precision.
	RotationDirection Vector3d `json:"rotation_direction"`

	// RotationVelocity in (rad/s)
	RotationVelocity float64 `json:"rotation_velocity"`

	// Tcp The identifier of the tool center point (TCP) used for the jogging motion.
	// If not specified, the TCP currently active on the robot controller will be used.
	// The maximum cartesian velocity limit set at the TCP will not be exceeded during movement.
	Tcp *interface{} `json:"tcp,omitempty"`
}

// DoubleArray defines model for DoubleArray.
type DoubleArray = []float64

// Empty defines model for Empty.
type Empty = map[string]interface{}

// Error defines model for Error.
type Error struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

// ExecuteTrajectoryResponse defines model for ExecuteTrajectoryResponse.
type ExecuteTrajectoryResponse struct {
	union json.RawMessage
}

// ExternalJointStreamDatapoint A datapoint inside external joint stream.
type ExternalJointStreamDatapoint struct {
	// Id Unique identifier addressing a controller in the cell.
	Id uint32 `json:"id"`

	// Value The joint-values of the external joint stream datapoint.
	Value ExternalJointStreamDatapointValue `json:"value"`
}

// ExternalJointStreamDatapointValue The joint-values of the external joint stream datapoint.
type ExternalJointStreamDatapointValue struct {
	// Accelerations The joint accelerations of the robot.
	Accelerations []float64 `json:"accelerations"`

	// Positions The joint positions of the robot.
	Positions []float64 `json:"positions"`

	// Torques The joint torques of the robot.
	Torques []float64 `json:"torques"`

	// Velocities The joint velocities of the robot.
	Velocities []float64 `json:"velocities"`
}

// FanucController The configuration of a physical FANUC robot controller has to contain IP address of the controller.
type FanucController struct {
	ControllerIp string              `json:"controllerIp"`
	Kind         FanucControllerKind `json:"kind,omitempty"`
}

// FanucControllerKind defines model for FanucController.Kind.
type FanucControllerKind string

// FeedbackCollision defines model for FeedbackCollision.
type FeedbackCollision struct {
	Collisions        *[]Collision `json:"collisions,omitempty"`
	ErrorFeedbackName string       `json:"error_feedback_name"`
	JointPosition     *DoubleArray `json:"joint_position,omitempty"`

	// TcpPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TcpPose *Pose2 `json:"tcp_pose,omitempty"`
}

// FeedbackJointLimitExceeded This error is returned when a joint position limit is exceeded.
// The joint index denotes which joint is out of its limits, starting with 1 and followed by the full joint position.
type FeedbackJointLimitExceeded struct {
	ErrorFeedbackName string       `json:"error_feedback_name"`
	JointIndex        *uint32      `json:"joint_index,omitempty"`
	JointPosition     *DoubleArray `json:"joint_position,omitempty"`
}

// FeedbackOutOfWorkspace Requested TCP pose is outside of motion group's workspace.
type FeedbackOutOfWorkspace struct {
	ErrorFeedbackName string `json:"error_feedback_name"`

	// InvalidTcpPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	InvalidTcpPose *Pose2 `json:"invalid_tcp_pose,omitempty"`
}

// FeedbackSingularity A singularity is a point in the robot's workspace where the robot loses one or more degrees of freedom with regards to moving its TCP.
// This means the robot cannot move or rotate the TCP in a certain direction from this specific point.
//
// Use PTP motions if possible. They will almost never fail due to singularities (only if the target point is at a singularity).
//
// Alternatively change the robot TCP's path to avoid moving through this point or try to move the TCP through this point in a different direction.
type FeedbackSingularity struct {
	ErrorFeedbackName     string               `json:"error_feedback_name"`
	SingularJointPosition *DoubleArray         `json:"singular_joint_position,omitempty"`
	SingularityType       *SingularityTypeEnum `json:"singularity_type,omitempty"`
}

// Flag defines model for Flag.
type Flag struct {
	Active bool `json:"active"`
}

// ForceVector Representing a force on a specific point in operational space (e.g. on robot flange).
type ForceVector struct {
	// CoordinateSystem optional, unique name of base coordinate system, if empty world is used
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// Force A 3 dimensional Vector with double precision.
	Force *Vector3d `json:"force,omitempty"`

	// Moment A 3 dimensional Vector with double precision.
	Moment *Vector3d `json:"moment,omitempty"`
}

// Geometry A Geometry is defined by a shape and a pose.
type Geometry struct {
	// Box Defines a cuboid shape centered around an origin.
	Box *Box `json:"box,omitempty"`

	// Capsule Defines a cylinder like shape with 2 semi-spheres on top and bottom.
	Capsule *Capsule `json:"capsule,omitempty"`

	// Compound Describes a collision shape compounded from multiple collision objects. All objects are described in the compounds reference frame.
	Compound *Compound `json:"compound,omitempty"`

	// ConvexHull Defines a convex hull encapsulating a set of vertices.
	ConvexHull *ConvexHull `json:"convex_hull,omitempty"`

	// Cylinder Defines a cylindrical shape centered around the z-axis.
	Cylinder *Cylinder `json:"cylinder,omitempty"`

	// Id An identifier may be used to refer to this geometry, e.g. when giving feedback.
	Id       *string     `json:"id,omitempty"`
	InitPose PlannerPose `json:"init_pose"`

	// Plane Defines an x-y plane with infinite size.
	Plane *Plane `json:"plane,omitempty"`

	// Rectangle Defines an x-y plane with finite size.
	Rectangle *Rectangle `json:"rectangle,omitempty"`

	// RectangularCapsule A convex hull around four spheres. Sphere center points in x-y-plane, offset by either combination +-sizeX/+-sizeY. Alternative description: Rectangle in x-y-plane with a 3D padding.
	RectangularCapsule *RectangularCapsule `json:"rectangular_capsule,omitempty"`

	// Sphere Defines a spherical shape centered around an origin.
	Sphere *Sphere `json:"sphere,omitempty"`
}

// GetModeResponse defines model for GetModeResponse.
type GetModeResponse struct {
	// RobotSystemMode The system mode of the robot system.
	//
	// ### ROBOT_SYSTEM_MODE_UNDEFINED
	//
	// Indicates that the robot controller is currently performing a mode transition.
	//
	// ### ROBOT_SYSTEM_MODE_DISCONNECT
	//
	// There is no communication with the robot controller at all. All connections are closed.
	// No command is sent to the robot controller while in this mode. No IO interaction is possible in this mode!
	// All move requests will be rejected in this mode!
	//
	// ### ROBOT_SYSTEM_MODE_MONITOR
	//
	// A connection to the robot controller is established to only read the robot controller state.
	// No command is sent to the robot controller while in this mode. It is possible to receive IO information.
	// All move requests will be rejected in this mode!
	//
	// ### ROBOT_SYSTEM_MODE_CONTROL
	//
	// An active connection is established with the robot controller and the robot system is cyclic commanded
	// to stay in its actual position. The robot controller state is received in the cycle time of the robot controller.
	// Requests via the MotionService and JoggingService will be processed and executed in this mode.
	// IO interaction is possible in this mode! **In this mode the robot system can be commanded to move.**
	//
	// ### ROBOT_SYSTEM_MODE_FREE_DRIVE
	//
	// Like ROBOT_SYSTEM_MODE_MONITOR a connection to the robot controller is established to only read the robot controller state.
	// The difference is that the motion groups can be moved by the user (Free Drive). Thus, the servo motors are turned on.
	// All move requests will be rejected in this mode! **This mode is not supported by every robot!**
	// Use [getSupportedModes](getSupportedModes) to evaluate if the device support free drive.
	RobotSystemMode RobotSystemMode `json:"robot_system_mode"`
}

// GetTrajectoryResponse defines model for GetTrajectoryResponse.
type GetTrajectoryResponse struct {
	// Trajectory A list of points representing the trajectory of a planned motion with defined `sample_time` in milliseconds (ms).
	Trajectory *[]TrajectorySample `json:"trajectory,omitempty"`
}

// GetTrajectorySampleResponse defines model for GetTrajectorySampleResponse.
type GetTrajectorySampleResponse struct {
	// Sample A sample of a trajectory is a single point of the trajectory at a specific location.
	Sample *TrajectorySample `json:"sample,omitempty"`
}

// GoogleProtobufAny Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.
type GoogleProtobufAny struct {
	// Type The type of the serialized message.
	Type                 *string                `json:"@type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// HTTPExceptionResponse defines model for HTTPExceptionResponse.
type HTTPExceptionResponse struct {
	// Detail A message describing the error.
	Detail string `json:"detail"`
}

// HTTPValidationError defines model for HTTPValidationError.
type HTTPValidationError struct {
	Detail *[]ValidationError `json:"detail,omitempty"`
}

// IODescription defines model for IODescription.
type IODescription struct {
	// BitSize OBSOLETE! Replaced by min/max. Amount of bits the value is encoded in.
	BitSize uint32 `json:"bit_size"`

	// Group Name of the I/O group. Customize it on the physical controller or in the virtual robot specification.
	Group *string `json:"group,omitempty"`

	// Id Unique identifier defined by the controller. Identifiers are only defined uniquely per controller, e.g. I/Os for two different robots on the same controller can have the same identifier.
	Id string `json:"id"`

	// Max I/O value representation. Depending on the I/O type, only one of the value fields will be set.
	Max *IOValue `json:"max,omitempty"`

	// Min I/O value representation. Depending on the I/O type, only one of the value fields will be set.
	Min *IOValue `json:"min,omitempty"`

	// Name Name of the I/O. Customize it on the physical controller or in the virtual robot specification.
	Name string `json:"name"`

	// Type Identifies the I/O type. Possible responses "input" or "output".
	Type IODescriptionType `json:"type"`

	// Unit The unit of I/O value.
	Unit *IODescriptionUnit `json:"unit,omitempty"`

	// ValueType Data type of the I/O.
	ValueType IODescriptionValueType `json:"value_type"`
}

// IODescriptionType Identifies the I/O type. Possible responses "input" or "output".
type IODescriptionType string

// IODescriptionUnit The unit of I/O value.
type IODescriptionUnit string

// IODescriptionValueType Data type of the I/O.
type IODescriptionValueType string

// IOValue I/O value representation. Depending on the I/O type, only one of the value fields will be set.
type IOValue struct {
	// BooleanValue Value of a digital I/O.
	// This field is only set if the I/O is of type IO_VALUE_DIGITAL.
	BooleanValue *bool `json:"boolean_value,omitempty"`

	// FloatingValue Value of an analog I/O with floating number representation.
	// This field is only set if the I/O is of type IO_VALUE_ANALOG_FLOATING.
	FloatingValue *float64 `json:"floating_value,omitempty"`

	// IntegerValue Value of an analog I/O with integer representation.
	// This field is only set if the I/O is of type IO_VALUE_ANALOG_INTEGER.
	//
	// > The integral value is transmitted as a string to avoid precision loss in conversion to JSON.
	// > We recommend to use int64 for implementation. If you want to interact with int64 in numbers,
	// > there are some JS bigint libraries availible to parse the string into an integral value.
	IntegerValue *string `json:"integer_value,omitempty"`

	// Io Unique identifier of the I/O.
	Io string `json:"io"`
}

// IOs defines model for IOs.
type IOs struct {
	IOs []IO `json:"IOs"`
}

// ImageCredentials User provided credentials for creating a secret to pull an image from a registry.
type ImageCredentials struct {
	Password string `json:"password"`
	Registry string `json:"registry"`
	User     string `json:"user"`
}

// InfoServiceCapabilities defines model for InfoServiceCapabilities.
type InfoServiceCapabilities struct {
	// GetActivePayload Is this motion group able to provide the currently active payload.
	GetActivePayload bool `json:"get_active_payload"`

	// GetActiveTcp Is this motion group able to provide the currently active TCP.
	GetActiveTcp bool `json:"get_active_tcp"`

	// GetMotionGroupSpecification Is this motion group able to provide a motion group specification.
	GetMotionGroupSpecification bool `json:"get_motion_group_specification"`

	// GetMounting Is this motion group able to provide the mounting information.
	GetMounting bool `json:"get_mounting"`

	// GetSafetySetup Is this motion group able to get the safety setup.
	GetSafetySetup bool `json:"get_safety_setup"`

	// ListPayloads Is this motion group able to provide a list of all available payloads.
	ListPayloads bool `json:"list_payloads"`

	// ListTcps Is this motion group able to provide a list of all available TCPs.
	ListTcps bool `json:"list_tcps"`
}

// InitializeMovementRequest Sets up connection by locking a trajectory for execution. The trajectory is identified by the UUID. The robot controller mode is set to control mode.
// ATTENTION: This request has to be sent before any StartMovementRequest is sent.
//
//	If initializing the movement was successful, no further movements can be initialized. To execute another trajectory, another connection has to be established.
type InitializeMovementRequest struct {
	// InitialLocation Location on trajectory where the execution will start.
	// The default value is the start (forward movement) or end (backward movement) of the trajectory.
	// If you want to start your movement from an arbitrary location, e.g. in combination with [streamMoveToTrajectoryViaJointPTP](streamMoveToTrajectoryViaJointPTP),
	// set the location by respecting the following format:
	// - The location is a scalar value that defines a position along a path, typically ranging from 0 to `n`,
	//   where `n` denotes the number of motion commands
	// - Each integer value of the location corresponds to a specific motion command,
	//   while non-integer values interpolate positions within the segments.
	// - The location is calculated from the joint path
	InitialLocation *float64 `json:"initial_location,omitempty"`

	// MessageType Type specifier for server, set automatically.
	MessageType *string `json:"message_type,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the responses are transformed.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `json:"response_coordinate_system,omitempty"`

	// ResponseRate Update rate for the response message in milliseconds (ms). Default is 200 ms.
	// Recommendation: As Wandelbots NOVA updates states in the controller's step rate, use either the controller's step rate, or multiply the step rate and use the product.
	//                 Wandelbots NOVA will not interpolate the state but rather round it to the nearest step rate below the configured response rate.
	// Minimal response rate is the step rate of controller.
	ResponseRate *uint32 `json:"response_rate,omitempty"`

	// Trajectory The UUID of the trajectory which should be executed and locked to the connection.
	// Get information about the trajectory via [getMotionTrajectorySample](getMotionTrajectorySample) or [getMotionTrajectory](getMotionTrajectory).
	Trajectory string `json:"trajectory"`
}

// InitializeMovementResponse Response for InitializeMovementRequest message.
type InitializeMovementResponse struct {
	InitResponse struct {
		// ErrorMessage Error message in case of invalid InitializeMovementRequest.
		ErrorMessage *string `json:"error_message,omitempty"`

		// Succeeded Indicates if the motion was successfully locked and is ready for execution by sending a StartMovementRequest.
		// Send PlaybackSpeedRequest to override the planned velocity.
		Succeeded bool `json:"succeeded"`
	} `json:"init_response"`
}

// JoggingResponse A response for a Jogging Request, is streamed during an active Jogging Movement.
type JoggingResponse struct {
	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// MovementState State of the current movement, e.g. ongoing or stopped due to a particular reason.
	MovementState JoggingResponseMovementState `json:"movement_state"`

	// State Returns the whole current state of robot controller.
	State RobotControllerState `json:"state"`
}

// JoggingResponseMovementState State of the current movement, e.g. ongoing or stopped due to a particular reason.
type JoggingResponseMovementState string

// JoggingServiceCapabilities defines model for JoggingServiceCapabilities.
type JoggingServiceCapabilities struct {
	// CartesianJogging Can this motion group be moved via cartesian jogging.
	CartesianJogging bool `json:"cartesian_jogging"`

	// JointJogging Can this motion group be moved via joint jogging.
	JointJogging bool `json:"joint_jogging"`
}

// JointJoggingRequest A request to move the joints of a motion group.
type JointJoggingRequest struct {
	// JointVelocities in [rad/s]
	JointVelocities []float64 `json:"joint_velocities"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system in which the responses should be converted.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `json:"response_coordinate_system,omitempty"`

	// ResponseRate Update rate for the response message in ms. If not set 200ms are used.
	ResponseRate *uint32 `json:"response_rate,omitempty"`

	// Tcp The identifier of the tool center point (TCP) to be used for the jogging motion.
	// If not specified, the TCP currently active on the robot controller will be used.
	// At this TCP, it will be assured, that the allowed cartesian velocity limits are not exceeded.
	Tcp *interface{} `json:"tcp,omitempty"`
}

// JointLimit A joint limit can contain a position (rad or mm), a velocity (rad/s or mm/s),
// an acceleration (rad/s² or mm/s²) or a jerk (rad/s³ or mm/s³).
type JointLimit struct {
	// Joint Definition of the joint where the limits are applied.
	Joint JointLimitJoint `json:"joint"`

	// LowerLimit Lower joint limit which is smaller than the upper joint limit.
	LowerLimit float64 `json:"lower_limit"`

	// Unlimited True, if joint limit is unlimited. Lower and upper limits are ignored.
	Unlimited *bool `json:"unlimited,omitempty"`

	// UpperLimit Upper joint boundary which is bigger than the lower joint limit.
	UpperLimit float64 `json:"upper_limit"`
}

// JointLimitJoint Definition of the joint where the limits are applied.
type JointLimitJoint string

// JointLimitExceeded This error is returned when a joint position limit is exceeded.
// The joint index denotes which joint is out of its limits, starting with 1 and the full joint position is returned.
type JointLimitExceeded struct {
	JointIndex *uint32 `json:"joint_index,omitempty"`

	// JointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointPosition *Joints `json:"joint_position,omitempty"`
}

// JointPositionRequest Request to find the joint positions the motion-group needs to apply for its TCP to be in a specified pose (Inverse Kinematic Solution).
type JointPositionRequest struct {
	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// ReferenceJointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	ReferenceJointPosition Joints `json:"reference_joint_position"`

	// TcpPose Representing a robot pose in operational space aware of a configured TCP.
	TcpPose TcpPose `json:"tcp_pose"`
}

// JointTrajectory defines model for JointTrajectory.
type JointTrajectory struct {
	// JointPositions List of joint positions [rad] for each sample.
	// The number of samples must match the number of timestamps provided in the times field.
	JointPositions []Joints `json:"joint_positions"`

	// Locations Location for each sample, scalar value defining a position along a path. Typical range: 0 to `n`, `n` denoting the number of motion commands.
	// Each integer value of the location corresponds to a specific motion command.
	// If provided, the number of samples must match the number of timestamps provided in the times field.
	Locations []float64 `json:"locations"`

	// Times Timestamp for each sample [s].
	Times []float64 `json:"times"`
}

// Joints This structure describes a set of joint values of a motion group.
// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
// Float precision is the default.
type Joints struct {
	Joints []float64 `json:"joints"`
}

// Key Unique identifier describing to adress an object.
//
// Special characters, such as `;`, `/`, `?`, `:`, `@`, `=` and `&`, have to be URL encoded.
type Key = string

// KinematicServiceCapabilities defines model for KinematicServiceCapabilities.
type KinematicServiceCapabilities struct {
	// CalculateAllJointPositions Can this motion-group compute all its possible joint positions from a TCP pose.
	CalculateAllJointPositions bool `json:"calculate_all_joint_positions"`

	// CalculateJointPosition Can this motion-group compute its nearest joint position from a TCP pose.
	CalculateJointPosition bool `json:"calculate_joint_position"`

	// CalculateTcpPose Can this motion-group compute its TCP pose from joint positions.
	CalculateTcpPose bool `json:"calculate_tcp_pose"`
}

// KukaController The configuration of a physical KUKA robot controller has to contain an IP address.
// Additionally an RSI server configuration has to be specified in order to control the robot.
// Deploying the server is a functionality of this API.
type KukaController struct {
	ControllerIp   string             `json:"controllerIp"`
	ControllerPort int                `json:"controllerPort"`
	Kind           KukaControllerKind `json:"kind,omitempty"`

	// RsiServer The RSI server runs inside of the cell.
	RsiServer struct {
		Ip   string `json:"ip"`
		Port int    `json:"port"`
	} `json:"rsiServer"`
}

// KukaControllerKind defines model for KukaController.Kind.
type KukaControllerKind string

// License defines model for License.
type License struct {
	// FeatureFlags Features enabled by a license.
	FeatureFlags *[]string `json:"feature_flags,omitempty"`

	// FeatureLimitations Feature limitations of the license.
	FeatureLimitations *map[string]int `json:"feature_limitations,omitempty"`

	// GracePeriodExpiryDate End date of grace period, given if instance is not connected to internet.
	GracePeriodExpiryDate time.Time `json:"grace_period_expiry_date"`

	// LicenseExpiryDate Expiration date of the license.
	LicenseExpiryDate *openapi_types.Date `json:"license_expiry_date,omitempty"`

	// LicenseKey Identification key of the license.
	LicenseKey string `json:"license_key"`

	// OwnerEmail Mail address of the license owner.
	OwnerEmail openapi_types.Email `json:"owner_email"`

	// ProductName Name of the licensed product.
	ProductName string `json:"product_name"`

	// Status Status of the license.
	Status LicenseStatus `json:"status"`
}

// LicenseStatus Status of the license.
type LicenseStatus struct {
	Message string            `json:"message"`
	Status  LicenseStatusEnum `json:"status"`
}

// LicenseStatusEnum defines model for LicenseStatusEnum.
type LicenseStatusEnum string

// LimitSettings NOTE: if a joint or Cartesian limit is not set or present for the corresponding device, then the value is not present (in the list or the optional value is null). The unit depends on the kind of axis (rotational or linear).
type LimitSettings struct {
	// ElbowAccelerationLimit [mm/s^2] max. allowed acceleration at the elbow, 1-dimensional.
	ElbowAccelerationLimit *float64 `json:"elbow_acceleration_limit,omitempty"`

	// ElbowForceLimit [N] max. allowed force at the elbow, 1-dimensional.
	ElbowForceLimit *float64 `json:"elbow_force_limit,omitempty"`

	// ElbowVelocityLimit [mm/s] max. allowed velocity at the elbow, 1-dimensional.
	ElbowVelocityLimit *float64 `json:"elbow_velocity_limit,omitempty"`

	// JointAccelerationLimits Max allowed acceleration for joints in [rad/s^2 or mm/s^2] of the safety setup, starting at base.
	JointAccelerationLimits *[]SingleJointLimit `json:"joint_acceleration_limits,omitempty"`

	// JointPositionLimits Joint position limits in [rad or mm], configured in the safety setup, starting at base.
	JointPositionLimits *[]JointLimit `json:"joint_position_limits,omitempty"`

	// JointTorqueLimits Max allowed torque for joints in [Nm or N] of the safety setup, starting at base.
	JointTorqueLimits *[]SingleJointLimit `json:"joint_torque_limits,omitempty"`

	// JointVelocityLimits Max allowed velocity for joints in [rad/s or mm/s] of the safety setup, starting at base.
	JointVelocityLimits *[]SingleJointLimit `json:"joint_velocity_limits,omitempty"`

	// TcpAccelerationLimit [mm/s^2] max. allowed acceleration at the TCP, 1-dimensional.
	TcpAccelerationLimit *float64 `json:"tcp_acceleration_limit,omitempty"`

	// TcpForceLimit [N] max. allowed force at the TCP, 1-dimensional.
	TcpForceLimit *float64 `json:"tcp_force_limit,omitempty"`

	// TcpOrientationAccelerationLimit [rad/s^2] max. allowed orientation acceleration at the TCP, 1-dimensional.
	TcpOrientationAccelerationLimit *float64 `json:"tcp_orientation_acceleration_limit,omitempty"`

	// TcpOrientationVelocityLimit [rad/s] max. allowed orientation velocity at the TCP, 1-dimensional.
	TcpOrientationVelocityLimit *float64 `json:"tcp_orientation_velocity_limit,omitempty"`

	// TcpVelocityLimit [mm/s] max. allowed velocity at the TCP, 1-dimensional.
	TcpVelocityLimit *float64 `json:"tcp_velocity_limit,omitempty"`
}

// LimitsOverride If a limit is not set, the default value will be used.
type LimitsOverride struct {
	// JointAccelerationLimits This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointAccelerationLimits *Joints `json:"joint_acceleration_limits,omitempty"`

	// JointVelocityLimits This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointVelocityLimits *Joints `json:"joint_velocity_limits,omitempty"`

	// TcpAccelerationLimit Maximum allowed TCP acceleration in [mm/s^2].
	TcpAccelerationLimit *float64 `json:"tcp_acceleration_limit,omitempty"`

	// TcpOrientationAccelerationLimit Maximum allowed TCP rotation acceleration in [rad/s^2].
	TcpOrientationAccelerationLimit *float64 `json:"tcp_orientation_acceleration_limit,omitempty"`

	// TcpOrientationVelocityLimit Maximum allowed TCP rotation velocity in [rad/s].
	TcpOrientationVelocityLimit *float64 `json:"tcp_orientation_velocity_limit,omitempty"`

	// TcpVelocityLimit Maximum allowed TCP velocity in [mm/s].
	TcpVelocityLimit *float64 `json:"tcp_velocity_limit,omitempty"`
}

// Link defines model for Link.
type Link map[string]Collider

// LinkChain A link chain is a kinematic chain of links that is connected via joints.
// A motion group can be used to control the motion of the joints in a link chain.
//
// A link is a group of colliders that is attached to the link reference frame.
//
// The reference frame of a link is obtained after applying all sets of Denavit-Hartenberg-parameters from base to (including) the link index.
//
// This means that the reference frame of the link is on the rotation axis of the next joint in the kinematic chain.
// Example: For a motion group with 2 joints, the collider reference frame (CRF) for link 1 is on the rotation axis of joint 2. The chain looks like:
// - Origin >> Mounting >> Base >> (CRF Base) Joint 0 >> Link 0 >> (CRF Link 0) Joint 1 >> Link 1 >> (CRF Link 1) Flange (CRF Tool) >> TCP
//
// Adjacent links in the kinematic chain of the motion group are not checked for mutual collision.
type LinkChain = []Link

// ListIODescriptionsResponse Array of I/O description values.
type ListIODescriptionsResponse struct {
	IoDescriptions []IODescription `json:"io_descriptions"`
}

// ListIOValuesResponse Array of I/O values.
type ListIOValuesResponse struct {
	IoValues []IOValue `json:"io_values"`
}

// ListPayloadsResponse defines model for ListPayloadsResponse.
type ListPayloadsResponse struct {
	Payloads *[]Payload `json:"payloads,omitempty"`
}

// ListProgramMetadataResponse List of all the stored programs, represented by their metadata.
type ListProgramMetadataResponse struct {
	Programs []ProgramMetadata `json:"programs"`
}

// ListRecipeMetadataResponse List of all the stored recipes, represented by their metadata.
type ListRecipeMetadataResponse struct {
	Recipes []RecipeMetadata `json:"recipes"`
}

// ListResponse defines model for ListResponse.
type ListResponse struct {
	Coordinatesystems *[]CoordinateSystem `json:"coordinatesystems,omitempty"`
}

// ListTcpsResponse defines model for ListTcpsResponse.
type ListTcpsResponse struct {
	// Tcps Represents the tcp offset from the device flange (in other words the absolute transformation from flange to the tcp).
	Tcps *[]RobotTcp `json:"tcps,omitempty"`
}

// Manufacturer defines model for Manufacturer.
type Manufacturer string

// ModeChangeResponse Mode change example:
// * Client sends [jointJogging](jointJogging)](cell="..",...)
// * Server responds with *current_robot_mode: ROBOT_SYSTEM_MODE_UNDEFINED, by_client_request: true* at the beginning of the transition.
// * Server responds with *current_robot_mode: ROBOT_SYSTEM_MODE_CONTROL, by_client_request: true* when transition is done.
//
// In case an error happens during execution, e.g. a path would lead to a joint limit violation:
// * Server responds with *current_robot_mode: ROBOT_SYSTEM_MODE_UNDEFINED, by_client_request: false*
// * Server responds with *current_robot_mode: ROBOT_SYSTEM_MODE_MONITOR, by_client_request: false*
//
// In case an error happens during connection, e.g. the robot is not reachable:
// * Client sends [setDefaultMode](setDefaultMode)(mode: MODE_CONTROL)
// * Server responds with *current_robot_mode:ROBOT_SYSTEM_MODE_UNDEFINED, by_client_request: true*
// * Server responds with *current_robot_mode:ROBOT_SYSTEM_MODE_DISCONNECT, by_client_request: false*
type ModeChangeResponse struct {
	// ByClientRequest True if mode change was requested by client.
	ByClientRequest bool `json:"by_client_request"`

	// CauseOfChange Details about cause of mode change.
	CauseOfChange string `json:"cause_of_change"`

	// CurrentRobotMode The system mode of the robot system.
	//
	// ### ROBOT_SYSTEM_MODE_UNDEFINED
	//
	// Indicates that the robot controller is currently performing a mode transition.
	//
	// ### ROBOT_SYSTEM_MODE_DISCONNECT
	//
	// There is no communication with the robot controller at all. All connections are closed.
	// No command is sent to the robot controller while in this mode. No IO interaction is possible in this mode!
	// All move requests will be rejected in this mode!
	//
	// ### ROBOT_SYSTEM_MODE_MONITOR
	//
	// A connection to the robot controller is established to only read the robot controller state.
	// No command is sent to the robot controller while in this mode. It is possible to receive IO information.
	// All move requests will be rejected in this mode!
	//
	// ### ROBOT_SYSTEM_MODE_CONTROL
	//
	// An active connection is established with the robot controller and the robot system is cyclic commanded
	// to stay in its actual position. The robot controller state is received in the cycle time of the robot controller.
	// Requests via the MotionService and JoggingService will be processed and executed in this mode.
	// IO interaction is possible in this mode! **In this mode the robot system can be commanded to move.**
	//
	// ### ROBOT_SYSTEM_MODE_FREE_DRIVE
	//
	// Like ROBOT_SYSTEM_MODE_MONITOR a connection to the robot controller is established to only read the robot controller state.
	// The difference is that the motion groups can be moved by the user (Free Drive). Thus, the servo motors are turned on.
	// All move requests will be rejected in this mode! **This mode is not supported by every robot!**
	// Use [getSupportedModes](getSupportedModes) to evaluate if the device support free drive.
	CurrentRobotMode RobotSystemMode `json:"current_robot_mode"`

	// PreviousRobotMode The system mode of the robot system.
	//
	// ### ROBOT_SYSTEM_MODE_UNDEFINED
	//
	// Indicates that the robot controller is currently performing a mode transition.
	//
	// ### ROBOT_SYSTEM_MODE_DISCONNECT
	//
	// There is no communication with the robot controller at all. All connections are closed.
	// No command is sent to the robot controller while in this mode. No IO interaction is possible in this mode!
	// All move requests will be rejected in this mode!
	//
	// ### ROBOT_SYSTEM_MODE_MONITOR
	//
	// A connection to the robot controller is established to only read the robot controller state.
	// No command is sent to the robot controller while in this mode. It is possible to receive IO information.
	// All move requests will be rejected in this mode!
	//
	// ### ROBOT_SYSTEM_MODE_CONTROL
	//
	// An active connection is established with the robot controller and the robot system is cyclic commanded
	// to stay in its actual position. The robot controller state is received in the cycle time of the robot controller.
	// Requests via the MotionService and JoggingService will be processed and executed in this mode.
	// IO interaction is possible in this mode! **In this mode the robot system can be commanded to move.**
	//
	// ### ROBOT_SYSTEM_MODE_FREE_DRIVE
	//
	// Like ROBOT_SYSTEM_MODE_MONITOR a connection to the robot controller is established to only read the robot controller state.
	// The difference is that the motion groups can be moved by the user (Free Drive). Thus, the servo motors are turned on.
	// All move requests will be rejected in this mode! **This mode is not supported by every robot!**
	// Use [getSupportedModes](getSupportedModes) to evaluate if the device support free drive.
	PreviousRobotMode RobotSystemMode `json:"previous_robot_mode"`
}

// MotionCommand defines model for MotionCommand.
type MotionCommand struct {
	// Blending Blending alters the TCP path at the target point of a motion command
	// to ensure that the velocity does not drop to zero between two motion commands.
	Blending *MotionCommand_Blending `json:"blending,omitempty"`

	// LimitsOverride If a limit is not set, the default value will be used.
	LimitsOverride *LimitsOverride    `json:"limits_override,omitempty"`
	Path           MotionCommand_Path `json:"path"`
}

// MotionCommand_Blending Blending alters the TCP path at the target point of a motion command
// to ensure that the velocity does not drop to zero between two motion commands.
type MotionCommand_Blending struct {
	union json.RawMessage
}

// MotionCommand_Path defines model for MotionCommand.Path.
type MotionCommand_Path struct {
	union json.RawMessage
}

// MotionGroupBehaviorGetter defines model for MotionGroupBehaviorGetter.
type MotionGroupBehaviorGetter struct {
	// Behavior ## BEHAVIOR_AUTOMATIC
	// This is the default behavior.
	// The motion group instantly takes any commanded joint configuration as actual joint state.
	// Configures the compliance of the virtual robot with the normal ControllerState cycle time. If set, the virtual robot will act like a physical one, e.g. with a cycle time of 8ms to respond to a new joint state command.
	// ## BEHAVIOR_AUTOMATIC_NOT_COMPLY_WITH_CYCLETIME
	// Configures the compliance of the virtual robot with the normal ControllerState cycle time. If set, the robot will respond as fast as possible, limited only by software execution speed. Because of that the execution of a movement requires less time than with BEHAVIOR_AUTOMATIC.
	// ## BEHAVIOR_EXTERNAL_SOURCE
	// The external client is the only source of actual joint state changes.
	// This mode is used to enable third party software indicating the current joint state via [externalJointsStream](externalJointsStream).
	Behavior Behavior `json:"behavior"`
}

// MotionGroupInfo defines model for MotionGroupInfo.
type MotionGroupInfo struct {
	// Dof The number of joints aka degrees of freedom in the motion group.
	Dof uint32 `json:"dof"`

	// Id The unique identifier of the motion group. Use it to refer to the motion group in other calls.
	Id uint32 `json:"id"`

	// Name The name of the motion group for display purposes.
	Name string `json:"name"`
}

// MotionGroupInfos defines model for MotionGroupInfos.
type MotionGroupInfos struct {
	Motiongroups []MotionGroupInfo `json:"motiongroups"`
}

// MotionGroupInstance The data type describes the physically connected motion groups on a robot controller, e.g. a robot arm.
type MotionGroupInstance struct {
	// Controller Identifier of the robot controller the motion group is attached to.
	Controller string `json:"controller"`

	// ModelFromController The robot controller model if available. Usable for frontend 3D visualization.
	ModelFromController string `json:"model_from_controller"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// NameFromController The name of the motion group has on the robot controller.
	NameFromController string `json:"name_from_controller"`

	// SerialNumber The serial number of the motion group if available. If not available, the serial number of the robot controller.
	// if available. If not available, then empty.
	SerialNumber *string `json:"serial_number,omitempty"`
}

// MotionGroupInstanceList A list of motion groups.
type MotionGroupInstanceList struct {
	Instances []MotionGroupInstance `json:"instances"`
}

// MotionGroupJoints Ensure to provide one value for each joint. See [getMotionGroups](getMotionGroups) for the number of joints.
// Everything but positions is optional.
type MotionGroupJoints struct {
	// Accelerations The joint accelerations of the motion group.
	Accelerations *[]float64 `json:"accelerations,omitempty"`

	// Positions The joint positions of the motion group.
	Positions []float64 `json:"positions"`

	// Torques The joint torques of the motion group.
	Torques *[]float64 `json:"torques,omitempty"`

	// Velocities The joint velocities of the motion group.
	Velocities *[]float64 `json:"velocities,omitempty"`
}

// MotionGroupPhysical The data type describes the physically connected motion groups on a robot controller.
type MotionGroupPhysical struct {
	// Active True if this motion group is active.
	// When a request for a motion group is made, the motion group will be activated and remain activated.
	// The robot controller provides the current state and data for all active motion groups.
	// See [getCurrentMotionGroupState](getCurrentMotionGroupState).
	// To deactivate a motion group, use [deactivateMotionGroup](deactivateMotionGroup).
	Active bool `json:"active"`

	// ModelFromController The robot controller model if available. Usable for frontend 3D visualization.
	ModelFromController *string `json:"model_from_controller,omitempty"`

	// MotionGroup The unique identifier to address a motion group.
	MotionGroup string `json:"motion_group"`

	// NameFromController The name the motion group has on the robot controller.
	NameFromController string `json:"name_from_controller"`

	// SerialNumber The serial number of the motion group if available. If not available, the serial number of the robot controller.
	// if available. If not available, then empty.
	SerialNumber *string `json:"serial_number,omitempty"`
}

// MotionGroupSpecification Holding static properties of the motion group.
type MotionGroupSpecification struct {
	// DhParameters A list of DH (Denavit-Hartenberg) parameters.
	// An element in this list contains a set of DH parameters that describe the relation of two cartesian reference frames.
	// Every joint of a serial motion group has an associated cartesian reference frame located in the rotation axis of the joint.
	// A set of DH parameters is applied in the following order: theta, d, a, alpha.
	DhParameters *[]DHParameter `json:"dh_parameters,omitempty"`

	// MechanicalJointLimits Mechanical joint limits in [rad/mm], starting with the first joint in the motion group base.
	// For every joint there is a minimum and maximum value.
	// Those are defined by the motion group manufacturer and can be found in its data sheet.
	// If a mechanical joint limit is exceeded, the motion group stops immediately. The stop is triggered by the physical robot controller.
	// This should be prevented by using proper soft joint limits.
	MechanicalJointLimits *[]JointLimit `json:"mechanical_joint_limits,omitempty"`
}

// MotionGroupState Presents the current state of the motion group.
type MotionGroupState struct {
	// Controller Convenience: Identifier of the robot controller the motion group is attached to.
	Controller string `json:"controller"`

	// FlangePose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	FlangePose *Pose `json:"flange_pose,omitempty"`

	// Force Representing a force on a specific point in operational space (e.g. on robot flange).
	Force *ForceVector `json:"force,omitempty"`

	// JointCurrent This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointCurrent *Joints `json:"joint_current,omitempty"`

	// JointLimitReached Indicates which joint of the motion group is in a limit. If a joint is in its limit, only this joint can be moved. Movements that affect any other joints are not executed.
	JointLimitReached MotionGroupStateJointLimitReached `json:"joint_limit_reached"`

	// JointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointPosition Joints `json:"joint_position"`

	// JointTorque This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointTorque *Joints `json:"joint_torque,omitempty"`

	// JointVelocity This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointVelocity Joints `json:"joint_velocity"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// TcpPose Representing a robot pose in operational space aware of a configured TCP.
	TcpPose  TcpPose      `json:"tcp_pose"`
	Velocity MotionVector `json:"velocity"`
}

// MotionGroupStateResponse defines model for MotionGroupStateResponse.
type MotionGroupStateResponse struct {
	// State Presents the current state of the motion group.
	State MotionGroupState `json:"state"`

	// TcpPose Representing a robot pose in operational space aware of a configured TCP.
	TcpPose *TcpPose `json:"tcp_pose,omitempty"`
}

// MotionGroupStateJointLimitReached Indicates which joint of the motion group is in a limit. If a joint is in its limit, only this joint can be moved. Movements that affect any other joints are not executed.
type MotionGroupStateJointLimitReached struct {
	// LimitReached If true, operational (soft) jointLimit is reached for specific joint.
	LimitReached []bool `json:"limit_reached"`
}

// MotionId defines model for MotionId.
type MotionId struct {
	// Motion This represents the UUID of a motion.
	// Every executable or partially executable motion is cached and an UUID is returned.
	// Indicate the UUID to execute the motion or retrieve information on the motion.
	Motion string `json:"motion"`
}

// MotionIdsListResponse defines model for MotionIdsListResponse.
type MotionIdsListResponse struct {
	// Motions -| Identifiers of all motions which are currently cached. Use [planMotion](planMotion) to add a new motion. Motions are deleted if corresponding motion group or controller is disconnected.
	Motions *[]string `json:"motions,omitempty"`
}

// MotionVector defines model for MotionVector.
type MotionVector struct {
	// Angular A 3 dimensional Vector with double precision.
	Angular *Vector3d `json:"angular,omitempty"`

	// CoordinateSystem optional, unique name of base coordinate system, if empty world is used
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// Linear A 3 dimensional Vector with double precision.
	Linear *Vector3d `json:"linear,omitempty"`
}

// Mounting Mounting of a motion group.
type Mounting struct {
	// CoordinateSystem Identifier of mounting coordinate system. The motion group is based on the origin of this coordinate system.
	CoordinateSystem string `json:"coordinate_system"`

	// Pose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	Pose Pose `json:"pose"`
}

// MoveRequest Moves the motion group forward or backward along a previously planned motion.
//
// Once started, you can stop a motion using the [stop](StreamStop) endpoint.
//
// Prerequisite, before starting the motion execution:
//   - The motion group is currently at the endpoint of the planned motion.
type MoveRequest struct {
	// Motion This represents the UUID of a motion.
	// Every executable or partially executable motion is cached and an UUID is returned.
	// Indicate the UUID to execute the motion or retrieve information on the motion.
	Motion string `json:"motion"`

	// PauseOnIo Defines an I/O that the motion will be paused for. The motion will stop gracefully on path.
	PauseOnIo *PauseOnIO `json:"pause_on_io,omitempty"`

	// PlaybackSpeedInPercent Set the velocity for executed movements of the motion in percent. A percentage of 100% means that the robot moves as
	// fast as possible without violating the limits. Setting this value does not affect the overall shape of the velocity profile.
	// Everything is slowed down by the same factor. Therefore, this should only be used for teaching and trajectory
	// evaluation purposes. If the process requires a certain velocity, the respective limits should be set when planning the motion.
	// This will not change the velocity override of the controller. The controller velocity override value shall be 100% to ensure
	// controllability of the motion group.
	PlaybackSpeedInPercent uint32 `json:"playback_speed_in_percent"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system in which the responses should be converted.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `json:"response_coordinate_system,omitempty"`

	// ResponseRate Update rate for the response message in milliseconds (ms). Default is 200 ms.
	// We recommend to use the step rate of the controller or a multiple of the step rate as NOVA updates the state in the controller's step rate as well.
	// Minimal response rate is the step rate of controller.
	ResponseRate *uint32 `json:"response_rate,omitempty"`

	// SetIOAction Define an arb I/O that is listened to during the motion. If the defined comparator evaluates to true the execution is started.
	SetIOAction *[]SetIO `json:"set_ios,omitempty"`

	// StartLocationOnTrajectory Location the motion is requested to start at.
	// The default value is the begin of the trajectory.
	// The location is a scalar value that defines a position along a path, typically ranging from 0 to `n`,
	// where `n` denotes the number of motion commands. Each integer value of the location corresponds to a specific motion command,
	// while non-integer values interpolate positions within the segments.
	// The location is calculated from the joint path.
	StartLocationOnTrajectory *float64 `json:"start_location_on_trajectory,omitempty"`

	// StartOnIo Defines an I/O that the motion should wait for to start the execution.
	StartOnIo *StartOnIO `json:"start_on_io,omitempty"`
}

// MoveResponse defines model for MoveResponse.
type MoveResponse struct {
	// CurrentLocationOnTrajectory Refers to the current location of motion group on the trajectory.
	CurrentLocationOnTrajectory float64 `json:"current_location_on_trajectory"`

	// TimeToEnd Remaining time in milliseconds (ms) to reach the end of the motion.
	TimeToEnd uint32 `json:"time_to_end"`
}

// MoveToTrajectoryViaJointPTPRequest Request to move the motion group via joint point-to-point to a given location on a planned motion.
// You must use this endpoint in order to start moving from an arbritrary location of the trajectory.
// Afterwards, you are able to call [streamMoveForward](streamMoveForward) or [streamMoveBackward](streamMoveBackward) to move along planned motion.
// Use the [stopExecution](stopExecution) endpoint to stop the motion gracefully.
type MoveToTrajectoryViaJointPTPRequest struct {
	// LimitOverride If a limit is not set, the default value will be used.
	LimitOverride *LimitsOverride `json:"limit_override,omitempty"`

	// LocationOnTrajectory Gets the target location the robot should move to via joint point-to-point (moveJ).
	// The location is a scalar value that defines a position along a path, typically ranging from 0 to `n`,
	// where `n` denotes the number of motion commands. Each integer value of the location corresponds to a specific motion command,
	// while non-integer values interpolate positions within the segments.
	// The location is calculated from the joint path.
	LocationOnTrajectory float64 `json:"location_on_trajectory"`

	// Motion This represents the UUID of a motion.
	// Every executable or partially executable motion is cached and an UUID is returned.
	// Indicate the UUID to execute the motion or retrieve information on the motion.
	Motion string `json:"motion"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system in which the responses should be converted.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `json:"response_coordinate_system,omitempty"`
}

// Movement Sent during movement, response-rate closest to the nearest multiple of controller step-rate but not exceeding the configured rate.
type Movement struct {
	Movement struct {
		// CurrentLocation Current location of motion group on the trajectory.
		CurrentLocation float64 `json:"current_location"`

		// State Returns the whole current state of robot controller.
		State RobotControllerState `json:"state"`

		// TimeToEnd Remaining time in milliseconds (ms) to reach the end of the motion.
		TimeToEnd uint32 `json:"time_to_end"`
	} `json:"movement"`
}

// MovementError Response signalling an error during trajectory execution.
// This response is sent in case of an unexpected error , e.g. controller disconnects.
// The error details are described in the error_message field.
type MovementError struct {
	Error struct {
		// ErrorMessage Human-readable error details that describes the error.
		ErrorMessage string `json:"error_message"`
	} `json:"error"`
}

// NameList A list of names
type NameList = []string

// OpMode Controllers have two operating modes: AUTOMATIC and MANUAL.
// MANUAL mode is mainly used for teaching a robot application.
// To ensure safe operation the velocity of the robot is limited to 250 mm/s.
// Running the finished application is done in AUTOMATIC operating mode without the limited velocity of the MANUAL mode.
type OpMode struct {
	Mode OpModeMode `json:"mode"`
}

// OpModeMode defines model for OpMode.Mode.
type OpModeMode string

// OpcuaNodeValueTriggerConfig Configuration for an OPC UA node value trigger.
// When the specified node has the specified value
// the trigger condition is met and the program is executed.
type OpcuaNodeValueTriggerConfig struct {
	// Host Url of the OPC UA server.
	Host string `json:"host"`

	// NodeId Identifier of the OPC UA node to monitor.
	NodeId string `json:"node_id"`

	// NodeValue Value to trigger the program when matched.
	NodeValue OpcuaNodeValueTriggerConfig_NodeValue `json:"node_value"`
}

// OpcuaNodeValueTriggerConfigNodeValue0 defines model for .
type OpcuaNodeValueTriggerConfigNodeValue0 = string

// OpcuaNodeValueTriggerConfigNodeValue1 defines model for .
type OpcuaNodeValueTriggerConfigNodeValue1 = float32

// OpcuaNodeValueTriggerConfigNodeValue2 defines model for .
type OpcuaNodeValueTriggerConfigNodeValue2 = bool

// OpcuaNodeValueTriggerConfig_NodeValue Value to trigger the program when matched.
type OpcuaNodeValueTriggerConfig_NodeValue struct {
	union json.RawMessage
}

// OptimizerSetup The configuration of a motion-group used for motion planning.
type OptimizerSetup struct {
	// CycleTime [ms] cycle time of the motion group controller. A trajectory for this motion group should be computed to this resolution.
	CycleTime *uint32 `json:"cycle_time,omitempty"`

	// DhParameters The DH parameters describing the motion group geometry, starting from base.
	DhParameters *[]DHParameter `json:"dh_parameters,omitempty"`

	// MotionGroupType String identifiying the exact motion group model (robot model).
	MotionGroupType string      `json:"motion_group_type"`
	Mounting        PlannerPose `json:"mounting"`
	Payload         *Payload    `json:"payload,omitempty"`

	// SafetySetup The safety configuration of a motion-group. Used for motion planning.
	SafetySetup SafetyConfiguration `json:"safety_setup"`
	Tcp         PlannerPose         `json:"tcp"`
}

// OutOfWorkspace Requested TCP pose is outside of motion group's workspace.
type OutOfWorkspace struct {
	// InvalidTcpPose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	InvalidTcpPose *Pose `json:"invalid_tcp_pose,omitempty"`
}

// PathCartesianPTP A cartesian point-to-point is representing a joint point-to-point motion from start point to the indicated target pose.
// The target pose is a joint point-to-point given in cartesian space. The target joint configuration will be calculated
// to be in the same kinematic configuration as the start point is. If that is not possible, planning will fail.
type PathCartesianPTP struct {
	PathDefinitionName string `json:"path_definition_name"`

	// TargetPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TargetPose Pose2 `json:"target_pose"`
}

// PathCircle A circular constructs a circle in translative space from 1) the start position which is provided via position, and 2) the indicated target position.
// The orientation is calculated via a [bezier spline](https://en.wikipedia.org/wiki/B%C3%A9zier_curve) from start orientation to the indicated target orientation.
// The via point defines the control point for the bezier spline.
// Therefore, the control point will not be hit directly.
type PathCircle struct {
	PathDefinitionName string `json:"path_definition_name"`

	// TargetPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TargetPose Pose2 `json:"target_pose"`

	// ViaPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	ViaPose Pose2 `json:"via_pose"`
}

// PathCubicSpline A [cubic spline](https://de.wikipedia.org/wiki/Spline-Interpolation) represents a cartesian cubic spline
// in translative and orientational space from start point to indicated target pose via control points.
type PathCubicSpline struct {
	Parameters         []CubicSplineParameter `json:"parameters"`
	PathDefinitionName string                 `json:"path_definition_name"`
}

// PathJointPTP A joint point-to-point represents a line in joint space. All joints will be moved synchronously.
type PathJointPTP struct {
	PathDefinitionName  string      `json:"path_definition_name"`
	TargetJointPosition DoubleArray `json:"target_joint_position"`
}

// PathLine A line represents a straight line from start position to indicated target position.
// The orientation is calculated via a quaternion [slerp](https://en.wikipedia.org/wiki/Slerp) from start orientation to indicated target orientation.
type PathLine struct {
	PathDefinitionName string `json:"path_definition_name"`

	// TargetPose Defines a pose in 3D space.
	// A pose is a combination of a position and an orientation.
	// The position is applied before the orientation.
	TargetPose Pose2 `json:"target_pose"`
}

// PauseMovementRequest Request to pause the movement execution. Movement pauses as soon as a [Standstill](Standstill.yaml) is sent back to the client.
// Resume movement with StartMovementRequest.
type PauseMovementRequest struct {
	// MessageType Type specifier for server, set automatically.
	MessageType *string `json:"message_type,omitempty"`

	// SendResponse Defaults to `true`.
	// Set to true to get a response signalling successful initiation to pause the movement.
	SendResponse *bool `json:"send_response,omitempty"`
}

// PauseMovementResponse Response for PauseMovementRequest message.
// ATTENTION: No confirmation that the movement was paused. Confirmation that the PauseMovementRequest was received and is processed.
//
//	End of movement execution is signalled by [StillstandResponse](StillstandResponse).
type PauseMovementResponse struct {
	PauseResponse struct {
		// ErrorMessage Error message in case of invalid PauseMovementRequest or failure while claiming motion.
		ErrorMessage *string `json:"error_message,omitempty"`

		// Succeeded Indicates if PauseMovementRequest can be executed.
		Succeeded bool `json:"succeeded"`
	} `json:"pause_response"`
}

// PauseOnIO Defines an I/O that the motion will be paused for. The motion will stop gracefully on path.
type PauseOnIO struct {
	// Comparator Comparator for the comparison of two values.
	// The comparator is used to compare two values and return a boolean result.
	// The default comparator is unknown.
	Comparator Comparator `json:"comparator"`

	// Io I/O value representation. Depending on the I/O type, only one of the value fields will be set.
	Io IOValue `json:"io"`
}

// Payload defines model for Payload.
type Payload struct {
	// CenterOfMass A 3 dimensional Vector with double precision.
	CenterOfMass *Vector3d `json:"center_of_mass,omitempty"`

	// MomentOfInertia A 3 dimensional Vector with double precision.
	MomentOfInertia *Vector3d `json:"moment_of_inertia,omitempty"`

	// Name Unique identifier of the payload.
	Name string `json:"name"`

	// Payload Mass of payload in [kg].
	Payload float64 `json:"payload"`
}

// PlanCollisionFreePTPRequest defines model for PlanCollisionFreePTPRequest.
type PlanCollisionFreePTPRequest struct {
	CollisionMotionGroup *CollisionMotionGroup `json:"collision_motion_group,omitempty"`

	// RobotSetup The configuration of a motion-group used for motion planning.
	RobotSetup         OptimizerSetup `json:"robot_setup"`
	StartJointPosition DoubleArray    `json:"start_joint_position"`

	// StaticColliders A collection of identifiable colliders.
	StaticColliders *ColliderDictionary `json:"static_colliders,omitempty"`

	// Target The target position of the motion. The target can be defined in joint space as joint positions,
	// or cartesian space as TCP pose.
	Target PlanCollisionFreePTPRequest_Target `json:"target"`
}

// PlanCollisionFreePTPRequest_Target The target position of the motion. The target can be defined in joint space as joint positions,
// or cartesian space as TCP pose.
type PlanCollisionFreePTPRequest_Target struct {
	union json.RawMessage
}

// PlanFailedOnTrajectoryResponse The planning failed. The motion can be executed until the defected command part starts.
type PlanFailedOnTrajectoryResponse struct {
	Description *string `json:"description,omitempty"`

	// ErrorLocationOnTrajectory Location on the trajectory where the error occurred. The location is defined as a floating point range from 0 to n, where 0 is the start of the trajectory and n is the end of the trajectory. n is the number commands. The decimal places represent the percentage of the defective command.
	ErrorLocationOnTrajectory *float64 `json:"error_location_on_trajectory,omitempty"`

	// JointLimitExceeded This error is returned when a joint position limit is exceeded.
	// The joint index denotes which joint is out of its limits, starting with 1 and the full joint position is returned.
	JointLimitExceeded *JointLimitExceeded `json:"joint_limit_exceeded,omitempty"`

	// LastValidJointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	LastValidJointPosition *Joints `json:"last_valid_joint_position,omitempty"`

	// LastValidTcpPose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	LastValidTcpPose *Pose `json:"last_valid_tcp_pose,omitempty"`

	// Motion Identifier of the motion until the error.
	Motion *string `json:"motion,omitempty"`

	// OutOfWorkspace Requested TCP pose is outside of motion group's workspace.
	OutOfWorkspace *OutOfWorkspace `json:"out_of_workspace,omitempty"`

	// SafetyZoneViolation Safety zone violations occur when a motion is planned within a safety zone set on the controller.
	// The message description indicates which part of the motion group collides with which safety zone.
	SafetyZoneViolation *SafetyZoneViolation `json:"safety_zone_violation,omitempty"`

	// Singularity A Singularity is a point in the robot's workspace where the robot loses one or more degrees of freedom with regards to moving its TCP.
	// This means the robot cannot move or rotate the TCP in a certain direction from this specific point.
	//
	// The singularity type is the type of singularity that the robot is in.
	// The singular joint position is the joint position of the robot when it is in a singularity.
	Singularity *Singularity `json:"singularity,omitempty"`
}

// PlanFailedResponse Starting point of motion is invalid. Therefore, planning a motion is not possible.
type PlanFailedResponse struct {
	// CommandsMissing Error in case no motion commands were provided. Every planning needs to have at least one motion command to describe the path to be followed.
	CommandsMissing *CommandsMissing `json:"commands_missing,omitempty"`
	Description     *string          `json:"description,omitempty"`

	// JointLimitExceeded This error is returned when a joint position limit is exceeded.
	// The joint index denotes which joint is out of its limits, starting with 1 and the full joint position is returned.
	JointLimitExceeded *JointLimitExceeded `json:"joint_limit_exceeded,omitempty"`

	// OutOfWorkspace Requested TCP pose is outside of motion group's workspace.
	OutOfWorkspace *OutOfWorkspace `json:"out_of_workspace,omitempty"`

	// SafetyZoneViolation Safety zone violations occur when a motion is planned within a safety zone set on the controller.
	// The message description indicates which part of the motion group collides with which safety zone.
	SafetyZoneViolation *SafetyZoneViolation `json:"safety_zone_violation,omitempty"`

	// Singularity A Singularity is a point in the robot's workspace where the robot loses one or more degrees of freedom with regards to moving its TCP.
	// This means the robot cannot move or rotate the TCP in a certain direction from this specific point.
	//
	// The singularity type is the type of singularity that the robot is in.
	// The singular joint position is the joint position of the robot when it is in a singularity.
	Singularity *Singularity `json:"singularity,omitempty"`

	// StartJointsMissing Error in case no start joint position was provided.
	// Every motion needs to start with a joint position as reference to uniquely define the kinematic configuration of the motion-group at the start the motion.
	StartJointsMissing *StartJointsMissing `json:"start_joints_missing,omitempty"`
}

// PlanRequest defines model for PlanRequest.
type PlanRequest struct {
	// Commands List of motion commands. A command consists of a motion command (line, circle, joint_ptp, cartesian_ptp, cubic_spline) and corresponding settings (blending, limits override).
	Commands []Command `json:"commands"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// Payload Payload identifier. If unset the currently set payload is used.
	Payload *string `json:"payload,omitempty"`

	// StartJointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	StartJointPosition Joints `json:"start_joint_position"`

	// Tcp Tool identifier. If not set the current tool is used.
	Tcp *string `json:"tcp,omitempty"`
}

// PlanResponse -| The plan response signals if the planned motion is executable, partially executable or not executable. If the motion is executable or partially executable, the response contains an unique identifier for the motion and the end joint position. To execute the motion use the unique identifier for calling move endpoints [streamMoveForward](streamMoveForward) or [streamMoveBackward](streamMoveBackward). Use the unique identifier within the endpoints [getMotionTrajectory](getMotionTrajectory) and [getMotionTrajectorySample](getMotionTrajectorySample) to retrieve information about the motion. Use the end joint position to plan and concatenate the next motion. If an error occurred, the response contains feedback including the reason for failure and the location where the failure occurred.
type PlanResponse struct {
	// PlanFailedOnTrajectoryResponse The planning failed. The motion can be executed until the defected command part starts.
	PlanFailedOnTrajectoryResponse *PlanFailedOnTrajectoryResponse `json:"plan_failed_on_trajectory_response,omitempty"`

	// PlanFailedResponse Starting point of motion is invalid. Therefore, planning a motion is not possible.
	PlanFailedResponse *PlanFailedResponse `json:"plan_failed_response,omitempty"`

	// PlanSuccessfulResponse The motion can be executed entirely.
	PlanSuccessfulResponse *PlanSuccessfulResponse `json:"plan_successful_response,omitempty"`
}

// PlanSuccessfulResponse The motion can be executed entirely.
type PlanSuccessfulResponse struct {
	// EndJointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	EndJointPosition Joints `json:"end_joint_position"`

	// Motion Unique identifier of the motion. Use as reference to execute the motion or to retrieve information on the motion.
	Motion string `json:"motion"`
}

// PlanTrajectoryFailedResponse defines model for PlanTrajectoryFailedResponse.
type PlanTrajectoryFailedResponse struct {
	ErrorFeedback             PlanTrajectoryFailedResponse_ErrorFeedback `json:"error_feedback"`
	ErrorLocationOnTrajectory *float64                                   `json:"error_location_on_trajectory,omitempty"`
	JointTrajectory           *JointTrajectory                           `json:"joint_trajectory,omitempty"`
}

// PlanTrajectoryFailedResponse_ErrorFeedback defines model for PlanTrajectoryFailedResponse.ErrorFeedback.
type PlanTrajectoryFailedResponse_ErrorFeedback struct {
	union json.RawMessage
}

// PlanTrajectoryRequest defines model for PlanTrajectoryRequest.
type PlanTrajectoryRequest struct {
	CollisionMotionGroup *CollisionMotionGroup `json:"collision_motion_group,omitempty"`

	// MotionCommands List of motion commands. A command consists of a path definition (line, circle, joint_ptp, cartesian_ptp, cubic_spline), blending, and limits override.
	MotionCommands []MotionCommand `json:"motion_commands"`

	// RobotSetup The configuration of a motion-group used for motion planning.
	RobotSetup         OptimizerSetup `json:"robot_setup"`
	StartJointPosition DoubleArray    `json:"start_joint_position"`

	// StaticColliders A collection of identifiable colliders.
	StaticColliders *ColliderDictionary `json:"static_colliders,omitempty"`
}

// PlanTrajectoryResponse defines model for PlanTrajectoryResponse.
type PlanTrajectoryResponse struct {
	Response *PlanTrajectoryResponse_Response `json:"response,omitempty"`
}

// PlanTrajectoryResponse_Response defines model for PlanTrajectoryResponse.Response.
type PlanTrajectoryResponse_Response struct {
	union json.RawMessage
}

// Plane Defines an x-y plane with infinite size.
type Plane = map[string]interface{}

// Plane2 Defines an x/y-plane with infinite size.
type Plane2 struct {
	ShapeType string `json:"shape_type"`
}

// Plane3 XY-plane.
type Plane3 struct {
	ShapeType Plane3ShapeType `json:"shape_type"`
}

// Plane3ShapeType defines model for Plane3.ShapeType.
type Plane3ShapeType string

// PlannedMotion defines model for PlannedMotion.
type PlannedMotion struct {
	// JointPositions List of Joint Positions [rad] for eache sample.
	// The number of samples must match the number of timestamps provided in the times field.
	JointPositions []Joints `json:"joint_positions"`

	// Locations Location for each sample, scalar value defining a position along a path. Typical range: 0 to `n`, `n` denoting the number of motion commands.
	// Each integer value of the location corresponds to a specific motion command.
	// If provided, the number of samples must match the number of timestamps provided in the times field.
	Locations *[]float64 `json:"locations,omitempty"`

	// MotionGroup Identifier of the motion group.
	MotionGroup string `json:"motion_group"`

	// Tcp Tool identifier for which this sequence was calculated.
	// Relevant for validation of the tcp-velocities.
	// If not set, the current tool is assumed.
	Tcp *string `json:"tcp,omitempty"`

	// Times Timestamp for each sample [s].
	Times []float64 `json:"times"`
}

// PlannerPose defines model for PlannerPose.
type PlannerPose struct {
	// Orientation A unit quaternion with double precision. The quaternion should be normalized: If interpreted as vector, its length has to be 1.
	Orientation *Quaternion `json:"orientation,omitempty"`

	// Position A 3 dimensional Vector with double precision.
	Position *Vector3d `json:"position,omitempty"`
}

// PlanningLimits All known joint and cartesian limits of a motion-group. Used for motion planning.
type PlanningLimits struct {
	// ElbowAccelerationLimit At maximum one dimensional acceleration in [mm/s^2] at the elbow allowed.
	ElbowAccelerationLimit *float64 `json:"elbow_acceleration_limit,omitempty"`

	// ElbowForceLimit At maximum one dimensional force in [N] at the elbow allowed.
	ElbowForceLimit *float64 `json:"elbow_force_limit,omitempty"`

	// ElbowVelocityLimit At maximum one dimensional velocity in [mm/s] at the elbow allowed.
	ElbowVelocityLimit *float64 `json:"elbow_velocity_limit,omitempty"`

	// JointAccelerationLimits Maximum allowed acceleration for joints in [rad/s^2 or mm/s^2] of the safety
	// setup, starting at base.
	JointAccelerationLimits *[]float64 `json:"joint_acceleration_limits,omitempty"`

	// JointPositionLimits Joint position limits in [rad], configured in the safety setup, starting
	// at base.
	JointPositionLimits *[]PlanningLimitsLimitRange `json:"joint_position_limits,omitempty"`

	// JointTorqueLimits Maximum allowed torque for joints in [Nm or N] of the safety setup, starting
	// at base.
	JointTorqueLimits *[]float64 `json:"joint_torque_limits,omitempty"`

	// JointVelocityLimits Maximum allowed velocity for joints in [rad/s or mm/s] of the safety setup,
	// starting at base.
	JointVelocityLimits *[]float64 `json:"joint_velocity_limits,omitempty"`

	// TcpAccelerationLimit At maximum one dimensional acceleration in [mm/s^2] at TCP allowed.
	TcpAccelerationLimit *float64 `json:"tcp_acceleration_limit,omitempty"`

	// TcpForceLimit At maximum one dimensional force in [N] at TCP allowed.
	TcpForceLimit *float64 `json:"tcp_force_limit,omitempty"`

	// TcpOrientationAccelerationLimit At maximum one dimensional orientation acceleration in [rad/s^2] at TCP allowed.
	TcpOrientationAccelerationLimit *float64 `json:"tcp_orientation_acceleration_limit,omitempty"`

	// TcpOrientationVelocityLimit At maximum one dimensional orientation velocity in [rad/s] at TCP allowed.
	TcpOrientationVelocityLimit *float64 `json:"tcp_orientation_velocity_limit,omitempty"`

	// TcpVelocityLimit At maximum one dimensional velocity in [mm/s] at TCP allowed.
	TcpVelocityLimit *float64 `json:"tcp_velocity_limit,omitempty"`
}

// PlanningLimitsLimitRange The upper_limit must be greater then the lower_limit.
type PlanningLimitsLimitRange struct {
	LowerLimit float64 `json:"lower_limit"`
	UpperLimit float64 `json:"upper_limit"`
}

// PlaybackSpeedRequest Sets velocity for executed movements of the motion, in percent. Send after initializing the connection with InitializeMovementRequest.
type PlaybackSpeedRequest struct {
	// MessageType Type specifier for server, set automatically.
	MessageType *string `json:"message_type,omitempty"`

	// PlaybackSpeedInPercent Sets velocity for executed movements of the trajectory, in percent. 100% means that the motion group moves as
	// fast as possible without violating any planning and motion group limits. Setting this value does not affect the overall shape of the velocity profile.
	// The velocity profile of the trajectory is scaled down by the same factor. Therefore, this should only be used for teaching and trajectory
	// evaluation purposes. To maintain a specific velocity, set the respective limits when planning the trajectory.
	PlaybackSpeedInPercent uint32 `json:"playback_speed_in_percent"`
}

// PlaybackSpeedResponse defines model for PlaybackSpeedResponse.
type PlaybackSpeedResponse struct {
	PlaybackSpeedResponse struct {
		// RequestedValue Value of the requested playback speed in percent [%].
		RequestedValue uint32 `json:"requested_value"`
	} `json:"playback_speed_response"`
}

// PointCloud defines model for PointCloud.
type PointCloud struct {
	Pointcloud string `json:"pointcloud"`
}

// Pose Representing a pose in space with its origin in `coordinate_system`.
// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
type Pose struct {
	// CoordinateSystem Unique identifier addressing the reference coordinate system of the pose.
	// Default is the world coordinate system.
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// Orientation A 3 dimensional Vector with double precision.
	Orientation *Vector3d `json:"orientation,omitempty"`

	// Position A 3 dimensional Vector with double precision.
	Position Vector3d `json:"position"`
}

// Pose2 Defines a pose in 3D space.
// A pose is a combination of a position and an orientation.
// The position is applied before the orientation.
type Pose2 struct {
	// Orientation Defines a rotation in 3D space.
	// A three-dimensional Vector [rx, ry, rz] with double precision.
	// Rotation is applied around the vector.
	// The angle of rotation equals the length of the vector.
	Orientation *RotationVector `json:"orientation,omitempty"`

	// Position Describes a position in 3D space.
	// A three-dimensional vector [x, y, z] with double precision.
	Position *Vector3d2 `json:"position,omitempty"`
}

// ProgramMetadata The metadata of a program.
type ProgramMetadata struct {
	// CreatedDate The date when the program was created.
	CreatedDate string `json:"created_date"`

	// Id The unique identifier of the program.
	Id string `json:"id"`

	// Image The path to the image of the program
	Image *string `json:"image,omitempty"`

	// IsHidden Whether the program is accessible for the enduser or only for the developer.
	IsHidden bool `json:"is_hidden"`

	// LastUpdatedDate The date when the program was last updated.
	LastUpdatedDate string `json:"last_updated_date"`

	// Name The name of the program presented to the enduser.
	Name string `json:"name"`
}

// Quaternion A unit quaternion with double precision. The quaternion should be normalized: If interpreted as vector, its length has to be 1.
type Quaternion struct {
	W float64 `json:"w"`
	X float64 `json:"x"`
	Y float64 `json:"y"`
	Z float64 `json:"z"`
}

// RecipeMetadata The metadata of a recipe.
type RecipeMetadata struct {
	CreatedDate string `json:"created_date"`

	// Id The unique identifier of the recipe.
	Id              *string `json:"id,omitempty"`
	Image           *string `json:"image,omitempty"`
	IsProduction    bool    `json:"is_production"`
	LastUpdatedDate string  `json:"last_updated_date"`
	Name            string  `json:"name"`
	ProgramId       string  `json:"program_id"`
}

// Rectangle Defines an x-y plane with finite size.
type Rectangle struct {
	// SizeX The dimension in x direction in [mm].
	SizeX float64 `json:"size_x"`

	// SizeY The dimension in y direction in [mm].
	SizeY float64 `json:"size_y"`
}

// Rectangle2 Defines an x/y-plane with finite size. Centred around the z-axis.
type Rectangle2 struct {
	ShapeType string `json:"shape_type"`

	// SizeX The dimension in x-direction in [mm].
	SizeX float64 `json:"size_x"`

	// SizeY The dimension in y-direction in [mm].
	SizeY float64 `json:"size_y"`
}

// Rectangle3 Centered in XY-plane.
type Rectangle3 struct {
	ShapeType Rectangle3ShapeType `json:"shape_type"`
	SizeX     float32             `json:"size_x"`
	SizeY     float32             `json:"size_y"`
}

// Rectangle3ShapeType defines model for Rectangle3.ShapeType.
type Rectangle3ShapeType string

// RectangularCapsule A convex hull around four spheres. Sphere center points in x-y-plane, offset by either combination +-sizeX/+-sizeY. Alternative description: Rectangle in x-y-plane with a 3D padding.
type RectangularCapsule struct {
	// Radius The radius of the inner spheres in [mm].
	Radius float64 `json:"radius"`

	// SphereCenterDistanceX The distance of the sphere center in x direction in [mm].
	SphereCenterDistanceX float64 `json:"sphere_center_distance_x"`

	// SphereCenterDistanceY The distance of the sphere center in y direction in [mm].
	SphereCenterDistanceY float64 `json:"sphere_center_distance_y"`
}

// RectangularCapsule2 Convex hull around four spheres. Sphere center points in x/y-plane, offset by either combination "+/- sizeX" or "+/- sizeY".
//
// Alternative description: Rectangle in x/y-plane with a 3D padding.
type RectangularCapsule2 struct {
	// Radius The radius of the inner spheres in [mm].
	Radius    float64 `json:"radius"`
	ShapeType string  `json:"shape_type"`

	// SphereCenterDistanceX The distance of the sphere center in x-direction in [mm].
	SphereCenterDistanceX float64 `json:"sphere_center_distance_x"`

	// SphereCenterDistanceY The distance of the sphere center in y-direction in [mm].
	SphereCenterDistanceY float64 `json:"sphere_center_distance_y"`
}

// RectangularCapsule3 Convex hull around four spheres. Sphere center points in XY-plane, offset by either combination "+/- sizeX" or "+/- sizeY".
//
// Alternative description: Rectangle in x-y-plane with a 3D padding.
type RectangularCapsule3 struct {
	Radius                float32                      `json:"radius"`
	ShapeType             RectangularCapsule3ShapeType `json:"shape_type"`
	SphereCenterDistanceX float32                      `json:"sphere_center_distance_x"`
	SphereCenterDistanceY float32                      `json:"sphere_center_distance_y"`
}

// RectangularCapsule3ShapeType defines model for RectangularCapsule3.ShapeType.
type RectangularCapsule3ShapeType string

// ReleaseChannel The channel that defines what a new Wandelbots NOVA version is.
//
//   - `next` the over all latest version
//   - `stable` newes patch of the current version
type ReleaseChannel string

// RobotController The configuration of a physical or virtual robot controller.
type RobotController struct {
	Configuration ControllerConfig `json:"configuration"`

	// Name A unique name of the Controller inside the Cell. It must be a valid k8s label name as defined by [RFC 1035](https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#rfc-1035-label-names).
	Name string `json:"name"`
}

// ControllerConfig defines model for .
type ControllerConfig struct {
	union json.RawMessage
}

// RobotControllerState Returns the whole current state of robot controller.
type RobotControllerState struct {
	// Controller Identifier of the configured robot controller.
	Controller string `json:"controller"`

	// MotionGroups State of indicated motion groups. In case of state request via controller all configured motion groups are returned. In case of executing a motion only the affected motion groups are returned.
	MotionGroups []MotionGroupState `json:"motion_groups"`

	// OperationMode Current operation mode of the configured robot controller.
	// Operation modes in which the attached motion groups can be moved are:
	// - OPERATION_MODE_MANUAL (if enabling switch is pressed)
	// - OPERATION_MODE_MANUAL_T1 (if enabling switch is pressed)
	// - OPERATION_MODE_MANUAL_T2 (if enabling switch is pressed)
	// - OPERATION_MODE_AUTO (without needing to press enabling switch)
	// All other modes are considered as non-operational.
	OperationMode RobotControllerStateOperationMode `json:"operation_mode"`

	// SafetyState Current safety state of the configured robot controller.
	// Operation modes in which the attached motion groups can be moved are:
	// - SAFETY_STATE_NORMAL
	// - SAFETY_STATE_REDUCED
	// All other modes are considered as non-operational.
	SafetyState RobotControllerStateSafetyState `json:"safety_state"`

	// Timestamp Timestamp indicating when the represented information was received from the robot controller.
	Timestamp time.Time `json:"timestamp"`

	// VelocityOverride If made available by the robot controller, returns the current velocity override in
	// [percentage] for movements adjusted on robot control panel.
	// Valid value range: 1 - 100.
	VelocityOverride *uint32 `json:"velocity_override,omitempty"`
}

// RobotControllerStateOperationMode Current operation mode of the configured robot controller.
// Operation modes in which the attached motion groups can be moved are:
// - OPERATION_MODE_MANUAL (if enabling switch is pressed)
// - OPERATION_MODE_MANUAL_T1 (if enabling switch is pressed)
// - OPERATION_MODE_MANUAL_T2 (if enabling switch is pressed)
// - OPERATION_MODE_AUTO (without needing to press enabling switch)
// All other modes are considered as non-operational.
type RobotControllerStateOperationMode string

// RobotControllerStateSafetyState Current safety state of the configured robot controller.
// Operation modes in which the attached motion groups can be moved are:
// - SAFETY_STATE_NORMAL
// - SAFETY_STATE_REDUCED
// All other modes are considered as non-operational.
type RobotControllerStateSafetyState string

// RobotLinkGeometry Describes a geometry encapsulating a given link from a robot.
type RobotLinkGeometry struct {
	// Geometry A Geometry is defined by a shape and a pose.
	Geometry Geometry `json:"geometry"`

	// LinkIndex Determines how many sets of DH-parameter are applied to get from robot base coordinate system to the link coordinate system in which the geometry is defined.
	LinkIndex uint32 `json:"link_index"`
}

// RobotSystemMode The system mode of the robot system.
//
// ### ROBOT_SYSTEM_MODE_UNDEFINED
//
// Indicates that the robot controller is currently performing a mode transition.
//
// ### ROBOT_SYSTEM_MODE_DISCONNECT
//
// There is no communication with the robot controller at all. All connections are closed.
// No command is sent to the robot controller while in this mode. No IO interaction is possible in this mode!
// All move requests will be rejected in this mode!
//
// ### ROBOT_SYSTEM_MODE_MONITOR
//
// A connection to the robot controller is established to only read the robot controller state.
// No command is sent to the robot controller while in this mode. It is possible to receive IO information.
// All move requests will be rejected in this mode!
//
// ### ROBOT_SYSTEM_MODE_CONTROL
//
// An active connection is established with the robot controller and the robot system is cyclic commanded
// to stay in its actual position. The robot controller state is received in the cycle time of the robot controller.
// Requests via the MotionService and JoggingService will be processed and executed in this mode.
// IO interaction is possible in this mode! **In this mode the robot system can be commanded to move.**
//
// ### ROBOT_SYSTEM_MODE_FREE_DRIVE
//
// Like ROBOT_SYSTEM_MODE_MONITOR a connection to the robot controller is established to only read the robot controller state.
// The difference is that the motion groups can be moved by the user (Free Drive). Thus, the servo motors are turned on.
// All move requests will be rejected in this mode! **This mode is not supported by every robot!**
// Use [getSupportedModes](getSupportedModes) to evaluate if the device support free drive.
type RobotSystemMode string

// RobotTcp defines model for RobotTcp.
type RobotTcp struct {
	// Id Identifier of this tcp.
	Id string `json:"id"`

	// Position A 3 dimensional Vector with double precision.
	Position Vector3d `json:"position"`

	// ReadableName A readable and changeable name for frontend visualization.
	ReadableName *string `json:"readable_name,omitempty"`

	// Rotation Defines rotation angles and their interpretation.
	// Except of QUATERNION the angles are in [rad].
	// Rotation Vector order: X = Vector[0], Y = Vector[1], Z = Vector[2], W = Vector[3].
	Rotation *RotationAngles `json:"rotation,omitempty"`
}

// RobotTcps defines model for RobotTcps.
type RobotTcps struct {
	Tcps []RobotTcp `json:"tcps"`
}

// RotationAngleTypes The type of rotation description that is used to specify the rotation.
//
// **Quaternion notation**
//
// * The rotation is represented using a quaternion: [x, y, z, w].
// * The vector part [x, y, z] is the imaginary part of the quaternion, and the scalar part [w] is the real part.
//
// **Rotation Vector notation**
//
// * The rotation is represented using an axis-angle representation:
// > axis = Vector[0:2]
// > angle = |axis| in [rad]
// > axis.normalized * angle
//
// **Euler notation**
//
// * *extrinsic* fixed external reference system
// * *intrinsic* reference system fixed to rotation body
// > angles = Vector[0:2] in [rad].
// * ZYX, ZXZ,...
//   - mapping of the given angles values to the (either intrinsic
//     or extrinsic) axes in the stated order.
//     > Example ZYX: Z = Vector[0], Y = Vector[1], X = Vector[2].
type RotationAngleTypes string

// RotationAngles Defines rotation angles and their interpretation.
// Except of QUATERNION the angles are in [rad].
// Rotation Vector order: X = Vector[0], Y = Vector[1], Z = Vector[2], W = Vector[3].
type RotationAngles struct {
	// Angles The values for the rotation notation.
	Angles []float64 `json:"angles"`

	// Type The type of rotation description that is used to specify the rotation.
	//
	// **Quaternion notation**
	//
	// * The rotation is represented using a quaternion: [x, y, z, w].
	// * The vector part [x, y, z] is the imaginary part of the quaternion, and the scalar part [w] is the real part.
	//
	// **Rotation Vector notation**
	//
	// * The rotation is represented using an axis-angle representation:
	// > axis = Vector[0:2]
	// > angle = |axis| in [rad]
	// > axis.normalized * angle
	//
	// **Euler notation**
	//
	// * *extrinsic* fixed external reference system
	// * *intrinsic* reference system fixed to rotation body
	// > angles = Vector[0:2] in [rad].
	// * ZYX, ZXZ,...
	//   - mapping of the given angles values to the (either intrinsic
	//     or extrinsic) axes in the stated order.
	//  > Example ZYX: Z = Vector[0], Y = Vector[1], X = Vector[2].
	Type RotationAngleTypes `json:"type"`
}

// RotationVector Defines a rotation in 3D space.
// A three-dimensional Vector [rx, ry, rz] with double precision.
// Rotation is applied around the vector.
// The angle of rotation equals the length of the vector.
type RotationVector = []float64

// SafetyConfiguration The safety configuration of a motion-group. Used for motion planning.
type SafetyConfiguration struct {
	// GlobalLimits All known joint and cartesian limits of a motion-group. Used for motion planning.
	GlobalLimits PlanningLimits `json:"global_limits"`

	// RobotModelGeometries The shape of the motion-group to validate against SafetyZones.
	RobotModelGeometries *[]RobotLinkGeometry `json:"robot_model_geometries,omitempty"`

	// SafetyZoneLimits All limits applied in certain SafetyZones.
	SafetyZoneLimits *[]SafetyZoneLimits `json:"safety_zone_limits,omitempty"`

	// SafetyZones SafetyZones are areas which cannot be entered or impose certain limits.
	SafetyZones *[]SafetyZone `json:"safety_zones,omitempty"`

	// TcpGeometries The shape of the TCP to validate against SafetyZones.
	TcpGeometries *[]Geometry `json:"tcp_geometries,omitempty"`
}

// SafetySetup defines model for SafetySetup.
type SafetySetup struct {
	RobotModelGeometries *[]RobotLinkGeometry         `json:"robot_model_geometries,omitempty"`
	SafetySettings       *[]SafetySetupSafetySettings `json:"safety_settings,omitempty"`
	SafetyZones          *[]SafetySetupSafetyZone     `json:"safety_zones,omitempty"`
	ToolGeometries       *[]ToolGeometry              `json:"tool_geometries,omitempty"`
}

// SafetySetupSafetySettings Restricts the robot movements due to the safety configuration.
type SafetySetupSafetySettings struct {
	// SafetyState The safety state that the settings are valid for.
	SafetyState *SafetySetupSafetySettingsSafetyState `json:"safety_state,omitempty"`

	// Settings NOTE: if a joint or Cartesian limit is not set or present for the corresponding device, then the value is not present (in the list or the optional value is null). The unit depends on the kind of axis (rotational or linear).
	Settings *LimitSettings `json:"settings,omitempty"`
}

// SafetySetupSafetySettingsSafetyState The safety state that the settings are valid for.
type SafetySetupSafetySettingsSafetyState string

// SafetySetupSafetyZone Describes the physical space in which the safety limitations will be applied.
type SafetySetupSafetyZone struct {
	// Geometry A Geometry is defined by a shape and a pose.
	Geometry *Geometry `json:"geometry,omitempty"`

	// Id A unique identifier.
	Id *uint32 `json:"id,omitempty"`

	// MotionGroupUid Unique identifier of an specific motion-group if the safety zone only applies to it.
	// If it is not set, then the safety zone applies to all motion-groups.
	MotionGroupUid *uint32 `json:"motion_group_uid,omitempty"`

	// Priority The precedence if two zones overlap.
	Priority *uint32 `json:"priority,omitempty"`
}

// SafetyZone A zone where the MotionGroup cannot enter or certain limits apply.
type SafetyZone struct {
	// Geometry A Geometry is defined by a shape and a pose.
	Geometry Geometry `json:"geometry"`

	// Id A unique identifier.
	Id uint32 `json:"id"`

	// Priority The precedence if multiple zones overlap.
	Priority uint32 `json:"priority"`
}

// SafetyZoneLimits All limits which apply within a single safety zone.
type SafetyZoneLimits struct {
	// Limits All known joint and cartesian limits of a motion-group. Used for motion planning.
	Limits     PlanningLimits `json:"limits"`
	SafetyZone uint32         `json:"safety_zone"`
}

// SafetyZoneViolation Safety zone violations occur when a motion is planned within a safety zone set on the controller.
// The message description indicates which part of the motion group collides with which safety zone.
type SafetyZoneViolation struct {
	Description *string `json:"description,omitempty"`
}

// ServiceStatus defines model for ServiceStatus.
type ServiceStatus struct {
	Service string `json:"service"`
	Status  struct {
		Code     ServiceStatusPhase    `json:"code"`
		Reason   *string               `json:"reason,omitempty"`
		Severity ServiceStatusSeverity `json:"severity"`
	} `json:"status"`
}

// ServiceStatusList defines model for ServiceStatusList.
type ServiceStatusList = []ServiceStatus

// ServiceStatusPhase defines model for ServiceStatusPhase.
type ServiceStatusPhase string

// ServiceStatusSeverity defines model for ServiceStatusSeverity.
type ServiceStatusSeverity string

// SetIO Defines an I/O that should be set upon reaching a certain location on the trajectory.
type SetIO struct {
	// Io I/O value representation. Depending on the I/O type, only one of the value fields will be set.
	Io IOValue `json:"io"`

	// Location The location on the trajectory where the I/O should be set.
	Location float64 `json:"location"`
}

// SetPlaybackSpeed Set the velocity for executed movements of the motion in percent.
type SetPlaybackSpeed struct {
	// Motion This represents the UUID of a motion.
	// Every executable or partially executable motion is cached and an UUID is returned.
	// Indicate the UUID to execute the motion or retrieve information on the motion.
	Motion string `json:"motion"`

	// PlaybackSpeedInPercent Set the velocity for executed movements of the motion in percent. A percentage of 100% means that the robot moves as
	// fast as possible without violating the limits. Setting this value does not affect the overall shape of the velocity profile.
	// Everything is slowed down by the same factor. Therefore, this should only be used for teaching and trajectory
	// evaluation purposes. If the process requires a certain velocity, the respective limits should be set when planning the motion.
	// This will not change the velocity override of the controller. The controller velocity override value shall be 100% to ensure
	// controllability of the motion group.
	PlaybackSpeedInPercent uint32 `json:"playback_speed_in_percent"`
}

// SingleJointLimit A joint limit can contain a position (rad or mm), a velocity (rad/s or mm/s), an acceleration (rad/s² or mm/s²) or a jerk (rad/s³ or mm/s³).
type SingleJointLimit struct {
	// Joint Definition of the joint where the limits are applied.
	Joint SingleJointLimitJoint `json:"joint"`

	// Limit Limit, unit depends on usage of this message structure.
	Limit float64 `json:"limit"`
}

// SingleJointLimitJoint Definition of the joint where the limits are applied.
type SingleJointLimitJoint string

// Singularity A Singularity is a point in the robot's workspace where the robot loses one or more degrees of freedom with regards to moving its TCP.
// This means the robot cannot move or rotate the TCP in a certain direction from this specific point.
//
// The singularity type is the type of singularity that the robot is in.
// The singular joint position is the joint position of the robot when it is in a singularity.
type Singularity struct {
	// SingularJointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	SingularJointPosition *Joints                     `json:"singular_joint_position,omitempty"`
	SingularityType       *SingularitySingularityType `json:"singularity_type,omitempty"`
}

// SingularitySingularityType defines model for Singularity.SingularityType.
type SingularitySingularityType string

// SingularityTypeEnum defines model for SingularityTypeEnum.
type SingularityTypeEnum string

// Sphere Defines a spherical shape centered around an origin.
type Sphere struct {
	// Radius The radius of the sphere in [mm].
	Radius float64 `json:"radius"`
}

// Sphere2 Defines a spherical shape centred around the origin.
type Sphere2 struct {
	// Radius The radius of the sphere in [mm].
	Radius    float64 `json:"radius"`
	ShapeType string  `json:"shape_type"`
}

// Sphere3 Centered around origin.
type Sphere3 struct {
	Radius    float32          `json:"radius"`
	ShapeType Sphere3ShapeType `json:"shape_type"`
}

// Sphere3ShapeType defines model for Sphere3.ShapeType.
type Sphere3ShapeType string

// Standstill The response will be sent one time at the end of every execution signalling that the motion group has stopped moving.
type Standstill struct {
	Standstill struct {
		Location float64 `json:"location"`

		// Reason The reason why the movement is paused.
		Reason StandstillReason `json:"reason"`

		// State Returns the whole current state of robot controller.
		State RobotControllerState `json:"state"`
	} `json:"standstill"`
}

// StandstillReason The reason why the movement is paused.
type StandstillReason string

// StartJointsMissing Error in case no start joint position was provided.
// Every motion needs to start with a joint position as reference to uniquely define the kinematic configuration of the motion-group at the start the motion.
type StartJointsMissing = map[string]interface{}

// StartMovementRequest Moves the motion group along a trajectory, added via [planTrajectory](planTrajectory) or [planMotion](planMotion).
// Trajectories can be executed forwards or backwards("in reverse").
//
// Pause the execution with PauseMovementRequest.
// Resume execution with StartMovementRequest.
//
// Precondition: To start execution, the motion group must be located at the trajectory's start location specified in InitializeMovementRequest.
type StartMovementRequest struct {
	// Direction The direction in which the trajectory is executed. Default: Forward.
	Direction *Direction `json:"direction,omitempty"`

	// MessageType Type specifier for server, set automatically.
	MessageType *string `json:"message_type,omitempty"`

	// PauseOnIo Defines an I/O that the motion will be paused for. The motion will stop gracefully on path.
	PauseOnIo *PauseOnIO `json:"pause_on_io,omitempty"`

	// SetIos Attaches a list of I/O commands to the trajectory. The I/Os are set to the specified values right after the specified location was reached.
	// If the specified location is located before the start location (forward direction: value is smaller, backward direction: value is bigger), the I/O is not set.
	SetIos *[]SetIO `json:"set_ios,omitempty"`

	// StartOnIo Defines an I/O that the motion should wait for to start the execution.
	StartOnIo *StartOnIO `json:"start_on_io,omitempty"`
}

// StartOnIO Defines an I/O that the motion should wait for to start the execution.
type StartOnIO struct {
	// Comparator Comparator for the comparison of two values.
	// The comparator is used to compare two values and return a boolean result.
	// The default comparator is unknown.
	Comparator Comparator `json:"comparator"`

	// Io I/O value representation. Depending on the I/O type, only one of the value fields will be set.
	Io IOValue `json:"io"`
}

// Status The `Status` type defines a logical error model that is suitable for different
// programming environments including REST APIs and RPC APIs. It is used by
// [gRPC](https://github.com/grpc). Each `status` message contains three pieces
// of data: error code, error message, and error details. You can find out more
// about this error model and how to work with it in the [API Design
// Guide](https://cloud.google.com/apis/design/errors).
type Status struct {
	// Code The status code, which should be an enum value of
	// [google.rpc.Code](https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto).
	Code *int32 `json:"code,omitempty"`

	// Details A list of messages that carry the error details. There is a common set of
	// message types for APIs to use.
	// > Currently, this is unused.
	Details *[]GoogleProtobufAny `json:"details,omitempty"`

	// Message An error message in English.
	Message *string `json:"message,omitempty"`
}

// StopResponse The response will be sent once at the end of every motion signalling that the motion group has stopped moving.
type StopResponse struct {
	LocationOnTrajectory float64 `json:"location_on_trajectory"`

	// Message Will provide detailed information about the reason for stopping.
	Message  *string              `json:"message,omitempty"`
	StopCode StopResponseStopCode `json:"stop_code"`
}

// StopResponseStopCode defines model for StopResponse.StopCode.
type StopResponseStopCode string

// StreamMoveBackward defines model for StreamMoveBackward.
type StreamMoveBackward struct {
	// Backward Moves the motion group forward or backward along a previously planned motion.
	//
	// Once started, you can stop a motion using the [stop](StreamStop) endpoint.
	//
	// Prerequisite, before starting the motion execution:
	//   - The motion group is currently at the endpoint of the planned motion.
	Backward MoveRequest `json:"backward"`
}

// StreamMoveForward defines model for StreamMoveForward.
type StreamMoveForward struct {
	// Forward Moves the motion group forward or backward along a previously planned motion.
	//
	// Once started, you can stop a motion using the [stop](StreamStop) endpoint.
	//
	// Prerequisite, before starting the motion execution:
	//   - The motion group is currently at the endpoint of the planned motion.
	Forward MoveRequest `json:"forward"`
}

// StreamMovePlaybackSpeed defines model for StreamMovePlaybackSpeed.
type StreamMovePlaybackSpeed struct {
	// PlaybackSpeed Set the velocity for executed movements of the motion in percent.
	PlaybackSpeed SetPlaybackSpeed `json:"playback_speed"`
}

// StreamMoveResponse The stream will return MoveResponse repeatedly as long as defined in `response_rate` until the movement is
// completed. Finally, a single StopResponse is returned and the stream is closed.
type StreamMoveResponse struct {
	MoveResponse *MoveResponse `json:"move_response,omitempty"`

	// State Returns the whole current state of robot controller.
	State *RobotControllerState `json:"state,omitempty"`

	// StopResponse The response will be sent once at the end of every motion signalling that the motion group has stopped moving.
	StopResponse *StopResponse `json:"stop_response,omitempty"`
}

// StreamMoveToTrajectory defines model for StreamMoveToTrajectory.
type StreamMoveToTrajectory struct {
	// ToTrajectory Request to move the motion group via joint point-to-point to a given location on a planned motion.
	// You must use this endpoint in order to start moving from an arbritrary location of the trajectory.
	// Afterwards, you are able to call [streamMoveForward](streamMoveForward) or [streamMoveBackward](streamMoveBackward) to move along planned motion.
	// Use the [stopExecution](stopExecution) endpoint to stop the motion gracefully.
	ToTrajectory MoveToTrajectoryViaJointPTPRequest `json:"to_trajectory"`
}

// StreamStop defines model for StreamStop.
type StreamStop struct {
	Stop MotionId `json:"stop"`
}

// TcpPose Representing a robot pose in operational space aware of a configured TCP.
type TcpPose struct {
	// CoordinateSystem Unique name of base coordinate system, if empty world is used.
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// Orientation A 3 dimensional Vector with double precision.
	Orientation Vector3d `json:"orientation"`

	// Position A 3 dimensional Vector with double precision.
	Position Vector3d `json:"position"`

	// Tcp Identifier of tcp on controller.
	Tcp string `json:"tcp"`
}

// TcpPoseRequest Request to compute the TCP pose for a single joint position sample.
type TcpPoseRequest struct {
	// CoordinateSystem Unique identifier of the base coordinate system of the calculated pose.
	// Optional. If empty, world is used.
	CoordinateSystem *string `json:"coordinate_system,omitempty"`

	// JointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointPosition Joints `json:"joint_position"`

	// MotionGroup Unique identifier of the motion-group.
	MotionGroup string `json:"motion_group"`

	// Tcp Specifies the TCP at which the pose is calculated via its unique identifier.
	// Optional. If not provided, the currently active TCP is used.
	Tcp *string `json:"tcp,omitempty"`
}

// Tool Defines the shape of a tool.
//
// A tool is a dictionary of colliders.
//
// All colliders that make up a tool are attached to the flange frame of the motion group.
type Tool map[string]Collider

// ToolGeometry Describes a geometry encapsulating a given tool from a robot.
type ToolGeometry struct {
	// Geometries The shape of the tool to validate against SafetyZones.
	Geometries *[]Geometry `json:"geometries,omitempty"`

	// Tcp Identifier of this tcp.
	Tcp string `json:"tcp"`
}

// TrajectorySample A sample of a trajectory is a single point of the trajectory at a specific location.
type TrajectorySample struct {
	// JointAcceleration This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointAcceleration *Joints `json:"joint_acceleration,omitempty"`

	// JointPosition This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointPosition *Joints `json:"joint_position,omitempty"`

	// JointTorques This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointTorques *Joints `json:"joint_torques,omitempty"`

	// JointVelocity This structure describes a set of joint values of a motion group.
	// We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
	// `joints` must have as many entries as the motion group's degrees of freedom to be valid.
	// Float precision is the default.
	JointVelocity *Joints `json:"joint_velocity,omitempty"`

	// LocationOnTrajectory location on trajectory
	LocationOnTrajectory *float64 `json:"location_on_trajectory,omitempty"`

	// TcpAcceleration [mm/s^2]
	TcpAcceleration *float64 `json:"tcp_acceleration,omitempty"`

	// TcpOrientationAcceleration [rad/s^2]
	TcpOrientationAcceleration *float64 `json:"tcp_orientation_acceleration,omitempty"`

	// TcpOrientationVelocity [rad/s]
	TcpOrientationVelocity *float64 `json:"tcp_orientation_velocity,omitempty"`

	// TcpPose Representing a pose in space with its origin in `coordinate_system`.
	// A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
	TcpPose *Pose `json:"tcp_pose,omitempty"`

	// TcpVelocity [mm/s]
	TcpVelocity *float64 `json:"tcp_velocity,omitempty"`

	// Time [s]
	Time *float64 `json:"time,omitempty"`
}

// UniversalrobotsController The configuration of a physical Universal Robots controller has to contain IP address of the controller.
type UniversalrobotsController struct {
	ControllerIp string                        `json:"controllerIp"`
	Kind         UniversalrobotsControllerKind `json:"kind,omitempty"`
}

// UniversalrobotsControllerKind defines model for UniversalrobotsController.Kind.
type UniversalrobotsControllerKind string

// UpdateProgramMetadataRequest This message is used to update the metadata of a program.
// Only the set fields get updated.
type UpdateProgramMetadataRequest struct {
	Image    *string `json:"image,omitempty"`
	IsHidden *bool   `json:"is_hidden,omitempty"`
	Name     *string `json:"name,omitempty"`
}

// UpdateRecipeMetadataRequest This message is used to update the metadata of a recipe.
// Only the set fields get updated.
type UpdateRecipeMetadataRequest struct {
	IsProduction *bool   `json:"is_production,omitempty"`
	Name         *string `json:"name,omitempty"`
	ProgramId    *string `json:"program_id,omitempty"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Loc  []ValidationError_Loc_Item `json:"loc"`
	Msg  string                     `json:"msg"`
	Type string                     `json:"type"`
}

// ValidationErrorLoc0 defines model for .
type ValidationErrorLoc0 = string

// ValidationErrorLoc1 defines model for .
type ValidationErrorLoc1 = int

// ValidationError_Loc_Item defines model for ValidationError.loc.Item.
type ValidationError_Loc_Item struct {
	union json.RawMessage
}

// Vector3d A 3 dimensional Vector with double precision.
type Vector3d struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
	Z float64 `json:"z"`
}

// Vector3d2 Describes a position in 3D space.
// A three-dimensional vector [x, y, z] with double precision.
type Vector3d2 = []float64

// VersionNumber A generic representation of a version number.
type VersionNumber struct {
	BugfixVersion *uint32 `json:"bugfix_version,omitempty"`

	// BugfixVersionWildcard If bugfix version is a wildcard set to true.
	BugfixVersionWildcard *bool   `json:"bugfix_version_wildcard,omitempty"`
	BuildVersion          *uint32 `json:"build_version,omitempty"`

	// BuildVersionWildcard If build version is a wildcard set to true.
	BuildVersionWildcard *bool   `json:"build_version_wildcard,omitempty"`
	MajorVersion         uint32  `json:"major_version"`
	MinorVersion         *uint32 `json:"minor_version,omitempty"`

	// MinorVersionWildcard If minor version is a wildcard set to true.
	MinorVersionWildcard *bool `json:"minor_version_wildcard,omitempty"`

	// StringVersion A string representation of the version e.g. 1.1.x.x.
	StringVersion *string `json:"string_version,omitempty"`
}

// VirtualController The configuration of a virtual robot controller has to contain the manufacturer string,
// an optional joint position string array and either a type or the full JSON configuration.
// The JSON config of a physical controller can be obtained via `/cells/{cell}/controllers/{controller}/virtual-robot-configuration`
type VirtualController struct {
	Json         *string               `json:"json,omitempty"`
	Kind         VirtualControllerKind `json:"kind,omitempty"`
	Manufacturer Manufacturer          `json:"manufacturer"`

	// Position Initial joint position of the first motion group from the virtual robot controller.
	// Provide the joint position as a JSON array containing 7 float values,
	// each representing a joint position in radians, e.g. "[0, 0, 0, 0, 0, 0, 0]". If the robot has fewer than 7 joints,
	// use "0" for each remaining position to ensure the array has exactly 7 values.
	Position *string                 `json:"position,omitempty"`
	Type     *VirtualControllerTypes `json:"type,omitempty"`
}

// VirtualControllerKind defines model for VirtualController.Kind.
type VirtualControllerKind string

// VirtualControllerTypes defines model for VirtualControllerTypes.
type VirtualControllerTypes string

// VirtualRobotConfiguration defines model for VirtualRobotConfiguration.
type VirtualRobotConfiguration struct {
	// Content Content of the configuration file. Copy & paste to the [addRobotController](addRobotController) configuration.json parameter.
	Content string `json:"content"`

	// Name Name of the configuration file generated by the unique identifier of the controller and a time stamp.
	Name string `json:"name"`
}

// YaskawaController The configuration of a physical Yaskawa robot controller has to contain IP address of the controller.
type YaskawaController struct {
	ControllerIp string                `json:"controllerIp"`
	Kind         YaskawaControllerKind `json:"kind,omitempty"`
}

// YaskawaControllerKind defines model for YaskawaController.Kind.
type YaskawaControllerKind string

// ProgramRunObject defines model for program_run_object.
type ProgramRunObject struct {
	// CreatedAt ISO 8601 date-time format when the program run was created.
	CreatedAt time.Time `json:"created_at"`

	// Id The identifier of the program run.
	Id string `json:"id"`

	// LastUpdatedAt ISO 8601 date-time format when the program run was last updated.
	LastUpdatedAt time.Time `json:"last_updated_at"`

	// ProgramId The identifier of the program stored in the program library.
	ProgramId string `json:"program_id"`

	// ProgramOutput The output of the program run, which provides the output generate while running the program.
	ProgramOutput *string `json:"program_output,omitempty"`

	// Status The status of the program run which shows which state the program run is currently is in.
	Status string `json:"status"`
}

// PyjectoryDatatypesCoreOrientation defines model for pyjectory__datatypes__core__Orientation.
type PyjectoryDatatypesCoreOrientation = []interface{}

// PyjectoryDatatypesCorePose A pose (position and orientation)
type PyjectoryDatatypesCorePose struct {
	Orientation PyjectoryDatatypesCoreOrientation `json:"orientation"`
	Position    PyjectoryDatatypesCorePosition    `json:"position"`
}

// PyjectoryDatatypesCorePosition defines model for pyjectory__datatypes__core__Position.
type PyjectoryDatatypesCorePosition = []interface{}

// PyjectoryDatatypesSerializerOrientation Rotation vector, defined in [rx, ry, rz] with floating numbers.
// The rotation is represented in vector3 using an axis-angle representation: axis.normalized * angle (angle in radians).
// Must be defined for the first pose of a path. If not defined for the rest of the path,
// the previous orientation will be used.
type PyjectoryDatatypesSerializerOrientation struct {
	Orientation []interface{} `json:"orientation"`
}

// PyjectoryDatatypesSerializerPose Object's position and orientaton, defined in [x, y, z, rx, ry, rz].
// x,y,z are defined in millimeters.
// rx,ry,rz are defined in radians.
type PyjectoryDatatypesSerializerPose struct {
	Pose []interface{} `json:"pose"`
}

// PyjectoryDatatypesSerializerPosition Single point, defined in [x, y, z] with floating numbers. Must be defined.
type PyjectoryDatatypesSerializerPosition struct {
	Position []interface{} `json:"position"`
}

// PyripheryEtcdETCDConfiguration Configuration of the etcd client
//
// This configuration is necessary to add an etcd server as device to the cell.
// The etcd server itself is running in the cell by default.
//
// [etcd](https://etcd.io/) is a distributed, reliable key-value store that can be used
// to store values which can be
// addressed by Wandelscript in advanced Wandelscript programs.
//
// Args:
//
//	identifier: the identifier name for etcd
//	host: The host name.  Default is 'etcd'.
//	port : The port defined in the etcd manifest file. The default is 2379.
type PyripheryEtcdETCDConfiguration struct {
	Host       *string      `json:"host,omitempty"`
	Identifier *string      `json:"identifier,omitempty"`
	Port       *int         `json:"port,omitempty"`
	Type       *interface{} `json:"type,omitempty"`
}

// PyripheryHardwareIsaacIsaacConfiguration The configuration of the Omniservice
type PyripheryHardwareIsaacIsaacConfiguration struct {
	Host       *string            `json:"host,omitempty"`
	Identifier *string            `json:"identifier,omitempty"`
	PrimPaths  *map[string]string `json:"prim_paths,omitempty"`
	Type       *interface{}       `json:"type,omitempty"`
}

// PyripheryOpcuaOPCUAConfiguration Configuration of the OPCUAConnector
//
// Args:
//
//	url: The URL of the OPC UA service
type PyripheryOpcuaOPCUAConfiguration struct {
	Identifier *string      `json:"identifier,omitempty"`
	Type       *interface{} `json:"type,omitempty"`
	Url        *string      `json:"url,omitempty"`
}

// PyripheryPyraeControllerControllerConfiguration Configuration of a Robot Controller.
//
// This will configure the robot controller such that it is controllable through Wandelscript.
//
// This is for advanced users only: it should not be necessary to change this configuration in most use cases.
type PyripheryPyraeControllerControllerConfiguration struct {
	ControllerModelName *string      `json:"controller_model_name,omitempty"`
	Host                *string      `json:"host,omitempty"`
	Identifier          *string      `json:"identifier,omitempty"`
	RaeHost             *string      `json:"rae_host,omitempty"`
	RaePort             *int         `json:"rae_port,omitempty"`
	Type                *interface{} `json:"type,omitempty"`
}

// PyripheryRoboticsConfigurableCollisionSceneConfigurableCollisionSceneConfigurationInput defines model for pyriphery__robotics__configurable_collision_scene__ConfigurableCollisionScene__Configuration-Input.
type PyripheryRoboticsConfigurableCollisionSceneConfigurableCollisionSceneConfigurationInput struct {
	// Identifier A unique identifier for the collision scene.
	Identifier *string `json:"identifier,omitempty"`

	// RobotConfigurations Configurations for robots within the scene. Allow for the specification of collision geometries and
	// other robot-specific settings, identified by robot names.
	RobotConfigurations *map[string]CollisionRobotConfigurationInput `json:"robot_configurations,omitempty"`

	// StaticColliders A collection of static colliders within the scene, identified by their names.
	StaticColliders *map[string]ColliderInput `json:"static_colliders,omitempty"`

	// Type This device is experimental and might experience functional changes in the future.
	//
	// The configuration of the collision scene. This configuration is used to create a collision scene for planning
	// at the start of a program execution. The scene can then be modified by the program.
	//
	// Note that in a cell with multiple robots only sequential robot motions are correctly checked for
	// collisions. Use simultaneous motions of multiple robots at your own risk.
	Type *interface{} `json:"type,omitempty"`
}

// PyripheryRoboticsRobotcellTimerConfiguration defines model for pyriphery__robotics__robotcell__Timer__Configuration.
type PyripheryRoboticsRobotcellTimerConfiguration struct {
	Identifier *string                                           `json:"identifier,omitempty"`
	Type       *PyripheryRoboticsRobotcellTimerConfigurationType `json:"type,omitempty"`
}

// PyripheryRoboticsRobotcellTimerConfigurationType defines model for PyripheryRoboticsRobotcellTimerConfiguration.Type.
type PyripheryRoboticsRobotcellTimerConfigurationType string

// PyripheryRoboticsSimulationRobotWithViewOpen3dConfiguration The configuration of a simulated robot
//
// Args:
//
//	initial_pose: The start pose of the robot, None means it is unknown
type PyripheryRoboticsSimulationRobotWithViewOpen3dConfiguration struct {
	Identifier  *string      `json:"identifier,omitempty"`
	InitialPose *[]float32   `json:"initial_pose,omitempty"`
	Type        *interface{} `json:"type,omitempty"`
}

// PyripheryRoboticsSimulationSimulatedIOConfiguration defines model for pyriphery__robotics__simulation__SimulatedIO__Configuration.
type PyripheryRoboticsSimulationSimulatedIOConfiguration struct {
	Identifier *string      `json:"identifier,omitempty"`
	Type       *interface{} `json:"type,omitempty"`
}

// PyripheryRoboticsSimulationSimulatedOPCUAConfiguration defines model for pyriphery__robotics__simulation__SimulatedOPCUA__Configuration.
type PyripheryRoboticsSimulationSimulatedOPCUAConfiguration struct {
	Identifier *string      `json:"identifier,omitempty"`
	Type       *interface{} `json:"type,omitempty"`
}

// TriggerObject defines model for trigger_object.
type TriggerObject struct {
	Config TriggerObject_Config `json:"config"`

	// CreatedAt ISO 8601 date-time format when the trigger was created.
	CreatedAt time.Time `json:"created_at"`

	// Enabled Indicates whether the trigger is enabled or not.
	Enabled bool `json:"enabled"`

	// Id The identifier of the trigger.
	Id *string `json:"id,omitempty"`

	// LastUpdatedAt ISO 8601 date-time format when the trigger was last updated.
	LastUpdatedAt time.Time `json:"last_updated_at"`

	// ProgramId The identifier of the program to run when the trigger condition is met.
	ProgramId string `json:"program_id"`

	// ProgramRuns The program runs that were triggered by this trigger.
	ProgramRuns *[]string `json:"program_runs,omitempty"`

	// Type The type of the trigger.
	Type TriggerType `json:"type"`
}

// TriggerObject_Config defines model for TriggerObject.Config.
type TriggerObject_Config struct {
	union json.RawMessage
}

// TriggerType The type of the trigger.
type TriggerType string

// AppID The name of the provided application.
// The name must be unique within the cell and is used as a identifier for addressing the application in all API calls, e.g. when updating the application.
type AppID = string

// CellID defines model for Cell.
type CellID = string

// ColliderID defines model for Collider.
type ColliderID = string

// ControllerID defines model for Controller.
type ControllerID = string

// CoordinateSystem defines model for CoordinateSystem.
type CoordinateSystem = string

// IO defines model for IO.
type IO = string

// Id defines model for Id.
type Id = uint32

// LinkChainID defines model for LinkChain.
type LinkChainID = string

// Motion defines model for Motion.
type Motion = string

// MotionGroup defines model for MotionGroup.
type MotionGroup = string

// MotionGroupModel defines model for MotionGroupModel.
type MotionGroupModel string

// PlaybackSpeed defines model for PlaybackSpeed.
type PlaybackSpeed = uint32

// Program Recieved from [listProgramMetadata](listProgramMetadata) or from the response of [createProgram](createProgram).
type Program = string

// Recipe Recieved from [listRecipeMetadata](listRecipeMetadata) or from the response of [createRecipe](createRecipe).
type Recipe = string

// ResponseCoordinateSystem defines model for ResponseCoordinateSystem.
type ResponseCoordinateSystem = string

// ResponseRate defines model for ResponseRate.
type ResponseRate = uint32

// SceneID defines model for Scene.
type SceneID = string

// TCP defines model for TCP.
type TCP = string

// Tcp defines model for Tcp.
type Tcp = string

// CompletionTimeout The maximum time (**in seconds**) spent waiting until the operation is complete.
//
// If the parameter is set, the request will wait for completion until the specified time is up.
// For POST and PUT requests completion means that all resources are running and usable.
// For DELETE completion means that the deletion process is completed.
type CompletionTimeout = int

// ToolID defines model for Tool.
type ToolID = string

// DefaultErrorResponse The `Status` type defines a logical error model that is suitable for different
// programming environments including REST APIs and RPC APIs. It is used by
// [gRPC](https://github.com/grpc). Each `status` message contains three pieces
// of data: error code, error message, and error details. You can find out more
// about this error model and how to work with it in the [API Design
// Guide](https://cloud.google.com/apis/design/errors).
type DefaultErrorResponse = Status

// NotFound defines model for NotFound.
type NotFound = Error

// DeployCellParams defines parameters for DeployCell.
type DeployCellParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// DeleteCellParams defines parameters for DeleteCell.
type DeleteCellParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// UpdateCellParams defines parameters for UpdateCell.
type UpdateCellParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// ClearAppsParams defines parameters for ClearApps.
type ClearAppsParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// AddAppParams defines parameters for AddApp.
type AddAppParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// DeleteAppParams defines parameters for DeleteApp.
type DeleteAppParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// UpdateAppParams defines parameters for UpdateApp.
type UpdateAppParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// ClearRobotControllersParams defines parameters for ClearRobotControllers.
type ClearRobotControllersParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// AddRobotControllerParams defines parameters for AddRobotController.
type AddRobotControllerParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// DeleteRobotControllerParams defines parameters for DeleteRobotController.
type DeleteRobotControllerParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// UpdateRobotControllerParams defines parameters for UpdateRobotController.
type UpdateRobotControllerParams struct {
	CompletionTimeout *CompletionTimeout `form:"completionTimeout,omitempty" json:"completionTimeout,omitempty"`
}

// StreamFreeDriveParams defines parameters for StreamFreeDrive.
type StreamFreeDriveParams struct {
	ResponseRate *uint32 `form:"response_rate,omitempty" json:"response_rate,omitempty"`
}

// ListIODescriptionsParams defines parameters for ListIODescriptions.
type ListIODescriptionsParams struct {
	Ios *[]string `form:"ios,omitempty" json:"ios,omitempty"`
}

// StreamIOValuesParams defines parameters for StreamIOValues.
type StreamIOValuesParams struct {
	Ios *[]string `form:"ios,omitempty" json:"ios,omitempty"`
}

// ListIOValuesParams defines parameters for ListIOValues.
type ListIOValuesParams struct {
	Ios *[]string `form:"ios,omitempty" json:"ios,omitempty"`
}

// SetOutputValuesJSONBody defines parameters for SetOutputValues.
type SetOutputValuesJSONBody = []IOValue

// WaitForIOEventParams defines parameters for WaitForIOEvent.
type WaitForIOEventParams struct {
	Io             string                             `form:"io" json:"io"`
	ComparisonType WaitForIOEventParamsComparisonType `form:"comparison_type" json:"comparison_type"`
	BooleanValue   *bool                              `form:"boolean_value,omitempty" json:"boolean_value,omitempty"`
	IntegerValue   *string                            `form:"integer_value,omitempty" json:"integer_value,omitempty"`
	FloatingValue  *float64                           `form:"floating_value,omitempty" json:"floating_value,omitempty"`
}

// WaitForIOEventParamsComparisonType defines parameters for WaitForIOEvent.
type WaitForIOEventParamsComparisonType string

// SetDefaultModeParams defines parameters for SetDefaultMode.
type SetDefaultModeParams struct {
	Mode SetDefaultModeParamsMode `form:"mode" json:"mode"`
}

// SetDefaultModeParamsMode defines parameters for SetDefaultMode.
type SetDefaultModeParamsMode string

// StreamRobotControllerStateParams defines parameters for StreamRobotControllerState.
type StreamRobotControllerStateParams struct {
	ResponseRate *uint32 `form:"response_rate,omitempty" json:"response_rate,omitempty"`
}

// DeleteVirtualRobotCoordinateSystemParams defines parameters for DeleteVirtualRobotCoordinateSystem.
type DeleteVirtualRobotCoordinateSystemParams struct {
	// DeleteDependent If true, all dependent coordinate systems will be deleted as well.
	DeleteDependent *bool `form:"delete_dependent,omitempty" json:"delete_dependent,omitempty"`
}

// SetVirtualRobotIOValueParams defines parameters for SetVirtualRobotIOValue.
type SetVirtualRobotIOValueParams struct {
	Bool    *bool    `form:"bool,omitempty" json:"bool,omitempty"`
	Integer *string  `form:"integer,omitempty" json:"integer,omitempty"`
	Double  *float64 `form:"double,omitempty" json:"double,omitempty"`
}

// SetMotionGroupBehaviorParams defines parameters for SetMotionGroupBehavior.
type SetMotionGroupBehaviorParams struct {
	Behavior *Behavior `form:"behavior,omitempty" json:"behavior,omitempty"`
}

// SetOperationModeParams defines parameters for SetOperationMode.
type SetOperationModeParams struct {
	Mode SetOperationModeParamsMode `form:"mode" json:"mode"`
}

// SetOperationModeParamsMode defines parameters for SetOperationMode.
type SetOperationModeParamsMode string

// ListCoordinateSystemsParams defines parameters for ListCoordinateSystems.
type ListCoordinateSystemsParams struct {
	RotationType *RotationAngleTypes `form:"rotation_type,omitempty" json:"rotation_type,omitempty"`
}

// GetCoordinateSystemParams defines parameters for GetCoordinateSystem.
type GetCoordinateSystemParams struct {
	RotationType *RotationAngleTypes `form:"rotation_type,omitempty" json:"rotation_type,omitempty"`
}

// CreateDeviceJSONBody defines parameters for CreateDevice.
type CreateDeviceJSONBody = []CreateDeviceJSONBody_Item

// CreateDeviceJSONBody_Item defines parameters for CreateDevice.
type CreateDeviceJSONBody_Item struct {
	union json.RawMessage
}

// ActivateMotionGroupParams defines parameters for ActivateMotionGroup.
type ActivateMotionGroupParams struct {
	MotionGroup string `form:"motion_group" json:"motion_group"`
}

// ActivateAllMotionGroupsParams defines parameters for ActivateAllMotionGroups.
type ActivateAllMotionGroupsParams struct {
	Controller string `form:"controller" json:"controller"`
}

// GetOptimizerConfigurationParams defines parameters for GetOptimizerConfiguration.
type GetOptimizerConfigurationParams struct {
	Tcp *string `form:"tcp,omitempty" json:"tcp,omitempty"`
}

// GetCurrentMotionGroupStateParams defines parameters for GetCurrentMotionGroupState.
type GetCurrentMotionGroupStateParams struct {
	// Tcp The identifier of the tool center point (TCP) to be used for tcp_pose in response.
	// If not set, the flange pose is returned as tcp_pose.
	Tcp *string `form:"tcp,omitempty" json:"tcp,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the responses should be converted.
	// If not set, world coordinate system is used.
	ResponseCoordinateSystem *string `form:"response_coordinate_system,omitempty" json:"response_coordinate_system,omitempty"`
}

// StreamMotionGroupStateParams defines parameters for StreamMotionGroupState.
type StreamMotionGroupStateParams struct {
	// ResponseRate Update rate for the response message in milliseconds (ms). Default is 200 ms.
	// We recommend to use the step rate of the controller or a multiple of the step rate as NOVA updates the state in the controller's step rate as well.
	// Minimal response rate is the step rate of controller.
	ResponseRate *ResponseRate `form:"response_rate,omitempty" json:"response_rate,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the cartesian data of the responses should be converted.
	// Default is the world coordinate system.
	ResponseCoordinateSystem *ResponseCoordinateSystem `form:"response_coordinate_system,omitempty" json:"response_coordinate_system,omitempty"`

	// Tcp The identifier of the tool center point (TCP) to be used for tcp_pose in response.
	// If not set, the flange pose is returned as tcp_pose.
	Tcp *TCP `form:"tcp,omitempty" json:"tcp,omitempty"`
}

// ListTcpsParams defines parameters for ListTcps.
type ListTcpsParams struct {
	RotationType *RotationAngleTypes `form:"rotation_type,omitempty" json:"rotation_type,omitempty"`
}

// GetActiveTcpParams defines parameters for GetActiveTcp.
type GetActiveTcpParams struct {
	RotationType *RotationAngleTypes `form:"rotation_type,omitempty" json:"rotation_type,omitempty"`
}

// ExecuteTrajectoryJSONBody defines parameters for ExecuteTrajectory.
type ExecuteTrajectoryJSONBody struct {
	union json.RawMessage
}

// StreamMoveJSONBody defines parameters for StreamMove.
type StreamMoveJSONBody struct {
	union json.RawMessage
}

// StreamMoveBackwardParams defines parameters for StreamMoveBackward.
type StreamMoveBackwardParams struct {
	// PlaybackSpeedInPercent Set the velocity for executed movements of the motion in percent. A percentage of 100% means that the robot moves as
	// fast as possible without violating the limits. Setting this value does not affect the overall shape of the velocity profile.
	// Everything is slowed down by the same factor. Therefore, this should only be used for teaching and trajectory
	// evaluation purposes. If the process requires a certain velocity, the respective limits should be set when planning the motion.
	// This will not change the velocity override of the controller. The controller velocity override value shall be 100% to ensure
	// controllability of the motion group.
	PlaybackSpeedInPercent PlaybackSpeed `form:"playback_speed_in_percent" json:"playback_speed_in_percent"`

	// ResponseRate Update rate for the response message in milliseconds (ms). Default is 200 ms.
	// We recommend to use the step rate of the controller or a multiple of the step rate as NOVA updates the state in the controller's step rate as well.
	// Minimal response rate is the step rate of controller.
	ResponseRate *ResponseRate `form:"response_rate,omitempty" json:"response_rate,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the cartesian data of the responses should be converted.
	// Default is the world coordinate system.
	ResponseCoordinateSystem *ResponseCoordinateSystem `form:"response_coordinate_system,omitempty" json:"response_coordinate_system,omitempty"`

	// StartLocationOnTrajectory Location the motion is requested to start at.
	// The default value is the end of the trajectory.
	// The location is a scalar value that defines a position along a path, typically ranging from 0 to `n`,
	// where `n` denotes the number of motion commands. Each integer value of the location corresponds to a specific motion command,
	// while non-integer values interpolate positions within the segments.
	// The location is calculated from the joint path.
	StartLocationOnTrajectory *float64 `form:"start_location_on_trajectory,omitempty" json:"start_location_on_trajectory,omitempty"`
}

// StreamMoveForwardParams defines parameters for StreamMoveForward.
type StreamMoveForwardParams struct {
	// PlaybackSpeedInPercent Set the velocity for executed movements of the motion in percent. A percentage of 100% means that the robot moves as
	// fast as possible without violating the limits. Setting this value does not affect the overall shape of the velocity profile.
	// Everything is slowed down by the same factor. Therefore, this should only be used for teaching and trajectory
	// evaluation purposes. If the process requires a certain velocity, the respective limits should be set when planning the motion.
	// This will not change the velocity override of the controller. The controller velocity override value shall be 100% to ensure
	// controllability of the motion group.
	PlaybackSpeedInPercent PlaybackSpeed `form:"playback_speed_in_percent" json:"playback_speed_in_percent"`

	// ResponseRate Update rate for the response message in milliseconds (ms). Default is 200 ms.
	// We recommend to use the step rate of the controller or a multiple of the step rate as NOVA updates the state in the controller's step rate as well.
	// Minimal response rate is the step rate of controller.
	ResponseRate *ResponseRate `form:"response_rate,omitempty" json:"response_rate,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system to which the cartesian data of the responses should be converted.
	// Default is the world coordinate system.
	ResponseCoordinateSystem *ResponseCoordinateSystem `form:"response_coordinate_system,omitempty" json:"response_coordinate_system,omitempty"`

	// StartLocationOnTrajectory Location the motion is requested to start at.
	// The default value is the begin of the trajectory.
	// The location is a scalar value that defines a position along a path, typically ranging from 0 to `n`,
	// where `n` denotes the number of motion commands. Each integer value of the location corresponds to a specific motion command,
	// while non-integer values interpolate positions within the segments.
	// The location is calculated from the joint path.
	StartLocationOnTrajectory *float64 `form:"start_location_on_trajectory,omitempty" json:"start_location_on_trajectory,omitempty"`
}

// StreamMoveToTrajectoryViaJointPTPParams defines parameters for StreamMoveToTrajectoryViaJointPTP.
type StreamMoveToTrajectoryViaJointPTPParams struct {
	LocationOnTrajectory float64 `form:"location_on_trajectory" json:"location_on_trajectory"`

	// LimitOverrideJointVelocityLimitsJoints The joint velocity limits for the p2p motion to a previously planned motion.
	LimitOverrideJointVelocityLimitsJoints *[]float64 `form:"limit_override.joint_velocity_limits.joints,omitempty" json:"limit_override.joint_velocity_limits.joints,omitempty"`

	// LimitOverrideJointAccelerationLimitsJoints The joint acceleration limits for the p2p motion to a previously planned motion.
	LimitOverrideJointAccelerationLimitsJoints *[]float64 `form:"limit_override.joint_acceleration_limits.joints,omitempty" json:"limit_override.joint_acceleration_limits.joints,omitempty"`

	// LimitOverrideTcpVelocityLimit Maximum allowed TCP velocity in [mm/s].
	LimitOverrideTcpVelocityLimit *float64 `form:"limit_override.tcp_velocity_limit,omitempty" json:"limit_override.tcp_velocity_limit,omitempty"`

	// LimitOverrideTcpAccelerationLimit Maximum allowed TCP acceleration in [mm/s^2].
	LimitOverrideTcpAccelerationLimit *float64 `form:"limit_override.tcp_acceleration_limit,omitempty" json:"limit_override.tcp_acceleration_limit,omitempty"`

	// LimitOverrideTcpOrientationVelocityLimit Maximum allowed TCP rotation velocity in [rad/s].
	LimitOverrideTcpOrientationVelocityLimit *float64 `form:"limit_override.tcp_orientation_velocity_limit,omitempty" json:"limit_override.tcp_orientation_velocity_limit,omitempty"`

	// LimitOverrideTcpOrientationAccelerationLimit Maximum allowed TCP rotation acceleration in [rad/s^2].
	LimitOverrideTcpOrientationAccelerationLimit *float64 `form:"limit_override.tcp_orientation_acceleration_limit,omitempty" json:"limit_override.tcp_orientation_acceleration_limit,omitempty"`
	ResponsesCoordinateSystem                    *string  `form:"responses_coordinate_system,omitempty" json:"responses_coordinate_system,omitempty"`
}

// GetPlannedMotionParams defines parameters for GetPlannedMotion.
type GetPlannedMotionParams struct {
	// SampleTime -| The value of `sample_time` is the time in milliseconds (ms) between each datapoint of the planned motion. Optional. If not provided, the data is returned as it is stored internally and equidistant sampling is not guaranteed.
	SampleTime *uint32 `form:"sample_time,omitempty" json:"sample_time,omitempty"`
}

// GetMotionTrajectoryParams defines parameters for GetMotionTrajectory.
type GetMotionTrajectoryParams struct {
	// SampleTime The value of `sample_time` is the time in milliseconds (ms) between each point in the trajectory.
	SampleTime uint32 `form:"sample_time" json:"sample_time"`

	// ResponsesCoordinateSystem Unique identifier addressing a coordinate system to which the cartesian data of the responses should be converted.
	// Default: world coordinate system.
	ResponsesCoordinateSystem *string `form:"responses_coordinate_system,omitempty" json:"responses_coordinate_system,omitempty"`
}

// GetMotionTrajectorySampleParams defines parameters for GetMotionTrajectorySample.
type GetMotionTrajectorySampleParams struct {
	LocationOnTrajectory *float64 `form:"location_on_trajectory,omitempty" json:"location_on_trajectory,omitempty"`

	// ResponseCoordinateSystem Unique identifier addressing a coordinate system in which the cartesian data of the response should be converted to.
	// Default is the world coordinate system.
	ResponseCoordinateSystem *string `form:"response_coordinate_system,omitempty" json:"response_coordinate_system,omitempty"`
}

// GetAllProgramRunsParams defines parameters for GetAllProgramRuns.
type GetAllProgramRunsParams struct {
	State *string `form:"state,omitempty" json:"state,omitempty"`
}

// CreateProgramRunJSONBody defines parameters for CreateProgramRun.
type CreateProgramRunJSONBody struct {
	// ProgramId The identifier of the program stored in the program library.
	ProgramId string `json:"program_id"`
}

// CreateTriggerJSONBody defines parameters for CreateTrigger.
type CreateTriggerJSONBody struct {
	Config *CreateTriggerJSONBody_Config `json:"config,omitempty"`

	// Enabled Indicated whether the trigger is enabled or not.
	Enabled bool `json:"enabled"`

	// ProgramId The identifier of the program to run when the trigger condition is met.
	ProgramId string `json:"program_id"`

	// Type The type of the trigger.
	Type TriggerType `json:"type"`
}

// CreateTriggerJSONBody_Config defines parameters for CreateTrigger.
type CreateTriggerJSONBody_Config struct {
	union json.RawMessage
}

// UpdateTriggerJSONBody defines parameters for UpdateTrigger.
type UpdateTriggerJSONBody struct {
	Config *UpdateTriggerJSONBody_Config `json:"config,omitempty"`

	// Enabled Whether the trigger is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// ProgramId The identifier of the program to run when the trigger condition is met.
	ProgramId *string `json:"program_id,omitempty"`
}

// UpdateTriggerJSONBody_Config defines parameters for UpdateTrigger.
type UpdateTriggerJSONBody_Config struct {
	union json.RawMessage
}

// CreateProgramsValueJSONBody defines parameters for CreateProgramsValue.
type CreateProgramsValueJSONBody map[string]CreateProgramsValueJSONBody_AdditionalProperties

// CreateProgramsValueJSONBody0 defines parameters for CreateProgramsValue.
type CreateProgramsValueJSONBody0 = float32

// CreateProgramsValueJSONBody1 defines parameters for CreateProgramsValue.
type CreateProgramsValueJSONBody1 = int

// CreateProgramsValueJSONBody2 defines parameters for CreateProgramsValue.
type CreateProgramsValueJSONBody2 = string

// CreateProgramsValueJSONBody3 defines parameters for CreateProgramsValue.
type CreateProgramsValueJSONBody3 = openapi_types.File

// CreateProgramsValueJSONBody_AdditionalProperties defines parameters for CreateProgramsValue.
type CreateProgramsValueJSONBody_AdditionalProperties struct {
	union json.RawMessage
}

// UpdateProgramValueJSONBody defines parameters for UpdateProgramValue.
type UpdateProgramValueJSONBody struct {
	union json.RawMessage
}

// UpdateProgramValueJSONBody0 defines parameters for UpdateProgramValue.
type UpdateProgramValueJSONBody0 = float32

// UpdateProgramValueJSONBody1 defines parameters for UpdateProgramValue.
type UpdateProgramValueJSONBody1 = int

// UpdateProgramValueJSONBody2 defines parameters for UpdateProgramValue.
type UpdateProgramValueJSONBody2 = string

// UpdateProgramValueJSONBody3 defines parameters for UpdateProgramValue.
type UpdateProgramValueJSONBody3 = openapi_types.File

// GetDefaultLinkChainParamsMotionGroupModel defines parameters for GetDefaultLinkChain.
type GetDefaultLinkChainParamsMotionGroupModel string

// StoreObjectMultipartBody defines parameters for StoreObject.
type StoreObjectMultipartBody struct {
	AnyValue *interface{} `json:"AnyValue,omitempty"`
}

// StoreObjectParams defines parameters for StoreObject.
type StoreObjectParams struct {
	XMetadata *map[string]string `json:"X-Metadata,omitempty"`
}

// DeleteProgramListParams defines parameters for DeleteProgramList.
type DeleteProgramListParams struct {
	// ProgramIds Recieved from [listProgramMetadata](listProgramMetadata) or from the response of [createProgram](createProgram).
	ProgramIds []string `form:"program_ids" json:"program_ids"`
}

// ListProgramMetadataParams defines parameters for ListProgramMetadata.
type ListProgramMetadataParams struct {
	// ShowHidden If true, hidden programs, where the `is_hidden` flag is active, are included in the list.
	ShowHidden *bool `form:"show_hidden,omitempty" json:"show_hidden,omitempty"`
}

// CreateProgramTextBody defines parameters for CreateProgram.
type CreateProgramTextBody = string

// CreateProgramParams defines parameters for CreateProgram.
type CreateProgramParams struct {
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// UpdateProgramTextBody defines parameters for UpdateProgram.
type UpdateProgramTextBody = string

// DeleteRecipeListParams defines parameters for DeleteRecipeList.
type DeleteRecipeListParams struct {
	// RecipeIds Recieved from [listRecipeMetadata](listRecipeMetadata) or from the response of [createRecipe](createRecipe)
	RecipeIds []string `form:"recipe_ids" json:"recipe_ids"`
}

// CreateRecipeJSONBody defines parameters for CreateRecipe.
type CreateRecipeJSONBody = map[string]interface{}

// CreateRecipeParams defines parameters for CreateRecipe.
type CreateRecipeParams struct {
	// ProgramId The identifier of the program the recipe will be associated with.
	ProgramId string `form:"program_id" json:"program_id"`

	// Name If no inital name is set a default name based on the program and timestamp is created.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// UpdateRecipeJSONBody defines parameters for UpdateRecipe.
type UpdateRecipeJSONBody = map[string]interface{}

// ActivateLicenseJSONBody defines parameters for ActivateLicense.
type ActivateLicenseJSONBody struct {
	OwnerRefreshToken string `json:"owner_refresh_token"`
}

// CheckNovaVersionUpdateParams defines parameters for CheckNovaVersionUpdate.
type CheckNovaVersionUpdateParams struct {
	Channel ReleaseChannel `form:"channel" json:"channel"`
}

// UpdateNovaVersionJSONBody defines parameters for UpdateNovaVersion.
type UpdateNovaVersionJSONBody struct {
	// Channel The channel that defines what a new Wandelbots NOVA version is.
	//
	//   * `next` the over all latest version
	//   * `stable` newes patch of the current version
	Channel ReleaseChannel `json:"channel"`
}

// DeployCellJSONRequestBody defines body for DeployCell for application/json ContentType.
type DeployCellJSONRequestBody = Cell

// UpdateCellJSONRequestBody defines body for UpdateCell for application/json ContentType.
type UpdateCellJSONRequestBody = Cell

// AddAppJSONRequestBody defines body for AddApp for application/json ContentType.
type AddAppJSONRequestBody = App

// UpdateAppJSONRequestBody defines body for UpdateApp for application/json ContentType.
type UpdateAppJSONRequestBody = App

// AddRobotControllerJSONRequestBody defines body for AddRobotController for application/json ContentType.
type AddRobotControllerJSONRequestBody = RobotController

// UpdateRobotControllerJSONRequestBody defines body for UpdateRobotController for application/json ContentType.
type UpdateRobotControllerJSONRequestBody = RobotController

// SetOutputValuesJSONRequestBody defines body for SetOutputValues for application/json ContentType.
type SetOutputValuesJSONRequestBody = SetOutputValuesJSONBody

// AddVirtualRobotCoordinateSystemJSONRequestBody defines body for AddVirtualRobotCoordinateSystem for application/json ContentType.
type AddVirtualRobotCoordinateSystemJSONRequestBody = CoordinateSystem

// ExternalJointsStreamJSONRequestBody defines body for ExternalJointsStream for application/json ContentType.
type ExternalJointsStreamJSONRequestBody = ExternalJointStreamDatapoint

// SetMotionGroupStateJSONRequestBody defines body for SetMotionGroupState for application/json ContentType.
type SetMotionGroupStateJSONRequestBody = MotionGroupJoints

// SetVirtualRobotMountingJSONRequestBody defines body for SetVirtualRobotMounting for application/json ContentType.
type SetVirtualRobotMountingJSONRequestBody = CoordinateSystem

// AddVirtualRobotTcpJSONRequestBody defines body for AddVirtualRobotTcp for application/json ContentType.
type AddVirtualRobotTcpJSONRequestBody = RobotTcp

// AddCoordinateSystemJSONRequestBody defines body for AddCoordinateSystem for application/json ContentType.
type AddCoordinateSystemJSONRequestBody = AddRequest

// TransformInCoordinateSystemJSONRequestBody defines body for TransformInCoordinateSystem for application/json ContentType.
type TransformInCoordinateSystemJSONRequestBody = Pose

// CreateDeviceJSONRequestBody defines body for CreateDevice for application/json ContentType.
type CreateDeviceJSONRequestBody = CreateDeviceJSONBody

// JointJoggingJSONRequestBody defines body for JointJogging for application/json ContentType.
type JointJoggingJSONRequestBody = JointJoggingRequest

// DirectionJoggingJSONRequestBody defines body for DirectionJogging for application/json ContentType.
type DirectionJoggingJSONRequestBody = DirectionJoggingRequest

// CalculateAllInverseKinematicJSONRequestBody defines body for CalculateAllInverseKinematic for application/json ContentType.
type CalculateAllInverseKinematicJSONRequestBody = AllJointPositionsRequest

// CalculateInverseKinematicJSONRequestBody defines body for CalculateInverseKinematic for application/json ContentType.
type CalculateInverseKinematicJSONRequestBody = JointPositionRequest

// CalculateForwardKinematicJSONRequestBody defines body for CalculateForwardKinematic for application/json ContentType.
type CalculateForwardKinematicJSONRequestBody = TcpPoseRequest

// PlanCollisionFreePTPJSONRequestBody defines body for PlanCollisionFreePTP for application/json ContentType.
type PlanCollisionFreePTPJSONRequestBody = PlanCollisionFreePTPRequest

// PlanTrajectoryJSONRequestBody defines body for PlanTrajectory for application/json ContentType.
type PlanTrajectoryJSONRequestBody = PlanTrajectoryRequest

// PlanMotionJSONRequestBody defines body for PlanMotion for application/json ContentType.
type PlanMotionJSONRequestBody = PlanRequest

// ExecuteTrajectoryJSONRequestBody defines body for ExecuteTrajectory for application/json ContentType.
type ExecuteTrajectoryJSONRequestBody ExecuteTrajectoryJSONBody

// StreamMoveJSONRequestBody defines body for StreamMove for application/json ContentType.
type StreamMoveJSONRequestBody StreamMoveJSONBody

// CreateProgramRunJSONRequestBody defines body for CreateProgramRun for application/json ContentType.
type CreateProgramRunJSONRequestBody CreateProgramRunJSONBody

// CreateTriggerJSONRequestBody defines body for CreateTrigger for application/json ContentType.
type CreateTriggerJSONRequestBody CreateTriggerJSONBody

// UpdateTriggerJSONRequestBody defines body for UpdateTrigger for application/json ContentType.
type UpdateTriggerJSONRequestBody UpdateTriggerJSONBody

// LoadPlannedMotionJSONRequestBody defines body for LoadPlannedMotion for application/json ContentType.
type LoadPlannedMotionJSONRequestBody = PlannedMotion

// CreateProgramsValueJSONRequestBody defines body for CreateProgramsValue for application/json ContentType.
type CreateProgramsValueJSONRequestBody CreateProgramsValueJSONBody

// UpdateProgramValueJSONRequestBody defines body for UpdateProgramValue for application/json ContentType.
type UpdateProgramValueJSONRequestBody UpdateProgramValueJSONBody

// StoreColliderJSONRequestBody defines body for StoreCollider for application/json ContentType.
type StoreColliderJSONRequestBody = Collider

// StoreCollisionLinkChainJSONRequestBody defines body for StoreCollisionLinkChain for application/json ContentType.
type StoreCollisionLinkChainJSONRequestBody = LinkChain

// StoreCollisionSceneJSONRequestBody defines body for StoreCollisionScene for application/json ContentType.
type StoreCollisionSceneJSONRequestBody = CollisionSceneAssembly

// StoreCollisionToolJSONRequestBody defines body for StoreCollisionTool for application/json ContentType.
type StoreCollisionToolJSONRequestBody = Tool

// StoreObjectMultipartRequestBody defines body for StoreObject for multipart/form-data ContentType.
type StoreObjectMultipartRequestBody StoreObjectMultipartBody

// CreateProgramTextRequestBody defines body for CreateProgram for text/plain ContentType.
type CreateProgramTextRequestBody = CreateProgramTextBody

// UpdateProgramTextRequestBody defines body for UpdateProgram for text/plain ContentType.
type UpdateProgramTextRequestBody = UpdateProgramTextBody

// UpdateProgramMetadataJSONRequestBody defines body for UpdateProgramMetadata for application/json ContentType.
type UpdateProgramMetadataJSONRequestBody = UpdateProgramMetadataRequest

// UploadProgramMetadataImageMultipartRequestBody defines body for UploadProgramMetadataImage for multipart/form-data ContentType.
type UploadProgramMetadataImageMultipartRequestBody = BodyUploadProgramMetadataImage

// CreateRecipeJSONRequestBody defines body for CreateRecipe for application/json ContentType.
type CreateRecipeJSONRequestBody = CreateRecipeJSONBody

// UpdateRecipeJSONRequestBody defines body for UpdateRecipe for application/json ContentType.
type UpdateRecipeJSONRequestBody = UpdateRecipeJSONBody

// UpdateRecipeMetadataJSONRequestBody defines body for UpdateRecipeMetadata for application/json ContentType.
type UpdateRecipeMetadataJSONRequestBody = UpdateRecipeMetadataRequest

// UploadRecipeMetadataImageMultipartRequestBody defines body for UploadRecipeMetadataImage for multipart/form-data ContentType.
type UploadRecipeMetadataImageMultipartRequestBody = BodyUploadRecipeMetadataImage

// ActivateLicenseJSONRequestBody defines body for ActivateLicense for application/json ContentType.
type ActivateLicenseJSONRequestBody ActivateLicenseJSONBody

// UpdateNovaVersionJSONRequestBody defines body for UpdateNovaVersion for application/json ContentType.
type UpdateNovaVersionJSONRequestBody UpdateNovaVersionJSONBody

// Getter for additional properties for GoogleProtobufAny. Returns the specified
// element and whether it was found
func (a GoogleProtobufAny) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GoogleProtobufAny
func (a *GoogleProtobufAny) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a *GoogleProtobufAny) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["@type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading '@type': %w", err)
		}
		delete(object, "@type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GoogleProtobufAny to handle AdditionalProperties
func (a GoogleProtobufAny) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Type != nil {
		object["@type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsArrayInputArray0 returns the union data inside the ArrayInput_Array_Item as a ArrayInputArray0
func (t ArrayInput_Array_Item) AsArrayInputArray0() (ArrayInputArray0, error) {
	var body ArrayInputArray0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayInputArray0 overwrites any union data inside the ArrayInput_Array_Item as the provided ArrayInputArray0
func (t *ArrayInput_Array_Item) FromArrayInputArray0(v ArrayInputArray0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayInputArray0 performs a merge with any union data inside the ArrayInput_Array_Item, using the provided ArrayInputArray0
func (t *ArrayInput_Array_Item) MergeArrayInputArray0(v ArrayInputArray0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayInputArray1 returns the union data inside the ArrayInput_Array_Item as a ArrayInputArray1
func (t ArrayInput_Array_Item) AsArrayInputArray1() (ArrayInputArray1, error) {
	var body ArrayInputArray1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayInputArray1 overwrites any union data inside the ArrayInput_Array_Item as the provided ArrayInputArray1
func (t *ArrayInput_Array_Item) FromArrayInputArray1(v ArrayInputArray1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayInputArray1 performs a merge with any union data inside the ArrayInput_Array_Item, using the provided ArrayInputArray1
func (t *ArrayInput_Array_Item) MergeArrayInputArray1(v ArrayInputArray1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayInputArray2 returns the union data inside the ArrayInput_Array_Item as a ArrayInputArray2
func (t ArrayInput_Array_Item) AsArrayInputArray2() (ArrayInputArray2, error) {
	var body ArrayInputArray2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayInputArray2 overwrites any union data inside the ArrayInput_Array_Item as the provided ArrayInputArray2
func (t *ArrayInput_Array_Item) FromArrayInputArray2(v ArrayInputArray2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayInputArray2 performs a merge with any union data inside the ArrayInput_Array_Item, using the provided ArrayInputArray2
func (t *ArrayInput_Array_Item) MergeArrayInputArray2(v ArrayInputArray2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayInputArray3 returns the union data inside the ArrayInput_Array_Item as a ArrayInputArray3
func (t ArrayInput_Array_Item) AsArrayInputArray3() (ArrayInputArray3, error) {
	var body ArrayInputArray3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayInputArray3 overwrites any union data inside the ArrayInput_Array_Item as the provided ArrayInputArray3
func (t *ArrayInput_Array_Item) FromArrayInputArray3(v ArrayInputArray3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayInputArray3 performs a merge with any union data inside the ArrayInput_Array_Item, using the provided ArrayInputArray3
func (t *ArrayInput_Array_Item) MergeArrayInputArray3(v ArrayInputArray3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPyjectoryDatatypesSerializerPose returns the union data inside the ArrayInput_Array_Item as a PyjectoryDatatypesSerializerPose
func (t ArrayInput_Array_Item) AsPyjectoryDatatypesSerializerPose() (PyjectoryDatatypesSerializerPose, error) {
	var body PyjectoryDatatypesSerializerPose
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPyjectoryDatatypesSerializerPose overwrites any union data inside the ArrayInput_Array_Item as the provided PyjectoryDatatypesSerializerPose
func (t *ArrayInput_Array_Item) FromPyjectoryDatatypesSerializerPose(v PyjectoryDatatypesSerializerPose) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePyjectoryDatatypesSerializerPose performs a merge with any union data inside the ArrayInput_Array_Item, using the provided PyjectoryDatatypesSerializerPose
func (t *ArrayInput_Array_Item) MergePyjectoryDatatypesSerializerPose(v PyjectoryDatatypesSerializerPose) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPyjectoryDatatypesSerializerPosition returns the union data inside the ArrayInput_Array_Item as a PyjectoryDatatypesSerializerPosition
func (t ArrayInput_Array_Item) AsPyjectoryDatatypesSerializerPosition() (PyjectoryDatatypesSerializerPosition, error) {
	var body PyjectoryDatatypesSerializerPosition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPyjectoryDatatypesSerializerPosition overwrites any union data inside the ArrayInput_Array_Item as the provided PyjectoryDatatypesSerializerPosition
func (t *ArrayInput_Array_Item) FromPyjectoryDatatypesSerializerPosition(v PyjectoryDatatypesSerializerPosition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePyjectoryDatatypesSerializerPosition performs a merge with any union data inside the ArrayInput_Array_Item, using the provided PyjectoryDatatypesSerializerPosition
func (t *ArrayInput_Array_Item) MergePyjectoryDatatypesSerializerPosition(v PyjectoryDatatypesSerializerPosition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPyjectoryDatatypesSerializerOrientation returns the union data inside the ArrayInput_Array_Item as a PyjectoryDatatypesSerializerOrientation
func (t ArrayInput_Array_Item) AsPyjectoryDatatypesSerializerOrientation() (PyjectoryDatatypesSerializerOrientation, error) {
	var body PyjectoryDatatypesSerializerOrientation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPyjectoryDatatypesSerializerOrientation overwrites any union data inside the ArrayInput_Array_Item as the provided PyjectoryDatatypesSerializerOrientation
func (t *ArrayInput_Array_Item) FromPyjectoryDatatypesSerializerOrientation(v PyjectoryDatatypesSerializerOrientation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePyjectoryDatatypesSerializerOrientation performs a merge with any union data inside the ArrayInput_Array_Item, using the provided PyjectoryDatatypesSerializerOrientation
func (t *ArrayInput_Array_Item) MergePyjectoryDatatypesSerializerOrientation(v PyjectoryDatatypesSerializerOrientation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapture returns the union data inside the ArrayInput_Array_Item as a Capture
func (t ArrayInput_Array_Item) AsCapture() (Capture, error) {
	var body Capture
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapture overwrites any union data inside the ArrayInput_Array_Item as the provided Capture
func (t *ArrayInput_Array_Item) FromCapture(v Capture) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapture performs a merge with any union data inside the ArrayInput_Array_Item, using the provided Capture
func (t *ArrayInput_Array_Item) MergeCapture(v Capture) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPointCloud returns the union data inside the ArrayInput_Array_Item as a PointCloud
func (t ArrayInput_Array_Item) AsPointCloud() (PointCloud, error) {
	var body PointCloud
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPointCloud overwrites any union data inside the ArrayInput_Array_Item as the provided PointCloud
func (t *ArrayInput_Array_Item) FromPointCloud(v PointCloud) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePointCloud performs a merge with any union data inside the ArrayInput_Array_Item, using the provided PointCloud
func (t *ArrayInput_Array_Item) MergePointCloud(v PointCloud) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayInput returns the union data inside the ArrayInput_Array_Item as a ArrayInput
func (t ArrayInput_Array_Item) AsArrayInput() (ArrayInput, error) {
	var body ArrayInput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayInput overwrites any union data inside the ArrayInput_Array_Item as the provided ArrayInput
func (t *ArrayInput_Array_Item) FromArrayInput(v ArrayInput) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayInput performs a merge with any union data inside the ArrayInput_Array_Item, using the provided ArrayInput
func (t *ArrayInput_Array_Item) MergeArrayInput(v ArrayInput) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ArrayInput_Array_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ArrayInput_Array_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsArrayOutputArray0 returns the union data inside the ArrayOutput_Array_Item as a ArrayOutputArray0
func (t ArrayOutput_Array_Item) AsArrayOutputArray0() (ArrayOutputArray0, error) {
	var body ArrayOutputArray0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayOutputArray0 overwrites any union data inside the ArrayOutput_Array_Item as the provided ArrayOutputArray0
func (t *ArrayOutput_Array_Item) FromArrayOutputArray0(v ArrayOutputArray0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayOutputArray0 performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided ArrayOutputArray0
func (t *ArrayOutput_Array_Item) MergeArrayOutputArray0(v ArrayOutputArray0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayOutputArray1 returns the union data inside the ArrayOutput_Array_Item as a ArrayOutputArray1
func (t ArrayOutput_Array_Item) AsArrayOutputArray1() (ArrayOutputArray1, error) {
	var body ArrayOutputArray1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayOutputArray1 overwrites any union data inside the ArrayOutput_Array_Item as the provided ArrayOutputArray1
func (t *ArrayOutput_Array_Item) FromArrayOutputArray1(v ArrayOutputArray1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayOutputArray1 performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided ArrayOutputArray1
func (t *ArrayOutput_Array_Item) MergeArrayOutputArray1(v ArrayOutputArray1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayOutputArray2 returns the union data inside the ArrayOutput_Array_Item as a ArrayOutputArray2
func (t ArrayOutput_Array_Item) AsArrayOutputArray2() (ArrayOutputArray2, error) {
	var body ArrayOutputArray2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayOutputArray2 overwrites any union data inside the ArrayOutput_Array_Item as the provided ArrayOutputArray2
func (t *ArrayOutput_Array_Item) FromArrayOutputArray2(v ArrayOutputArray2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayOutputArray2 performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided ArrayOutputArray2
func (t *ArrayOutput_Array_Item) MergeArrayOutputArray2(v ArrayOutputArray2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayOutputArray3 returns the union data inside the ArrayOutput_Array_Item as a ArrayOutputArray3
func (t ArrayOutput_Array_Item) AsArrayOutputArray3() (ArrayOutputArray3, error) {
	var body ArrayOutputArray3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayOutputArray3 overwrites any union data inside the ArrayOutput_Array_Item as the provided ArrayOutputArray3
func (t *ArrayOutput_Array_Item) FromArrayOutputArray3(v ArrayOutputArray3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayOutputArray3 performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided ArrayOutputArray3
func (t *ArrayOutput_Array_Item) MergeArrayOutputArray3(v ArrayOutputArray3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPyjectoryDatatypesSerializerPose returns the union data inside the ArrayOutput_Array_Item as a PyjectoryDatatypesSerializerPose
func (t ArrayOutput_Array_Item) AsPyjectoryDatatypesSerializerPose() (PyjectoryDatatypesSerializerPose, error) {
	var body PyjectoryDatatypesSerializerPose
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPyjectoryDatatypesSerializerPose overwrites any union data inside the ArrayOutput_Array_Item as the provided PyjectoryDatatypesSerializerPose
func (t *ArrayOutput_Array_Item) FromPyjectoryDatatypesSerializerPose(v PyjectoryDatatypesSerializerPose) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePyjectoryDatatypesSerializerPose performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided PyjectoryDatatypesSerializerPose
func (t *ArrayOutput_Array_Item) MergePyjectoryDatatypesSerializerPose(v PyjectoryDatatypesSerializerPose) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPyjectoryDatatypesSerializerPosition returns the union data inside the ArrayOutput_Array_Item as a PyjectoryDatatypesSerializerPosition
func (t ArrayOutput_Array_Item) AsPyjectoryDatatypesSerializerPosition() (PyjectoryDatatypesSerializerPosition, error) {
	var body PyjectoryDatatypesSerializerPosition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPyjectoryDatatypesSerializerPosition overwrites any union data inside the ArrayOutput_Array_Item as the provided PyjectoryDatatypesSerializerPosition
func (t *ArrayOutput_Array_Item) FromPyjectoryDatatypesSerializerPosition(v PyjectoryDatatypesSerializerPosition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePyjectoryDatatypesSerializerPosition performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided PyjectoryDatatypesSerializerPosition
func (t *ArrayOutput_Array_Item) MergePyjectoryDatatypesSerializerPosition(v PyjectoryDatatypesSerializerPosition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPyjectoryDatatypesSerializerOrientation returns the union data inside the ArrayOutput_Array_Item as a PyjectoryDatatypesSerializerOrientation
func (t ArrayOutput_Array_Item) AsPyjectoryDatatypesSerializerOrientation() (PyjectoryDatatypesSerializerOrientation, error) {
	var body PyjectoryDatatypesSerializerOrientation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPyjectoryDatatypesSerializerOrientation overwrites any union data inside the ArrayOutput_Array_Item as the provided PyjectoryDatatypesSerializerOrientation
func (t *ArrayOutput_Array_Item) FromPyjectoryDatatypesSerializerOrientation(v PyjectoryDatatypesSerializerOrientation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePyjectoryDatatypesSerializerOrientation performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided PyjectoryDatatypesSerializerOrientation
func (t *ArrayOutput_Array_Item) MergePyjectoryDatatypesSerializerOrientation(v PyjectoryDatatypesSerializerOrientation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapture returns the union data inside the ArrayOutput_Array_Item as a Capture
func (t ArrayOutput_Array_Item) AsCapture() (Capture, error) {
	var body Capture
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapture overwrites any union data inside the ArrayOutput_Array_Item as the provided Capture
func (t *ArrayOutput_Array_Item) FromCapture(v Capture) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapture performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided Capture
func (t *ArrayOutput_Array_Item) MergeCapture(v Capture) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPointCloud returns the union data inside the ArrayOutput_Array_Item as a PointCloud
func (t ArrayOutput_Array_Item) AsPointCloud() (PointCloud, error) {
	var body PointCloud
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPointCloud overwrites any union data inside the ArrayOutput_Array_Item as the provided PointCloud
func (t *ArrayOutput_Array_Item) FromPointCloud(v PointCloud) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePointCloud performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided PointCloud
func (t *ArrayOutput_Array_Item) MergePointCloud(v PointCloud) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsArrayOutput returns the union data inside the ArrayOutput_Array_Item as a ArrayOutput
func (t ArrayOutput_Array_Item) AsArrayOutput() (ArrayOutput, error) {
	var body ArrayOutput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayOutput overwrites any union data inside the ArrayOutput_Array_Item as the provided ArrayOutput
func (t *ArrayOutput_Array_Item) FromArrayOutput(v ArrayOutput) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayOutput performs a merge with any union data inside the ArrayOutput_Array_Item, using the provided ArrayOutput
func (t *ArrayOutput_Array_Item) MergeArrayOutput(v ArrayOutput) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ArrayOutput_Array_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ArrayOutput_Array_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSphere2 returns the union data inside the Collider_Shape as a Sphere2
func (t Collider_Shape) AsSphere2() (Sphere2, error) {
	var body Sphere2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSphere2 overwrites any union data inside the Collider_Shape as the provided Sphere2
func (t *Collider_Shape) FromSphere2(v Sphere2) error {
	v.ShapeType = "sphere"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSphere2 performs a merge with any union data inside the Collider_Shape, using the provided Sphere2
func (t *Collider_Shape) MergeSphere2(v Sphere2) error {
	v.ShapeType = "sphere"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBox2 returns the union data inside the Collider_Shape as a Box2
func (t Collider_Shape) AsBox2() (Box2, error) {
	var body Box2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBox2 overwrites any union data inside the Collider_Shape as the provided Box2
func (t *Collider_Shape) FromBox2(v Box2) error {
	v.ShapeType = "box"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBox2 performs a merge with any union data inside the Collider_Shape, using the provided Box2
func (t *Collider_Shape) MergeBox2(v Box2) error {
	v.ShapeType = "box"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRectangle2 returns the union data inside the Collider_Shape as a Rectangle2
func (t Collider_Shape) AsRectangle2() (Rectangle2, error) {
	var body Rectangle2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRectangle2 overwrites any union data inside the Collider_Shape as the provided Rectangle2
func (t *Collider_Shape) FromRectangle2(v Rectangle2) error {
	v.ShapeType = "rectangle"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRectangle2 performs a merge with any union data inside the Collider_Shape, using the provided Rectangle2
func (t *Collider_Shape) MergeRectangle2(v Rectangle2) error {
	v.ShapeType = "rectangle"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlane2 returns the union data inside the Collider_Shape as a Plane2
func (t Collider_Shape) AsPlane2() (Plane2, error) {
	var body Plane2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlane2 overwrites any union data inside the Collider_Shape as the provided Plane2
func (t *Collider_Shape) FromPlane2(v Plane2) error {
	v.ShapeType = "plane"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlane2 performs a merge with any union data inside the Collider_Shape, using the provided Plane2
func (t *Collider_Shape) MergePlane2(v Plane2) error {
	v.ShapeType = "plane"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCylinder2 returns the union data inside the Collider_Shape as a Cylinder2
func (t Collider_Shape) AsCylinder2() (Cylinder2, error) {
	var body Cylinder2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCylinder2 overwrites any union data inside the Collider_Shape as the provided Cylinder2
func (t *Collider_Shape) FromCylinder2(v Cylinder2) error {
	v.ShapeType = "cylinder"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCylinder2 performs a merge with any union data inside the Collider_Shape, using the provided Cylinder2
func (t *Collider_Shape) MergeCylinder2(v Cylinder2) error {
	v.ShapeType = "cylinder"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapsule2 returns the union data inside the Collider_Shape as a Capsule2
func (t Collider_Shape) AsCapsule2() (Capsule2, error) {
	var body Capsule2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapsule2 overwrites any union data inside the Collider_Shape as the provided Capsule2
func (t *Collider_Shape) FromCapsule2(v Capsule2) error {
	v.ShapeType = "capsule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapsule2 performs a merge with any union data inside the Collider_Shape, using the provided Capsule2
func (t *Collider_Shape) MergeCapsule2(v Capsule2) error {
	v.ShapeType = "capsule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRectangularCapsule2 returns the union data inside the Collider_Shape as a RectangularCapsule2
func (t Collider_Shape) AsRectangularCapsule2() (RectangularCapsule2, error) {
	var body RectangularCapsule2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRectangularCapsule2 overwrites any union data inside the Collider_Shape as the provided RectangularCapsule2
func (t *Collider_Shape) FromRectangularCapsule2(v RectangularCapsule2) error {
	v.ShapeType = "rectangular_capsule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRectangularCapsule2 performs a merge with any union data inside the Collider_Shape, using the provided RectangularCapsule2
func (t *Collider_Shape) MergeRectangularCapsule2(v RectangularCapsule2) error {
	v.ShapeType = "rectangular_capsule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConvexHull2 returns the union data inside the Collider_Shape as a ConvexHull2
func (t Collider_Shape) AsConvexHull2() (ConvexHull2, error) {
	var body ConvexHull2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConvexHull2 overwrites any union data inside the Collider_Shape as the provided ConvexHull2
func (t *Collider_Shape) FromConvexHull2(v ConvexHull2) error {
	v.ShapeType = "convex_hull"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConvexHull2 performs a merge with any union data inside the Collider_Shape, using the provided ConvexHull2
func (t *Collider_Shape) MergeConvexHull2(v ConvexHull2) error {
	v.ShapeType = "convex_hull"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Collider_Shape) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"shape_type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Collider_Shape) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "box":
		return t.AsBox2()
	case "capsule":
		return t.AsCapsule2()
	case "convex_hull":
		return t.AsConvexHull2()
	case "cylinder":
		return t.AsCylinder2()
	case "plane":
		return t.AsPlane2()
	case "rectangle":
		return t.AsRectangle2()
	case "rectangular_capsule":
		return t.AsRectangularCapsule2()
	case "sphere":
		return t.AsSphere2()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Collider_Shape) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Collider_Shape) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSphere3 returns the union data inside the ColliderInput_Shape as a Sphere3
func (t ColliderInput_Shape) AsSphere3() (Sphere3, error) {
	var body Sphere3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSphere3 overwrites any union data inside the ColliderInput_Shape as the provided Sphere3
func (t *ColliderInput_Shape) FromSphere3(v Sphere3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSphere3 performs a merge with any union data inside the ColliderInput_Shape, using the provided Sphere3
func (t *ColliderInput_Shape) MergeSphere3(v Sphere3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBox3 returns the union data inside the ColliderInput_Shape as a Box3
func (t ColliderInput_Shape) AsBox3() (Box3, error) {
	var body Box3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBox3 overwrites any union data inside the ColliderInput_Shape as the provided Box3
func (t *ColliderInput_Shape) FromBox3(v Box3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBox3 performs a merge with any union data inside the ColliderInput_Shape, using the provided Box3
func (t *ColliderInput_Shape) MergeBox3(v Box3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRectangle3 returns the union data inside the ColliderInput_Shape as a Rectangle3
func (t ColliderInput_Shape) AsRectangle3() (Rectangle3, error) {
	var body Rectangle3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRectangle3 overwrites any union data inside the ColliderInput_Shape as the provided Rectangle3
func (t *ColliderInput_Shape) FromRectangle3(v Rectangle3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRectangle3 performs a merge with any union data inside the ColliderInput_Shape, using the provided Rectangle3
func (t *ColliderInput_Shape) MergeRectangle3(v Rectangle3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlane3 returns the union data inside the ColliderInput_Shape as a Plane3
func (t ColliderInput_Shape) AsPlane3() (Plane3, error) {
	var body Plane3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlane3 overwrites any union data inside the ColliderInput_Shape as the provided Plane3
func (t *ColliderInput_Shape) FromPlane3(v Plane3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlane3 performs a merge with any union data inside the ColliderInput_Shape, using the provided Plane3
func (t *ColliderInput_Shape) MergePlane3(v Plane3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCylinder3 returns the union data inside the ColliderInput_Shape as a Cylinder3
func (t ColliderInput_Shape) AsCylinder3() (Cylinder3, error) {
	var body Cylinder3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCylinder3 overwrites any union data inside the ColliderInput_Shape as the provided Cylinder3
func (t *ColliderInput_Shape) FromCylinder3(v Cylinder3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCylinder3 performs a merge with any union data inside the ColliderInput_Shape, using the provided Cylinder3
func (t *ColliderInput_Shape) MergeCylinder3(v Cylinder3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCapsule3 returns the union data inside the ColliderInput_Shape as a Capsule3
func (t ColliderInput_Shape) AsCapsule3() (Capsule3, error) {
	var body Capsule3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCapsule3 overwrites any union data inside the ColliderInput_Shape as the provided Capsule3
func (t *ColliderInput_Shape) FromCapsule3(v Capsule3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCapsule3 performs a merge with any union data inside the ColliderInput_Shape, using the provided Capsule3
func (t *ColliderInput_Shape) MergeCapsule3(v Capsule3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRectangularCapsule3 returns the union data inside the ColliderInput_Shape as a RectangularCapsule3
func (t ColliderInput_Shape) AsRectangularCapsule3() (RectangularCapsule3, error) {
	var body RectangularCapsule3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRectangularCapsule3 overwrites any union data inside the ColliderInput_Shape as the provided RectangularCapsule3
func (t *ColliderInput_Shape) FromRectangularCapsule3(v RectangularCapsule3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRectangularCapsule3 performs a merge with any union data inside the ColliderInput_Shape, using the provided RectangularCapsule3
func (t *ColliderInput_Shape) MergeRectangularCapsule3(v RectangularCapsule3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConvexHull3 returns the union data inside the ColliderInput_Shape as a ConvexHull3
func (t ColliderInput_Shape) AsConvexHull3() (ConvexHull3, error) {
	var body ConvexHull3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConvexHull3 overwrites any union data inside the ColliderInput_Shape as the provided ConvexHull3
func (t *ColliderInput_Shape) FromConvexHull3(v ConvexHull3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConvexHull3 performs a merge with any union data inside the ColliderInput_Shape, using the provided ConvexHull3
func (t *ColliderInput_Shape) MergeConvexHull3(v ConvexHull3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ColliderInput_Shape) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ColliderInput_Shape) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInitializeMovementResponse returns the union data inside the ExecuteTrajectoryResponse as a InitializeMovementResponse
func (t ExecuteTrajectoryResponse) AsInitializeMovementResponse() (InitializeMovementResponse, error) {
	var body InitializeMovementResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInitializeMovementResponse overwrites any union data inside the ExecuteTrajectoryResponse as the provided InitializeMovementResponse
func (t *ExecuteTrajectoryResponse) FromInitializeMovementResponse(v InitializeMovementResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInitializeMovementResponse performs a merge with any union data inside the ExecuteTrajectoryResponse, using the provided InitializeMovementResponse
func (t *ExecuteTrajectoryResponse) MergeInitializeMovementResponse(v InitializeMovementResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMovement returns the union data inside the ExecuteTrajectoryResponse as a Movement
func (t ExecuteTrajectoryResponse) AsMovement() (Movement, error) {
	var body Movement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMovement overwrites any union data inside the ExecuteTrajectoryResponse as the provided Movement
func (t *ExecuteTrajectoryResponse) FromMovement(v Movement) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMovement performs a merge with any union data inside the ExecuteTrajectoryResponse, using the provided Movement
func (t *ExecuteTrajectoryResponse) MergeMovement(v Movement) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStandstill returns the union data inside the ExecuteTrajectoryResponse as a Standstill
func (t ExecuteTrajectoryResponse) AsStandstill() (Standstill, error) {
	var body Standstill
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStandstill overwrites any union data inside the ExecuteTrajectoryResponse as the provided Standstill
func (t *ExecuteTrajectoryResponse) FromStandstill(v Standstill) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStandstill performs a merge with any union data inside the ExecuteTrajectoryResponse, using the provided Standstill
func (t *ExecuteTrajectoryResponse) MergeStandstill(v Standstill) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPauseMovementResponse returns the union data inside the ExecuteTrajectoryResponse as a PauseMovementResponse
func (t ExecuteTrajectoryResponse) AsPauseMovementResponse() (PauseMovementResponse, error) {
	var body PauseMovementResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPauseMovementResponse overwrites any union data inside the ExecuteTrajectoryResponse as the provided PauseMovementResponse
func (t *ExecuteTrajectoryResponse) FromPauseMovementResponse(v PauseMovementResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePauseMovementResponse performs a merge with any union data inside the ExecuteTrajectoryResponse, using the provided PauseMovementResponse
func (t *ExecuteTrajectoryResponse) MergePauseMovementResponse(v PauseMovementResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlaybackSpeedResponse returns the union data inside the ExecuteTrajectoryResponse as a PlaybackSpeedResponse
func (t ExecuteTrajectoryResponse) AsPlaybackSpeedResponse() (PlaybackSpeedResponse, error) {
	var body PlaybackSpeedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaybackSpeedResponse overwrites any union data inside the ExecuteTrajectoryResponse as the provided PlaybackSpeedResponse
func (t *ExecuteTrajectoryResponse) FromPlaybackSpeedResponse(v PlaybackSpeedResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaybackSpeedResponse performs a merge with any union data inside the ExecuteTrajectoryResponse, using the provided PlaybackSpeedResponse
func (t *ExecuteTrajectoryResponse) MergePlaybackSpeedResponse(v PlaybackSpeedResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMovementError returns the union data inside the ExecuteTrajectoryResponse as a MovementError
func (t ExecuteTrajectoryResponse) AsMovementError() (MovementError, error) {
	var body MovementError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMovementError overwrites any union data inside the ExecuteTrajectoryResponse as the provided MovementError
func (t *ExecuteTrajectoryResponse) FromMovementError(v MovementError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMovementError performs a merge with any union data inside the ExecuteTrajectoryResponse, using the provided MovementError
func (t *ExecuteTrajectoryResponse) MergeMovementError(v MovementError) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ExecuteTrajectoryResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExecuteTrajectoryResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBlendingAuto returns the union data inside the MotionCommand_Blending as a BlendingAuto
func (t MotionCommand_Blending) AsBlendingAuto() (BlendingAuto, error) {
	var body BlendingAuto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlendingAuto overwrites any union data inside the MotionCommand_Blending as the provided BlendingAuto
func (t *MotionCommand_Blending) FromBlendingAuto(v BlendingAuto) error {
	v.BlendingName = "BlendingAuto"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlendingAuto performs a merge with any union data inside the MotionCommand_Blending, using the provided BlendingAuto
func (t *MotionCommand_Blending) MergeBlendingAuto(v BlendingAuto) error {
	v.BlendingName = "BlendingAuto"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlendingPosition returns the union data inside the MotionCommand_Blending as a BlendingPosition
func (t MotionCommand_Blending) AsBlendingPosition() (BlendingPosition, error) {
	var body BlendingPosition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlendingPosition overwrites any union data inside the MotionCommand_Blending as the provided BlendingPosition
func (t *MotionCommand_Blending) FromBlendingPosition(v BlendingPosition) error {
	v.BlendingName = "BlendingPosition"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlendingPosition performs a merge with any union data inside the MotionCommand_Blending, using the provided BlendingPosition
func (t *MotionCommand_Blending) MergeBlendingPosition(v BlendingPosition) error {
	v.BlendingName = "BlendingPosition"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MotionCommand_Blending) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"blending_name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MotionCommand_Blending) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BlendingAuto":
		return t.AsBlendingAuto()
	case "BlendingPosition":
		return t.AsBlendingPosition()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MotionCommand_Blending) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MotionCommand_Blending) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPathCartesianPTP returns the union data inside the MotionCommand_Path as a PathCartesianPTP
func (t MotionCommand_Path) AsPathCartesianPTP() (PathCartesianPTP, error) {
	var body PathCartesianPTP
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathCartesianPTP overwrites any union data inside the MotionCommand_Path as the provided PathCartesianPTP
func (t *MotionCommand_Path) FromPathCartesianPTP(v PathCartesianPTP) error {
	v.PathDefinitionName = "PathCartesianPTP"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathCartesianPTP performs a merge with any union data inside the MotionCommand_Path, using the provided PathCartesianPTP
func (t *MotionCommand_Path) MergePathCartesianPTP(v PathCartesianPTP) error {
	v.PathDefinitionName = "PathCartesianPTP"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPathCubicSpline returns the union data inside the MotionCommand_Path as a PathCubicSpline
func (t MotionCommand_Path) AsPathCubicSpline() (PathCubicSpline, error) {
	var body PathCubicSpline
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathCubicSpline overwrites any union data inside the MotionCommand_Path as the provided PathCubicSpline
func (t *MotionCommand_Path) FromPathCubicSpline(v PathCubicSpline) error {
	v.PathDefinitionName = "PathCubicSpline"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathCubicSpline performs a merge with any union data inside the MotionCommand_Path, using the provided PathCubicSpline
func (t *MotionCommand_Path) MergePathCubicSpline(v PathCubicSpline) error {
	v.PathDefinitionName = "PathCubicSpline"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPathLine returns the union data inside the MotionCommand_Path as a PathLine
func (t MotionCommand_Path) AsPathLine() (PathLine, error) {
	var body PathLine
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathLine overwrites any union data inside the MotionCommand_Path as the provided PathLine
func (t *MotionCommand_Path) FromPathLine(v PathLine) error {
	v.PathDefinitionName = "PathLine"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathLine performs a merge with any union data inside the MotionCommand_Path, using the provided PathLine
func (t *MotionCommand_Path) MergePathLine(v PathLine) error {
	v.PathDefinitionName = "PathLine"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPathCircle returns the union data inside the MotionCommand_Path as a PathCircle
func (t MotionCommand_Path) AsPathCircle() (PathCircle, error) {
	var body PathCircle
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathCircle overwrites any union data inside the MotionCommand_Path as the provided PathCircle
func (t *MotionCommand_Path) FromPathCircle(v PathCircle) error {
	v.PathDefinitionName = "PathCircle"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathCircle performs a merge with any union data inside the MotionCommand_Path, using the provided PathCircle
func (t *MotionCommand_Path) MergePathCircle(v PathCircle) error {
	v.PathDefinitionName = "PathCircle"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPathJointPTP returns the union data inside the MotionCommand_Path as a PathJointPTP
func (t MotionCommand_Path) AsPathJointPTP() (PathJointPTP, error) {
	var body PathJointPTP
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPathJointPTP overwrites any union data inside the MotionCommand_Path as the provided PathJointPTP
func (t *MotionCommand_Path) FromPathJointPTP(v PathJointPTP) error {
	v.PathDefinitionName = "PathJointPTP"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePathJointPTP performs a merge with any union data inside the MotionCommand_Path, using the provided PathJointPTP
func (t *MotionCommand_Path) MergePathJointPTP(v PathJointPTP) error {
	v.PathDefinitionName = "PathJointPTP"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MotionCommand_Path) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"path_definition_name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MotionCommand_Path) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "PathCartesianPTP":
		return t.AsPathCartesianPTP()
	case "PathCircle":
		return t.AsPathCircle()
	case "PathCubicSpline":
		return t.AsPathCubicSpline()
	case "PathJointPTP":
		return t.AsPathJointPTP()
	case "PathLine":
		return t.AsPathLine()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MotionCommand_Path) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MotionCommand_Path) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOpcuaNodeValueTriggerConfigNodeValue0 returns the union data inside the OpcuaNodeValueTriggerConfig_NodeValue as a OpcuaNodeValueTriggerConfigNodeValue0
func (t OpcuaNodeValueTriggerConfig_NodeValue) AsOpcuaNodeValueTriggerConfigNodeValue0() (OpcuaNodeValueTriggerConfigNodeValue0, error) {
	var body OpcuaNodeValueTriggerConfigNodeValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpcuaNodeValueTriggerConfigNodeValue0 overwrites any union data inside the OpcuaNodeValueTriggerConfig_NodeValue as the provided OpcuaNodeValueTriggerConfigNodeValue0
func (t *OpcuaNodeValueTriggerConfig_NodeValue) FromOpcuaNodeValueTriggerConfigNodeValue0(v OpcuaNodeValueTriggerConfigNodeValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpcuaNodeValueTriggerConfigNodeValue0 performs a merge with any union data inside the OpcuaNodeValueTriggerConfig_NodeValue, using the provided OpcuaNodeValueTriggerConfigNodeValue0
func (t *OpcuaNodeValueTriggerConfig_NodeValue) MergeOpcuaNodeValueTriggerConfigNodeValue0(v OpcuaNodeValueTriggerConfigNodeValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpcuaNodeValueTriggerConfigNodeValue1 returns the union data inside the OpcuaNodeValueTriggerConfig_NodeValue as a OpcuaNodeValueTriggerConfigNodeValue1
func (t OpcuaNodeValueTriggerConfig_NodeValue) AsOpcuaNodeValueTriggerConfigNodeValue1() (OpcuaNodeValueTriggerConfigNodeValue1, error) {
	var body OpcuaNodeValueTriggerConfigNodeValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpcuaNodeValueTriggerConfigNodeValue1 overwrites any union data inside the OpcuaNodeValueTriggerConfig_NodeValue as the provided OpcuaNodeValueTriggerConfigNodeValue1
func (t *OpcuaNodeValueTriggerConfig_NodeValue) FromOpcuaNodeValueTriggerConfigNodeValue1(v OpcuaNodeValueTriggerConfigNodeValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpcuaNodeValueTriggerConfigNodeValue1 performs a merge with any union data inside the OpcuaNodeValueTriggerConfig_NodeValue, using the provided OpcuaNodeValueTriggerConfigNodeValue1
func (t *OpcuaNodeValueTriggerConfig_NodeValue) MergeOpcuaNodeValueTriggerConfigNodeValue1(v OpcuaNodeValueTriggerConfigNodeValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpcuaNodeValueTriggerConfigNodeValue2 returns the union data inside the OpcuaNodeValueTriggerConfig_NodeValue as a OpcuaNodeValueTriggerConfigNodeValue2
func (t OpcuaNodeValueTriggerConfig_NodeValue) AsOpcuaNodeValueTriggerConfigNodeValue2() (OpcuaNodeValueTriggerConfigNodeValue2, error) {
	var body OpcuaNodeValueTriggerConfigNodeValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpcuaNodeValueTriggerConfigNodeValue2 overwrites any union data inside the OpcuaNodeValueTriggerConfig_NodeValue as the provided OpcuaNodeValueTriggerConfigNodeValue2
func (t *OpcuaNodeValueTriggerConfig_NodeValue) FromOpcuaNodeValueTriggerConfigNodeValue2(v OpcuaNodeValueTriggerConfigNodeValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpcuaNodeValueTriggerConfigNodeValue2 performs a merge with any union data inside the OpcuaNodeValueTriggerConfig_NodeValue, using the provided OpcuaNodeValueTriggerConfigNodeValue2
func (t *OpcuaNodeValueTriggerConfig_NodeValue) MergeOpcuaNodeValueTriggerConfigNodeValue2(v OpcuaNodeValueTriggerConfigNodeValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OpcuaNodeValueTriggerConfig_NodeValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OpcuaNodeValueTriggerConfig_NodeValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDoubleArray returns the union data inside the PlanCollisionFreePTPRequest_Target as a DoubleArray
func (t PlanCollisionFreePTPRequest_Target) AsDoubleArray() (DoubleArray, error) {
	var body DoubleArray
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDoubleArray overwrites any union data inside the PlanCollisionFreePTPRequest_Target as the provided DoubleArray
func (t *PlanCollisionFreePTPRequest_Target) FromDoubleArray(v DoubleArray) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDoubleArray performs a merge with any union data inside the PlanCollisionFreePTPRequest_Target, using the provided DoubleArray
func (t *PlanCollisionFreePTPRequest_Target) MergeDoubleArray(v DoubleArray) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPose2 returns the union data inside the PlanCollisionFreePTPRequest_Target as a Pose2
func (t PlanCollisionFreePTPRequest_Target) AsPose2() (Pose2, error) {
	var body Pose2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPose2 overwrites any union data inside the PlanCollisionFreePTPRequest_Target as the provided Pose2
func (t *PlanCollisionFreePTPRequest_Target) FromPose2(v Pose2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePose2 performs a merge with any union data inside the PlanCollisionFreePTPRequest_Target, using the provided Pose2
func (t *PlanCollisionFreePTPRequest_Target) MergePose2(v Pose2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlanCollisionFreePTPRequest_Target) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlanCollisionFreePTPRequest_Target) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFeedbackOutOfWorkspace returns the union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as a FeedbackOutOfWorkspace
func (t PlanTrajectoryFailedResponse_ErrorFeedback) AsFeedbackOutOfWorkspace() (FeedbackOutOfWorkspace, error) {
	var body FeedbackOutOfWorkspace
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeedbackOutOfWorkspace overwrites any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as the provided FeedbackOutOfWorkspace
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) FromFeedbackOutOfWorkspace(v FeedbackOutOfWorkspace) error {
	v.ErrorFeedbackName = "FeedbackOutOfWorkspace"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeedbackOutOfWorkspace performs a merge with any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback, using the provided FeedbackOutOfWorkspace
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) MergeFeedbackOutOfWorkspace(v FeedbackOutOfWorkspace) error {
	v.ErrorFeedbackName = "FeedbackOutOfWorkspace"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeedbackSingularity returns the union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as a FeedbackSingularity
func (t PlanTrajectoryFailedResponse_ErrorFeedback) AsFeedbackSingularity() (FeedbackSingularity, error) {
	var body FeedbackSingularity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeedbackSingularity overwrites any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as the provided FeedbackSingularity
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) FromFeedbackSingularity(v FeedbackSingularity) error {
	v.ErrorFeedbackName = "FeedbackSingularity"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeedbackSingularity performs a merge with any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback, using the provided FeedbackSingularity
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) MergeFeedbackSingularity(v FeedbackSingularity) error {
	v.ErrorFeedbackName = "FeedbackSingularity"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeedbackJointLimitExceeded returns the union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as a FeedbackJointLimitExceeded
func (t PlanTrajectoryFailedResponse_ErrorFeedback) AsFeedbackJointLimitExceeded() (FeedbackJointLimitExceeded, error) {
	var body FeedbackJointLimitExceeded
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeedbackJointLimitExceeded overwrites any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as the provided FeedbackJointLimitExceeded
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) FromFeedbackJointLimitExceeded(v FeedbackJointLimitExceeded) error {
	v.ErrorFeedbackName = "FeedbackJointLimitExceeded"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeedbackJointLimitExceeded performs a merge with any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback, using the provided FeedbackJointLimitExceeded
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) MergeFeedbackJointLimitExceeded(v FeedbackJointLimitExceeded) error {
	v.ErrorFeedbackName = "FeedbackJointLimitExceeded"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFeedbackCollision returns the union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as a FeedbackCollision
func (t PlanTrajectoryFailedResponse_ErrorFeedback) AsFeedbackCollision() (FeedbackCollision, error) {
	var body FeedbackCollision
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeedbackCollision overwrites any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback as the provided FeedbackCollision
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) FromFeedbackCollision(v FeedbackCollision) error {
	v.ErrorFeedbackName = "FeedbackCollision"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeedbackCollision performs a merge with any union data inside the PlanTrajectoryFailedResponse_ErrorFeedback, using the provided FeedbackCollision
func (t *PlanTrajectoryFailedResponse_ErrorFeedback) MergeFeedbackCollision(v FeedbackCollision) error {
	v.ErrorFeedbackName = "FeedbackCollision"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlanTrajectoryFailedResponse_ErrorFeedback) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"error_feedback_name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PlanTrajectoryFailedResponse_ErrorFeedback) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "FeedbackCollision":
		return t.AsFeedbackCollision()
	case "FeedbackJointLimitExceeded":
		return t.AsFeedbackJointLimitExceeded()
	case "FeedbackOutOfWorkspace":
		return t.AsFeedbackOutOfWorkspace()
	case "FeedbackSingularity":
		return t.AsFeedbackSingularity()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PlanTrajectoryFailedResponse_ErrorFeedback) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlanTrajectoryFailedResponse_ErrorFeedback) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJointTrajectory returns the union data inside the PlanTrajectoryResponse_Response as a JointTrajectory
func (t PlanTrajectoryResponse_Response) AsJointTrajectory() (JointTrajectory, error) {
	var body JointTrajectory
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJointTrajectory overwrites any union data inside the PlanTrajectoryResponse_Response as the provided JointTrajectory
func (t *PlanTrajectoryResponse_Response) FromJointTrajectory(v JointTrajectory) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJointTrajectory performs a merge with any union data inside the PlanTrajectoryResponse_Response, using the provided JointTrajectory
func (t *PlanTrajectoryResponse_Response) MergeJointTrajectory(v JointTrajectory) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlanTrajectoryFailedResponse returns the union data inside the PlanTrajectoryResponse_Response as a PlanTrajectoryFailedResponse
func (t PlanTrajectoryResponse_Response) AsPlanTrajectoryFailedResponse() (PlanTrajectoryFailedResponse, error) {
	var body PlanTrajectoryFailedResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlanTrajectoryFailedResponse overwrites any union data inside the PlanTrajectoryResponse_Response as the provided PlanTrajectoryFailedResponse
func (t *PlanTrajectoryResponse_Response) FromPlanTrajectoryFailedResponse(v PlanTrajectoryFailedResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlanTrajectoryFailedResponse performs a merge with any union data inside the PlanTrajectoryResponse_Response, using the provided PlanTrajectoryFailedResponse
func (t *PlanTrajectoryResponse_Response) MergePlanTrajectoryFailedResponse(v PlanTrajectoryFailedResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlanTrajectoryResponse_Response) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlanTrajectoryResponse_Response) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAbbController returns the union data inside the ControllerConfig as a AbbController
func (t ControllerConfig) AsAbbController() (AbbController, error) {
	var body AbbController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAbbController overwrites any union data inside the ControllerConfig as the provided AbbController
func (t *ControllerConfig) FromAbbController(v AbbController) error {
	v.Kind = "AbbController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAbbController performs a merge with any union data inside the ControllerConfig, using the provided AbbController
func (t *ControllerConfig) MergeAbbController(v AbbController) error {
	v.Kind = "AbbController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFanucController returns the union data inside the ControllerConfig as a FanucController
func (t ControllerConfig) AsFanucController() (FanucController, error) {
	var body FanucController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFanucController overwrites any union data inside the ControllerConfig as the provided FanucController
func (t *ControllerConfig) FromFanucController(v FanucController) error {
	v.Kind = "FanucController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFanucController performs a merge with any union data inside the ControllerConfig, using the provided FanucController
func (t *ControllerConfig) MergeFanucController(v FanucController) error {
	v.Kind = "FanucController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKukaController returns the union data inside the ControllerConfig as a KukaController
func (t ControllerConfig) AsKukaController() (KukaController, error) {
	var body KukaController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKukaController overwrites any union data inside the ControllerConfig as the provided KukaController
func (t *ControllerConfig) FromKukaController(v KukaController) error {
	v.Kind = "KukaController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKukaController performs a merge with any union data inside the ControllerConfig, using the provided KukaController
func (t *ControllerConfig) MergeKukaController(v KukaController) error {
	v.Kind = "KukaController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUniversalrobotsController returns the union data inside the ControllerConfig as a UniversalrobotsController
func (t ControllerConfig) AsUniversalrobotsController() (UniversalrobotsController, error) {
	var body UniversalrobotsController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUniversalrobotsController overwrites any union data inside the ControllerConfig as the provided UniversalrobotsController
func (t *ControllerConfig) FromUniversalrobotsController(v UniversalrobotsController) error {
	v.Kind = "UniversalrobotsController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUniversalrobotsController performs a merge with any union data inside the ControllerConfig, using the provided UniversalrobotsController
func (t *ControllerConfig) MergeUniversalrobotsController(v UniversalrobotsController) error {
	v.Kind = "UniversalrobotsController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualController returns the union data inside the ControllerConfig as a VirtualController
func (t ControllerConfig) AsVirtualController() (VirtualController, error) {
	var body VirtualController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualController overwrites any union data inside the ControllerConfig as the provided VirtualController
func (t *ControllerConfig) FromVirtualController(v VirtualController) error {
	v.Kind = "VirtualController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualController performs a merge with any union data inside the ControllerConfig, using the provided VirtualController
func (t *ControllerConfig) MergeVirtualController(v VirtualController) error {
	v.Kind = "VirtualController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsYaskawaController returns the union data inside the ControllerConfig as a YaskawaController
func (t ControllerConfig) AsYaskawaController() (YaskawaController, error) {
	var body YaskawaController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromYaskawaController overwrites any union data inside the ControllerConfig as the provided YaskawaController
func (t *ControllerConfig) FromYaskawaController(v YaskawaController) error {
	v.Kind = "YaskawaController"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeYaskawaController performs a merge with any union data inside the ControllerConfig, using the provided YaskawaController
func (t *ControllerConfig) MergeYaskawaController(v YaskawaController) error {
	v.Kind = "YaskawaController"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ControllerConfig) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"kind"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ControllerConfig) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "AbbController":
		return t.AsAbbController()
	case "FanucController":
		return t.AsFanucController()
	case "KukaController":
		return t.AsKukaController()
	case "UniversalrobotsController":
		return t.AsUniversalrobotsController()
	case "VirtualController":
		return t.AsVirtualController()
	case "YaskawaController":
		return t.AsYaskawaController()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ControllerConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ControllerConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsValidationErrorLoc0 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc0
func (t ValidationError_Loc_Item) AsValidationErrorLoc0() (ValidationErrorLoc0, error) {
	var body ValidationErrorLoc0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc0 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) FromValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc0 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsValidationErrorLoc1 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc1
func (t ValidationError_Loc_Item) AsValidationErrorLoc1() (ValidationErrorLoc1, error) {
	var body ValidationErrorLoc1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc1 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) FromValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc1 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ValidationError_Loc_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOpcuaNodeValueTriggerConfig returns the union data inside the TriggerObject_Config as a OpcuaNodeValueTriggerConfig
func (t TriggerObject_Config) AsOpcuaNodeValueTriggerConfig() (OpcuaNodeValueTriggerConfig, error) {
	var body OpcuaNodeValueTriggerConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpcuaNodeValueTriggerConfig overwrites any union data inside the TriggerObject_Config as the provided OpcuaNodeValueTriggerConfig
func (t *TriggerObject_Config) FromOpcuaNodeValueTriggerConfig(v OpcuaNodeValueTriggerConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpcuaNodeValueTriggerConfig performs a merge with any union data inside the TriggerObject_Config, using the provided OpcuaNodeValueTriggerConfig
func (t *TriggerObject_Config) MergeOpcuaNodeValueTriggerConfig(v OpcuaNodeValueTriggerConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t TriggerObject_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TriggerObject_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListCells request
	ListCells(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeployCellWithBody request with any body
	DeployCellWithBody(ctx context.Context, params *DeployCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeployCell(ctx context.Context, params *DeployCellParams, body DeployCellJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCell request
	DeleteCell(ctx context.Context, cellID CellID, params *DeleteCellParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCell request
	GetCell(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCellWithBody request with any body
	UpdateCellWithBody(ctx context.Context, cellID CellID, params *UpdateCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCell(ctx context.Context, cellID CellID, params *UpdateCellParams, body UpdateCellJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearApps request
	ClearApps(ctx context.Context, cellID CellID, params *ClearAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApps request
	ListApps(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAppWithBody request with any body
	AddAppWithBody(ctx context.Context, cellID CellID, params *AddAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddApp(ctx context.Context, cellID CellID, params *AddAppParams, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApp request
	DeleteApp(ctx context.Context, cellID CellID, appID AppID, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppWithBody request with any body
	UpdateAppWithBody(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApp(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearRobotControllers request
	ClearRobotControllers(ctx context.Context, cellID CellID, params *ClearRobotControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListControllers request
	ListControllers(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRobotControllerWithBody request with any body
	AddRobotControllerWithBody(ctx context.Context, cellID CellID, params *AddRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRobotController(ctx context.Context, cellID CellID, params *AddRobotControllerParams, body AddRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRobotController request
	DeleteRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, params *DeleteRobotControllerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRobotController request
	GetRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRobotControllerWithBody request with any body
	UpdateRobotControllerWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, body UpdateRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSupportedModes request
	GetSupportedModes(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamFreeDrive request
	StreamFreeDrive(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIODescriptions request
	ListIODescriptions(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamIOValues request
	StreamIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIOValues request
	ListIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOutputValuesWithBody request with any body
	SetOutputValuesWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetOutputValues(ctx context.Context, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WaitForIOEvent request
	WaitForIOEvent(ctx context.Context, cellID CellID, controllerID ControllerID, params *WaitForIOEventParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMode request
	GetMode(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetDefaultMode request
	SetDefaultMode(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamModeChange request
	StreamModeChange(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentRobotControllerState request
	GetCurrentRobotControllerState(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamRobotControllerState request
	StreamRobotControllerState(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVirtualRobotCoordinateSystems request
	ListVirtualRobotCoordinateSystems(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddVirtualRobotCoordinateSystemWithBody request with any body
	AddVirtualRobotCoordinateSystemWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddVirtualRobotCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, body AddVirtualRobotCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualRobotCoordinateSystem request
	DeleteVirtualRobotCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystem CoordinateSystem, params *DeleteVirtualRobotCoordinateSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCycleTime request
	GetCycleTime(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEStop request
	GetEStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PushEStop request
	PushEStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReleaseEStop request
	ReleaseEStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIOs request
	ListIOs(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualRobotIOValue request
	GetVirtualRobotIOValue(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetVirtualRobotIOValue request
	SetVirtualRobotIOValue(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, params *SetVirtualRobotIOValueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExternalJointsStreamWithBody request with any body
	ExternalJointsStreamWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExternalJointsStream(ctx context.Context, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroupState request
	GetMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMotionGroupStateWithBody request with any body
	SetMotionGroupStateWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetMotionGroupStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroupBehavior request
	GetMotionGroupBehavior(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetMotionGroupBehavior request
	SetMotionGroupBehavior(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, params *SetMotionGroupBehaviorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualRobotMounting request
	GetVirtualRobotMounting(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetVirtualRobotMountingWithBody request with any body
	SetVirtualRobotMountingWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetVirtualRobotMounting(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetVirtualRobotMountingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVirtualRobotTcps request
	ListVirtualRobotTcps(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddVirtualRobotTcpWithBody request with any body
	AddVirtualRobotTcpWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddVirtualRobotTcp(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body AddVirtualRobotTcpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualRobotTcp request
	DeleteVirtualRobotTcp(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, tcp Tcp, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroups request
	GetMotionGroups(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOperationMode request
	GetOperationMode(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetOperationMode request
	SetOperationMode(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetOperationModeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualRobotConfiguration request
	GetVirtualRobotConfiguration(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCoordinateSystems request
	ListCoordinateSystems(ctx context.Context, cellID CellID, params *ListCoordinateSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddCoordinateSystemWithBody request with any body
	AddCoordinateSystemWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddCoordinateSystem(ctx context.Context, cellID CellID, body AddCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCoordinateSystem request
	DeleteCoordinateSystem(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoordinateSystem request
	GetCoordinateSystem(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, params *GetCoordinateSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransformInCoordinateSystemWithBody request with any body
	TransformInCoordinateSystemWithBody(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransformInCoordinateSystem(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, body TransformInCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearDevices request
	ClearDevices(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDeviceWithBody request with any body
	CreateDeviceWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDevice(ctx context.Context, cellID CellID, body CreateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDevice request
	DeleteDevice(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDevice request
	GetDevice(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMotionGroups request
	ListMotionGroups(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateMotionGroup request
	ActivateMotionGroup(ctx context.Context, cellID CellID, params *ActivateMotionGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateAllMotionGroups request
	ActivateAllMotionGroups(ctx context.Context, cellID CellID, params *ActivateAllMotionGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JointJoggingWithBody request with any body
	JointJoggingWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JointJogging(ctx context.Context, cellID CellID, body JointJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DirectionJoggingWithBody request with any body
	DirectionJoggingWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DirectionJogging(ctx context.Context, cellID CellID, body DirectionJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeactivateMotionGroup request
	DeactivateMotionGroup(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInfoCapabilities request
	GetInfoCapabilities(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJoggingCapabilities request
	GetJoggingCapabilities(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKinematicCapabilities request
	GetKinematicCapabilities(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CalculateAllInverseKinematicWithBody request with any body
	CalculateAllInverseKinematicWithBody(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CalculateAllInverseKinematic(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateAllInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CalculateInverseKinematicWithBody request with any body
	CalculateInverseKinematicWithBody(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CalculateInverseKinematic(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CalculateForwardKinematicWithBody request with any body
	CalculateForwardKinematicWithBody(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CalculateForwardKinematic(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateForwardKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMounting request
	GetMounting(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOptimizerConfiguration request
	GetOptimizerConfiguration(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetOptimizerConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPayloads request
	ListPayloads(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivePayload request
	GetActivePayload(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSafetySetup request
	GetSafetySetup(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionGroupSpecification request
	GetMotionGroupSpecification(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentMotionGroupState request
	GetCurrentMotionGroupState(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetCurrentMotionGroupStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamMotionGroupState request
	StreamMotionGroupState(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *StreamMotionGroupStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopJogging request
	StopJogging(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTcps request
	ListTcps(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *ListTcpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActiveTcp request
	GetActiveTcp(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetActiveTcpParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlanningMotionGroupModels request
	GetPlanningMotionGroupModels(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlanCollisionFreePTPWithBody request with any body
	PlanCollisionFreePTPWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PlanCollisionFreePTP(ctx context.Context, cellID CellID, body PlanCollisionFreePTPJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlanTrajectoryWithBody request with any body
	PlanTrajectoryWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PlanTrajectory(ctx context.Context, cellID CellID, body PlanTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAllMotions request
	DeleteAllMotions(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMotions request
	ListMotions(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlanMotionWithBody request with any body
	PlanMotionWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PlanMotion(ctx context.Context, cellID CellID, body PlanMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteTrajectoryWithBody request with any body
	ExecuteTrajectoryWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteTrajectory(ctx context.Context, cellID CellID, body ExecuteTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamMoveWithBody request with any body
	StreamMoveWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StreamMove(ctx context.Context, cellID CellID, body StreamMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMotion request
	DeleteMotion(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamMoveBackward request
	StreamMoveBackward(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveBackwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamMoveForward request
	StreamMoveForward(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamMoveToTrajectoryViaJointPTP request
	StreamMoveToTrajectoryViaJointPTP(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveToTrajectoryViaJointPTPParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlannedMotion request
	GetPlannedMotion(ctx context.Context, cellID CellID, motion Motion, params *GetPlannedMotionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopExecution request
	StopExecution(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionTrajectory request
	GetMotionTrajectory(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMotionTrajectorySample request
	GetMotionTrajectorySample(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectorySampleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllProgramRuns request
	GetAllProgramRuns(ctx context.Context, cellID CellID, params *GetAllProgramRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProgramRunWithBody request with any body
	CreateProgramRunWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProgramRun(ctx context.Context, cellID CellID, body CreateProgramRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgramRun request
	GetProgramRun(ctx context.Context, cellID CellID, run string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTriggers request
	GetAllTriggers(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTriggerWithBody request with any body
	CreateTriggerWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTrigger(ctx context.Context, cellID CellID, body CreateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTrigger request
	DeleteTrigger(ctx context.Context, cellID CellID, trigger string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTrigger request
	GetTrigger(ctx context.Context, cellID CellID, trigger string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTriggerWithBody request with any body
	UpdateTriggerWithBody(ctx context.Context, cellID CellID, trigger string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTrigger(ctx context.Context, cellID CellID, trigger string, body UpdateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadPlannedMotionWithBody request with any body
	LoadPlannedMotionWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoadPlannedMotion(ctx context.Context, cellID CellID, body LoadPlannedMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearProgramsValues request
	ClearProgramsValues(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProgramsValueWithBody request with any body
	CreateProgramsValueWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProgramsValue(ctx context.Context, cellID CellID, body CreateProgramsValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProgramValue request
	DeleteProgramValue(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgramValue request
	GetProgramValue(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProgramValueWithBody request with any body
	UpdateProgramValueWithBody(ctx context.Context, cellID CellID, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProgramValue(ctx context.Context, cellID CellID, key string, body UpdateProgramValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCellStatus request
	GetCellStatus(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStoredColliders request
	ListStoredColliders(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoredCollider request
	DeleteStoredCollider(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoredCollider request
	GetStoredCollider(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreColliderWithBody request with any body
	StoreColliderWithBody(ctx context.Context, cellID CellID, colliderID ColliderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCollider(ctx context.Context, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultLinkChain request
	GetDefaultLinkChain(ctx context.Context, cellID CellID, motionGroupModel GetDefaultLinkChainParamsMotionGroupModel, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCollisionLinkChains request
	ListCollisionLinkChains(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoredCollisionLinkChain request
	DeleteStoredCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoredCollisionLinkChain request
	GetStoredCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreCollisionLinkChainWithBody request with any body
	StoreCollisionLinkChainWithBody(ctx context.Context, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStoredCollisionScenes request
	ListStoredCollisionScenes(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoredCollisionScene request
	DeleteStoredCollisionScene(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoredCollisionScene request
	GetStoredCollisionScene(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreCollisionSceneWithBody request with any body
	StoreCollisionSceneWithBody(ctx context.Context, cellID CellID, sceneID SceneID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCollisionScene(ctx context.Context, cellID CellID, sceneID SceneID, body StoreCollisionSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStoredCollisionTools request
	ListStoredCollisionTools(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStoredCollisionTool request
	DeleteStoredCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStoredCollisionTool request
	GetStoredCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreCollisionToolWithBody request with any body
	StoreCollisionToolWithBody(ctx context.Context, cellID CellID, toolID ToolID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearAllObjects request
	ClearAllObjects(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAllObjectKeys request
	ListAllObjectKeys(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObject request
	DeleteObject(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObject request
	GetObject(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObjectMetadata request
	GetObjectMetadata(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreObjectWithBody request with any body
	StoreObjectWithBody(ctx context.Context, cellID CellID, key Key, params *StoreObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProgramList request
	DeleteProgramList(ctx context.Context, cellID CellID, params *DeleteProgramListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProgramMetadata request
	ListProgramMetadata(ctx context.Context, cellID CellID, params *ListProgramMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProgramWithBody request with any body
	CreateProgramWithBody(ctx context.Context, cellID CellID, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProgramWithTextBody(ctx context.Context, cellID CellID, params *CreateProgramParams, body CreateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProgram request
	DeleteProgram(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgram request
	GetProgram(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProgramWithBody request with any body
	UpdateProgramWithBody(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProgramWithTextBody(ctx context.Context, cellID CellID, program Program, body UpdateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgramMetadata request
	GetProgramMetadata(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProgramMetadataWithBody request with any body
	UpdateProgramMetadataWithBody(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProgramMetadata(ctx context.Context, cellID CellID, program Program, body UpdateProgramMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadProgramMetadataImageWithBody request with any body
	UploadProgramMetadataImageWithBody(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecipeList request
	DeleteRecipeList(ctx context.Context, cellID CellID, params *DeleteRecipeListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRecipeMetadata request
	ListRecipeMetadata(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRecipeWithBody request with any body
	CreateRecipeWithBody(ctx context.Context, cellID CellID, params *CreateRecipeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRecipe(ctx context.Context, cellID CellID, params *CreateRecipeParams, body CreateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecipe request
	DeleteRecipe(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecipe request
	GetRecipe(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRecipeWithBody request with any body
	UpdateRecipeWithBody(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecipe(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecipeMetadata request
	GetRecipeMetadata(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRecipeMetadataWithBody request with any body
	UpdateRecipeMetadataWithBody(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecipeMetadata(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadRecipeMetadataImageWithBody request with any body
	UploadRecipeMetadataImageWithBody(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeactivateLicense request
	DeactivateLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicense request
	GetLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateLicenseWithBody request with any body
	ActivateLicenseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivateLicense(ctx context.Context, body ActivateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLicenseStatus request
	GetLicenseStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDiagnosePackage request
	GetDiagnosePackage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemStatus request
	GetSystemStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckNovaVersionUpdate request
	CheckNovaVersionUpdate(ctx context.Context, params *CheckNovaVersionUpdateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNovaVersionWithBody request with any body
	UpdateNovaVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNovaVersion(ctx context.Context, body UpdateNovaVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSystemVersion request
	GetSystemVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListCells(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCellsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeployCellWithBody(ctx context.Context, params *DeployCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeployCellRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeployCell(ctx context.Context, params *DeployCellParams, body DeployCellJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeployCellRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCell(ctx context.Context, cellID CellID, params *DeleteCellParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCellRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCell(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCellRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCellWithBody(ctx context.Context, cellID CellID, params *UpdateCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCellRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCell(ctx context.Context, cellID CellID, params *UpdateCellParams, body UpdateCellJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCellRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearApps(ctx context.Context, cellID CellID, params *ClearAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearAppsRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApps(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddAppWithBody(ctx context.Context, cellID CellID, params *AddAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAppRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddApp(ctx context.Context, cellID CellID, params *AddAppParams, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAppRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApp(ctx context.Context, cellID CellID, appID AppID, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppRequest(c.Server, cellID, appID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApp(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, cellID, appID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppWithBody(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequestWithBody(c.Server, cellID, appID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApp(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequest(c.Server, cellID, appID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearRobotControllers(ctx context.Context, cellID CellID, params *ClearRobotControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearRobotControllersRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListControllers(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListControllersRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRobotControllerWithBody(ctx context.Context, cellID CellID, params *AddRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRobotControllerRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRobotController(ctx context.Context, cellID CellID, params *AddRobotControllerParams, body AddRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRobotControllerRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, params *DeleteRobotControllerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRobotControllerRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRobotControllerRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRobotControllerWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRobotControllerRequestWithBody(c.Server, cellID, controllerID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRobotController(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, body UpdateRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRobotControllerRequest(c.Server, cellID, controllerID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSupportedModes(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSupportedModesRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamFreeDrive(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamFreeDriveRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIODescriptions(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIODescriptionsRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamIOValuesRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIOValues(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIOValuesRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOutputValuesWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOutputValuesRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOutputValues(ctx context.Context, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOutputValuesRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WaitForIOEvent(ctx context.Context, cellID CellID, controllerID ControllerID, params *WaitForIOEventParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWaitForIOEventRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMode(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModeRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetDefaultMode(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetDefaultModeRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamModeChange(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamModeChangeRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentRobotControllerState(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentRobotControllerStateRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamRobotControllerState(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamRobotControllerStateRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVirtualRobotCoordinateSystems(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVirtualRobotCoordinateSystemsRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualRobotCoordinateSystemWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualRobotCoordinateSystemRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualRobotCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, body AddVirtualRobotCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualRobotCoordinateSystemRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualRobotCoordinateSystem(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystem CoordinateSystem, params *DeleteVirtualRobotCoordinateSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualRobotCoordinateSystemRequest(c.Server, cellID, controllerID, coordinateSystem, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCycleTime(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCycleTimeRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEStopRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PushEStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPushEStopRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseEStop(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseEStopRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIOs(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIOsRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualRobotIOValue(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualRobotIOValueRequest(c.Server, cellID, controllerID, io)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetVirtualRobotIOValue(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, params *SetVirtualRobotIOValueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetVirtualRobotIOValueRequest(c.Server, cellID, controllerID, io, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalJointsStreamWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalJointsStreamRequestWithBody(c.Server, cellID, controllerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalJointsStream(ctx context.Context, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalJointsStreamRequest(c.Server, cellID, controllerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupStateRequest(c.Server, cellID, controllerID, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMotionGroupStateWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMotionGroupStateRequestWithBody(c.Server, cellID, controllerID, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMotionGroupState(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetMotionGroupStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMotionGroupStateRequest(c.Server, cellID, controllerID, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroupBehavior(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupBehaviorRequest(c.Server, cellID, controllerID, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetMotionGroupBehavior(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, params *SetMotionGroupBehaviorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetMotionGroupBehaviorRequest(c.Server, cellID, controllerID, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualRobotMounting(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualRobotMountingRequest(c.Server, cellID, controllerID, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetVirtualRobotMountingWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetVirtualRobotMountingRequestWithBody(c.Server, cellID, controllerID, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetVirtualRobotMounting(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetVirtualRobotMountingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetVirtualRobotMountingRequest(c.Server, cellID, controllerID, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVirtualRobotTcps(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVirtualRobotTcpsRequest(c.Server, cellID, controllerID, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualRobotTcpWithBody(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualRobotTcpRequestWithBody(c.Server, cellID, controllerID, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddVirtualRobotTcp(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body AddVirtualRobotTcpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddVirtualRobotTcpRequest(c.Server, cellID, controllerID, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualRobotTcp(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, tcp Tcp, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualRobotTcpRequest(c.Server, cellID, controllerID, id, tcp)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroups(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupsRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOperationMode(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOperationModeRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetOperationMode(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetOperationModeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetOperationModeRequest(c.Server, cellID, controllerID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualRobotConfiguration(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualRobotConfigurationRequest(c.Server, cellID, controllerID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCoordinateSystems(ctx context.Context, cellID CellID, params *ListCoordinateSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCoordinateSystemsRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCoordinateSystemWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCoordinateSystemRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCoordinateSystem(ctx context.Context, cellID CellID, body AddCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCoordinateSystemRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCoordinateSystem(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCoordinateSystemRequest(c.Server, cellID, coordinateSystem)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoordinateSystem(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, params *GetCoordinateSystemParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoordinateSystemRequest(c.Server, cellID, coordinateSystem, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransformInCoordinateSystemWithBody(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransformInCoordinateSystemRequestWithBody(c.Server, cellID, coordinateSystem, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransformInCoordinateSystem(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, body TransformInCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransformInCoordinateSystemRequest(c.Server, cellID, coordinateSystem, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearDevices(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearDevicesRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeviceWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeviceRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDevice(ctx context.Context, cellID CellID, body CreateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeviceRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDevice(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeviceRequest(c.Server, cellID, identifier)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDevice(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeviceRequest(c.Server, cellID, identifier)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMotionGroups(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMotionGroupsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateMotionGroup(ctx context.Context, cellID CellID, params *ActivateMotionGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateMotionGroupRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateAllMotionGroups(ctx context.Context, cellID CellID, params *ActivateAllMotionGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateAllMotionGroupsRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JointJoggingWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJointJoggingRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JointJogging(ctx context.Context, cellID CellID, body JointJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJointJoggingRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectionJoggingWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectionJoggingRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DirectionJogging(ctx context.Context, cellID CellID, body DirectionJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDirectionJoggingRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeactivateMotionGroup(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeactivateMotionGroupRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInfoCapabilities(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInfoCapabilitiesRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJoggingCapabilities(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJoggingCapabilitiesRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKinematicCapabilities(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKinematicCapabilitiesRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculateAllInverseKinematicWithBody(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculateAllInverseKinematicRequestWithBody(c.Server, cellID, motionGroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculateAllInverseKinematic(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateAllInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculateAllInverseKinematicRequest(c.Server, cellID, motionGroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculateInverseKinematicWithBody(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculateInverseKinematicRequestWithBody(c.Server, cellID, motionGroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculateInverseKinematic(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculateInverseKinematicRequest(c.Server, cellID, motionGroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculateForwardKinematicWithBody(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculateForwardKinematicRequestWithBody(c.Server, cellID, motionGroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CalculateForwardKinematic(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateForwardKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCalculateForwardKinematicRequest(c.Server, cellID, motionGroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMounting(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMountingRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOptimizerConfiguration(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetOptimizerConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOptimizerConfigurationRequest(c.Server, cellID, motionGroup, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPayloads(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPayloadsRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivePayload(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivePayloadRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSafetySetup(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSafetySetupRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionGroupSpecification(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionGroupSpecificationRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentMotionGroupState(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetCurrentMotionGroupStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentMotionGroupStateRequest(c.Server, cellID, motionGroup, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMotionGroupState(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *StreamMotionGroupStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMotionGroupStateRequest(c.Server, cellID, motionGroup, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopJogging(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopJoggingRequest(c.Server, cellID, motionGroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTcps(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *ListTcpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTcpsRequest(c.Server, cellID, motionGroup, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActiveTcp(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetActiveTcpParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActiveTcpRequest(c.Server, cellID, motionGroup, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlanningMotionGroupModels(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlanningMotionGroupModelsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanCollisionFreePTPWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanCollisionFreePTPRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanCollisionFreePTP(ctx context.Context, cellID CellID, body PlanCollisionFreePTPJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanCollisionFreePTPRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanTrajectoryWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanTrajectoryRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanTrajectory(ctx context.Context, cellID CellID, body PlanTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanTrajectoryRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAllMotions(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAllMotionsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMotions(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMotionsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanMotionWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanMotionRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlanMotion(ctx context.Context, cellID CellID, body PlanMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlanMotionRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteTrajectoryWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteTrajectoryRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteTrajectory(ctx context.Context, cellID CellID, body ExecuteTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteTrajectoryRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMoveWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMoveRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMove(ctx context.Context, cellID CellID, body StreamMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMoveRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMotion(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMotionRequest(c.Server, cellID, motion)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMoveBackward(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveBackwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMoveBackwardRequest(c.Server, cellID, motion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMoveForward(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMoveForwardRequest(c.Server, cellID, motion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamMoveToTrajectoryViaJointPTP(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveToTrajectoryViaJointPTPParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamMoveToTrajectoryViaJointPTPRequest(c.Server, cellID, motion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlannedMotion(ctx context.Context, cellID CellID, motion Motion, params *GetPlannedMotionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlannedMotionRequest(c.Server, cellID, motion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopExecution(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopExecutionRequest(c.Server, cellID, motion)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionTrajectory(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionTrajectoryRequest(c.Server, cellID, motion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMotionTrajectorySample(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectorySampleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMotionTrajectorySampleRequest(c.Server, cellID, motion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllProgramRuns(ctx context.Context, cellID CellID, params *GetAllProgramRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllProgramRunsRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramRunWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramRunRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramRun(ctx context.Context, cellID CellID, body CreateProgramRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramRunRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgramRun(ctx context.Context, cellID CellID, run string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramRunRequest(c.Server, cellID, run)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTriggers(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTriggersRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTriggerWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTriggerRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTrigger(ctx context.Context, cellID CellID, body CreateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTriggerRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTrigger(ctx context.Context, cellID CellID, trigger string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTriggerRequest(c.Server, cellID, trigger)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrigger(ctx context.Context, cellID CellID, trigger string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTriggerRequest(c.Server, cellID, trigger)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTriggerWithBody(ctx context.Context, cellID CellID, trigger string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTriggerRequestWithBody(c.Server, cellID, trigger, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTrigger(ctx context.Context, cellID CellID, trigger string, body UpdateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTriggerRequest(c.Server, cellID, trigger, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadPlannedMotionWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadPlannedMotionRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadPlannedMotion(ctx context.Context, cellID CellID, body LoadPlannedMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadPlannedMotionRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearProgramsValues(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearProgramsValuesRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramsValueWithBody(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramsValueRequestWithBody(c.Server, cellID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramsValue(ctx context.Context, cellID CellID, body CreateProgramsValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramsValueRequest(c.Server, cellID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProgramValue(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProgramValueRequest(c.Server, cellID, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgramValue(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramValueRequest(c.Server, cellID, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramValueWithBody(ctx context.Context, cellID CellID, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramValueRequestWithBody(c.Server, cellID, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramValue(ctx context.Context, cellID CellID, key string, body UpdateProgramValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramValueRequest(c.Server, cellID, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCellStatus(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCellStatusRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStoredColliders(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStoredCollidersRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoredCollider(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoredColliderRequest(c.Server, cellID, colliderID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoredCollider(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoredColliderRequest(c.Server, cellID, colliderID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreColliderWithBody(ctx context.Context, cellID CellID, colliderID ColliderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreColliderRequestWithBody(c.Server, cellID, colliderID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollider(ctx context.Context, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreColliderRequest(c.Server, cellID, colliderID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultLinkChain(ctx context.Context, cellID CellID, motionGroupModel GetDefaultLinkChainParamsMotionGroupModel, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultLinkChainRequest(c.Server, cellID, motionGroupModel)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCollisionLinkChains(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCollisionLinkChainsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoredCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoredCollisionLinkChainRequest(c.Server, cellID, linkChainID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoredCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoredCollisionLinkChainRequest(c.Server, cellID, linkChainID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionLinkChainWithBody(ctx context.Context, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionLinkChainRequestWithBody(c.Server, cellID, linkChainID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionLinkChain(ctx context.Context, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionLinkChainRequest(c.Server, cellID, linkChainID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStoredCollisionScenes(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStoredCollisionScenesRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoredCollisionScene(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoredCollisionSceneRequest(c.Server, cellID, sceneID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoredCollisionScene(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoredCollisionSceneRequest(c.Server, cellID, sceneID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionSceneWithBody(ctx context.Context, cellID CellID, sceneID SceneID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionSceneRequestWithBody(c.Server, cellID, sceneID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionScene(ctx context.Context, cellID CellID, sceneID SceneID, body StoreCollisionSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionSceneRequest(c.Server, cellID, sceneID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStoredCollisionTools(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStoredCollisionToolsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStoredCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoredCollisionToolRequest(c.Server, cellID, toolID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStoredCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoredCollisionToolRequest(c.Server, cellID, toolID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionToolWithBody(ctx context.Context, cellID CellID, toolID ToolID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionToolRequestWithBody(c.Server, cellID, toolID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreCollisionTool(ctx context.Context, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreCollisionToolRequest(c.Server, cellID, toolID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearAllObjects(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearAllObjectsRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAllObjectKeys(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllObjectKeysRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObject(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectRequest(c.Server, cellID, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObject(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectRequest(c.Server, cellID, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObjectMetadata(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectMetadataRequest(c.Server, cellID, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreObjectWithBody(ctx context.Context, cellID CellID, key Key, params *StoreObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreObjectRequestWithBody(c.Server, cellID, key, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProgramList(ctx context.Context, cellID CellID, params *DeleteProgramListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProgramListRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProgramMetadata(ctx context.Context, cellID CellID, params *ListProgramMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProgramMetadataRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramWithBody(ctx context.Context, cellID CellID, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramWithTextBody(ctx context.Context, cellID CellID, params *CreateProgramParams, body CreateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramRequestWithTextBody(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProgram(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProgramRequest(c.Server, cellID, program)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgram(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramRequest(c.Server, cellID, program)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramWithBody(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramRequestWithBody(c.Server, cellID, program, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramWithTextBody(ctx context.Context, cellID CellID, program Program, body UpdateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramRequestWithTextBody(c.Server, cellID, program, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgramMetadata(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramMetadataRequest(c.Server, cellID, program)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramMetadataWithBody(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramMetadataRequestWithBody(c.Server, cellID, program, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProgramMetadata(ctx context.Context, cellID CellID, program Program, body UpdateProgramMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProgramMetadataRequest(c.Server, cellID, program, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadProgramMetadataImageWithBody(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadProgramMetadataImageRequestWithBody(c.Server, cellID, program, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecipeList(ctx context.Context, cellID CellID, params *DeleteRecipeListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecipeListRequest(c.Server, cellID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRecipeMetadata(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRecipeMetadataRequest(c.Server, cellID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRecipeWithBody(ctx context.Context, cellID CellID, params *CreateRecipeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRecipeRequestWithBody(c.Server, cellID, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRecipe(ctx context.Context, cellID CellID, params *CreateRecipeParams, body CreateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRecipeRequest(c.Server, cellID, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecipe(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecipeRequest(c.Server, cellID, recipe)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecipe(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecipeRequest(c.Server, cellID, recipe)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecipeWithBody(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecipeRequestWithBody(c.Server, cellID, recipe, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecipe(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecipeRequest(c.Server, cellID, recipe, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecipeMetadata(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecipeMetadataRequest(c.Server, cellID, recipe)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecipeMetadataWithBody(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecipeMetadataRequestWithBody(c.Server, cellID, recipe, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecipeMetadata(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecipeMetadataRequest(c.Server, cellID, recipe, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadRecipeMetadataImageWithBody(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadRecipeMetadataImageRequestWithBody(c.Server, cellID, recipe, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeactivateLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeactivateLicenseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicense(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateLicenseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateLicenseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateLicense(ctx context.Context, body ActivateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateLicenseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLicenseStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLicenseStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDiagnosePackage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDiagnosePackageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckNovaVersionUpdate(ctx context.Context, params *CheckNovaVersionUpdateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckNovaVersionUpdateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNovaVersionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNovaVersionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNovaVersion(ctx context.Context, body UpdateNovaVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNovaVersionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSystemVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSystemVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListCellsRequest generates requests for ListCells
func NewListCellsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeployCellRequest calls the generic DeployCell builder with application/json body
func NewDeployCellRequest(server string, params *DeployCellParams, body DeployCellJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeployCellRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDeployCellRequestWithBody generates requests for DeployCell with any type of body
func NewDeployCellRequestWithBody(server string, params *DeployCellParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCellRequest generates requests for DeleteCell
func NewDeleteCellRequest(server string, cellID CellID, params *DeleteCellParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCellRequest generates requests for GetCell
func NewGetCellRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCellRequest calls the generic UpdateCell builder with application/json body
func NewUpdateCellRequest(server string, cellID CellID, params *UpdateCellParams, body UpdateCellJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCellRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewUpdateCellRequestWithBody generates requests for UpdateCell with any type of body
func NewUpdateCellRequestWithBody(server string, cellID CellID, params *UpdateCellParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearAppsRequest generates requests for ClearApps
func NewClearAppsRequest(server string, cellID CellID, params *ClearAppsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddAppRequest calls the generic AddApp builder with application/json body
func NewAddAppRequest(server string, cellID CellID, params *AddAppParams, body AddAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAppRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewAddAppRequestWithBody generates requests for AddApp with any type of body
func NewAddAppRequestWithBody(server string, cellID CellID, params *AddAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/apps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppRequest generates requests for DeleteApp
func NewDeleteAppRequest(server string, cellID CellID, appID AppID, params *DeleteAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, appID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, cellID CellID, appID AppID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, appID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppRequest calls the generic UpdateApp builder with application/json body
func NewUpdateAppRequest(server string, cellID CellID, appID AppID, params *UpdateAppParams, body UpdateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppRequestWithBody(server, cellID, appID, params, "application/json", bodyReader)
}

// NewUpdateAppRequestWithBody generates requests for UpdateApp with any type of body
func NewUpdateAppRequestWithBody(server string, cellID CellID, appID AppID, params *UpdateAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "app", runtime.ParamLocationPath, appID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/apps/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearRobotControllersRequest generates requests for ClearRobotControllers
func NewClearRobotControllersRequest(server string, cellID CellID, params *ClearRobotControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListControllersRequest generates requests for ListControllers
func NewListControllersRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRobotControllerRequest calls the generic AddRobotController builder with application/json body
func NewAddRobotControllerRequest(server string, cellID CellID, params *AddRobotControllerParams, body AddRobotControllerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRobotControllerRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewAddRobotControllerRequestWithBody generates requests for AddRobotController with any type of body
func NewAddRobotControllerRequestWithBody(server string, cellID CellID, params *AddRobotControllerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRobotControllerRequest generates requests for DeleteRobotController
func NewDeleteRobotControllerRequest(server string, cellID CellID, controllerID ControllerID, params *DeleteRobotControllerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRobotControllerRequest generates requests for GetRobotController
func NewGetRobotControllerRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRobotControllerRequest calls the generic UpdateRobotController builder with application/json body
func NewUpdateRobotControllerRequest(server string, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, body UpdateRobotControllerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRobotControllerRequestWithBody(server, cellID, controllerID, params, "application/json", bodyReader)
}

// NewUpdateRobotControllerRequestWithBody generates requests for UpdateRobotController with any type of body
func NewUpdateRobotControllerRequestWithBody(server string, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CompletionTimeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completionTimeout", runtime.ParamLocationQuery, *params.CompletionTimeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSupportedModesRequest generates requests for GetSupportedModes
func NewGetSupportedModesRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/controller-capabilities", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamFreeDriveRequest generates requests for StreamFreeDrive
func NewStreamFreeDriveRequest(server string, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/free-drive-stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIODescriptionsRequest generates requests for ListIODescriptions
func NewListIODescriptionsRequest(server string, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/description", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ios", runtime.ParamLocationQuery, *params.Ios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamIOValuesRequest generates requests for StreamIOValues
func NewStreamIOValuesRequest(server string, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ios", runtime.ParamLocationQuery, *params.Ios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIOValuesRequest generates requests for ListIOValues
func NewListIOValuesRequest(server string, cellID CellID, controllerID ControllerID, params *ListIOValuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/values", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ios != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ios", runtime.ParamLocationQuery, *params.Ios); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetOutputValuesRequest calls the generic SetOutputValues builder with application/json body
func NewSetOutputValuesRequest(server string, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetOutputValuesRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewSetOutputValuesRequestWithBody generates requests for SetOutputValues with any type of body
func NewSetOutputValuesRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/values", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWaitForIOEventRequest generates requests for WaitForIOEvent
func NewWaitForIOEventRequest(server string, cellID CellID, controllerID ControllerID, params *WaitForIOEventParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/ios/wait-for", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "io", runtime.ParamLocationQuery, params.Io); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "comparison_type", runtime.ParamLocationQuery, params.ComparisonType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.BooleanValue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "boolean_value", runtime.ParamLocationQuery, *params.BooleanValue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntegerValue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integer_value", runtime.ParamLocationQuery, *params.IntegerValue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FloatingValue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "floating_value", runtime.ParamLocationQuery, *params.FloatingValue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModeRequest generates requests for GetMode
func NewGetModeRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/mode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetDefaultModeRequest generates requests for SetDefaultMode
func NewSetDefaultModeRequest(server string, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/mode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamModeChangeRequest generates requests for StreamModeChange
func NewStreamModeChangeRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/mode-stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentRobotControllerStateRequest generates requests for GetCurrentRobotControllerState
func NewGetCurrentRobotControllerStateRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/state", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamRobotControllerStateRequest generates requests for StreamRobotControllerState
func NewStreamRobotControllerStateRequest(server string, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/state-stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVirtualRobotCoordinateSystemsRequest generates requests for ListVirtualRobotCoordinateSystems
func NewListVirtualRobotCoordinateSystemsRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/coordinate-systems", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddVirtualRobotCoordinateSystemRequest calls the generic AddVirtualRobotCoordinateSystem builder with application/json body
func NewAddVirtualRobotCoordinateSystemRequest(server string, cellID CellID, controllerID ControllerID, body AddVirtualRobotCoordinateSystemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddVirtualRobotCoordinateSystemRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewAddVirtualRobotCoordinateSystemRequestWithBody generates requests for AddVirtualRobotCoordinateSystem with any type of body
func NewAddVirtualRobotCoordinateSystemRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/coordinate-systems", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVirtualRobotCoordinateSystemRequest generates requests for DeleteVirtualRobotCoordinateSystem
func NewDeleteVirtualRobotCoordinateSystemRequest(server string, cellID CellID, controllerID ControllerID, coordinateSystem CoordinateSystem, params *DeleteVirtualRobotCoordinateSystemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "coordinate-system", runtime.ParamLocationPath, coordinateSystem)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/coordinate-systems/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteDependent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_dependent", runtime.ParamLocationQuery, *params.DeleteDependent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCycleTimeRequest generates requests for GetCycleTime
func NewGetCycleTimeRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/cycle-time", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEStopRequest generates requests for GetEStop
func NewGetEStopRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/estop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPushEStopRequest generates requests for PushEStop
func NewPushEStopRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/estop/push", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReleaseEStopRequest generates requests for ReleaseEStop
func NewReleaseEStopRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/estop/release", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIOsRequest generates requests for ListIOs
func NewListIOsRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/ios", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualRobotIOValueRequest generates requests for GetVirtualRobotIOValue
func NewGetVirtualRobotIOValueRequest(server string, cellID CellID, controllerID ControllerID, io IO) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "io", runtime.ParamLocationPath, io)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/ios/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetVirtualRobotIOValueRequest generates requests for SetVirtualRobotIOValue
func NewSetVirtualRobotIOValueRequest(server string, cellID CellID, controllerID ControllerID, io IO, params *SetVirtualRobotIOValueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "io", runtime.ParamLocationPath, io)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/ios/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Bool != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bool", runtime.ParamLocationQuery, *params.Bool); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Integer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integer", runtime.ParamLocationQuery, *params.Integer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Double != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "double", runtime.ParamLocationQuery, *params.Double); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExternalJointsStreamRequest calls the generic ExternalJointsStream builder with application/json body
func NewExternalJointsStreamRequest(server string, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExternalJointsStreamRequestWithBody(server, cellID, controllerID, "application/json", bodyReader)
}

// NewExternalJointsStreamRequestWithBody generates requests for ExternalJointsStream with any type of body
func NewExternalJointsStreamRequestWithBody(server string, cellID CellID, controllerID ControllerID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/externalJointsStream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMotionGroupStateRequest generates requests for GetMotionGroupState
func NewGetMotionGroupStateRequest(server string, cellID CellID, controllerID ControllerID, id Id) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMotionGroupStateRequest calls the generic SetMotionGroupState builder with application/json body
func NewSetMotionGroupStateRequest(server string, cellID CellID, controllerID ControllerID, id Id, body SetMotionGroupStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetMotionGroupStateRequestWithBody(server, cellID, controllerID, id, "application/json", bodyReader)
}

// NewSetMotionGroupStateRequestWithBody generates requests for SetMotionGroupState with any type of body
func NewSetMotionGroupStateRequestWithBody(server string, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMotionGroupBehaviorRequest generates requests for GetMotionGroupBehavior
func NewGetMotionGroupBehaviorRequest(server string, cellID CellID, controllerID ControllerID, id Id) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/behavior", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetMotionGroupBehaviorRequest generates requests for SetMotionGroupBehavior
func NewSetMotionGroupBehaviorRequest(server string, cellID CellID, controllerID ControllerID, id Id, params *SetMotionGroupBehaviorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/behavior", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Behavior != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "behavior", runtime.ParamLocationQuery, *params.Behavior); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualRobotMountingRequest generates requests for GetVirtualRobotMounting
func NewGetVirtualRobotMountingRequest(server string, cellID CellID, controllerID ControllerID, id Id) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/mounting", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetVirtualRobotMountingRequest calls the generic SetVirtualRobotMounting builder with application/json body
func NewSetVirtualRobotMountingRequest(server string, cellID CellID, controllerID ControllerID, id Id, body SetVirtualRobotMountingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetVirtualRobotMountingRequestWithBody(server, cellID, controllerID, id, "application/json", bodyReader)
}

// NewSetVirtualRobotMountingRequestWithBody generates requests for SetVirtualRobotMounting with any type of body
func NewSetVirtualRobotMountingRequestWithBody(server string, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/mounting", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVirtualRobotTcpsRequest generates requests for ListVirtualRobotTcps
func NewListVirtualRobotTcpsRequest(server string, cellID CellID, controllerID ControllerID, id Id) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/tcps", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddVirtualRobotTcpRequest calls the generic AddVirtualRobotTcp builder with application/json body
func NewAddVirtualRobotTcpRequest(server string, cellID CellID, controllerID ControllerID, id Id, body AddVirtualRobotTcpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddVirtualRobotTcpRequestWithBody(server, cellID, controllerID, id, "application/json", bodyReader)
}

// NewAddVirtualRobotTcpRequestWithBody generates requests for AddVirtualRobotTcp with any type of body
func NewAddVirtualRobotTcpRequestWithBody(server string, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/tcps", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVirtualRobotTcpRequest generates requests for DeleteVirtualRobotTcp
func NewDeleteVirtualRobotTcpRequest(server string, cellID CellID, controllerID ControllerID, id Id, tcp Tcp) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "tcp", runtime.ParamLocationPath, tcp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motion-groups/%s/tcps/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMotionGroupsRequest generates requests for GetMotionGroups
func NewGetMotionGroupsRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/motiongroups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOperationModeRequest generates requests for GetOperationMode
func NewGetOperationModeRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/operationmode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetOperationModeRequest generates requests for SetOperationMode
func NewSetOperationModeRequest(server string, cellID CellID, controllerID ControllerID, params *SetOperationModeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/teach-pendant/operationmode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualRobotConfigurationRequest generates requests for GetVirtualRobotConfiguration
func NewGetVirtualRobotConfigurationRequest(server string, cellID CellID, controllerID ControllerID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "controller", runtime.ParamLocationPath, controllerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/controllers/%s/virtual-robot-configuration", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCoordinateSystemsRequest generates requests for ListCoordinateSystems
func NewListCoordinateSystemsRequest(server string, cellID CellID, params *ListCoordinateSystemsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/coordinate-systems", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rotation_type", runtime.ParamLocationQuery, *params.RotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddCoordinateSystemRequest calls the generic AddCoordinateSystem builder with application/json body
func NewAddCoordinateSystemRequest(server string, cellID CellID, body AddCoordinateSystemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddCoordinateSystemRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewAddCoordinateSystemRequestWithBody generates requests for AddCoordinateSystem with any type of body
func NewAddCoordinateSystemRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/coordinate-systems", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCoordinateSystemRequest generates requests for DeleteCoordinateSystem
func NewDeleteCoordinateSystemRequest(server string, cellID CellID, coordinateSystem CoordinateSystem) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "coordinate-system", runtime.ParamLocationPath, coordinateSystem)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/coordinate-systems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoordinateSystemRequest generates requests for GetCoordinateSystem
func NewGetCoordinateSystemRequest(server string, cellID CellID, coordinateSystem CoordinateSystem, params *GetCoordinateSystemParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "coordinate-system", runtime.ParamLocationPath, coordinateSystem)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/coordinate-systems/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rotation_type", runtime.ParamLocationQuery, *params.RotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransformInCoordinateSystemRequest calls the generic TransformInCoordinateSystem builder with application/json body
func NewTransformInCoordinateSystemRequest(server string, cellID CellID, coordinateSystem CoordinateSystem, body TransformInCoordinateSystemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTransformInCoordinateSystemRequestWithBody(server, cellID, coordinateSystem, "application/json", bodyReader)
}

// NewTransformInCoordinateSystemRequestWithBody generates requests for TransformInCoordinateSystem with any type of body
func NewTransformInCoordinateSystemRequestWithBody(server string, cellID CellID, coordinateSystem CoordinateSystem, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "coordinate-system", runtime.ParamLocationPath, coordinateSystem)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/coordinate-systems/%s/transform", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearDevicesRequest generates requests for ClearDevices
func NewClearDevicesRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/devices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDeviceRequest calls the generic CreateDevice builder with application/json body
func NewCreateDeviceRequest(server string, cellID CellID, body CreateDeviceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDeviceRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewCreateDeviceRequestWithBody generates requests for CreateDevice with any type of body
func NewCreateDeviceRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/devices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDeviceRequest generates requests for DeleteDevice
func NewDeleteDeviceRequest(server string, cellID CellID, identifier string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "identifier", runtime.ParamLocationPath, identifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/devices/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeviceRequest generates requests for GetDevice
func NewGetDeviceRequest(server string, cellID CellID, identifier string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "identifier", runtime.ParamLocationPath, identifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/devices/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMotionGroupsRequest generates requests for ListMotionGroups
func NewListMotionGroupsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivateMotionGroupRequest generates requests for ActivateMotionGroup
func NewActivateMotionGroupRequest(server string, cellID CellID, params *ActivateMotionGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "motion_group", runtime.ParamLocationQuery, params.MotionGroup); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivateAllMotionGroupsRequest generates requests for ActivateAllMotionGroups
func NewActivateAllMotionGroupsRequest(server string, cellID CellID, params *ActivateAllMotionGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/all", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "controller", runtime.ParamLocationQuery, params.Controller); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJointJoggingRequest calls the generic JointJogging builder with application/json body
func NewJointJoggingRequest(server string, cellID CellID, body JointJoggingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJointJoggingRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewJointJoggingRequestWithBody generates requests for JointJogging with any type of body
func NewJointJoggingRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/move-joint", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDirectionJoggingRequest calls the generic DirectionJogging builder with application/json body
func NewDirectionJoggingRequest(server string, cellID CellID, body DirectionJoggingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDirectionJoggingRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewDirectionJoggingRequestWithBody generates requests for DirectionJogging with any type of body
func NewDirectionJoggingRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/move-tcp", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeactivateMotionGroupRequest generates requests for DeactivateMotionGroup
func NewDeactivateMotionGroupRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInfoCapabilitiesRequest generates requests for GetInfoCapabilities
func NewGetInfoCapabilitiesRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/info-capabilities", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJoggingCapabilitiesRequest generates requests for GetJoggingCapabilities
func NewGetJoggingCapabilitiesRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/jogging-capabilities", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKinematicCapabilitiesRequest generates requests for GetKinematicCapabilities
func NewGetKinematicCapabilitiesRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/kinematic-capabilities", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCalculateAllInverseKinematicRequest calls the generic CalculateAllInverseKinematic builder with application/json body
func NewCalculateAllInverseKinematicRequest(server string, cellID CellID, motionGroup MotionGroup, body CalculateAllInverseKinematicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCalculateAllInverseKinematicRequestWithBody(server, cellID, motionGroup, "application/json", bodyReader)
}

// NewCalculateAllInverseKinematicRequestWithBody generates requests for CalculateAllInverseKinematic with any type of body
func NewCalculateAllInverseKinematicRequestWithBody(server string, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/kinematic/calculate-all-joint-positions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCalculateInverseKinematicRequest calls the generic CalculateInverseKinematic builder with application/json body
func NewCalculateInverseKinematicRequest(server string, cellID CellID, motionGroup MotionGroup, body CalculateInverseKinematicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCalculateInverseKinematicRequestWithBody(server, cellID, motionGroup, "application/json", bodyReader)
}

// NewCalculateInverseKinematicRequestWithBody generates requests for CalculateInverseKinematic with any type of body
func NewCalculateInverseKinematicRequestWithBody(server string, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/kinematic/calculate-joint-position", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCalculateForwardKinematicRequest calls the generic CalculateForwardKinematic builder with application/json body
func NewCalculateForwardKinematicRequest(server string, cellID CellID, motionGroup MotionGroup, body CalculateForwardKinematicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCalculateForwardKinematicRequestWithBody(server, cellID, motionGroup, "application/json", bodyReader)
}

// NewCalculateForwardKinematicRequestWithBody generates requests for CalculateForwardKinematic with any type of body
func NewCalculateForwardKinematicRequestWithBody(server string, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/kinematic/calculate-tcp-pose", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMountingRequest generates requests for GetMounting
func NewGetMountingRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/mounting", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOptimizerConfigurationRequest generates requests for GetOptimizerConfiguration
func NewGetOptimizerConfigurationRequest(server string, cellID CellID, motionGroup MotionGroup, params *GetOptimizerConfigurationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/optimizer-setup", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tcp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tcp", runtime.ParamLocationQuery, *params.Tcp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPayloadsRequest generates requests for ListPayloads
func NewListPayloadsRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/payloads", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivePayloadRequest generates requests for GetActivePayload
func NewGetActivePayloadRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/payloads/current", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSafetySetupRequest generates requests for GetSafetySetup
func NewGetSafetySetupRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/safety-setup", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMotionGroupSpecificationRequest generates requests for GetMotionGroupSpecification
func NewGetMotionGroupSpecificationRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/specification", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentMotionGroupStateRequest generates requests for GetCurrentMotionGroupState
func NewGetCurrentMotionGroupStateRequest(server string, cellID CellID, motionGroup MotionGroup, params *GetCurrentMotionGroupStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/state", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tcp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tcp", runtime.ParamLocationQuery, *params.Tcp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponseCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_coordinate_system", runtime.ParamLocationQuery, *params.ResponseCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamMotionGroupStateRequest generates requests for StreamMotionGroupState
func NewStreamMotionGroupStateRequest(server string, cellID CellID, motionGroup MotionGroup, params *StreamMotionGroupStateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/state-stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponseCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_coordinate_system", runtime.ParamLocationQuery, *params.ResponseCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tcp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tcp", runtime.ParamLocationQuery, *params.Tcp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopJoggingRequest generates requests for StopJogging
func NewStopJoggingRequest(server string, cellID CellID, motionGroup MotionGroup) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/stop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTcpsRequest generates requests for ListTcps
func NewListTcpsRequest(server string, cellID CellID, motionGroup MotionGroup, params *ListTcpsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/tcps", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rotation_type", runtime.ParamLocationQuery, *params.RotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActiveTcpRequest generates requests for GetActiveTcp
func NewGetActiveTcpRequest(server string, cellID CellID, motionGroup MotionGroup, params *GetActiveTcpParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group", runtime.ParamLocationPath, motionGroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-groups/%s/tcps/current", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RotationType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rotation_type", runtime.ParamLocationQuery, *params.RotationType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlanningMotionGroupModelsRequest generates requests for GetPlanningMotionGroupModels
func NewGetPlanningMotionGroupModelsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-planning/motion-group-models", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlanCollisionFreePTPRequest calls the generic PlanCollisionFreePTP builder with application/json body
func NewPlanCollisionFreePTPRequest(server string, cellID CellID, body PlanCollisionFreePTPJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPlanCollisionFreePTPRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewPlanCollisionFreePTPRequestWithBody generates requests for PlanCollisionFreePTP with any type of body
func NewPlanCollisionFreePTPRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-planning/plan-collision-free-ptp", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPlanTrajectoryRequest calls the generic PlanTrajectory builder with application/json body
func NewPlanTrajectoryRequest(server string, cellID CellID, body PlanTrajectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPlanTrajectoryRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewPlanTrajectoryRequestWithBody generates requests for PlanTrajectory with any type of body
func NewPlanTrajectoryRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motion-planning/plan-trajectory", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAllMotionsRequest generates requests for DeleteAllMotions
func NewDeleteAllMotionsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListMotionsRequest generates requests for ListMotions
func NewListMotionsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPlanMotionRequest calls the generic PlanMotion builder with application/json body
func NewPlanMotionRequest(server string, cellID CellID, body PlanMotionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPlanMotionRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewPlanMotionRequestWithBody generates requests for PlanMotion with any type of body
func NewPlanMotionRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExecuteTrajectoryRequest calls the generic ExecuteTrajectory builder with application/json body
func NewExecuteTrajectoryRequest(server string, cellID CellID, body ExecuteTrajectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteTrajectoryRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewExecuteTrajectoryRequestWithBody generates requests for ExecuteTrajectory with any type of body
func NewExecuteTrajectoryRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/executetrajectory", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStreamMoveRequest calls the generic StreamMove builder with application/json body
func NewStreamMoveRequest(server string, cellID CellID, body StreamMoveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStreamMoveRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewStreamMoveRequestWithBody generates requests for StreamMove with any type of body
func NewStreamMoveRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/streammove", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMotionRequest generates requests for DeleteMotion
func NewDeleteMotionRequest(server string, cellID CellID, motion Motion) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/delete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamMoveBackwardRequest generates requests for StreamMoveBackward
func NewStreamMoveBackwardRequest(server string, cellID CellID, motion Motion, params *StreamMoveBackwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/executebackward", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playback_speed_in_percent", runtime.ParamLocationQuery, params.PlaybackSpeedInPercent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponseCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_coordinate_system", runtime.ParamLocationQuery, *params.ResponseCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartLocationOnTrajectory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_location_on_trajectory", runtime.ParamLocationQuery, *params.StartLocationOnTrajectory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamMoveForwardRequest generates requests for StreamMoveForward
func NewStreamMoveForwardRequest(server string, cellID CellID, motion Motion, params *StreamMoveForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/executeforward", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "playback_speed_in_percent", runtime.ParamLocationQuery, params.PlaybackSpeedInPercent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResponseRate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_rate", runtime.ParamLocationQuery, *params.ResponseRate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponseCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_coordinate_system", runtime.ParamLocationQuery, *params.ResponseCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartLocationOnTrajectory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_location_on_trajectory", runtime.ParamLocationQuery, *params.StartLocationOnTrajectory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStreamMoveToTrajectoryViaJointPTPRequest generates requests for StreamMoveToTrajectoryViaJointPTP
func NewStreamMoveToTrajectoryViaJointPTPRequest(server string, cellID CellID, motion Motion, params *StreamMoveToTrajectoryViaJointPTPParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/executetotrajectory", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location_on_trajectory", runtime.ParamLocationQuery, params.LocationOnTrajectory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.LimitOverrideJointVelocityLimitsJoints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_override.joint_velocity_limits.joints", runtime.ParamLocationQuery, *params.LimitOverrideJointVelocityLimitsJoints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitOverrideJointAccelerationLimitsJoints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_override.joint_acceleration_limits.joints", runtime.ParamLocationQuery, *params.LimitOverrideJointAccelerationLimitsJoints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitOverrideTcpVelocityLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_override.tcp_velocity_limit", runtime.ParamLocationQuery, *params.LimitOverrideTcpVelocityLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitOverrideTcpAccelerationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_override.tcp_acceleration_limit", runtime.ParamLocationQuery, *params.LimitOverrideTcpAccelerationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitOverrideTcpOrientationVelocityLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_override.tcp_orientation_velocity_limit", runtime.ParamLocationQuery, *params.LimitOverrideTcpOrientationVelocityLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LimitOverrideTcpOrientationAccelerationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit_override.tcp_orientation_acceleration_limit", runtime.ParamLocationQuery, *params.LimitOverrideTcpOrientationAccelerationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponsesCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "responses_coordinate_system", runtime.ParamLocationQuery, *params.ResponsesCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlannedMotionRequest generates requests for GetPlannedMotion
func NewGetPlannedMotionRequest(server string, cellID CellID, motion Motion, params *GetPlannedMotionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/planned-motion", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SampleTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sample_time", runtime.ParamLocationQuery, *params.SampleTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopExecutionRequest generates requests for StopExecution
func NewStopExecutionRequest(server string, cellID CellID, motion Motion) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/stop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMotionTrajectoryRequest generates requests for GetMotionTrajectory
func NewGetMotionTrajectoryRequest(server string, cellID CellID, motion Motion, params *GetMotionTrajectoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/trajectory", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sample_time", runtime.ParamLocationQuery, params.SampleTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResponsesCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "responses_coordinate_system", runtime.ParamLocationQuery, *params.ResponsesCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMotionTrajectorySampleRequest generates requests for GetMotionTrajectorySample
func NewGetMotionTrajectorySampleRequest(server string, cellID CellID, motion Motion, params *GetMotionTrajectorySampleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion", runtime.ParamLocationPath, motion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/motions/%s/trajectorysample", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LocationOnTrajectory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location_on_trajectory", runtime.ParamLocationQuery, *params.LocationOnTrajectory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponseCoordinateSystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_coordinate_system", runtime.ParamLocationQuery, *params.ResponseCoordinateSystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllProgramRunsRequest generates requests for GetAllProgramRuns
func NewGetAllProgramRunsRequest(server string, cellID CellID, params *GetAllProgramRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/operator/programs/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProgramRunRequest calls the generic CreateProgramRun builder with application/json body
func NewCreateProgramRunRequest(server string, cellID CellID, body CreateProgramRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProgramRunRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewCreateProgramRunRequestWithBody generates requests for CreateProgramRun with any type of body
func NewCreateProgramRunRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/operator/programs/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProgramRunRequest generates requests for GetProgramRun
func NewGetProgramRunRequest(server string, cellID CellID, run string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run", runtime.ParamLocationPath, run)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/operator/programs/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllTriggersRequest generates requests for GetAllTriggers
func NewGetAllTriggersRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/operator/triggers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTriggerRequest calls the generic CreateTrigger builder with application/json body
func NewCreateTriggerRequest(server string, cellID CellID, body CreateTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTriggerRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewCreateTriggerRequestWithBody generates requests for CreateTrigger with any type of body
func NewCreateTriggerRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/operator/triggers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTriggerRequest generates requests for DeleteTrigger
func NewDeleteTriggerRequest(server string, cellID CellID, trigger string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "trigger", runtime.ParamLocationPath, trigger)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/operator/triggers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTriggerRequest generates requests for GetTrigger
func NewGetTriggerRequest(server string, cellID CellID, trigger string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "trigger", runtime.ParamLocationPath, trigger)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/operator/triggers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTriggerRequest calls the generic UpdateTrigger builder with application/json body
func NewUpdateTriggerRequest(server string, cellID CellID, trigger string, body UpdateTriggerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTriggerRequestWithBody(server, cellID, trigger, "application/json", bodyReader)
}

// NewUpdateTriggerRequestWithBody generates requests for UpdateTrigger with any type of body
func NewUpdateTriggerRequestWithBody(server string, cellID CellID, trigger string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "trigger", runtime.ParamLocationPath, trigger)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/operator/triggers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLoadPlannedMotionRequest calls the generic LoadPlannedMotion builder with application/json body
func NewLoadPlannedMotionRequest(server string, cellID CellID, body LoadPlannedMotionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoadPlannedMotionRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewLoadPlannedMotionRequestWithBody generates requests for LoadPlannedMotion with any type of body
func NewLoadPlannedMotionRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/planned-motions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearProgramsValuesRequest generates requests for ClearProgramsValues
func NewClearProgramsValuesRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/programs/values", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProgramsValueRequest calls the generic CreateProgramsValue builder with application/json body
func NewCreateProgramsValueRequest(server string, cellID CellID, body CreateProgramsValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProgramsValueRequestWithBody(server, cellID, "application/json", bodyReader)
}

// NewCreateProgramsValueRequestWithBody generates requests for CreateProgramsValue with any type of body
func NewCreateProgramsValueRequestWithBody(server string, cellID CellID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/programs/values", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProgramValueRequest generates requests for DeleteProgramValue
func NewDeleteProgramValueRequest(server string, cellID CellID, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/programs/values/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramValueRequest generates requests for GetProgramValue
func NewGetProgramValueRequest(server string, cellID CellID, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/programs/values/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProgramValueRequest calls the generic UpdateProgramValue builder with application/json body
func NewUpdateProgramValueRequest(server string, cellID CellID, key string, body UpdateProgramValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProgramValueRequestWithBody(server, cellID, key, "application/json", bodyReader)
}

// NewUpdateProgramValueRequestWithBody generates requests for UpdateProgramValue with any type of body
func NewUpdateProgramValueRequestWithBody(server string, cellID CellID, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/programs/values/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCellStatusRequest generates requests for GetCellStatus
func NewGetCellStatusRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListStoredCollidersRequest generates requests for ListStoredColliders
func NewListStoredCollidersRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/colliders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStoredColliderRequest generates requests for DeleteStoredCollider
func NewDeleteStoredColliderRequest(server string, cellID CellID, colliderID ColliderID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collider", runtime.ParamLocationPath, colliderID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/colliders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoredColliderRequest generates requests for GetStoredCollider
func NewGetStoredColliderRequest(server string, cellID CellID, colliderID ColliderID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collider", runtime.ParamLocationPath, colliderID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/colliders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreColliderRequest calls the generic StoreCollider builder with application/json body
func NewStoreColliderRequest(server string, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreColliderRequestWithBody(server, cellID, colliderID, "application/json", bodyReader)
}

// NewStoreColliderRequestWithBody generates requests for StoreCollider with any type of body
func NewStoreColliderRequestWithBody(server string, cellID CellID, colliderID ColliderID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collider", runtime.ParamLocationPath, colliderID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/colliders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultLinkChainRequest generates requests for GetDefaultLinkChain
func NewGetDefaultLinkChainRequest(server string, cellID CellID, motionGroupModel GetDefaultLinkChainParamsMotionGroupModel) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "motion-group-model", runtime.ParamLocationPath, motionGroupModel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/default-link-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCollisionLinkChainsRequest generates requests for ListCollisionLinkChains
func NewListCollisionLinkChainsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/link-chains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStoredCollisionLinkChainRequest generates requests for DeleteStoredCollisionLinkChain
func NewDeleteStoredCollisionLinkChainRequest(server string, cellID CellID, linkChainID LinkChainID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "link-chain", runtime.ParamLocationPath, linkChainID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/link-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoredCollisionLinkChainRequest generates requests for GetStoredCollisionLinkChain
func NewGetStoredCollisionLinkChainRequest(server string, cellID CellID, linkChainID LinkChainID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "link-chain", runtime.ParamLocationPath, linkChainID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/link-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreCollisionLinkChainRequest calls the generic StoreCollisionLinkChain builder with application/json body
func NewStoreCollisionLinkChainRequest(server string, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreCollisionLinkChainRequestWithBody(server, cellID, linkChainID, "application/json", bodyReader)
}

// NewStoreCollisionLinkChainRequestWithBody generates requests for StoreCollisionLinkChain with any type of body
func NewStoreCollisionLinkChainRequestWithBody(server string, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "link-chain", runtime.ParamLocationPath, linkChainID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/link-chains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListStoredCollisionScenesRequest generates requests for ListStoredCollisionScenes
func NewListStoredCollisionScenesRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/scenes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStoredCollisionSceneRequest generates requests for DeleteStoredCollisionScene
func NewDeleteStoredCollisionSceneRequest(server string, cellID CellID, sceneID SceneID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scene", runtime.ParamLocationPath, sceneID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/scenes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoredCollisionSceneRequest generates requests for GetStoredCollisionScene
func NewGetStoredCollisionSceneRequest(server string, cellID CellID, sceneID SceneID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scene", runtime.ParamLocationPath, sceneID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/scenes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreCollisionSceneRequest calls the generic StoreCollisionScene builder with application/json body
func NewStoreCollisionSceneRequest(server string, cellID CellID, sceneID SceneID, body StoreCollisionSceneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreCollisionSceneRequestWithBody(server, cellID, sceneID, "application/json", bodyReader)
}

// NewStoreCollisionSceneRequestWithBody generates requests for StoreCollisionScene with any type of body
func NewStoreCollisionSceneRequestWithBody(server string, cellID CellID, sceneID SceneID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scene", runtime.ParamLocationPath, sceneID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/scenes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListStoredCollisionToolsRequest generates requests for ListStoredCollisionTools
func NewListStoredCollisionToolsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/tools", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStoredCollisionToolRequest generates requests for DeleteStoredCollisionTool
func NewDeleteStoredCollisionToolRequest(server string, cellID CellID, toolID ToolID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tool", runtime.ParamLocationPath, toolID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/tools/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoredCollisionToolRequest generates requests for GetStoredCollisionTool
func NewGetStoredCollisionToolRequest(server string, cellID CellID, toolID ToolID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tool", runtime.ParamLocationPath, toolID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/tools/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreCollisionToolRequest calls the generic StoreCollisionTool builder with application/json body
func NewStoreCollisionToolRequest(server string, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreCollisionToolRequestWithBody(server, cellID, toolID, "application/json", bodyReader)
}

// NewStoreCollisionToolRequestWithBody generates requests for StoreCollisionTool with any type of body
func NewStoreCollisionToolRequestWithBody(server string, cellID CellID, toolID ToolID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tool", runtime.ParamLocationPath, toolID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/collision/tools/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClearAllObjectsRequest generates requests for ClearAllObjects
func NewClearAllObjectsRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllObjectKeysRequest generates requests for ListAllObjectKeys
func NewListAllObjectKeysRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteObjectRequest generates requests for DeleteObject
func NewDeleteObjectRequest(server string, cellID CellID, key Key) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetObjectRequest generates requests for GetObject
func NewGetObjectRequest(server string, cellID CellID, key Key) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetObjectMetadataRequest generates requests for GetObjectMetadata
func NewGetObjectMetadataRequest(server string, cellID CellID, key Key) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreObjectRequestWithBody generates requests for StoreObject with any type of body
func NewStoreObjectRequestWithBody(server string, cellID CellID, key Key, params *StoreObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/objects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XMetadata != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Metadata", runtime.ParamLocationHeader, *params.XMetadata)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Metadata", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteProgramListRequest generates requests for DeleteProgramList
func NewDeleteProgramListRequest(server string, cellID CellID, params *DeleteProgramListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "program_ids", runtime.ParamLocationQuery, params.ProgramIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListProgramMetadataRequest generates requests for ListProgramMetadata
func NewListProgramMetadataRequest(server string, cellID CellID, params *ListProgramMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowHidden != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_hidden", runtime.ParamLocationQuery, *params.ShowHidden); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProgramRequestWithTextBody calls the generic CreateProgram builder with text/plain body
func NewCreateProgramRequestWithTextBody(server string, cellID CellID, params *CreateProgramParams, body CreateProgramTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewCreateProgramRequestWithBody(server, cellID, params, "text/plain", bodyReader)
}

// NewCreateProgramRequestWithBody generates requests for CreateProgram with any type of body
func NewCreateProgramRequestWithBody(server string, cellID CellID, params *CreateProgramParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProgramRequest generates requests for DeleteProgram
func NewDeleteProgramRequest(server string, cellID CellID, program Program) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "program", runtime.ParamLocationPath, program)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramRequest generates requests for GetProgram
func NewGetProgramRequest(server string, cellID CellID, program Program) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "program", runtime.ParamLocationPath, program)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProgramRequestWithTextBody calls the generic UpdateProgram builder with text/plain body
func NewUpdateProgramRequestWithTextBody(server string, cellID CellID, program Program, body UpdateProgramTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewUpdateProgramRequestWithBody(server, cellID, program, "text/plain", bodyReader)
}

// NewUpdateProgramRequestWithBody generates requests for UpdateProgram with any type of body
func NewUpdateProgramRequestWithBody(server string, cellID CellID, program Program, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "program", runtime.ParamLocationPath, program)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProgramMetadataRequest generates requests for GetProgramMetadata
func NewGetProgramMetadataRequest(server string, cellID CellID, program Program) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "program", runtime.ParamLocationPath, program)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs/%s/metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProgramMetadataRequest calls the generic UpdateProgramMetadata builder with application/json body
func NewUpdateProgramMetadataRequest(server string, cellID CellID, program Program, body UpdateProgramMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProgramMetadataRequestWithBody(server, cellID, program, "application/json", bodyReader)
}

// NewUpdateProgramMetadataRequestWithBody generates requests for UpdateProgramMetadata with any type of body
func NewUpdateProgramMetadataRequestWithBody(server string, cellID CellID, program Program, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "program", runtime.ParamLocationPath, program)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs/%s/metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadProgramMetadataImageRequestWithBody generates requests for UploadProgramMetadataImage with any type of body
func NewUploadProgramMetadataImageRequestWithBody(server string, cellID CellID, program Program, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "program", runtime.ParamLocationPath, program)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/programs/%s/metadata/image", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRecipeListRequest generates requests for DeleteRecipeList
func NewDeleteRecipeListRequest(server string, cellID CellID, params *DeleteRecipeListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recipe_ids", runtime.ParamLocationQuery, params.RecipeIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRecipeMetadataRequest generates requests for ListRecipeMetadata
func NewListRecipeMetadataRequest(server string, cellID CellID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRecipeRequest calls the generic CreateRecipe builder with application/json body
func NewCreateRecipeRequest(server string, cellID CellID, params *CreateRecipeParams, body CreateRecipeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRecipeRequestWithBody(server, cellID, params, "application/json", bodyReader)
}

// NewCreateRecipeRequestWithBody generates requests for CreateRecipe with any type of body
func NewCreateRecipeRequestWithBody(server string, cellID CellID, params *CreateRecipeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "program_id", runtime.ParamLocationQuery, params.ProgramId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRecipeRequest generates requests for DeleteRecipe
func NewDeleteRecipeRequest(server string, cellID CellID, recipe Recipe) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recipe", runtime.ParamLocationPath, recipe)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecipeRequest generates requests for GetRecipe
func NewGetRecipeRequest(server string, cellID CellID, recipe Recipe) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recipe", runtime.ParamLocationPath, recipe)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRecipeRequest calls the generic UpdateRecipe builder with application/json body
func NewUpdateRecipeRequest(server string, cellID CellID, recipe Recipe, body UpdateRecipeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRecipeRequestWithBody(server, cellID, recipe, "application/json", bodyReader)
}

// NewUpdateRecipeRequestWithBody generates requests for UpdateRecipe with any type of body
func NewUpdateRecipeRequestWithBody(server string, cellID CellID, recipe Recipe, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recipe", runtime.ParamLocationPath, recipe)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRecipeMetadataRequest generates requests for GetRecipeMetadata
func NewGetRecipeMetadataRequest(server string, cellID CellID, recipe Recipe) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recipe", runtime.ParamLocationPath, recipe)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes/%s/metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRecipeMetadataRequest calls the generic UpdateRecipeMetadata builder with application/json body
func NewUpdateRecipeMetadataRequest(server string, cellID CellID, recipe Recipe, body UpdateRecipeMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRecipeMetadataRequestWithBody(server, cellID, recipe, "application/json", bodyReader)
}

// NewUpdateRecipeMetadataRequestWithBody generates requests for UpdateRecipeMetadata with any type of body
func NewUpdateRecipeMetadataRequestWithBody(server string, cellID CellID, recipe Recipe, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recipe", runtime.ParamLocationPath, recipe)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes/%s/metadata", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadRecipeMetadataImageRequestWithBody generates requests for UploadRecipeMetadataImage with any type of body
func NewUploadRecipeMetadataImageRequestWithBody(server string, cellID CellID, recipe Recipe, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cell", runtime.ParamLocationPath, cellID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recipe", runtime.ParamLocationPath, recipe)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cells/%s/store/recipes/%s/metadata/image", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeactivateLicenseRequest generates requests for DeactivateLicense
func NewDeactivateLicenseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLicenseRequest generates requests for GetLicense
func NewGetLicenseRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivateLicenseRequest calls the generic ActivateLicense builder with application/json body
func NewActivateLicenseRequest(server string, body ActivateLicenseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivateLicenseRequestWithBody(server, "application/json", bodyReader)
}

// NewActivateLicenseRequestWithBody generates requests for ActivateLicense with any type of body
func NewActivateLicenseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLicenseStatusRequest generates requests for GetLicenseStatus
func NewGetLicenseStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/license/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDiagnosePackageRequest generates requests for GetDiagnosePackage
func NewGetDiagnosePackageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/diagnosis-package/zip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSystemStatusRequest generates requests for GetSystemStatus
func NewGetSystemStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckNovaVersionUpdateRequest generates requests for CheckNovaVersionUpdate
func NewCheckNovaVersionUpdateRequest(server string, params *CheckNovaVersionUpdateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channel", runtime.ParamLocationQuery, params.Channel); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNovaVersionRequest calls the generic UpdateNovaVersion builder with application/json body
func NewUpdateNovaVersionRequest(server string, body UpdateNovaVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNovaVersionRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateNovaVersionRequestWithBody generates requests for UpdateNovaVersion with any type of body
func NewUpdateNovaVersionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSystemVersionRequest generates requests for GetSystemVersion
func NewGetSystemVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/system/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListCellsWithResponse request
	ListCellsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCellsResp, error)

	// DeployCellWithBodyWithResponse request with any body
	DeployCellWithBodyWithResponse(ctx context.Context, params *DeployCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeployCellResp, error)

	DeployCellWithResponse(ctx context.Context, params *DeployCellParams, body DeployCellJSONRequestBody, reqEditors ...RequestEditorFn) (*DeployCellResp, error)

	// DeleteCellWithResponse request
	DeleteCellWithResponse(ctx context.Context, cellID CellID, params *DeleteCellParams, reqEditors ...RequestEditorFn) (*DeleteCellResp, error)

	// GetCellWithResponse request
	GetCellWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetCellResp, error)

	// UpdateCellWithBodyWithResponse request with any body
	UpdateCellWithBodyWithResponse(ctx context.Context, cellID CellID, params *UpdateCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCellResp, error)

	UpdateCellWithResponse(ctx context.Context, cellID CellID, params *UpdateCellParams, body UpdateCellJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCellResp, error)

	// ClearAppsWithResponse request
	ClearAppsWithResponse(ctx context.Context, cellID CellID, params *ClearAppsParams, reqEditors ...RequestEditorFn) (*ClearAppsResp, error)

	// ListAppsWithResponse request
	ListAppsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListAppsResp, error)

	// AddAppWithBodyWithResponse request with any body
	AddAppWithBodyWithResponse(ctx context.Context, cellID CellID, params *AddAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAppResp, error)

	AddAppWithResponse(ctx context.Context, cellID CellID, params *AddAppParams, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAppResp, error)

	// DeleteAppWithResponse request
	DeleteAppWithResponse(ctx context.Context, cellID CellID, appID AppID, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*DeleteAppResp, error)

	// GetAppWithResponse request
	GetAppWithResponse(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*GetAppResp, error)

	// UpdateAppWithBodyWithResponse request with any body
	UpdateAppWithBodyWithResponse(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResp, error)

	UpdateAppWithResponse(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResp, error)

	// ClearRobotControllersWithResponse request
	ClearRobotControllersWithResponse(ctx context.Context, cellID CellID, params *ClearRobotControllersParams, reqEditors ...RequestEditorFn) (*ClearRobotControllersResp, error)

	// ListControllersWithResponse request
	ListControllersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListControllersResp, error)

	// AddRobotControllerWithBodyWithResponse request with any body
	AddRobotControllerWithBodyWithResponse(ctx context.Context, cellID CellID, params *AddRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRobotControllerResp, error)

	AddRobotControllerWithResponse(ctx context.Context, cellID CellID, params *AddRobotControllerParams, body AddRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRobotControllerResp, error)

	// DeleteRobotControllerWithResponse request
	DeleteRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *DeleteRobotControllerParams, reqEditors ...RequestEditorFn) (*DeleteRobotControllerResp, error)

	// GetRobotControllerWithResponse request
	GetRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetRobotControllerResp, error)

	// UpdateRobotControllerWithBodyWithResponse request with any body
	UpdateRobotControllerWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRobotControllerResp, error)

	UpdateRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, body UpdateRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRobotControllerResp, error)

	// GetSupportedModesWithResponse request
	GetSupportedModesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetSupportedModesResp, error)

	// StreamFreeDriveWithResponse request
	StreamFreeDriveWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams, reqEditors ...RequestEditorFn) (*StreamFreeDriveResp, error)

	// ListIODescriptionsWithResponse request
	ListIODescriptionsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams, reqEditors ...RequestEditorFn) (*ListIODescriptionsResp, error)

	// StreamIOValuesWithResponse request
	StreamIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams, reqEditors ...RequestEditorFn) (*StreamIOValuesResp, error)

	// ListIOValuesWithResponse request
	ListIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOValuesParams, reqEditors ...RequestEditorFn) (*ListIOValuesResp, error)

	// SetOutputValuesWithBodyWithResponse request with any body
	SetOutputValuesWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOutputValuesResp, error)

	SetOutputValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOutputValuesResp, error)

	// WaitForIOEventWithResponse request
	WaitForIOEventWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *WaitForIOEventParams, reqEditors ...RequestEditorFn) (*WaitForIOEventResp, error)

	// GetModeWithResponse request
	GetModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetModeResp, error)

	// SetDefaultModeWithResponse request
	SetDefaultModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams, reqEditors ...RequestEditorFn) (*SetDefaultModeResp, error)

	// StreamModeChangeWithResponse request
	StreamModeChangeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*StreamModeChangeResp, error)

	// GetCurrentRobotControllerStateWithResponse request
	GetCurrentRobotControllerStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetCurrentRobotControllerStateResp, error)

	// StreamRobotControllerStateWithResponse request
	StreamRobotControllerStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams, reqEditors ...RequestEditorFn) (*StreamRobotControllerStateResp, error)

	// ListVirtualRobotCoordinateSystemsWithResponse request
	ListVirtualRobotCoordinateSystemsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListVirtualRobotCoordinateSystemsResp, error)

	// AddVirtualRobotCoordinateSystemWithBodyWithResponse request with any body
	AddVirtualRobotCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualRobotCoordinateSystemResp, error)

	AddVirtualRobotCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body AddVirtualRobotCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualRobotCoordinateSystemResp, error)

	// DeleteVirtualRobotCoordinateSystemWithResponse request
	DeleteVirtualRobotCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystem CoordinateSystem, params *DeleteVirtualRobotCoordinateSystemParams, reqEditors ...RequestEditorFn) (*DeleteVirtualRobotCoordinateSystemResp, error)

	// GetCycleTimeWithResponse request
	GetCycleTimeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetCycleTimeResp, error)

	// GetEStopWithResponse request
	GetEStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetEStopResp, error)

	// PushEStopWithResponse request
	PushEStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*PushEStopResp, error)

	// ReleaseEStopWithResponse request
	ReleaseEStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ReleaseEStopResp, error)

	// ListIOsWithResponse request
	ListIOsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListIOsResp, error)

	// GetVirtualRobotIOValueWithResponse request
	GetVirtualRobotIOValueWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, reqEditors ...RequestEditorFn) (*GetVirtualRobotIOValueResp, error)

	// SetVirtualRobotIOValueWithResponse request
	SetVirtualRobotIOValueWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, params *SetVirtualRobotIOValueParams, reqEditors ...RequestEditorFn) (*SetVirtualRobotIOValueResp, error)

	// ExternalJointsStreamWithBodyWithResponse request with any body
	ExternalJointsStreamWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExternalJointsStreamResp, error)

	ExternalJointsStreamWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*ExternalJointsStreamResp, error)

	// GetMotionGroupStateWithResponse request
	GetMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*GetMotionGroupStateResp, error)

	// SetMotionGroupStateWithBodyWithResponse request with any body
	SetMotionGroupStateWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMotionGroupStateResp, error)

	SetMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetMotionGroupStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMotionGroupStateResp, error)

	// GetMotionGroupBehaviorWithResponse request
	GetMotionGroupBehaviorWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*GetMotionGroupBehaviorResp, error)

	// SetMotionGroupBehaviorWithResponse request
	SetMotionGroupBehaviorWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, params *SetMotionGroupBehaviorParams, reqEditors ...RequestEditorFn) (*SetMotionGroupBehaviorResp, error)

	// GetVirtualRobotMountingWithResponse request
	GetVirtualRobotMountingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*GetVirtualRobotMountingResp, error)

	// SetVirtualRobotMountingWithBodyWithResponse request with any body
	SetVirtualRobotMountingWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetVirtualRobotMountingResp, error)

	SetVirtualRobotMountingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetVirtualRobotMountingJSONRequestBody, reqEditors ...RequestEditorFn) (*SetVirtualRobotMountingResp, error)

	// ListVirtualRobotTcpsWithResponse request
	ListVirtualRobotTcpsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*ListVirtualRobotTcpsResp, error)

	// AddVirtualRobotTcpWithBodyWithResponse request with any body
	AddVirtualRobotTcpWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualRobotTcpResp, error)

	AddVirtualRobotTcpWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body AddVirtualRobotTcpJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualRobotTcpResp, error)

	// DeleteVirtualRobotTcpWithResponse request
	DeleteVirtualRobotTcpWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, tcp Tcp, reqEditors ...RequestEditorFn) (*DeleteVirtualRobotTcpResp, error)

	// GetMotionGroupsWithResponse request
	GetMotionGroupsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetMotionGroupsResp, error)

	// GetOperationModeWithResponse request
	GetOperationModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetOperationModeResp, error)

	// SetOperationModeWithResponse request
	SetOperationModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetOperationModeParams, reqEditors ...RequestEditorFn) (*SetOperationModeResp, error)

	// GetVirtualRobotConfigurationWithResponse request
	GetVirtualRobotConfigurationWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetVirtualRobotConfigurationResp, error)

	// ListCoordinateSystemsWithResponse request
	ListCoordinateSystemsWithResponse(ctx context.Context, cellID CellID, params *ListCoordinateSystemsParams, reqEditors ...RequestEditorFn) (*ListCoordinateSystemsResp, error)

	// AddCoordinateSystemWithBodyWithResponse request with any body
	AddCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCoordinateSystemResp, error)

	AddCoordinateSystemWithResponse(ctx context.Context, cellID CellID, body AddCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCoordinateSystemResp, error)

	// DeleteCoordinateSystemWithResponse request
	DeleteCoordinateSystemWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, reqEditors ...RequestEditorFn) (*DeleteCoordinateSystemResp, error)

	// GetCoordinateSystemWithResponse request
	GetCoordinateSystemWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, params *GetCoordinateSystemParams, reqEditors ...RequestEditorFn) (*GetCoordinateSystemResp, error)

	// TransformInCoordinateSystemWithBodyWithResponse request with any body
	TransformInCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransformInCoordinateSystemResp, error)

	TransformInCoordinateSystemWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, body TransformInCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*TransformInCoordinateSystemResp, error)

	// ClearDevicesWithResponse request
	ClearDevicesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearDevicesResp, error)

	// CreateDeviceWithBodyWithResponse request with any body
	CreateDeviceWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeviceResp, error)

	CreateDeviceWithResponse(ctx context.Context, cellID CellID, body CreateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeviceResp, error)

	// DeleteDeviceWithResponse request
	DeleteDeviceWithResponse(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*DeleteDeviceResp, error)

	// GetDeviceWithResponse request
	GetDeviceWithResponse(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*GetDeviceResp, error)

	// ListMotionGroupsWithResponse request
	ListMotionGroupsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListMotionGroupsResp, error)

	// ActivateMotionGroupWithResponse request
	ActivateMotionGroupWithResponse(ctx context.Context, cellID CellID, params *ActivateMotionGroupParams, reqEditors ...RequestEditorFn) (*ActivateMotionGroupResp, error)

	// ActivateAllMotionGroupsWithResponse request
	ActivateAllMotionGroupsWithResponse(ctx context.Context, cellID CellID, params *ActivateAllMotionGroupsParams, reqEditors ...RequestEditorFn) (*ActivateAllMotionGroupsResp, error)

	// JointJoggingWithBodyWithResponse request with any body
	JointJoggingWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JointJoggingResp, error)

	JointJoggingWithResponse(ctx context.Context, cellID CellID, body JointJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*JointJoggingResp, error)

	// DirectionJoggingWithBodyWithResponse request with any body
	DirectionJoggingWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectionJoggingResp, error)

	DirectionJoggingWithResponse(ctx context.Context, cellID CellID, body DirectionJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectionJoggingResp, error)

	// DeactivateMotionGroupWithResponse request
	DeactivateMotionGroupWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*DeactivateMotionGroupResp, error)

	// GetInfoCapabilitiesWithResponse request
	GetInfoCapabilitiesWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetInfoCapabilitiesResp, error)

	// GetJoggingCapabilitiesWithResponse request
	GetJoggingCapabilitiesWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetJoggingCapabilitiesResp, error)

	// GetKinematicCapabilitiesWithResponse request
	GetKinematicCapabilitiesWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetKinematicCapabilitiesResp, error)

	// CalculateAllInverseKinematicWithBodyWithResponse request with any body
	CalculateAllInverseKinematicWithBodyWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculateAllInverseKinematicResp, error)

	CalculateAllInverseKinematicWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateAllInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculateAllInverseKinematicResp, error)

	// CalculateInverseKinematicWithBodyWithResponse request with any body
	CalculateInverseKinematicWithBodyWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculateInverseKinematicResp, error)

	CalculateInverseKinematicWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculateInverseKinematicResp, error)

	// CalculateForwardKinematicWithBodyWithResponse request with any body
	CalculateForwardKinematicWithBodyWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculateForwardKinematicResp, error)

	CalculateForwardKinematicWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateForwardKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculateForwardKinematicResp, error)

	// GetMountingWithResponse request
	GetMountingWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetMountingResp, error)

	// GetOptimizerConfigurationWithResponse request
	GetOptimizerConfigurationWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetOptimizerConfigurationParams, reqEditors ...RequestEditorFn) (*GetOptimizerConfigurationResp, error)

	// ListPayloadsWithResponse request
	ListPayloadsWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*ListPayloadsResp, error)

	// GetActivePayloadWithResponse request
	GetActivePayloadWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetActivePayloadResp, error)

	// GetSafetySetupWithResponse request
	GetSafetySetupWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetSafetySetupResp, error)

	// GetMotionGroupSpecificationWithResponse request
	GetMotionGroupSpecificationWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetMotionGroupSpecificationResp, error)

	// GetCurrentMotionGroupStateWithResponse request
	GetCurrentMotionGroupStateWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetCurrentMotionGroupStateParams, reqEditors ...RequestEditorFn) (*GetCurrentMotionGroupStateResp, error)

	// StreamMotionGroupStateWithResponse request
	StreamMotionGroupStateWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *StreamMotionGroupStateParams, reqEditors ...RequestEditorFn) (*StreamMotionGroupStateResp, error)

	// StopJoggingWithResponse request
	StopJoggingWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*StopJoggingResp, error)

	// ListTcpsWithResponse request
	ListTcpsWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *ListTcpsParams, reqEditors ...RequestEditorFn) (*ListTcpsResp, error)

	// GetActiveTcpWithResponse request
	GetActiveTcpWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetActiveTcpParams, reqEditors ...RequestEditorFn) (*GetActiveTcpResp, error)

	// GetPlanningMotionGroupModelsWithResponse request
	GetPlanningMotionGroupModelsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetPlanningMotionGroupModelsResp, error)

	// PlanCollisionFreePTPWithBodyWithResponse request with any body
	PlanCollisionFreePTPWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanCollisionFreePTPResp, error)

	PlanCollisionFreePTPWithResponse(ctx context.Context, cellID CellID, body PlanCollisionFreePTPJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanCollisionFreePTPResp, error)

	// PlanTrajectoryWithBodyWithResponse request with any body
	PlanTrajectoryWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanTrajectoryResp, error)

	PlanTrajectoryWithResponse(ctx context.Context, cellID CellID, body PlanTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanTrajectoryResp, error)

	// DeleteAllMotionsWithResponse request
	DeleteAllMotionsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*DeleteAllMotionsResp, error)

	// ListMotionsWithResponse request
	ListMotionsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListMotionsResp, error)

	// PlanMotionWithBodyWithResponse request with any body
	PlanMotionWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanMotionResp, error)

	PlanMotionWithResponse(ctx context.Context, cellID CellID, body PlanMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanMotionResp, error)

	// ExecuteTrajectoryWithBodyWithResponse request with any body
	ExecuteTrajectoryWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteTrajectoryResp, error)

	ExecuteTrajectoryWithResponse(ctx context.Context, cellID CellID, body ExecuteTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteTrajectoryResp, error)

	// StreamMoveWithBodyWithResponse request with any body
	StreamMoveWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StreamMoveResp, error)

	StreamMoveWithResponse(ctx context.Context, cellID CellID, body StreamMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*StreamMoveResp, error)

	// DeleteMotionWithResponse request
	DeleteMotionWithResponse(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*DeleteMotionResp, error)

	// StreamMoveBackwardWithResponse request
	StreamMoveBackwardWithResponse(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveBackwardParams, reqEditors ...RequestEditorFn) (*StreamMoveBackwardResp, error)

	// StreamMoveForwardWithResponse request
	StreamMoveForwardWithResponse(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveForwardParams, reqEditors ...RequestEditorFn) (*StreamMoveForwardResp, error)

	// StreamMoveToTrajectoryViaJointPTPWithResponse request
	StreamMoveToTrajectoryViaJointPTPWithResponse(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveToTrajectoryViaJointPTPParams, reqEditors ...RequestEditorFn) (*StreamMoveToTrajectoryViaJointPTPResp, error)

	// GetPlannedMotionWithResponse request
	GetPlannedMotionWithResponse(ctx context.Context, cellID CellID, motion Motion, params *GetPlannedMotionParams, reqEditors ...RequestEditorFn) (*GetPlannedMotionResp, error)

	// StopExecutionWithResponse request
	StopExecutionWithResponse(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*StopExecutionResp, error)

	// GetMotionTrajectoryWithResponse request
	GetMotionTrajectoryWithResponse(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectoryParams, reqEditors ...RequestEditorFn) (*GetMotionTrajectoryResp, error)

	// GetMotionTrajectorySampleWithResponse request
	GetMotionTrajectorySampleWithResponse(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectorySampleParams, reqEditors ...RequestEditorFn) (*GetMotionTrajectorySampleResp, error)

	// GetAllProgramRunsWithResponse request
	GetAllProgramRunsWithResponse(ctx context.Context, cellID CellID, params *GetAllProgramRunsParams, reqEditors ...RequestEditorFn) (*GetAllProgramRunsResp, error)

	// CreateProgramRunWithBodyWithResponse request with any body
	CreateProgramRunWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramRunResp, error)

	CreateProgramRunWithResponse(ctx context.Context, cellID CellID, body CreateProgramRunJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramRunResp, error)

	// GetProgramRunWithResponse request
	GetProgramRunWithResponse(ctx context.Context, cellID CellID, run string, reqEditors ...RequestEditorFn) (*GetProgramRunResp, error)

	// GetAllTriggersWithResponse request
	GetAllTriggersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetAllTriggersResp, error)

	// CreateTriggerWithBodyWithResponse request with any body
	CreateTriggerWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTriggerResp, error)

	CreateTriggerWithResponse(ctx context.Context, cellID CellID, body CreateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTriggerResp, error)

	// DeleteTriggerWithResponse request
	DeleteTriggerWithResponse(ctx context.Context, cellID CellID, trigger string, reqEditors ...RequestEditorFn) (*DeleteTriggerResp, error)

	// GetTriggerWithResponse request
	GetTriggerWithResponse(ctx context.Context, cellID CellID, trigger string, reqEditors ...RequestEditorFn) (*GetTriggerResp, error)

	// UpdateTriggerWithBodyWithResponse request with any body
	UpdateTriggerWithBodyWithResponse(ctx context.Context, cellID CellID, trigger string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTriggerResp, error)

	UpdateTriggerWithResponse(ctx context.Context, cellID CellID, trigger string, body UpdateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTriggerResp, error)

	// LoadPlannedMotionWithBodyWithResponse request with any body
	LoadPlannedMotionWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoadPlannedMotionResp, error)

	LoadPlannedMotionWithResponse(ctx context.Context, cellID CellID, body LoadPlannedMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*LoadPlannedMotionResp, error)

	// ClearProgramsValuesWithResponse request
	ClearProgramsValuesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearProgramsValuesResp, error)

	// CreateProgramsValueWithBodyWithResponse request with any body
	CreateProgramsValueWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramsValueResp, error)

	CreateProgramsValueWithResponse(ctx context.Context, cellID CellID, body CreateProgramsValueJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramsValueResp, error)

	// DeleteProgramValueWithResponse request
	DeleteProgramValueWithResponse(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*DeleteProgramValueResp, error)

	// GetProgramValueWithResponse request
	GetProgramValueWithResponse(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*GetProgramValueResp, error)

	// UpdateProgramValueWithBodyWithResponse request with any body
	UpdateProgramValueWithBodyWithResponse(ctx context.Context, cellID CellID, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramValueResp, error)

	UpdateProgramValueWithResponse(ctx context.Context, cellID CellID, key string, body UpdateProgramValueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramValueResp, error)

	// GetCellStatusWithResponse request
	GetCellStatusWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetCellStatusResp, error)

	// ListStoredCollidersWithResponse request
	ListStoredCollidersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollidersResp, error)

	// DeleteStoredColliderWithResponse request
	DeleteStoredColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*DeleteStoredColliderResp, error)

	// GetStoredColliderWithResponse request
	GetStoredColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*GetStoredColliderResp, error)

	// StoreColliderWithBodyWithResponse request with any body
	StoreColliderWithBodyWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreColliderResp, error)

	StoreColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreColliderResp, error)

	// GetDefaultLinkChainWithResponse request
	GetDefaultLinkChainWithResponse(ctx context.Context, cellID CellID, motionGroupModel GetDefaultLinkChainParamsMotionGroupModel, reqEditors ...RequestEditorFn) (*GetDefaultLinkChainResp, error)

	// ListCollisionLinkChainsWithResponse request
	ListCollisionLinkChainsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListCollisionLinkChainsResp, error)

	// DeleteStoredCollisionLinkChainWithResponse request
	DeleteStoredCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionLinkChainResp, error)

	// GetStoredCollisionLinkChainWithResponse request
	GetStoredCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*GetStoredCollisionLinkChainResp, error)

	// StoreCollisionLinkChainWithBodyWithResponse request with any body
	StoreCollisionLinkChainWithBodyWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionLinkChainResp, error)

	StoreCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionLinkChainResp, error)

	// ListStoredCollisionScenesWithResponse request
	ListStoredCollisionScenesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollisionScenesResp, error)

	// DeleteStoredCollisionSceneWithResponse request
	DeleteStoredCollisionSceneWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionSceneResp, error)

	// GetStoredCollisionSceneWithResponse request
	GetStoredCollisionSceneWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*GetStoredCollisionSceneResp, error)

	// StoreCollisionSceneWithBodyWithResponse request with any body
	StoreCollisionSceneWithBodyWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionSceneResp, error)

	StoreCollisionSceneWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, body StoreCollisionSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionSceneResp, error)

	// ListStoredCollisionToolsWithResponse request
	ListStoredCollisionToolsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollisionToolsResp, error)

	// DeleteStoredCollisionToolWithResponse request
	DeleteStoredCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionToolResp, error)

	// GetStoredCollisionToolWithResponse request
	GetStoredCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*GetStoredCollisionToolResp, error)

	// StoreCollisionToolWithBodyWithResponse request with any body
	StoreCollisionToolWithBodyWithResponse(ctx context.Context, cellID CellID, toolID ToolID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionToolResp, error)

	StoreCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionToolResp, error)

	// ClearAllObjectsWithResponse request
	ClearAllObjectsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearAllObjectsResp, error)

	// ListAllObjectKeysWithResponse request
	ListAllObjectKeysWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListAllObjectKeysResp, error)

	// DeleteObjectWithResponse request
	DeleteObjectWithResponse(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*DeleteObjectResp, error)

	// GetObjectWithResponse request
	GetObjectWithResponse(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*GetObjectResp, error)

	// GetObjectMetadataWithResponse request
	GetObjectMetadataWithResponse(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*GetObjectMetadataResp, error)

	// StoreObjectWithBodyWithResponse request with any body
	StoreObjectWithBodyWithResponse(ctx context.Context, cellID CellID, key Key, params *StoreObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreObjectResp, error)

	// DeleteProgramListWithResponse request
	DeleteProgramListWithResponse(ctx context.Context, cellID CellID, params *DeleteProgramListParams, reqEditors ...RequestEditorFn) (*DeleteProgramListResp, error)

	// ListProgramMetadataWithResponse request
	ListProgramMetadataWithResponse(ctx context.Context, cellID CellID, params *ListProgramMetadataParams, reqEditors ...RequestEditorFn) (*ListProgramMetadataResp, error)

	// CreateProgramWithBodyWithResponse request with any body
	CreateProgramWithBodyWithResponse(ctx context.Context, cellID CellID, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramResp, error)

	CreateProgramWithTextBodyWithResponse(ctx context.Context, cellID CellID, params *CreateProgramParams, body CreateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramResp, error)

	// DeleteProgramWithResponse request
	DeleteProgramWithResponse(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*DeleteProgramResp, error)

	// GetProgramWithResponse request
	GetProgramWithResponse(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*GetProgramResp, error)

	// UpdateProgramWithBodyWithResponse request with any body
	UpdateProgramWithBodyWithResponse(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramResp, error)

	UpdateProgramWithTextBodyWithResponse(ctx context.Context, cellID CellID, program Program, body UpdateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramResp, error)

	// GetProgramMetadataWithResponse request
	GetProgramMetadataWithResponse(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*GetProgramMetadataResp, error)

	// UpdateProgramMetadataWithBodyWithResponse request with any body
	UpdateProgramMetadataWithBodyWithResponse(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramMetadataResp, error)

	UpdateProgramMetadataWithResponse(ctx context.Context, cellID CellID, program Program, body UpdateProgramMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramMetadataResp, error)

	// UploadProgramMetadataImageWithBodyWithResponse request with any body
	UploadProgramMetadataImageWithBodyWithResponse(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadProgramMetadataImageResp, error)

	// DeleteRecipeListWithResponse request
	DeleteRecipeListWithResponse(ctx context.Context, cellID CellID, params *DeleteRecipeListParams, reqEditors ...RequestEditorFn) (*DeleteRecipeListResp, error)

	// ListRecipeMetadataWithResponse request
	ListRecipeMetadataWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListRecipeMetadataResp, error)

	// CreateRecipeWithBodyWithResponse request with any body
	CreateRecipeWithBodyWithResponse(ctx context.Context, cellID CellID, params *CreateRecipeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRecipeResp, error)

	CreateRecipeWithResponse(ctx context.Context, cellID CellID, params *CreateRecipeParams, body CreateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRecipeResp, error)

	// DeleteRecipeWithResponse request
	DeleteRecipeWithResponse(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*DeleteRecipeResp, error)

	// GetRecipeWithResponse request
	GetRecipeWithResponse(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*GetRecipeResp, error)

	// UpdateRecipeWithBodyWithResponse request with any body
	UpdateRecipeWithBodyWithResponse(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecipeResp, error)

	UpdateRecipeWithResponse(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecipeResp, error)

	// GetRecipeMetadataWithResponse request
	GetRecipeMetadataWithResponse(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*GetRecipeMetadataResp, error)

	// UpdateRecipeMetadataWithBodyWithResponse request with any body
	UpdateRecipeMetadataWithBodyWithResponse(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecipeMetadataResp, error)

	UpdateRecipeMetadataWithResponse(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecipeMetadataResp, error)

	// UploadRecipeMetadataImageWithBodyWithResponse request with any body
	UploadRecipeMetadataImageWithBodyWithResponse(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadRecipeMetadataImageResp, error)

	// DeactivateLicenseWithResponse request
	DeactivateLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeactivateLicenseResp, error)

	// GetLicenseWithResponse request
	GetLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseResp, error)

	// ActivateLicenseWithBodyWithResponse request with any body
	ActivateLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateLicenseResp, error)

	ActivateLicenseWithResponse(ctx context.Context, body ActivateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateLicenseResp, error)

	// GetLicenseStatusWithResponse request
	GetLicenseStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseStatusResp, error)

	// GetDiagnosePackageWithResponse request
	GetDiagnosePackageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDiagnosePackageResp, error)

	// GetSystemStatusWithResponse request
	GetSystemStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemStatusResp, error)

	// CheckNovaVersionUpdateWithResponse request
	CheckNovaVersionUpdateWithResponse(ctx context.Context, params *CheckNovaVersionUpdateParams, reqEditors ...RequestEditorFn) (*CheckNovaVersionUpdateResp, error)

	// UpdateNovaVersionWithBodyWithResponse request with any body
	UpdateNovaVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNovaVersionResp, error)

	UpdateNovaVersionWithResponse(ctx context.Context, body UpdateNovaVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNovaVersionResp, error)

	// GetSystemVersionWithResponse request
	GetSystemVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemVersionResp, error)
}

type ListCellsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameList
}

// Status returns HTTPResponse.Status
func (r ListCellsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCellsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeployCellResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Error
}

// Status returns HTTPResponse.Status
func (r DeployCellResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeployCellResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCellResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteCellResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCellResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCellResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cell
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetCellResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCellResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCellResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON403      *Error
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateCellResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCellResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearAppsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ClearAppsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearAppsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NameList
}

// Status returns HTTPResponse.Status
func (r ListAppsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearRobotControllersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ClearRobotControllersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearRobotControllersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListControllersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ControllerInstanceList
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListControllersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListControllersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRobotControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *Error
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AddRobotControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRobotControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRobotControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteRobotControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRobotControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRobotControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotController
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetRobotControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRobotControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRobotControllerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateRobotControllerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRobotControllerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSupportedModesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ControllerCapabilities
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSupportedModesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSupportedModesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamFreeDriveResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotControllerState
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamFreeDriveResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamFreeDriveResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIODescriptionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIODescriptionsResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListIODescriptionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIODescriptionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamIOValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIOValuesResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamIOValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamIOValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIOValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIOValuesResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListIOValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIOValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOutputValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetOutputValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOutputValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WaitForIOEventResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r WaitForIOEventResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WaitForIOEventResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetModeResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetModeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetDefaultModeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetDefaultModeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetDefaultModeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamModeChangeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModeChangeResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamModeChangeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamModeChangeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentRobotControllerStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotControllerState
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCurrentRobotControllerStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentRobotControllerStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamRobotControllerStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotControllerState
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamRobotControllerStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamRobotControllerStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVirtualRobotCoordinateSystemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystems
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListVirtualRobotCoordinateSystemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVirtualRobotCoordinateSystemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddVirtualRobotCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r AddVirtualRobotCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddVirtualRobotCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualRobotCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualRobotCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualRobotCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCycleTimeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CycleTime
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCycleTimeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCycleTimeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEStopResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Flag
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetEStopResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEStopResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PushEStopResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r PushEStopResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PushEStopResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReleaseEStopResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ReleaseEStopResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReleaseEStopResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIOsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IOs
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListIOsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIOsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualRobotIOValueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IO
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVirtualRobotIOValueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualRobotIOValueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetVirtualRobotIOValueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetVirtualRobotIOValueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetVirtualRobotIOValueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExternalJointsStreamResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupJoints
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ExternalJointsStreamResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExternalJointsStreamResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupJoints
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMotionGroupStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetMotionGroupStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMotionGroupStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupBehaviorResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupBehaviorGetter
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupBehaviorResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupBehaviorResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetMotionGroupBehaviorResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetMotionGroupBehaviorResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetMotionGroupBehaviorResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualRobotMountingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystem
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVirtualRobotMountingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualRobotMountingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetVirtualRobotMountingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystem
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetVirtualRobotMountingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetVirtualRobotMountingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVirtualRobotTcpsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotTcps
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListVirtualRobotTcpsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVirtualRobotTcpsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddVirtualRobotTcpResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r AddVirtualRobotTcpResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddVirtualRobotTcpResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualRobotTcpResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualRobotTcpResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualRobotTcpResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupInfos
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOperationModeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OpMode
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetOperationModeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOperationModeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetOperationModeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Empty
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetOperationModeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetOperationModeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualRobotConfigurationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VirtualRobotConfiguration
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVirtualRobotConfigurationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualRobotConfigurationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCoordinateSystemsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListCoordinateSystemsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCoordinateSystemsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystem
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r AddCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoordinateSystem
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransformInCoordinateSystemResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pose
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r TransformInCoordinateSystemResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransformInCoordinateSystemResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearDevicesResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearDevicesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearDevicesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeviceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateDeviceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeviceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeviceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteDeviceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeviceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeviceResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetDeviceResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeviceResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMotionGroupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupInstanceList
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListMotionGroupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMotionGroupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateMotionGroupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupInstance
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ActivateMotionGroupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateMotionGroupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateAllMotionGroupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupInstanceList
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ActivateAllMotionGroupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateAllMotionGroupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JointJoggingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JoggingResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r JointJoggingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JointJoggingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DirectionJoggingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JoggingResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DirectionJoggingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DirectionJoggingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeactivateMotionGroupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeactivateMotionGroupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeactivateMotionGroupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInfoCapabilitiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InfoServiceCapabilities
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetInfoCapabilitiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInfoCapabilitiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJoggingCapabilitiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JoggingServiceCapabilities
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetJoggingCapabilitiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJoggingCapabilitiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKinematicCapabilitiesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KinematicServiceCapabilities
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetKinematicCapabilitiesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKinematicCapabilitiesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CalculateAllInverseKinematicResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllJointPositionsResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r CalculateAllInverseKinematicResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CalculateAllInverseKinematicResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CalculateInverseKinematicResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Joints
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r CalculateInverseKinematicResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CalculateInverseKinematicResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CalculateForwardKinematicResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pose
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r CalculateForwardKinematicResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CalculateForwardKinematicResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMountingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Mounting
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMountingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMountingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOptimizerConfigurationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OptimizerSetup
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetOptimizerConfigurationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOptimizerConfigurationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPayloadsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPayloadsResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListPayloadsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPayloadsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivePayloadResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Payload
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetActivePayloadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivePayloadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSafetySetupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SafetySetup
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSafetySetupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSafetySetupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionGroupSpecificationResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupSpecification
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMotionGroupSpecificationResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionGroupSpecificationResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentMotionGroupStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupStateResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCurrentMotionGroupStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentMotionGroupStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamMotionGroupStateResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionGroupStateResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamMotionGroupStateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamMotionGroupStateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopJoggingResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StopJoggingResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopJoggingResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTcpsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTcpsResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListTcpsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTcpsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActiveTcpResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RobotTcp
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetActiveTcpResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActiveTcpResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlanningMotionGroupModelsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetPlanningMotionGroupModelsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlanningMotionGroupModelsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlanCollisionFreePTPResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlanTrajectoryResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PlanCollisionFreePTPResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlanCollisionFreePTPResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlanTrajectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlanTrajectoryResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PlanTrajectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlanTrajectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAllMotionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAllMotionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAllMotionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMotionsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MotionIdsListResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListMotionsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMotionsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlanMotionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlanResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r PlanMotionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlanMotionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteTrajectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExecuteTrajectoryResponse
}

// Status returns HTTPResponse.Status
func (r ExecuteTrajectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteTrajectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamMoveResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamMoveResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamMoveResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamMoveResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMotionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteMotionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMotionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamMoveBackwardResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamMoveResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamMoveBackwardResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamMoveBackwardResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamMoveForwardResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamMoveResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamMoveForwardResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamMoveForwardResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamMoveToTrajectoryViaJointPTPResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamMoveResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StreamMoveToTrajectoryViaJointPTPResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamMoveToTrajectoryViaJointPTPResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlannedMotionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlannedMotion
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPlannedMotionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlannedMotionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopExecutionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r StopExecutionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopExecutionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionTrajectoryResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTrajectoryResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMotionTrajectoryResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionTrajectoryResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMotionTrajectorySampleResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTrajectorySampleResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMotionTrajectorySampleResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMotionTrajectorySampleResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllProgramRunsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ProgramRuns *[]ProgramRunObject `json:"program_runs,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllProgramRunsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllProgramRunsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProgramRunResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The identifier of the program run for further inspection of the
		// running program.
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateProgramRunResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProgramRunResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramRunResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramRunObject
}

// Status returns HTTPResponse.Status
func (r GetProgramRunResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramRunResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTriggersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Triggers *[]TriggerObject `json:"triggers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAllTriggersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTriggersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTriggerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The identifier of the created trigger.
		Id *string `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateTriggerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTriggerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTriggerResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTriggerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTriggerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTriggerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TriggerObject
}

// Status returns HTTPResponse.Status
func (r GetTriggerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTriggerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTriggerResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TriggerObject
}

// Status returns HTTPResponse.Status
func (r UpdateTriggerResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTriggerResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadPlannedMotionResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlanResponse
	JSONDefault  *DefaultErrorResponse
}

// Status returns HTTPResponse.Status
func (r LoadPlannedMotionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadPlannedMotionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearProgramsValuesResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearProgramsValuesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearProgramsValuesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProgramsValueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateProgramsValueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProgramsValueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProgramValueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteProgramValueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProgramValueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramValueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON422 *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetProgramValueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramValueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProgramValueResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateProgramValueResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProgramValueResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCellStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceStatusList
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetCellStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCellStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStoredCollidersResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ColliderDictionary
}

// Status returns HTTPResponse.Status
func (r ListStoredCollidersResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStoredCollidersResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoredColliderResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteStoredColliderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoredColliderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoredColliderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collider
}

// Status returns HTTPResponse.Status
func (r GetStoredColliderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoredColliderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreColliderResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collider
}

// Status returns HTTPResponse.Status
func (r StoreColliderResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreColliderResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultLinkChainResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkChain
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetDefaultLinkChainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultLinkChainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCollisionLinkChainsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]LinkChain
}

// Status returns HTTPResponse.Status
func (r ListCollisionLinkChainsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCollisionLinkChainsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoredCollisionLinkChainResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteStoredCollisionLinkChainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoredCollisionLinkChainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoredCollisionLinkChainResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkChain
}

// Status returns HTTPResponse.Status
func (r GetStoredCollisionLinkChainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoredCollisionLinkChainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreCollisionLinkChainResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkChain
}

// Status returns HTTPResponse.Status
func (r StoreCollisionLinkChainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreCollisionLinkChainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStoredCollisionScenesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]CollisionScene
}

// Status returns HTTPResponse.Status
func (r ListStoredCollisionScenesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStoredCollisionScenesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoredCollisionSceneResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteStoredCollisionSceneResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoredCollisionSceneResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoredCollisionSceneResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollisionScene
}

// Status returns HTTPResponse.Status
func (r GetStoredCollisionSceneResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoredCollisionSceneResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreCollisionSceneResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollisionScene
}

// Status returns HTTPResponse.Status
func (r StoreCollisionSceneResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreCollisionSceneResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStoredCollisionToolsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]Tool
}

// Status returns HTTPResponse.Status
func (r ListStoredCollisionToolsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStoredCollisionToolsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoredCollisionToolResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteStoredCollisionToolResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoredCollisionToolResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoredCollisionToolResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tool
}

// Status returns HTTPResponse.Status
func (r GetStoredCollisionToolResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoredCollisionToolResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreCollisionToolResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tool
}

// Status returns HTTPResponse.Status
func (r StoreCollisionToolResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreCollisionToolResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearAllObjectsResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearAllObjectsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearAllObjectsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAllObjectKeysResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Key
}

// Status returns HTTPResponse.Status
func (r ListAllObjectKeysResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllObjectKeysResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteObjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetObjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetObjectMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreObjectResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r StoreObjectResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreObjectResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProgramListResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProgramMetadataResponse
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteProgramListResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProgramListResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProgramMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProgramMetadataResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListProgramMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProgramMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProgramResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateProgramResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProgramResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProgramResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteProgramResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProgramResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetProgramResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProgramResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateProgramResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProgramResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetProgramMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProgramMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateProgramMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProgramMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadProgramMetadataImageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProgramMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UploadProgramMetadataImageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadProgramMetadataImageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecipeListResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRecipeMetadataResponse
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteRecipeListResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecipeListResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRecipeMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRecipeMetadataResponse
}

// Status returns HTTPResponse.Status
func (r ListRecipeMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecipeMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRecipeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateRecipeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRecipeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecipeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteRecipeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecipeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecipeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetRecipeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecipeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRecipeResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateRecipeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRecipeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecipeMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetRecipeMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecipeMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRecipeMetadataResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateRecipeMetadataResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRecipeMetadataResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadRecipeMetadataImageResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeMetadata
	JSON404      *HTTPExceptionResponse
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UploadRecipeMetadataImageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadRecipeMetadataImageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeactivateLicenseResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeactivateLicenseResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeactivateLicenseResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *License
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r GetLicenseResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateLicenseResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *License
	JSON403      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r ActivateLicenseResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateLicenseResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLicenseStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LicenseStatus
	JSON403      *LicenseStatus
}

// Status returns HTTPResponse.Status
func (r GetLicenseStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLicenseStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDiagnosePackageResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetDiagnosePackageResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDiagnosePackageResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemStatusResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceStatusList
}

// Status returns HTTPResponse.Status
func (r GetSystemStatusResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemStatusResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckNovaVersionUpdateResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CheckNovaVersionUpdateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckNovaVersionUpdateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNovaVersionResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateNovaVersionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNovaVersionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSystemVersionResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetSystemVersionResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSystemVersionResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListCellsWithResponse request returning *ListCellsResp
func (c *ClientWithResponses) ListCellsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListCellsResp, error) {
	rsp, err := c.ListCells(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCellsResp(rsp)
}

// DeployCellWithBodyWithResponse request with arbitrary body returning *DeployCellResp
func (c *ClientWithResponses) DeployCellWithBodyWithResponse(ctx context.Context, params *DeployCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeployCellResp, error) {
	rsp, err := c.DeployCellWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeployCellResp(rsp)
}

func (c *ClientWithResponses) DeployCellWithResponse(ctx context.Context, params *DeployCellParams, body DeployCellJSONRequestBody, reqEditors ...RequestEditorFn) (*DeployCellResp, error) {
	rsp, err := c.DeployCell(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeployCellResp(rsp)
}

// DeleteCellWithResponse request returning *DeleteCellResp
func (c *ClientWithResponses) DeleteCellWithResponse(ctx context.Context, cellID CellID, params *DeleteCellParams, reqEditors ...RequestEditorFn) (*DeleteCellResp, error) {
	rsp, err := c.DeleteCell(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCellResp(rsp)
}

// GetCellWithResponse request returning *GetCellResp
func (c *ClientWithResponses) GetCellWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetCellResp, error) {
	rsp, err := c.GetCell(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCellResp(rsp)
}

// UpdateCellWithBodyWithResponse request with arbitrary body returning *UpdateCellResp
func (c *ClientWithResponses) UpdateCellWithBodyWithResponse(ctx context.Context, cellID CellID, params *UpdateCellParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCellResp, error) {
	rsp, err := c.UpdateCellWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCellResp(rsp)
}

func (c *ClientWithResponses) UpdateCellWithResponse(ctx context.Context, cellID CellID, params *UpdateCellParams, body UpdateCellJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCellResp, error) {
	rsp, err := c.UpdateCell(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCellResp(rsp)
}

// ClearAppsWithResponse request returning *ClearAppsResp
func (c *ClientWithResponses) ClearAppsWithResponse(ctx context.Context, cellID CellID, params *ClearAppsParams, reqEditors ...RequestEditorFn) (*ClearAppsResp, error) {
	rsp, err := c.ClearApps(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearAppsResp(rsp)
}

// ListAppsWithResponse request returning *ListAppsResp
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListAppsResp, error) {
	rsp, err := c.ListApps(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResp(rsp)
}

// AddAppWithBodyWithResponse request with arbitrary body returning *AddAppResp
func (c *ClientWithResponses) AddAppWithBodyWithResponse(ctx context.Context, cellID CellID, params *AddAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAppResp, error) {
	rsp, err := c.AddAppWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAppResp(rsp)
}

func (c *ClientWithResponses) AddAppWithResponse(ctx context.Context, cellID CellID, params *AddAppParams, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAppResp, error) {
	rsp, err := c.AddApp(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAppResp(rsp)
}

// DeleteAppWithResponse request returning *DeleteAppResp
func (c *ClientWithResponses) DeleteAppWithResponse(ctx context.Context, cellID CellID, appID AppID, params *DeleteAppParams, reqEditors ...RequestEditorFn) (*DeleteAppResp, error) {
	rsp, err := c.DeleteApp(ctx, cellID, appID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppResp(rsp)
}

// GetAppWithResponse request returning *GetAppResp
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, cellID CellID, appID AppID, reqEditors ...RequestEditorFn) (*GetAppResp, error) {
	rsp, err := c.GetApp(ctx, cellID, appID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppResp(rsp)
}

// UpdateAppWithBodyWithResponse request with arbitrary body returning *UpdateAppResp
func (c *ClientWithResponses) UpdateAppWithBodyWithResponse(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResp, error) {
	rsp, err := c.UpdateAppWithBody(ctx, cellID, appID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResp(rsp)
}

func (c *ClientWithResponses) UpdateAppWithResponse(ctx context.Context, cellID CellID, appID AppID, params *UpdateAppParams, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResp, error) {
	rsp, err := c.UpdateApp(ctx, cellID, appID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResp(rsp)
}

// ClearRobotControllersWithResponse request returning *ClearRobotControllersResp
func (c *ClientWithResponses) ClearRobotControllersWithResponse(ctx context.Context, cellID CellID, params *ClearRobotControllersParams, reqEditors ...RequestEditorFn) (*ClearRobotControllersResp, error) {
	rsp, err := c.ClearRobotControllers(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearRobotControllersResp(rsp)
}

// ListControllersWithResponse request returning *ListControllersResp
func (c *ClientWithResponses) ListControllersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListControllersResp, error) {
	rsp, err := c.ListControllers(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListControllersResp(rsp)
}

// AddRobotControllerWithBodyWithResponse request with arbitrary body returning *AddRobotControllerResp
func (c *ClientWithResponses) AddRobotControllerWithBodyWithResponse(ctx context.Context, cellID CellID, params *AddRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRobotControllerResp, error) {
	rsp, err := c.AddRobotControllerWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRobotControllerResp(rsp)
}

func (c *ClientWithResponses) AddRobotControllerWithResponse(ctx context.Context, cellID CellID, params *AddRobotControllerParams, body AddRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRobotControllerResp, error) {
	rsp, err := c.AddRobotController(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRobotControllerResp(rsp)
}

// DeleteRobotControllerWithResponse request returning *DeleteRobotControllerResp
func (c *ClientWithResponses) DeleteRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *DeleteRobotControllerParams, reqEditors ...RequestEditorFn) (*DeleteRobotControllerResp, error) {
	rsp, err := c.DeleteRobotController(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRobotControllerResp(rsp)
}

// GetRobotControllerWithResponse request returning *GetRobotControllerResp
func (c *ClientWithResponses) GetRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetRobotControllerResp, error) {
	rsp, err := c.GetRobotController(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRobotControllerResp(rsp)
}

// UpdateRobotControllerWithBodyWithResponse request with arbitrary body returning *UpdateRobotControllerResp
func (c *ClientWithResponses) UpdateRobotControllerWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRobotControllerResp, error) {
	rsp, err := c.UpdateRobotControllerWithBody(ctx, cellID, controllerID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRobotControllerResp(rsp)
}

func (c *ClientWithResponses) UpdateRobotControllerWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *UpdateRobotControllerParams, body UpdateRobotControllerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRobotControllerResp, error) {
	rsp, err := c.UpdateRobotController(ctx, cellID, controllerID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRobotControllerResp(rsp)
}

// GetSupportedModesWithResponse request returning *GetSupportedModesResp
func (c *ClientWithResponses) GetSupportedModesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetSupportedModesResp, error) {
	rsp, err := c.GetSupportedModes(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSupportedModesResp(rsp)
}

// StreamFreeDriveWithResponse request returning *StreamFreeDriveResp
func (c *ClientWithResponses) StreamFreeDriveWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamFreeDriveParams, reqEditors ...RequestEditorFn) (*StreamFreeDriveResp, error) {
	rsp, err := c.StreamFreeDrive(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamFreeDriveResp(rsp)
}

// ListIODescriptionsWithResponse request returning *ListIODescriptionsResp
func (c *ClientWithResponses) ListIODescriptionsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIODescriptionsParams, reqEditors ...RequestEditorFn) (*ListIODescriptionsResp, error) {
	rsp, err := c.ListIODescriptions(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIODescriptionsResp(rsp)
}

// StreamIOValuesWithResponse request returning *StreamIOValuesResp
func (c *ClientWithResponses) StreamIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamIOValuesParams, reqEditors ...RequestEditorFn) (*StreamIOValuesResp, error) {
	rsp, err := c.StreamIOValues(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamIOValuesResp(rsp)
}

// ListIOValuesWithResponse request returning *ListIOValuesResp
func (c *ClientWithResponses) ListIOValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *ListIOValuesParams, reqEditors ...RequestEditorFn) (*ListIOValuesResp, error) {
	rsp, err := c.ListIOValues(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIOValuesResp(rsp)
}

// SetOutputValuesWithBodyWithResponse request with arbitrary body returning *SetOutputValuesResp
func (c *ClientWithResponses) SetOutputValuesWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetOutputValuesResp, error) {
	rsp, err := c.SetOutputValuesWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOutputValuesResp(rsp)
}

func (c *ClientWithResponses) SetOutputValuesWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body SetOutputValuesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetOutputValuesResp, error) {
	rsp, err := c.SetOutputValues(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOutputValuesResp(rsp)
}

// WaitForIOEventWithResponse request returning *WaitForIOEventResp
func (c *ClientWithResponses) WaitForIOEventWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *WaitForIOEventParams, reqEditors ...RequestEditorFn) (*WaitForIOEventResp, error) {
	rsp, err := c.WaitForIOEvent(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWaitForIOEventResp(rsp)
}

// GetModeWithResponse request returning *GetModeResp
func (c *ClientWithResponses) GetModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetModeResp, error) {
	rsp, err := c.GetMode(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModeResp(rsp)
}

// SetDefaultModeWithResponse request returning *SetDefaultModeResp
func (c *ClientWithResponses) SetDefaultModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetDefaultModeParams, reqEditors ...RequestEditorFn) (*SetDefaultModeResp, error) {
	rsp, err := c.SetDefaultMode(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetDefaultModeResp(rsp)
}

// StreamModeChangeWithResponse request returning *StreamModeChangeResp
func (c *ClientWithResponses) StreamModeChangeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*StreamModeChangeResp, error) {
	rsp, err := c.StreamModeChange(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamModeChangeResp(rsp)
}

// GetCurrentRobotControllerStateWithResponse request returning *GetCurrentRobotControllerStateResp
func (c *ClientWithResponses) GetCurrentRobotControllerStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetCurrentRobotControllerStateResp, error) {
	rsp, err := c.GetCurrentRobotControllerState(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentRobotControllerStateResp(rsp)
}

// StreamRobotControllerStateWithResponse request returning *StreamRobotControllerStateResp
func (c *ClientWithResponses) StreamRobotControllerStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *StreamRobotControllerStateParams, reqEditors ...RequestEditorFn) (*StreamRobotControllerStateResp, error) {
	rsp, err := c.StreamRobotControllerState(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamRobotControllerStateResp(rsp)
}

// ListVirtualRobotCoordinateSystemsWithResponse request returning *ListVirtualRobotCoordinateSystemsResp
func (c *ClientWithResponses) ListVirtualRobotCoordinateSystemsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListVirtualRobotCoordinateSystemsResp, error) {
	rsp, err := c.ListVirtualRobotCoordinateSystems(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVirtualRobotCoordinateSystemsResp(rsp)
}

// AddVirtualRobotCoordinateSystemWithBodyWithResponse request with arbitrary body returning *AddVirtualRobotCoordinateSystemResp
func (c *ClientWithResponses) AddVirtualRobotCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualRobotCoordinateSystemResp, error) {
	rsp, err := c.AddVirtualRobotCoordinateSystemWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualRobotCoordinateSystemResp(rsp)
}

func (c *ClientWithResponses) AddVirtualRobotCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body AddVirtualRobotCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualRobotCoordinateSystemResp, error) {
	rsp, err := c.AddVirtualRobotCoordinateSystem(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualRobotCoordinateSystemResp(rsp)
}

// DeleteVirtualRobotCoordinateSystemWithResponse request returning *DeleteVirtualRobotCoordinateSystemResp
func (c *ClientWithResponses) DeleteVirtualRobotCoordinateSystemWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, coordinateSystem CoordinateSystem, params *DeleteVirtualRobotCoordinateSystemParams, reqEditors ...RequestEditorFn) (*DeleteVirtualRobotCoordinateSystemResp, error) {
	rsp, err := c.DeleteVirtualRobotCoordinateSystem(ctx, cellID, controllerID, coordinateSystem, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualRobotCoordinateSystemResp(rsp)
}

// GetCycleTimeWithResponse request returning *GetCycleTimeResp
func (c *ClientWithResponses) GetCycleTimeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetCycleTimeResp, error) {
	rsp, err := c.GetCycleTime(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCycleTimeResp(rsp)
}

// GetEStopWithResponse request returning *GetEStopResp
func (c *ClientWithResponses) GetEStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetEStopResp, error) {
	rsp, err := c.GetEStop(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEStopResp(rsp)
}

// PushEStopWithResponse request returning *PushEStopResp
func (c *ClientWithResponses) PushEStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*PushEStopResp, error) {
	rsp, err := c.PushEStop(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePushEStopResp(rsp)
}

// ReleaseEStopWithResponse request returning *ReleaseEStopResp
func (c *ClientWithResponses) ReleaseEStopWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ReleaseEStopResp, error) {
	rsp, err := c.ReleaseEStop(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseEStopResp(rsp)
}

// ListIOsWithResponse request returning *ListIOsResp
func (c *ClientWithResponses) ListIOsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*ListIOsResp, error) {
	rsp, err := c.ListIOs(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIOsResp(rsp)
}

// GetVirtualRobotIOValueWithResponse request returning *GetVirtualRobotIOValueResp
func (c *ClientWithResponses) GetVirtualRobotIOValueWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, reqEditors ...RequestEditorFn) (*GetVirtualRobotIOValueResp, error) {
	rsp, err := c.GetVirtualRobotIOValue(ctx, cellID, controllerID, io, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualRobotIOValueResp(rsp)
}

// SetVirtualRobotIOValueWithResponse request returning *SetVirtualRobotIOValueResp
func (c *ClientWithResponses) SetVirtualRobotIOValueWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, io IO, params *SetVirtualRobotIOValueParams, reqEditors ...RequestEditorFn) (*SetVirtualRobotIOValueResp, error) {
	rsp, err := c.SetVirtualRobotIOValue(ctx, cellID, controllerID, io, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetVirtualRobotIOValueResp(rsp)
}

// ExternalJointsStreamWithBodyWithResponse request with arbitrary body returning *ExternalJointsStreamResp
func (c *ClientWithResponses) ExternalJointsStreamWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExternalJointsStreamResp, error) {
	rsp, err := c.ExternalJointsStreamWithBody(ctx, cellID, controllerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalJointsStreamResp(rsp)
}

func (c *ClientWithResponses) ExternalJointsStreamWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, body ExternalJointsStreamJSONRequestBody, reqEditors ...RequestEditorFn) (*ExternalJointsStreamResp, error) {
	rsp, err := c.ExternalJointsStream(ctx, cellID, controllerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalJointsStreamResp(rsp)
}

// GetMotionGroupStateWithResponse request returning *GetMotionGroupStateResp
func (c *ClientWithResponses) GetMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*GetMotionGroupStateResp, error) {
	rsp, err := c.GetMotionGroupState(ctx, cellID, controllerID, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupStateResp(rsp)
}

// SetMotionGroupStateWithBodyWithResponse request with arbitrary body returning *SetMotionGroupStateResp
func (c *ClientWithResponses) SetMotionGroupStateWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetMotionGroupStateResp, error) {
	rsp, err := c.SetMotionGroupStateWithBody(ctx, cellID, controllerID, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMotionGroupStateResp(rsp)
}

func (c *ClientWithResponses) SetMotionGroupStateWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetMotionGroupStateJSONRequestBody, reqEditors ...RequestEditorFn) (*SetMotionGroupStateResp, error) {
	rsp, err := c.SetMotionGroupState(ctx, cellID, controllerID, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMotionGroupStateResp(rsp)
}

// GetMotionGroupBehaviorWithResponse request returning *GetMotionGroupBehaviorResp
func (c *ClientWithResponses) GetMotionGroupBehaviorWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*GetMotionGroupBehaviorResp, error) {
	rsp, err := c.GetMotionGroupBehavior(ctx, cellID, controllerID, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupBehaviorResp(rsp)
}

// SetMotionGroupBehaviorWithResponse request returning *SetMotionGroupBehaviorResp
func (c *ClientWithResponses) SetMotionGroupBehaviorWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, params *SetMotionGroupBehaviorParams, reqEditors ...RequestEditorFn) (*SetMotionGroupBehaviorResp, error) {
	rsp, err := c.SetMotionGroupBehavior(ctx, cellID, controllerID, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetMotionGroupBehaviorResp(rsp)
}

// GetVirtualRobotMountingWithResponse request returning *GetVirtualRobotMountingResp
func (c *ClientWithResponses) GetVirtualRobotMountingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*GetVirtualRobotMountingResp, error) {
	rsp, err := c.GetVirtualRobotMounting(ctx, cellID, controllerID, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualRobotMountingResp(rsp)
}

// SetVirtualRobotMountingWithBodyWithResponse request with arbitrary body returning *SetVirtualRobotMountingResp
func (c *ClientWithResponses) SetVirtualRobotMountingWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetVirtualRobotMountingResp, error) {
	rsp, err := c.SetVirtualRobotMountingWithBody(ctx, cellID, controllerID, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetVirtualRobotMountingResp(rsp)
}

func (c *ClientWithResponses) SetVirtualRobotMountingWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body SetVirtualRobotMountingJSONRequestBody, reqEditors ...RequestEditorFn) (*SetVirtualRobotMountingResp, error) {
	rsp, err := c.SetVirtualRobotMounting(ctx, cellID, controllerID, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetVirtualRobotMountingResp(rsp)
}

// ListVirtualRobotTcpsWithResponse request returning *ListVirtualRobotTcpsResp
func (c *ClientWithResponses) ListVirtualRobotTcpsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, reqEditors ...RequestEditorFn) (*ListVirtualRobotTcpsResp, error) {
	rsp, err := c.ListVirtualRobotTcps(ctx, cellID, controllerID, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVirtualRobotTcpsResp(rsp)
}

// AddVirtualRobotTcpWithBodyWithResponse request with arbitrary body returning *AddVirtualRobotTcpResp
func (c *ClientWithResponses) AddVirtualRobotTcpWithBodyWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddVirtualRobotTcpResp, error) {
	rsp, err := c.AddVirtualRobotTcpWithBody(ctx, cellID, controllerID, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualRobotTcpResp(rsp)
}

func (c *ClientWithResponses) AddVirtualRobotTcpWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, body AddVirtualRobotTcpJSONRequestBody, reqEditors ...RequestEditorFn) (*AddVirtualRobotTcpResp, error) {
	rsp, err := c.AddVirtualRobotTcp(ctx, cellID, controllerID, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddVirtualRobotTcpResp(rsp)
}

// DeleteVirtualRobotTcpWithResponse request returning *DeleteVirtualRobotTcpResp
func (c *ClientWithResponses) DeleteVirtualRobotTcpWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, id Id, tcp Tcp, reqEditors ...RequestEditorFn) (*DeleteVirtualRobotTcpResp, error) {
	rsp, err := c.DeleteVirtualRobotTcp(ctx, cellID, controllerID, id, tcp, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualRobotTcpResp(rsp)
}

// GetMotionGroupsWithResponse request returning *GetMotionGroupsResp
func (c *ClientWithResponses) GetMotionGroupsWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetMotionGroupsResp, error) {
	rsp, err := c.GetMotionGroups(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupsResp(rsp)
}

// GetOperationModeWithResponse request returning *GetOperationModeResp
func (c *ClientWithResponses) GetOperationModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetOperationModeResp, error) {
	rsp, err := c.GetOperationMode(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOperationModeResp(rsp)
}

// SetOperationModeWithResponse request returning *SetOperationModeResp
func (c *ClientWithResponses) SetOperationModeWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, params *SetOperationModeParams, reqEditors ...RequestEditorFn) (*SetOperationModeResp, error) {
	rsp, err := c.SetOperationMode(ctx, cellID, controllerID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetOperationModeResp(rsp)
}

// GetVirtualRobotConfigurationWithResponse request returning *GetVirtualRobotConfigurationResp
func (c *ClientWithResponses) GetVirtualRobotConfigurationWithResponse(ctx context.Context, cellID CellID, controllerID ControllerID, reqEditors ...RequestEditorFn) (*GetVirtualRobotConfigurationResp, error) {
	rsp, err := c.GetVirtualRobotConfiguration(ctx, cellID, controllerID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualRobotConfigurationResp(rsp)
}

// ListCoordinateSystemsWithResponse request returning *ListCoordinateSystemsResp
func (c *ClientWithResponses) ListCoordinateSystemsWithResponse(ctx context.Context, cellID CellID, params *ListCoordinateSystemsParams, reqEditors ...RequestEditorFn) (*ListCoordinateSystemsResp, error) {
	rsp, err := c.ListCoordinateSystems(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCoordinateSystemsResp(rsp)
}

// AddCoordinateSystemWithBodyWithResponse request with arbitrary body returning *AddCoordinateSystemResp
func (c *ClientWithResponses) AddCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCoordinateSystemResp, error) {
	rsp, err := c.AddCoordinateSystemWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCoordinateSystemResp(rsp)
}

func (c *ClientWithResponses) AddCoordinateSystemWithResponse(ctx context.Context, cellID CellID, body AddCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCoordinateSystemResp, error) {
	rsp, err := c.AddCoordinateSystem(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCoordinateSystemResp(rsp)
}

// DeleteCoordinateSystemWithResponse request returning *DeleteCoordinateSystemResp
func (c *ClientWithResponses) DeleteCoordinateSystemWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, reqEditors ...RequestEditorFn) (*DeleteCoordinateSystemResp, error) {
	rsp, err := c.DeleteCoordinateSystem(ctx, cellID, coordinateSystem, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCoordinateSystemResp(rsp)
}

// GetCoordinateSystemWithResponse request returning *GetCoordinateSystemResp
func (c *ClientWithResponses) GetCoordinateSystemWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, params *GetCoordinateSystemParams, reqEditors ...RequestEditorFn) (*GetCoordinateSystemResp, error) {
	rsp, err := c.GetCoordinateSystem(ctx, cellID, coordinateSystem, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoordinateSystemResp(rsp)
}

// TransformInCoordinateSystemWithBodyWithResponse request with arbitrary body returning *TransformInCoordinateSystemResp
func (c *ClientWithResponses) TransformInCoordinateSystemWithBodyWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransformInCoordinateSystemResp, error) {
	rsp, err := c.TransformInCoordinateSystemWithBody(ctx, cellID, coordinateSystem, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransformInCoordinateSystemResp(rsp)
}

func (c *ClientWithResponses) TransformInCoordinateSystemWithResponse(ctx context.Context, cellID CellID, coordinateSystem CoordinateSystem, body TransformInCoordinateSystemJSONRequestBody, reqEditors ...RequestEditorFn) (*TransformInCoordinateSystemResp, error) {
	rsp, err := c.TransformInCoordinateSystem(ctx, cellID, coordinateSystem, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransformInCoordinateSystemResp(rsp)
}

// ClearDevicesWithResponse request returning *ClearDevicesResp
func (c *ClientWithResponses) ClearDevicesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearDevicesResp, error) {
	rsp, err := c.ClearDevices(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearDevicesResp(rsp)
}

// CreateDeviceWithBodyWithResponse request with arbitrary body returning *CreateDeviceResp
func (c *ClientWithResponses) CreateDeviceWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeviceResp, error) {
	rsp, err := c.CreateDeviceWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeviceResp(rsp)
}

func (c *ClientWithResponses) CreateDeviceWithResponse(ctx context.Context, cellID CellID, body CreateDeviceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeviceResp, error) {
	rsp, err := c.CreateDevice(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeviceResp(rsp)
}

// DeleteDeviceWithResponse request returning *DeleteDeviceResp
func (c *ClientWithResponses) DeleteDeviceWithResponse(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*DeleteDeviceResp, error) {
	rsp, err := c.DeleteDevice(ctx, cellID, identifier, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeviceResp(rsp)
}

// GetDeviceWithResponse request returning *GetDeviceResp
func (c *ClientWithResponses) GetDeviceWithResponse(ctx context.Context, cellID CellID, identifier string, reqEditors ...RequestEditorFn) (*GetDeviceResp, error) {
	rsp, err := c.GetDevice(ctx, cellID, identifier, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeviceResp(rsp)
}

// ListMotionGroupsWithResponse request returning *ListMotionGroupsResp
func (c *ClientWithResponses) ListMotionGroupsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListMotionGroupsResp, error) {
	rsp, err := c.ListMotionGroups(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMotionGroupsResp(rsp)
}

// ActivateMotionGroupWithResponse request returning *ActivateMotionGroupResp
func (c *ClientWithResponses) ActivateMotionGroupWithResponse(ctx context.Context, cellID CellID, params *ActivateMotionGroupParams, reqEditors ...RequestEditorFn) (*ActivateMotionGroupResp, error) {
	rsp, err := c.ActivateMotionGroup(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateMotionGroupResp(rsp)
}

// ActivateAllMotionGroupsWithResponse request returning *ActivateAllMotionGroupsResp
func (c *ClientWithResponses) ActivateAllMotionGroupsWithResponse(ctx context.Context, cellID CellID, params *ActivateAllMotionGroupsParams, reqEditors ...RequestEditorFn) (*ActivateAllMotionGroupsResp, error) {
	rsp, err := c.ActivateAllMotionGroups(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateAllMotionGroupsResp(rsp)
}

// JointJoggingWithBodyWithResponse request with arbitrary body returning *JointJoggingResp
func (c *ClientWithResponses) JointJoggingWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JointJoggingResp, error) {
	rsp, err := c.JointJoggingWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJointJoggingResp(rsp)
}

func (c *ClientWithResponses) JointJoggingWithResponse(ctx context.Context, cellID CellID, body JointJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*JointJoggingResp, error) {
	rsp, err := c.JointJogging(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJointJoggingResp(rsp)
}

// DirectionJoggingWithBodyWithResponse request with arbitrary body returning *DirectionJoggingResp
func (c *ClientWithResponses) DirectionJoggingWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DirectionJoggingResp, error) {
	rsp, err := c.DirectionJoggingWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectionJoggingResp(rsp)
}

func (c *ClientWithResponses) DirectionJoggingWithResponse(ctx context.Context, cellID CellID, body DirectionJoggingJSONRequestBody, reqEditors ...RequestEditorFn) (*DirectionJoggingResp, error) {
	rsp, err := c.DirectionJogging(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDirectionJoggingResp(rsp)
}

// DeactivateMotionGroupWithResponse request returning *DeactivateMotionGroupResp
func (c *ClientWithResponses) DeactivateMotionGroupWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*DeactivateMotionGroupResp, error) {
	rsp, err := c.DeactivateMotionGroup(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeactivateMotionGroupResp(rsp)
}

// GetInfoCapabilitiesWithResponse request returning *GetInfoCapabilitiesResp
func (c *ClientWithResponses) GetInfoCapabilitiesWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetInfoCapabilitiesResp, error) {
	rsp, err := c.GetInfoCapabilities(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInfoCapabilitiesResp(rsp)
}

// GetJoggingCapabilitiesWithResponse request returning *GetJoggingCapabilitiesResp
func (c *ClientWithResponses) GetJoggingCapabilitiesWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetJoggingCapabilitiesResp, error) {
	rsp, err := c.GetJoggingCapabilities(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJoggingCapabilitiesResp(rsp)
}

// GetKinematicCapabilitiesWithResponse request returning *GetKinematicCapabilitiesResp
func (c *ClientWithResponses) GetKinematicCapabilitiesWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetKinematicCapabilitiesResp, error) {
	rsp, err := c.GetKinematicCapabilities(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKinematicCapabilitiesResp(rsp)
}

// CalculateAllInverseKinematicWithBodyWithResponse request with arbitrary body returning *CalculateAllInverseKinematicResp
func (c *ClientWithResponses) CalculateAllInverseKinematicWithBodyWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculateAllInverseKinematicResp, error) {
	rsp, err := c.CalculateAllInverseKinematicWithBody(ctx, cellID, motionGroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculateAllInverseKinematicResp(rsp)
}

func (c *ClientWithResponses) CalculateAllInverseKinematicWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateAllInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculateAllInverseKinematicResp, error) {
	rsp, err := c.CalculateAllInverseKinematic(ctx, cellID, motionGroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculateAllInverseKinematicResp(rsp)
}

// CalculateInverseKinematicWithBodyWithResponse request with arbitrary body returning *CalculateInverseKinematicResp
func (c *ClientWithResponses) CalculateInverseKinematicWithBodyWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculateInverseKinematicResp, error) {
	rsp, err := c.CalculateInverseKinematicWithBody(ctx, cellID, motionGroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculateInverseKinematicResp(rsp)
}

func (c *ClientWithResponses) CalculateInverseKinematicWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateInverseKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculateInverseKinematicResp, error) {
	rsp, err := c.CalculateInverseKinematic(ctx, cellID, motionGroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculateInverseKinematicResp(rsp)
}

// CalculateForwardKinematicWithBodyWithResponse request with arbitrary body returning *CalculateForwardKinematicResp
func (c *ClientWithResponses) CalculateForwardKinematicWithBodyWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CalculateForwardKinematicResp, error) {
	rsp, err := c.CalculateForwardKinematicWithBody(ctx, cellID, motionGroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculateForwardKinematicResp(rsp)
}

func (c *ClientWithResponses) CalculateForwardKinematicWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, body CalculateForwardKinematicJSONRequestBody, reqEditors ...RequestEditorFn) (*CalculateForwardKinematicResp, error) {
	rsp, err := c.CalculateForwardKinematic(ctx, cellID, motionGroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCalculateForwardKinematicResp(rsp)
}

// GetMountingWithResponse request returning *GetMountingResp
func (c *ClientWithResponses) GetMountingWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetMountingResp, error) {
	rsp, err := c.GetMounting(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMountingResp(rsp)
}

// GetOptimizerConfigurationWithResponse request returning *GetOptimizerConfigurationResp
func (c *ClientWithResponses) GetOptimizerConfigurationWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetOptimizerConfigurationParams, reqEditors ...RequestEditorFn) (*GetOptimizerConfigurationResp, error) {
	rsp, err := c.GetOptimizerConfiguration(ctx, cellID, motionGroup, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOptimizerConfigurationResp(rsp)
}

// ListPayloadsWithResponse request returning *ListPayloadsResp
func (c *ClientWithResponses) ListPayloadsWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*ListPayloadsResp, error) {
	rsp, err := c.ListPayloads(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPayloadsResp(rsp)
}

// GetActivePayloadWithResponse request returning *GetActivePayloadResp
func (c *ClientWithResponses) GetActivePayloadWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetActivePayloadResp, error) {
	rsp, err := c.GetActivePayload(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivePayloadResp(rsp)
}

// GetSafetySetupWithResponse request returning *GetSafetySetupResp
func (c *ClientWithResponses) GetSafetySetupWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetSafetySetupResp, error) {
	rsp, err := c.GetSafetySetup(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSafetySetupResp(rsp)
}

// GetMotionGroupSpecificationWithResponse request returning *GetMotionGroupSpecificationResp
func (c *ClientWithResponses) GetMotionGroupSpecificationWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*GetMotionGroupSpecificationResp, error) {
	rsp, err := c.GetMotionGroupSpecification(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionGroupSpecificationResp(rsp)
}

// GetCurrentMotionGroupStateWithResponse request returning *GetCurrentMotionGroupStateResp
func (c *ClientWithResponses) GetCurrentMotionGroupStateWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetCurrentMotionGroupStateParams, reqEditors ...RequestEditorFn) (*GetCurrentMotionGroupStateResp, error) {
	rsp, err := c.GetCurrentMotionGroupState(ctx, cellID, motionGroup, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentMotionGroupStateResp(rsp)
}

// StreamMotionGroupStateWithResponse request returning *StreamMotionGroupStateResp
func (c *ClientWithResponses) StreamMotionGroupStateWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *StreamMotionGroupStateParams, reqEditors ...RequestEditorFn) (*StreamMotionGroupStateResp, error) {
	rsp, err := c.StreamMotionGroupState(ctx, cellID, motionGroup, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMotionGroupStateResp(rsp)
}

// StopJoggingWithResponse request returning *StopJoggingResp
func (c *ClientWithResponses) StopJoggingWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, reqEditors ...RequestEditorFn) (*StopJoggingResp, error) {
	rsp, err := c.StopJogging(ctx, cellID, motionGroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopJoggingResp(rsp)
}

// ListTcpsWithResponse request returning *ListTcpsResp
func (c *ClientWithResponses) ListTcpsWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *ListTcpsParams, reqEditors ...RequestEditorFn) (*ListTcpsResp, error) {
	rsp, err := c.ListTcps(ctx, cellID, motionGroup, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTcpsResp(rsp)
}

// GetActiveTcpWithResponse request returning *GetActiveTcpResp
func (c *ClientWithResponses) GetActiveTcpWithResponse(ctx context.Context, cellID CellID, motionGroup MotionGroup, params *GetActiveTcpParams, reqEditors ...RequestEditorFn) (*GetActiveTcpResp, error) {
	rsp, err := c.GetActiveTcp(ctx, cellID, motionGroup, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActiveTcpResp(rsp)
}

// GetPlanningMotionGroupModelsWithResponse request returning *GetPlanningMotionGroupModelsResp
func (c *ClientWithResponses) GetPlanningMotionGroupModelsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetPlanningMotionGroupModelsResp, error) {
	rsp, err := c.GetPlanningMotionGroupModels(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlanningMotionGroupModelsResp(rsp)
}

// PlanCollisionFreePTPWithBodyWithResponse request with arbitrary body returning *PlanCollisionFreePTPResp
func (c *ClientWithResponses) PlanCollisionFreePTPWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanCollisionFreePTPResp, error) {
	rsp, err := c.PlanCollisionFreePTPWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanCollisionFreePTPResp(rsp)
}

func (c *ClientWithResponses) PlanCollisionFreePTPWithResponse(ctx context.Context, cellID CellID, body PlanCollisionFreePTPJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanCollisionFreePTPResp, error) {
	rsp, err := c.PlanCollisionFreePTP(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanCollisionFreePTPResp(rsp)
}

// PlanTrajectoryWithBodyWithResponse request with arbitrary body returning *PlanTrajectoryResp
func (c *ClientWithResponses) PlanTrajectoryWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanTrajectoryResp, error) {
	rsp, err := c.PlanTrajectoryWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanTrajectoryResp(rsp)
}

func (c *ClientWithResponses) PlanTrajectoryWithResponse(ctx context.Context, cellID CellID, body PlanTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanTrajectoryResp, error) {
	rsp, err := c.PlanTrajectory(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanTrajectoryResp(rsp)
}

// DeleteAllMotionsWithResponse request returning *DeleteAllMotionsResp
func (c *ClientWithResponses) DeleteAllMotionsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*DeleteAllMotionsResp, error) {
	rsp, err := c.DeleteAllMotions(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAllMotionsResp(rsp)
}

// ListMotionsWithResponse request returning *ListMotionsResp
func (c *ClientWithResponses) ListMotionsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListMotionsResp, error) {
	rsp, err := c.ListMotions(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMotionsResp(rsp)
}

// PlanMotionWithBodyWithResponse request with arbitrary body returning *PlanMotionResp
func (c *ClientWithResponses) PlanMotionWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlanMotionResp, error) {
	rsp, err := c.PlanMotionWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanMotionResp(rsp)
}

func (c *ClientWithResponses) PlanMotionWithResponse(ctx context.Context, cellID CellID, body PlanMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*PlanMotionResp, error) {
	rsp, err := c.PlanMotion(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlanMotionResp(rsp)
}

// ExecuteTrajectoryWithBodyWithResponse request with arbitrary body returning *ExecuteTrajectoryResp
func (c *ClientWithResponses) ExecuteTrajectoryWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteTrajectoryResp, error) {
	rsp, err := c.ExecuteTrajectoryWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteTrajectoryResp(rsp)
}

func (c *ClientWithResponses) ExecuteTrajectoryWithResponse(ctx context.Context, cellID CellID, body ExecuteTrajectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteTrajectoryResp, error) {
	rsp, err := c.ExecuteTrajectory(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteTrajectoryResp(rsp)
}

// StreamMoveWithBodyWithResponse request with arbitrary body returning *StreamMoveResp
func (c *ClientWithResponses) StreamMoveWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StreamMoveResp, error) {
	rsp, err := c.StreamMoveWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMoveResp(rsp)
}

func (c *ClientWithResponses) StreamMoveWithResponse(ctx context.Context, cellID CellID, body StreamMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*StreamMoveResp, error) {
	rsp, err := c.StreamMove(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMoveResp(rsp)
}

// DeleteMotionWithResponse request returning *DeleteMotionResp
func (c *ClientWithResponses) DeleteMotionWithResponse(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*DeleteMotionResp, error) {
	rsp, err := c.DeleteMotion(ctx, cellID, motion, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMotionResp(rsp)
}

// StreamMoveBackwardWithResponse request returning *StreamMoveBackwardResp
func (c *ClientWithResponses) StreamMoveBackwardWithResponse(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveBackwardParams, reqEditors ...RequestEditorFn) (*StreamMoveBackwardResp, error) {
	rsp, err := c.StreamMoveBackward(ctx, cellID, motion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMoveBackwardResp(rsp)
}

// StreamMoveForwardWithResponse request returning *StreamMoveForwardResp
func (c *ClientWithResponses) StreamMoveForwardWithResponse(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveForwardParams, reqEditors ...RequestEditorFn) (*StreamMoveForwardResp, error) {
	rsp, err := c.StreamMoveForward(ctx, cellID, motion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMoveForwardResp(rsp)
}

// StreamMoveToTrajectoryViaJointPTPWithResponse request returning *StreamMoveToTrajectoryViaJointPTPResp
func (c *ClientWithResponses) StreamMoveToTrajectoryViaJointPTPWithResponse(ctx context.Context, cellID CellID, motion Motion, params *StreamMoveToTrajectoryViaJointPTPParams, reqEditors ...RequestEditorFn) (*StreamMoveToTrajectoryViaJointPTPResp, error) {
	rsp, err := c.StreamMoveToTrajectoryViaJointPTP(ctx, cellID, motion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamMoveToTrajectoryViaJointPTPResp(rsp)
}

// GetPlannedMotionWithResponse request returning *GetPlannedMotionResp
func (c *ClientWithResponses) GetPlannedMotionWithResponse(ctx context.Context, cellID CellID, motion Motion, params *GetPlannedMotionParams, reqEditors ...RequestEditorFn) (*GetPlannedMotionResp, error) {
	rsp, err := c.GetPlannedMotion(ctx, cellID, motion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlannedMotionResp(rsp)
}

// StopExecutionWithResponse request returning *StopExecutionResp
func (c *ClientWithResponses) StopExecutionWithResponse(ctx context.Context, cellID CellID, motion Motion, reqEditors ...RequestEditorFn) (*StopExecutionResp, error) {
	rsp, err := c.StopExecution(ctx, cellID, motion, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopExecutionResp(rsp)
}

// GetMotionTrajectoryWithResponse request returning *GetMotionTrajectoryResp
func (c *ClientWithResponses) GetMotionTrajectoryWithResponse(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectoryParams, reqEditors ...RequestEditorFn) (*GetMotionTrajectoryResp, error) {
	rsp, err := c.GetMotionTrajectory(ctx, cellID, motion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionTrajectoryResp(rsp)
}

// GetMotionTrajectorySampleWithResponse request returning *GetMotionTrajectorySampleResp
func (c *ClientWithResponses) GetMotionTrajectorySampleWithResponse(ctx context.Context, cellID CellID, motion Motion, params *GetMotionTrajectorySampleParams, reqEditors ...RequestEditorFn) (*GetMotionTrajectorySampleResp, error) {
	rsp, err := c.GetMotionTrajectorySample(ctx, cellID, motion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMotionTrajectorySampleResp(rsp)
}

// GetAllProgramRunsWithResponse request returning *GetAllProgramRunsResp
func (c *ClientWithResponses) GetAllProgramRunsWithResponse(ctx context.Context, cellID CellID, params *GetAllProgramRunsParams, reqEditors ...RequestEditorFn) (*GetAllProgramRunsResp, error) {
	rsp, err := c.GetAllProgramRuns(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllProgramRunsResp(rsp)
}

// CreateProgramRunWithBodyWithResponse request with arbitrary body returning *CreateProgramRunResp
func (c *ClientWithResponses) CreateProgramRunWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramRunResp, error) {
	rsp, err := c.CreateProgramRunWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramRunResp(rsp)
}

func (c *ClientWithResponses) CreateProgramRunWithResponse(ctx context.Context, cellID CellID, body CreateProgramRunJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramRunResp, error) {
	rsp, err := c.CreateProgramRun(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramRunResp(rsp)
}

// GetProgramRunWithResponse request returning *GetProgramRunResp
func (c *ClientWithResponses) GetProgramRunWithResponse(ctx context.Context, cellID CellID, run string, reqEditors ...RequestEditorFn) (*GetProgramRunResp, error) {
	rsp, err := c.GetProgramRun(ctx, cellID, run, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramRunResp(rsp)
}

// GetAllTriggersWithResponse request returning *GetAllTriggersResp
func (c *ClientWithResponses) GetAllTriggersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetAllTriggersResp, error) {
	rsp, err := c.GetAllTriggers(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTriggersResp(rsp)
}

// CreateTriggerWithBodyWithResponse request with arbitrary body returning *CreateTriggerResp
func (c *ClientWithResponses) CreateTriggerWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTriggerResp, error) {
	rsp, err := c.CreateTriggerWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTriggerResp(rsp)
}

func (c *ClientWithResponses) CreateTriggerWithResponse(ctx context.Context, cellID CellID, body CreateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTriggerResp, error) {
	rsp, err := c.CreateTrigger(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTriggerResp(rsp)
}

// DeleteTriggerWithResponse request returning *DeleteTriggerResp
func (c *ClientWithResponses) DeleteTriggerWithResponse(ctx context.Context, cellID CellID, trigger string, reqEditors ...RequestEditorFn) (*DeleteTriggerResp, error) {
	rsp, err := c.DeleteTrigger(ctx, cellID, trigger, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTriggerResp(rsp)
}

// GetTriggerWithResponse request returning *GetTriggerResp
func (c *ClientWithResponses) GetTriggerWithResponse(ctx context.Context, cellID CellID, trigger string, reqEditors ...RequestEditorFn) (*GetTriggerResp, error) {
	rsp, err := c.GetTrigger(ctx, cellID, trigger, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTriggerResp(rsp)
}

// UpdateTriggerWithBodyWithResponse request with arbitrary body returning *UpdateTriggerResp
func (c *ClientWithResponses) UpdateTriggerWithBodyWithResponse(ctx context.Context, cellID CellID, trigger string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTriggerResp, error) {
	rsp, err := c.UpdateTriggerWithBody(ctx, cellID, trigger, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTriggerResp(rsp)
}

func (c *ClientWithResponses) UpdateTriggerWithResponse(ctx context.Context, cellID CellID, trigger string, body UpdateTriggerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTriggerResp, error) {
	rsp, err := c.UpdateTrigger(ctx, cellID, trigger, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTriggerResp(rsp)
}

// LoadPlannedMotionWithBodyWithResponse request with arbitrary body returning *LoadPlannedMotionResp
func (c *ClientWithResponses) LoadPlannedMotionWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoadPlannedMotionResp, error) {
	rsp, err := c.LoadPlannedMotionWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadPlannedMotionResp(rsp)
}

func (c *ClientWithResponses) LoadPlannedMotionWithResponse(ctx context.Context, cellID CellID, body LoadPlannedMotionJSONRequestBody, reqEditors ...RequestEditorFn) (*LoadPlannedMotionResp, error) {
	rsp, err := c.LoadPlannedMotion(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadPlannedMotionResp(rsp)
}

// ClearProgramsValuesWithResponse request returning *ClearProgramsValuesResp
func (c *ClientWithResponses) ClearProgramsValuesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearProgramsValuesResp, error) {
	rsp, err := c.ClearProgramsValues(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearProgramsValuesResp(rsp)
}

// CreateProgramsValueWithBodyWithResponse request with arbitrary body returning *CreateProgramsValueResp
func (c *ClientWithResponses) CreateProgramsValueWithBodyWithResponse(ctx context.Context, cellID CellID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramsValueResp, error) {
	rsp, err := c.CreateProgramsValueWithBody(ctx, cellID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramsValueResp(rsp)
}

func (c *ClientWithResponses) CreateProgramsValueWithResponse(ctx context.Context, cellID CellID, body CreateProgramsValueJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramsValueResp, error) {
	rsp, err := c.CreateProgramsValue(ctx, cellID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramsValueResp(rsp)
}

// DeleteProgramValueWithResponse request returning *DeleteProgramValueResp
func (c *ClientWithResponses) DeleteProgramValueWithResponse(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*DeleteProgramValueResp, error) {
	rsp, err := c.DeleteProgramValue(ctx, cellID, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProgramValueResp(rsp)
}

// GetProgramValueWithResponse request returning *GetProgramValueResp
func (c *ClientWithResponses) GetProgramValueWithResponse(ctx context.Context, cellID CellID, key string, reqEditors ...RequestEditorFn) (*GetProgramValueResp, error) {
	rsp, err := c.GetProgramValue(ctx, cellID, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramValueResp(rsp)
}

// UpdateProgramValueWithBodyWithResponse request with arbitrary body returning *UpdateProgramValueResp
func (c *ClientWithResponses) UpdateProgramValueWithBodyWithResponse(ctx context.Context, cellID CellID, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramValueResp, error) {
	rsp, err := c.UpdateProgramValueWithBody(ctx, cellID, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramValueResp(rsp)
}

func (c *ClientWithResponses) UpdateProgramValueWithResponse(ctx context.Context, cellID CellID, key string, body UpdateProgramValueJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramValueResp, error) {
	rsp, err := c.UpdateProgramValue(ctx, cellID, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramValueResp(rsp)
}

// GetCellStatusWithResponse request returning *GetCellStatusResp
func (c *ClientWithResponses) GetCellStatusWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*GetCellStatusResp, error) {
	rsp, err := c.GetCellStatus(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCellStatusResp(rsp)
}

// ListStoredCollidersWithResponse request returning *ListStoredCollidersResp
func (c *ClientWithResponses) ListStoredCollidersWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollidersResp, error) {
	rsp, err := c.ListStoredColliders(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStoredCollidersResp(rsp)
}

// DeleteStoredColliderWithResponse request returning *DeleteStoredColliderResp
func (c *ClientWithResponses) DeleteStoredColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*DeleteStoredColliderResp, error) {
	rsp, err := c.DeleteStoredCollider(ctx, cellID, colliderID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoredColliderResp(rsp)
}

// GetStoredColliderWithResponse request returning *GetStoredColliderResp
func (c *ClientWithResponses) GetStoredColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, reqEditors ...RequestEditorFn) (*GetStoredColliderResp, error) {
	rsp, err := c.GetStoredCollider(ctx, cellID, colliderID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoredColliderResp(rsp)
}

// StoreColliderWithBodyWithResponse request with arbitrary body returning *StoreColliderResp
func (c *ClientWithResponses) StoreColliderWithBodyWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreColliderResp, error) {
	rsp, err := c.StoreColliderWithBody(ctx, cellID, colliderID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreColliderResp(rsp)
}

func (c *ClientWithResponses) StoreColliderWithResponse(ctx context.Context, cellID CellID, colliderID ColliderID, body StoreColliderJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreColliderResp, error) {
	rsp, err := c.StoreCollider(ctx, cellID, colliderID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreColliderResp(rsp)
}

// GetDefaultLinkChainWithResponse request returning *GetDefaultLinkChainResp
func (c *ClientWithResponses) GetDefaultLinkChainWithResponse(ctx context.Context, cellID CellID, motionGroupModel GetDefaultLinkChainParamsMotionGroupModel, reqEditors ...RequestEditorFn) (*GetDefaultLinkChainResp, error) {
	rsp, err := c.GetDefaultLinkChain(ctx, cellID, motionGroupModel, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultLinkChainResp(rsp)
}

// ListCollisionLinkChainsWithResponse request returning *ListCollisionLinkChainsResp
func (c *ClientWithResponses) ListCollisionLinkChainsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListCollisionLinkChainsResp, error) {
	rsp, err := c.ListCollisionLinkChains(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCollisionLinkChainsResp(rsp)
}

// DeleteStoredCollisionLinkChainWithResponse request returning *DeleteStoredCollisionLinkChainResp
func (c *ClientWithResponses) DeleteStoredCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionLinkChainResp, error) {
	rsp, err := c.DeleteStoredCollisionLinkChain(ctx, cellID, linkChainID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoredCollisionLinkChainResp(rsp)
}

// GetStoredCollisionLinkChainWithResponse request returning *GetStoredCollisionLinkChainResp
func (c *ClientWithResponses) GetStoredCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, reqEditors ...RequestEditorFn) (*GetStoredCollisionLinkChainResp, error) {
	rsp, err := c.GetStoredCollisionLinkChain(ctx, cellID, linkChainID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoredCollisionLinkChainResp(rsp)
}

// StoreCollisionLinkChainWithBodyWithResponse request with arbitrary body returning *StoreCollisionLinkChainResp
func (c *ClientWithResponses) StoreCollisionLinkChainWithBodyWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionLinkChainResp, error) {
	rsp, err := c.StoreCollisionLinkChainWithBody(ctx, cellID, linkChainID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionLinkChainResp(rsp)
}

func (c *ClientWithResponses) StoreCollisionLinkChainWithResponse(ctx context.Context, cellID CellID, linkChainID LinkChainID, body StoreCollisionLinkChainJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionLinkChainResp, error) {
	rsp, err := c.StoreCollisionLinkChain(ctx, cellID, linkChainID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionLinkChainResp(rsp)
}

// ListStoredCollisionScenesWithResponse request returning *ListStoredCollisionScenesResp
func (c *ClientWithResponses) ListStoredCollisionScenesWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollisionScenesResp, error) {
	rsp, err := c.ListStoredCollisionScenes(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStoredCollisionScenesResp(rsp)
}

// DeleteStoredCollisionSceneWithResponse request returning *DeleteStoredCollisionSceneResp
func (c *ClientWithResponses) DeleteStoredCollisionSceneWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionSceneResp, error) {
	rsp, err := c.DeleteStoredCollisionScene(ctx, cellID, sceneID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoredCollisionSceneResp(rsp)
}

// GetStoredCollisionSceneWithResponse request returning *GetStoredCollisionSceneResp
func (c *ClientWithResponses) GetStoredCollisionSceneWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, reqEditors ...RequestEditorFn) (*GetStoredCollisionSceneResp, error) {
	rsp, err := c.GetStoredCollisionScene(ctx, cellID, sceneID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoredCollisionSceneResp(rsp)
}

// StoreCollisionSceneWithBodyWithResponse request with arbitrary body returning *StoreCollisionSceneResp
func (c *ClientWithResponses) StoreCollisionSceneWithBodyWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionSceneResp, error) {
	rsp, err := c.StoreCollisionSceneWithBody(ctx, cellID, sceneID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionSceneResp(rsp)
}

func (c *ClientWithResponses) StoreCollisionSceneWithResponse(ctx context.Context, cellID CellID, sceneID SceneID, body StoreCollisionSceneJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionSceneResp, error) {
	rsp, err := c.StoreCollisionScene(ctx, cellID, sceneID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionSceneResp(rsp)
}

// ListStoredCollisionToolsWithResponse request returning *ListStoredCollisionToolsResp
func (c *ClientWithResponses) ListStoredCollisionToolsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListStoredCollisionToolsResp, error) {
	rsp, err := c.ListStoredCollisionTools(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStoredCollisionToolsResp(rsp)
}

// DeleteStoredCollisionToolWithResponse request returning *DeleteStoredCollisionToolResp
func (c *ClientWithResponses) DeleteStoredCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*DeleteStoredCollisionToolResp, error) {
	rsp, err := c.DeleteStoredCollisionTool(ctx, cellID, toolID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoredCollisionToolResp(rsp)
}

// GetStoredCollisionToolWithResponse request returning *GetStoredCollisionToolResp
func (c *ClientWithResponses) GetStoredCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, reqEditors ...RequestEditorFn) (*GetStoredCollisionToolResp, error) {
	rsp, err := c.GetStoredCollisionTool(ctx, cellID, toolID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoredCollisionToolResp(rsp)
}

// StoreCollisionToolWithBodyWithResponse request with arbitrary body returning *StoreCollisionToolResp
func (c *ClientWithResponses) StoreCollisionToolWithBodyWithResponse(ctx context.Context, cellID CellID, toolID ToolID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreCollisionToolResp, error) {
	rsp, err := c.StoreCollisionToolWithBody(ctx, cellID, toolID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionToolResp(rsp)
}

func (c *ClientWithResponses) StoreCollisionToolWithResponse(ctx context.Context, cellID CellID, toolID ToolID, body StoreCollisionToolJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreCollisionToolResp, error) {
	rsp, err := c.StoreCollisionTool(ctx, cellID, toolID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreCollisionToolResp(rsp)
}

// ClearAllObjectsWithResponse request returning *ClearAllObjectsResp
func (c *ClientWithResponses) ClearAllObjectsWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ClearAllObjectsResp, error) {
	rsp, err := c.ClearAllObjects(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearAllObjectsResp(rsp)
}

// ListAllObjectKeysWithResponse request returning *ListAllObjectKeysResp
func (c *ClientWithResponses) ListAllObjectKeysWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListAllObjectKeysResp, error) {
	rsp, err := c.ListAllObjectKeys(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllObjectKeysResp(rsp)
}

// DeleteObjectWithResponse request returning *DeleteObjectResp
func (c *ClientWithResponses) DeleteObjectWithResponse(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*DeleteObjectResp, error) {
	rsp, err := c.DeleteObject(ctx, cellID, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectResp(rsp)
}

// GetObjectWithResponse request returning *GetObjectResp
func (c *ClientWithResponses) GetObjectWithResponse(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*GetObjectResp, error) {
	rsp, err := c.GetObject(ctx, cellID, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectResp(rsp)
}

// GetObjectMetadataWithResponse request returning *GetObjectMetadataResp
func (c *ClientWithResponses) GetObjectMetadataWithResponse(ctx context.Context, cellID CellID, key Key, reqEditors ...RequestEditorFn) (*GetObjectMetadataResp, error) {
	rsp, err := c.GetObjectMetadata(ctx, cellID, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectMetadataResp(rsp)
}

// StoreObjectWithBodyWithResponse request with arbitrary body returning *StoreObjectResp
func (c *ClientWithResponses) StoreObjectWithBodyWithResponse(ctx context.Context, cellID CellID, key Key, params *StoreObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreObjectResp, error) {
	rsp, err := c.StoreObjectWithBody(ctx, cellID, key, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreObjectResp(rsp)
}

// DeleteProgramListWithResponse request returning *DeleteProgramListResp
func (c *ClientWithResponses) DeleteProgramListWithResponse(ctx context.Context, cellID CellID, params *DeleteProgramListParams, reqEditors ...RequestEditorFn) (*DeleteProgramListResp, error) {
	rsp, err := c.DeleteProgramList(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProgramListResp(rsp)
}

// ListProgramMetadataWithResponse request returning *ListProgramMetadataResp
func (c *ClientWithResponses) ListProgramMetadataWithResponse(ctx context.Context, cellID CellID, params *ListProgramMetadataParams, reqEditors ...RequestEditorFn) (*ListProgramMetadataResp, error) {
	rsp, err := c.ListProgramMetadata(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProgramMetadataResp(rsp)
}

// CreateProgramWithBodyWithResponse request with arbitrary body returning *CreateProgramResp
func (c *ClientWithResponses) CreateProgramWithBodyWithResponse(ctx context.Context, cellID CellID, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramResp, error) {
	rsp, err := c.CreateProgramWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramResp(rsp)
}

func (c *ClientWithResponses) CreateProgramWithTextBodyWithResponse(ctx context.Context, cellID CellID, params *CreateProgramParams, body CreateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramResp, error) {
	rsp, err := c.CreateProgramWithTextBody(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramResp(rsp)
}

// DeleteProgramWithResponse request returning *DeleteProgramResp
func (c *ClientWithResponses) DeleteProgramWithResponse(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*DeleteProgramResp, error) {
	rsp, err := c.DeleteProgram(ctx, cellID, program, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProgramResp(rsp)
}

// GetProgramWithResponse request returning *GetProgramResp
func (c *ClientWithResponses) GetProgramWithResponse(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*GetProgramResp, error) {
	rsp, err := c.GetProgram(ctx, cellID, program, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramResp(rsp)
}

// UpdateProgramWithBodyWithResponse request with arbitrary body returning *UpdateProgramResp
func (c *ClientWithResponses) UpdateProgramWithBodyWithResponse(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramResp, error) {
	rsp, err := c.UpdateProgramWithBody(ctx, cellID, program, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramResp(rsp)
}

func (c *ClientWithResponses) UpdateProgramWithTextBodyWithResponse(ctx context.Context, cellID CellID, program Program, body UpdateProgramTextRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramResp, error) {
	rsp, err := c.UpdateProgramWithTextBody(ctx, cellID, program, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramResp(rsp)
}

// GetProgramMetadataWithResponse request returning *GetProgramMetadataResp
func (c *ClientWithResponses) GetProgramMetadataWithResponse(ctx context.Context, cellID CellID, program Program, reqEditors ...RequestEditorFn) (*GetProgramMetadataResp, error) {
	rsp, err := c.GetProgramMetadata(ctx, cellID, program, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramMetadataResp(rsp)
}

// UpdateProgramMetadataWithBodyWithResponse request with arbitrary body returning *UpdateProgramMetadataResp
func (c *ClientWithResponses) UpdateProgramMetadataWithBodyWithResponse(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProgramMetadataResp, error) {
	rsp, err := c.UpdateProgramMetadataWithBody(ctx, cellID, program, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramMetadataResp(rsp)
}

func (c *ClientWithResponses) UpdateProgramMetadataWithResponse(ctx context.Context, cellID CellID, program Program, body UpdateProgramMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProgramMetadataResp, error) {
	rsp, err := c.UpdateProgramMetadata(ctx, cellID, program, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProgramMetadataResp(rsp)
}

// UploadProgramMetadataImageWithBodyWithResponse request with arbitrary body returning *UploadProgramMetadataImageResp
func (c *ClientWithResponses) UploadProgramMetadataImageWithBodyWithResponse(ctx context.Context, cellID CellID, program Program, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadProgramMetadataImageResp, error) {
	rsp, err := c.UploadProgramMetadataImageWithBody(ctx, cellID, program, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadProgramMetadataImageResp(rsp)
}

// DeleteRecipeListWithResponse request returning *DeleteRecipeListResp
func (c *ClientWithResponses) DeleteRecipeListWithResponse(ctx context.Context, cellID CellID, params *DeleteRecipeListParams, reqEditors ...RequestEditorFn) (*DeleteRecipeListResp, error) {
	rsp, err := c.DeleteRecipeList(ctx, cellID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecipeListResp(rsp)
}

// ListRecipeMetadataWithResponse request returning *ListRecipeMetadataResp
func (c *ClientWithResponses) ListRecipeMetadataWithResponse(ctx context.Context, cellID CellID, reqEditors ...RequestEditorFn) (*ListRecipeMetadataResp, error) {
	rsp, err := c.ListRecipeMetadata(ctx, cellID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRecipeMetadataResp(rsp)
}

// CreateRecipeWithBodyWithResponse request with arbitrary body returning *CreateRecipeResp
func (c *ClientWithResponses) CreateRecipeWithBodyWithResponse(ctx context.Context, cellID CellID, params *CreateRecipeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRecipeResp, error) {
	rsp, err := c.CreateRecipeWithBody(ctx, cellID, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRecipeResp(rsp)
}

func (c *ClientWithResponses) CreateRecipeWithResponse(ctx context.Context, cellID CellID, params *CreateRecipeParams, body CreateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRecipeResp, error) {
	rsp, err := c.CreateRecipe(ctx, cellID, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRecipeResp(rsp)
}

// DeleteRecipeWithResponse request returning *DeleteRecipeResp
func (c *ClientWithResponses) DeleteRecipeWithResponse(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*DeleteRecipeResp, error) {
	rsp, err := c.DeleteRecipe(ctx, cellID, recipe, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecipeResp(rsp)
}

// GetRecipeWithResponse request returning *GetRecipeResp
func (c *ClientWithResponses) GetRecipeWithResponse(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*GetRecipeResp, error) {
	rsp, err := c.GetRecipe(ctx, cellID, recipe, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecipeResp(rsp)
}

// UpdateRecipeWithBodyWithResponse request with arbitrary body returning *UpdateRecipeResp
func (c *ClientWithResponses) UpdateRecipeWithBodyWithResponse(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecipeResp, error) {
	rsp, err := c.UpdateRecipeWithBody(ctx, cellID, recipe, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecipeResp(rsp)
}

func (c *ClientWithResponses) UpdateRecipeWithResponse(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecipeResp, error) {
	rsp, err := c.UpdateRecipe(ctx, cellID, recipe, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecipeResp(rsp)
}

// GetRecipeMetadataWithResponse request returning *GetRecipeMetadataResp
func (c *ClientWithResponses) GetRecipeMetadataWithResponse(ctx context.Context, cellID CellID, recipe Recipe, reqEditors ...RequestEditorFn) (*GetRecipeMetadataResp, error) {
	rsp, err := c.GetRecipeMetadata(ctx, cellID, recipe, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecipeMetadataResp(rsp)
}

// UpdateRecipeMetadataWithBodyWithResponse request with arbitrary body returning *UpdateRecipeMetadataResp
func (c *ClientWithResponses) UpdateRecipeMetadataWithBodyWithResponse(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecipeMetadataResp, error) {
	rsp, err := c.UpdateRecipeMetadataWithBody(ctx, cellID, recipe, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecipeMetadataResp(rsp)
}

func (c *ClientWithResponses) UpdateRecipeMetadataWithResponse(ctx context.Context, cellID CellID, recipe Recipe, body UpdateRecipeMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecipeMetadataResp, error) {
	rsp, err := c.UpdateRecipeMetadata(ctx, cellID, recipe, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecipeMetadataResp(rsp)
}

// UploadRecipeMetadataImageWithBodyWithResponse request with arbitrary body returning *UploadRecipeMetadataImageResp
func (c *ClientWithResponses) UploadRecipeMetadataImageWithBodyWithResponse(ctx context.Context, cellID CellID, recipe Recipe, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadRecipeMetadataImageResp, error) {
	rsp, err := c.UploadRecipeMetadataImageWithBody(ctx, cellID, recipe, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadRecipeMetadataImageResp(rsp)
}

// DeactivateLicenseWithResponse request returning *DeactivateLicenseResp
func (c *ClientWithResponses) DeactivateLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeactivateLicenseResp, error) {
	rsp, err := c.DeactivateLicense(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeactivateLicenseResp(rsp)
}

// GetLicenseWithResponse request returning *GetLicenseResp
func (c *ClientWithResponses) GetLicenseWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseResp, error) {
	rsp, err := c.GetLicense(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseResp(rsp)
}

// ActivateLicenseWithBodyWithResponse request with arbitrary body returning *ActivateLicenseResp
func (c *ClientWithResponses) ActivateLicenseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivateLicenseResp, error) {
	rsp, err := c.ActivateLicenseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateLicenseResp(rsp)
}

func (c *ClientWithResponses) ActivateLicenseWithResponse(ctx context.Context, body ActivateLicenseJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivateLicenseResp, error) {
	rsp, err := c.ActivateLicense(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateLicenseResp(rsp)
}

// GetLicenseStatusWithResponse request returning *GetLicenseStatusResp
func (c *ClientWithResponses) GetLicenseStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLicenseStatusResp, error) {
	rsp, err := c.GetLicenseStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLicenseStatusResp(rsp)
}

// GetDiagnosePackageWithResponse request returning *GetDiagnosePackageResp
func (c *ClientWithResponses) GetDiagnosePackageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDiagnosePackageResp, error) {
	rsp, err := c.GetDiagnosePackage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDiagnosePackageResp(rsp)
}

// GetSystemStatusWithResponse request returning *GetSystemStatusResp
func (c *ClientWithResponses) GetSystemStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemStatusResp, error) {
	rsp, err := c.GetSystemStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemStatusResp(rsp)
}

// CheckNovaVersionUpdateWithResponse request returning *CheckNovaVersionUpdateResp
func (c *ClientWithResponses) CheckNovaVersionUpdateWithResponse(ctx context.Context, params *CheckNovaVersionUpdateParams, reqEditors ...RequestEditorFn) (*CheckNovaVersionUpdateResp, error) {
	rsp, err := c.CheckNovaVersionUpdate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckNovaVersionUpdateResp(rsp)
}

// UpdateNovaVersionWithBodyWithResponse request with arbitrary body returning *UpdateNovaVersionResp
func (c *ClientWithResponses) UpdateNovaVersionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNovaVersionResp, error) {
	rsp, err := c.UpdateNovaVersionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNovaVersionResp(rsp)
}

func (c *ClientWithResponses) UpdateNovaVersionWithResponse(ctx context.Context, body UpdateNovaVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNovaVersionResp, error) {
	rsp, err := c.UpdateNovaVersion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNovaVersionResp(rsp)
}

// GetSystemVersionWithResponse request returning *GetSystemVersionResp
func (c *ClientWithResponses) GetSystemVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSystemVersionResp, error) {
	rsp, err := c.GetSystemVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSystemVersionResp(rsp)
}

// ParseListCellsResp parses an HTTP response from a ListCellsWithResponse call
func ParseListCellsResp(rsp *http.Response) (*ListCellsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCellsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeployCellResp parses an HTTP response from a DeployCellWithResponse call
func ParseDeployCellResp(rsp *http.Response) (*DeployCellResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeployCellResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteCellResp parses an HTTP response from a DeleteCellWithResponse call
func ParseDeleteCellResp(rsp *http.Response) (*DeleteCellResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCellResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCellResp parses an HTTP response from a GetCellWithResponse call
func ParseGetCellResp(rsp *http.Response) (*GetCellResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCellResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cell
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateCellResp parses an HTTP response from a UpdateCellWithResponse call
func ParseUpdateCellResp(rsp *http.Response) (*UpdateCellResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCellResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseClearAppsResp parses an HTTP response from a ClearAppsWithResponse call
func ParseClearAppsResp(rsp *http.Response) (*ClearAppsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearAppsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListAppsResp parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResp(rsp *http.Response) (*ListAppsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NameList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddAppResp parses an HTTP response from a AddAppWithResponse call
func ParseAddAppResp(rsp *http.Response) (*AddAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteAppResp parses an HTTP response from a DeleteAppWithResponse call
func ParseDeleteAppResp(rsp *http.Response) (*DeleteAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAppResp parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResp(rsp *http.Response) (*GetAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAppResp parses an HTTP response from a UpdateAppWithResponse call
func ParseUpdateAppResp(rsp *http.Response) (*UpdateAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseClearRobotControllersResp parses an HTTP response from a ClearRobotControllersWithResponse call
func ParseClearRobotControllersResp(rsp *http.Response) (*ClearRobotControllersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearRobotControllersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListControllersResp parses an HTTP response from a ListControllersWithResponse call
func ParseListControllersResp(rsp *http.Response) (*ListControllersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListControllersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ControllerInstanceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddRobotControllerResp parses an HTTP response from a AddRobotControllerWithResponse call
func ParseAddRobotControllerResp(rsp *http.Response) (*AddRobotControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRobotControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteRobotControllerResp parses an HTTP response from a DeleteRobotControllerWithResponse call
func ParseDeleteRobotControllerResp(rsp *http.Response) (*DeleteRobotControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRobotControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetRobotControllerResp parses an HTTP response from a GetRobotControllerWithResponse call
func ParseGetRobotControllerResp(rsp *http.Response) (*GetRobotControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRobotControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotController
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateRobotControllerResp parses an HTTP response from a UpdateRobotControllerWithResponse call
func ParseUpdateRobotControllerResp(rsp *http.Response) (*UpdateRobotControllerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRobotControllerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSupportedModesResp parses an HTTP response from a GetSupportedModesWithResponse call
func ParseGetSupportedModesResp(rsp *http.Response) (*GetSupportedModesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSupportedModesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ControllerCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamFreeDriveResp parses an HTTP response from a StreamFreeDriveWithResponse call
func ParseStreamFreeDriveResp(rsp *http.Response) (*StreamFreeDriveResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamFreeDriveResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotControllerState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIODescriptionsResp parses an HTTP response from a ListIODescriptionsWithResponse call
func ParseListIODescriptionsResp(rsp *http.Response) (*ListIODescriptionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIODescriptionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIODescriptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamIOValuesResp parses an HTTP response from a StreamIOValuesWithResponse call
func ParseStreamIOValuesResp(rsp *http.Response) (*StreamIOValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamIOValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIOValuesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIOValuesResp parses an HTTP response from a ListIOValuesWithResponse call
func ParseListIOValuesResp(rsp *http.Response) (*ListIOValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIOValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIOValuesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetOutputValuesResp parses an HTTP response from a SetOutputValuesWithResponse call
func ParseSetOutputValuesResp(rsp *http.Response) (*SetOutputValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOutputValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseWaitForIOEventResp parses an HTTP response from a WaitForIOEventWithResponse call
func ParseWaitForIOEventResp(rsp *http.Response) (*WaitForIOEventResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WaitForIOEventResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetModeResp parses an HTTP response from a GetModeWithResponse call
func ParseGetModeResp(rsp *http.Response) (*GetModeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetModeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetDefaultModeResp parses an HTTP response from a SetDefaultModeWithResponse call
func ParseSetDefaultModeResp(rsp *http.Response) (*SetDefaultModeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetDefaultModeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamModeChangeResp parses an HTTP response from a StreamModeChangeWithResponse call
func ParseStreamModeChangeResp(rsp *http.Response) (*StreamModeChangeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamModeChangeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModeChangeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCurrentRobotControllerStateResp parses an HTTP response from a GetCurrentRobotControllerStateWithResponse call
func ParseGetCurrentRobotControllerStateResp(rsp *http.Response) (*GetCurrentRobotControllerStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentRobotControllerStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotControllerState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamRobotControllerStateResp parses an HTTP response from a StreamRobotControllerStateWithResponse call
func ParseStreamRobotControllerStateResp(rsp *http.Response) (*StreamRobotControllerStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamRobotControllerStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotControllerState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListVirtualRobotCoordinateSystemsResp parses an HTTP response from a ListVirtualRobotCoordinateSystemsWithResponse call
func ParseListVirtualRobotCoordinateSystemsResp(rsp *http.Response) (*ListVirtualRobotCoordinateSystemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVirtualRobotCoordinateSystemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddVirtualRobotCoordinateSystemResp parses an HTTP response from a AddVirtualRobotCoordinateSystemWithResponse call
func ParseAddVirtualRobotCoordinateSystemResp(rsp *http.Response) (*AddVirtualRobotCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddVirtualRobotCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVirtualRobotCoordinateSystemResp parses an HTTP response from a DeleteVirtualRobotCoordinateSystemWithResponse call
func ParseDeleteVirtualRobotCoordinateSystemResp(rsp *http.Response) (*DeleteVirtualRobotCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualRobotCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCycleTimeResp parses an HTTP response from a GetCycleTimeWithResponse call
func ParseGetCycleTimeResp(rsp *http.Response) (*GetCycleTimeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCycleTimeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CycleTime
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEStopResp parses an HTTP response from a GetEStopWithResponse call
func ParseGetEStopResp(rsp *http.Response) (*GetEStopResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEStopResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Flag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePushEStopResp parses an HTTP response from a PushEStopWithResponse call
func ParsePushEStopResp(rsp *http.Response) (*PushEStopResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PushEStopResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReleaseEStopResp parses an HTTP response from a ReleaseEStopWithResponse call
func ParseReleaseEStopResp(rsp *http.Response) (*ReleaseEStopResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReleaseEStopResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIOsResp parses an HTTP response from a ListIOsWithResponse call
func ParseListIOsResp(rsp *http.Response) (*ListIOsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIOsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IOs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualRobotIOValueResp parses an HTTP response from a GetVirtualRobotIOValueWithResponse call
func ParseGetVirtualRobotIOValueResp(rsp *http.Response) (*GetVirtualRobotIOValueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualRobotIOValueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IO
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetVirtualRobotIOValueResp parses an HTTP response from a SetVirtualRobotIOValueWithResponse call
func ParseSetVirtualRobotIOValueResp(rsp *http.Response) (*SetVirtualRobotIOValueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetVirtualRobotIOValueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExternalJointsStreamResp parses an HTTP response from a ExternalJointsStreamWithResponse call
func ParseExternalJointsStreamResp(rsp *http.Response) (*ExternalJointsStreamResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExternalJointsStreamResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupJoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMotionGroupStateResp parses an HTTP response from a GetMotionGroupStateWithResponse call
func ParseGetMotionGroupStateResp(rsp *http.Response) (*GetMotionGroupStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupJoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetMotionGroupStateResp parses an HTTP response from a SetMotionGroupStateWithResponse call
func ParseSetMotionGroupStateResp(rsp *http.Response) (*SetMotionGroupStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMotionGroupStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMotionGroupBehaviorResp parses an HTTP response from a GetMotionGroupBehaviorWithResponse call
func ParseGetMotionGroupBehaviorResp(rsp *http.Response) (*GetMotionGroupBehaviorResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupBehaviorResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupBehaviorGetter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetMotionGroupBehaviorResp parses an HTTP response from a SetMotionGroupBehaviorWithResponse call
func ParseSetMotionGroupBehaviorResp(rsp *http.Response) (*SetMotionGroupBehaviorResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetMotionGroupBehaviorResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualRobotMountingResp parses an HTTP response from a GetVirtualRobotMountingWithResponse call
func ParseGetVirtualRobotMountingResp(rsp *http.Response) (*GetVirtualRobotMountingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualRobotMountingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetVirtualRobotMountingResp parses an HTTP response from a SetVirtualRobotMountingWithResponse call
func ParseSetVirtualRobotMountingResp(rsp *http.Response) (*SetVirtualRobotMountingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetVirtualRobotMountingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListVirtualRobotTcpsResp parses an HTTP response from a ListVirtualRobotTcpsWithResponse call
func ParseListVirtualRobotTcpsResp(rsp *http.Response) (*ListVirtualRobotTcpsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVirtualRobotTcpsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotTcps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddVirtualRobotTcpResp parses an HTTP response from a AddVirtualRobotTcpWithResponse call
func ParseAddVirtualRobotTcpResp(rsp *http.Response) (*AddVirtualRobotTcpResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddVirtualRobotTcpResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVirtualRobotTcpResp parses an HTTP response from a DeleteVirtualRobotTcpWithResponse call
func ParseDeleteVirtualRobotTcpResp(rsp *http.Response) (*DeleteVirtualRobotTcpResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualRobotTcpResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMotionGroupsResp parses an HTTP response from a GetMotionGroupsWithResponse call
func ParseGetMotionGroupsResp(rsp *http.Response) (*GetMotionGroupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupInfos
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOperationModeResp parses an HTTP response from a GetOperationModeWithResponse call
func ParseGetOperationModeResp(rsp *http.Response) (*GetOperationModeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOperationModeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OpMode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetOperationModeResp parses an HTTP response from a SetOperationModeWithResponse call
func ParseSetOperationModeResp(rsp *http.Response) (*SetOperationModeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetOperationModeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Empty
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualRobotConfigurationResp parses an HTTP response from a GetVirtualRobotConfigurationWithResponse call
func ParseGetVirtualRobotConfigurationResp(rsp *http.Response) (*GetVirtualRobotConfigurationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualRobotConfigurationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VirtualRobotConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListCoordinateSystemsResp parses an HTTP response from a ListCoordinateSystemsWithResponse call
func ParseListCoordinateSystemsResp(rsp *http.Response) (*ListCoordinateSystemsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCoordinateSystemsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddCoordinateSystemResp parses an HTTP response from a AddCoordinateSystemWithResponse call
func ParseAddCoordinateSystemResp(rsp *http.Response) (*AddCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCoordinateSystemResp parses an HTTP response from a DeleteCoordinateSystemWithResponse call
func ParseDeleteCoordinateSystemResp(rsp *http.Response) (*DeleteCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCoordinateSystemResp parses an HTTP response from a GetCoordinateSystemWithResponse call
func ParseGetCoordinateSystemResp(rsp *http.Response) (*GetCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoordinateSystem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTransformInCoordinateSystemResp parses an HTTP response from a TransformInCoordinateSystemWithResponse call
func ParseTransformInCoordinateSystemResp(rsp *http.Response) (*TransformInCoordinateSystemResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransformInCoordinateSystemResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pose
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseClearDevicesResp parses an HTTP response from a ClearDevicesWithResponse call
func ParseClearDevicesResp(rsp *http.Response) (*ClearDevicesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearDevicesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateDeviceResp parses an HTTP response from a CreateDeviceWithResponse call
func ParseCreateDeviceResp(rsp *http.Response) (*CreateDeviceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeviceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteDeviceResp parses an HTTP response from a DeleteDeviceWithResponse call
func ParseDeleteDeviceResp(rsp *http.Response) (*DeleteDeviceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeviceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetDeviceResp parses an HTTP response from a GetDeviceWithResponse call
func ParseGetDeviceResp(rsp *http.Response) (*GetDeviceResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeviceResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListMotionGroupsResp parses an HTTP response from a ListMotionGroupsWithResponse call
func ParseListMotionGroupsResp(rsp *http.Response) (*ListMotionGroupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMotionGroupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupInstanceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseActivateMotionGroupResp parses an HTTP response from a ActivateMotionGroupWithResponse call
func ParseActivateMotionGroupResp(rsp *http.Response) (*ActivateMotionGroupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateMotionGroupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseActivateAllMotionGroupsResp parses an HTTP response from a ActivateAllMotionGroupsWithResponse call
func ParseActivateAllMotionGroupsResp(rsp *http.Response) (*ActivateAllMotionGroupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateAllMotionGroupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupInstanceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseJointJoggingResp parses an HTTP response from a JointJoggingWithResponse call
func ParseJointJoggingResp(rsp *http.Response) (*JointJoggingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JointJoggingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JoggingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDirectionJoggingResp parses an HTTP response from a DirectionJoggingWithResponse call
func ParseDirectionJoggingResp(rsp *http.Response) (*DirectionJoggingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DirectionJoggingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JoggingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeactivateMotionGroupResp parses an HTTP response from a DeactivateMotionGroupWithResponse call
func ParseDeactivateMotionGroupResp(rsp *http.Response) (*DeactivateMotionGroupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeactivateMotionGroupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInfoCapabilitiesResp parses an HTTP response from a GetInfoCapabilitiesWithResponse call
func ParseGetInfoCapabilitiesResp(rsp *http.Response) (*GetInfoCapabilitiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInfoCapabilitiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InfoServiceCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetJoggingCapabilitiesResp parses an HTTP response from a GetJoggingCapabilitiesWithResponse call
func ParseGetJoggingCapabilitiesResp(rsp *http.Response) (*GetJoggingCapabilitiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJoggingCapabilitiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JoggingServiceCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKinematicCapabilitiesResp parses an HTTP response from a GetKinematicCapabilitiesWithResponse call
func ParseGetKinematicCapabilitiesResp(rsp *http.Response) (*GetKinematicCapabilitiesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKinematicCapabilitiesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KinematicServiceCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCalculateAllInverseKinematicResp parses an HTTP response from a CalculateAllInverseKinematicWithResponse call
func ParseCalculateAllInverseKinematicResp(rsp *http.Response) (*CalculateAllInverseKinematicResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CalculateAllInverseKinematicResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllJointPositionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCalculateInverseKinematicResp parses an HTTP response from a CalculateInverseKinematicWithResponse call
func ParseCalculateInverseKinematicResp(rsp *http.Response) (*CalculateInverseKinematicResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CalculateInverseKinematicResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Joints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCalculateForwardKinematicResp parses an HTTP response from a CalculateForwardKinematicWithResponse call
func ParseCalculateForwardKinematicResp(rsp *http.Response) (*CalculateForwardKinematicResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CalculateForwardKinematicResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pose
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMountingResp parses an HTTP response from a GetMountingWithResponse call
func ParseGetMountingResp(rsp *http.Response) (*GetMountingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMountingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Mounting
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOptimizerConfigurationResp parses an HTTP response from a GetOptimizerConfigurationWithResponse call
func ParseGetOptimizerConfigurationResp(rsp *http.Response) (*GetOptimizerConfigurationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOptimizerConfigurationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OptimizerSetup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPayloadsResp parses an HTTP response from a ListPayloadsWithResponse call
func ParseListPayloadsResp(rsp *http.Response) (*ListPayloadsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPayloadsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPayloadsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetActivePayloadResp parses an HTTP response from a GetActivePayloadWithResponse call
func ParseGetActivePayloadResp(rsp *http.Response) (*GetActivePayloadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivePayloadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Payload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSafetySetupResp parses an HTTP response from a GetSafetySetupWithResponse call
func ParseGetSafetySetupResp(rsp *http.Response) (*GetSafetySetupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSafetySetupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SafetySetup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMotionGroupSpecificationResp parses an HTTP response from a GetMotionGroupSpecificationWithResponse call
func ParseGetMotionGroupSpecificationResp(rsp *http.Response) (*GetMotionGroupSpecificationResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionGroupSpecificationResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupSpecification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCurrentMotionGroupStateResp parses an HTTP response from a GetCurrentMotionGroupStateWithResponse call
func ParseGetCurrentMotionGroupStateResp(rsp *http.Response) (*GetCurrentMotionGroupStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentMotionGroupStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupStateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamMotionGroupStateResp parses an HTTP response from a StreamMotionGroupStateWithResponse call
func ParseStreamMotionGroupStateResp(rsp *http.Response) (*StreamMotionGroupStateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamMotionGroupStateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionGroupStateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStopJoggingResp parses an HTTP response from a StopJoggingWithResponse call
func ParseStopJoggingResp(rsp *http.Response) (*StopJoggingResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopJoggingResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTcpsResp parses an HTTP response from a ListTcpsWithResponse call
func ParseListTcpsResp(rsp *http.Response) (*ListTcpsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTcpsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTcpsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetActiveTcpResp parses an HTTP response from a GetActiveTcpWithResponse call
func ParseGetActiveTcpResp(rsp *http.Response) (*GetActiveTcpResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActiveTcpResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RobotTcp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPlanningMotionGroupModelsResp parses an HTTP response from a GetPlanningMotionGroupModelsWithResponse call
func ParseGetPlanningMotionGroupModelsResp(rsp *http.Response) (*GetPlanningMotionGroupModelsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlanningMotionGroupModelsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePlanCollisionFreePTPResp parses an HTTP response from a PlanCollisionFreePTPWithResponse call
func ParsePlanCollisionFreePTPResp(rsp *http.Response) (*PlanCollisionFreePTPResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlanCollisionFreePTPResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanTrajectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePlanTrajectoryResp parses an HTTP response from a PlanTrajectoryWithResponse call
func ParsePlanTrajectoryResp(rsp *http.Response) (*PlanTrajectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlanTrajectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanTrajectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteAllMotionsResp parses an HTTP response from a DeleteAllMotionsWithResponse call
func ParseDeleteAllMotionsResp(rsp *http.Response) (*DeleteAllMotionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAllMotionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMotionsResp parses an HTTP response from a ListMotionsWithResponse call
func ParseListMotionsResp(rsp *http.Response) (*ListMotionsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMotionsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MotionIdsListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePlanMotionResp parses an HTTP response from a PlanMotionWithResponse call
func ParsePlanMotionResp(rsp *http.Response) (*PlanMotionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlanMotionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExecuteTrajectoryResp parses an HTTP response from a ExecuteTrajectoryWithResponse call
func ParseExecuteTrajectoryResp(rsp *http.Response) (*ExecuteTrajectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteTrajectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExecuteTrajectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStreamMoveResp parses an HTTP response from a StreamMoveWithResponse call
func ParseStreamMoveResp(rsp *http.Response) (*StreamMoveResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamMoveResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamMoveResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMotionResp parses an HTTP response from a DeleteMotionWithResponse call
func ParseDeleteMotionResp(rsp *http.Response) (*DeleteMotionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMotionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamMoveBackwardResp parses an HTTP response from a StreamMoveBackwardWithResponse call
func ParseStreamMoveBackwardResp(rsp *http.Response) (*StreamMoveBackwardResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamMoveBackwardResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamMoveResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamMoveForwardResp parses an HTTP response from a StreamMoveForwardWithResponse call
func ParseStreamMoveForwardResp(rsp *http.Response) (*StreamMoveForwardResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamMoveForwardResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamMoveResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStreamMoveToTrajectoryViaJointPTPResp parses an HTTP response from a StreamMoveToTrajectoryViaJointPTPWithResponse call
func ParseStreamMoveToTrajectoryViaJointPTPResp(rsp *http.Response) (*StreamMoveToTrajectoryViaJointPTPResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamMoveToTrajectoryViaJointPTPResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamMoveResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPlannedMotionResp parses an HTTP response from a GetPlannedMotionWithResponse call
func ParseGetPlannedMotionResp(rsp *http.Response) (*GetPlannedMotionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlannedMotionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlannedMotion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStopExecutionResp parses an HTTP response from a StopExecutionWithResponse call
func ParseStopExecutionResp(rsp *http.Response) (*StopExecutionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopExecutionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMotionTrajectoryResp parses an HTTP response from a GetMotionTrajectoryWithResponse call
func ParseGetMotionTrajectoryResp(rsp *http.Response) (*GetMotionTrajectoryResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionTrajectoryResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTrajectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMotionTrajectorySampleResp parses an HTTP response from a GetMotionTrajectorySampleWithResponse call
func ParseGetMotionTrajectorySampleResp(rsp *http.Response) (*GetMotionTrajectorySampleResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMotionTrajectorySampleResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTrajectorySampleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllProgramRunsResp parses an HTTP response from a GetAllProgramRunsWithResponse call
func ParseGetAllProgramRunsResp(rsp *http.Response) (*GetAllProgramRunsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllProgramRunsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ProgramRuns *[]ProgramRunObject `json:"program_runs,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateProgramRunResp parses an HTTP response from a CreateProgramRunWithResponse call
func ParseCreateProgramRunResp(rsp *http.Response) (*CreateProgramRunResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProgramRunResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The identifier of the program run for further inspection of the
			// running program.
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProgramRunResp parses an HTTP response from a GetProgramRunWithResponse call
func ParseGetProgramRunResp(rsp *http.Response) (*GetProgramRunResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramRunResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramRunObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllTriggersResp parses an HTTP response from a GetAllTriggersWithResponse call
func ParseGetAllTriggersResp(rsp *http.Response) (*GetAllTriggersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTriggersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Triggers *[]TriggerObject `json:"triggers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTriggerResp parses an HTTP response from a CreateTriggerWithResponse call
func ParseCreateTriggerResp(rsp *http.Response) (*CreateTriggerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTriggerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The identifier of the created trigger.
			Id *string `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTriggerResp parses an HTTP response from a DeleteTriggerWithResponse call
func ParseDeleteTriggerResp(rsp *http.Response) (*DeleteTriggerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTriggerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTriggerResp parses an HTTP response from a GetTriggerWithResponse call
func ParseGetTriggerResp(rsp *http.Response) (*GetTriggerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTriggerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TriggerObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTriggerResp parses an HTTP response from a UpdateTriggerWithResponse call
func ParseUpdateTriggerResp(rsp *http.Response) (*UpdateTriggerResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTriggerResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TriggerObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadPlannedMotionResp parses an HTTP response from a LoadPlannedMotionWithResponse call
func ParseLoadPlannedMotionResp(rsp *http.Response) (*LoadPlannedMotionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadPlannedMotionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseClearProgramsValuesResp parses an HTTP response from a ClearProgramsValuesWithResponse call
func ParseClearProgramsValuesResp(rsp *http.Response) (*ClearProgramsValuesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearProgramsValuesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateProgramsValueResp parses an HTTP response from a CreateProgramsValueWithResponse call
func ParseCreateProgramsValueResp(rsp *http.Response) (*CreateProgramsValueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProgramsValueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteProgramValueResp parses an HTTP response from a DeleteProgramValueWithResponse call
func ParseDeleteProgramValueResp(rsp *http.Response) (*DeleteProgramValueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProgramValueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetProgramValueResp parses an HTTP response from a GetProgramValueWithResponse call
func ParseGetProgramValueResp(rsp *http.Response) (*GetProgramValueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramValueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateProgramValueResp parses an HTTP response from a UpdateProgramValueWithResponse call
func ParseUpdateProgramValueResp(rsp *http.Response) (*UpdateProgramValueResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProgramValueResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetCellStatusResp parses an HTTP response from a GetCellStatusWithResponse call
func ParseGetCellStatusResp(rsp *http.Response) (*GetCellStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCellStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListStoredCollidersResp parses an HTTP response from a ListStoredCollidersWithResponse call
func ParseListStoredCollidersResp(rsp *http.Response) (*ListStoredCollidersResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStoredCollidersResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ColliderDictionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStoredColliderResp parses an HTTP response from a DeleteStoredColliderWithResponse call
func ParseDeleteStoredColliderResp(rsp *http.Response) (*DeleteStoredColliderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoredColliderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStoredColliderResp parses an HTTP response from a GetStoredColliderWithResponse call
func ParseGetStoredColliderResp(rsp *http.Response) (*GetStoredColliderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoredColliderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreColliderResp parses an HTTP response from a StoreColliderWithResponse call
func ParseStoreColliderResp(rsp *http.Response) (*StoreColliderResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreColliderResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDefaultLinkChainResp parses an HTTP response from a GetDefaultLinkChainWithResponse call
func ParseGetDefaultLinkChainResp(rsp *http.Response) (*GetDefaultLinkChainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultLinkChainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkChain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListCollisionLinkChainsResp parses an HTTP response from a ListCollisionLinkChainsWithResponse call
func ParseListCollisionLinkChainsResp(rsp *http.Response) (*ListCollisionLinkChainsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCollisionLinkChainsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]LinkChain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStoredCollisionLinkChainResp parses an HTTP response from a DeleteStoredCollisionLinkChainWithResponse call
func ParseDeleteStoredCollisionLinkChainResp(rsp *http.Response) (*DeleteStoredCollisionLinkChainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoredCollisionLinkChainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStoredCollisionLinkChainResp parses an HTTP response from a GetStoredCollisionLinkChainWithResponse call
func ParseGetStoredCollisionLinkChainResp(rsp *http.Response) (*GetStoredCollisionLinkChainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoredCollisionLinkChainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkChain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreCollisionLinkChainResp parses an HTTP response from a StoreCollisionLinkChainWithResponse call
func ParseStoreCollisionLinkChainResp(rsp *http.Response) (*StoreCollisionLinkChainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreCollisionLinkChainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkChain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListStoredCollisionScenesResp parses an HTTP response from a ListStoredCollisionScenesWithResponse call
func ParseListStoredCollisionScenesResp(rsp *http.Response) (*ListStoredCollisionScenesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStoredCollisionScenesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]CollisionScene
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStoredCollisionSceneResp parses an HTTP response from a DeleteStoredCollisionSceneWithResponse call
func ParseDeleteStoredCollisionSceneResp(rsp *http.Response) (*DeleteStoredCollisionSceneResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoredCollisionSceneResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStoredCollisionSceneResp parses an HTTP response from a GetStoredCollisionSceneWithResponse call
func ParseGetStoredCollisionSceneResp(rsp *http.Response) (*GetStoredCollisionSceneResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoredCollisionSceneResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollisionScene
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreCollisionSceneResp parses an HTTP response from a StoreCollisionSceneWithResponse call
func ParseStoreCollisionSceneResp(rsp *http.Response) (*StoreCollisionSceneResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreCollisionSceneResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollisionScene
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListStoredCollisionToolsResp parses an HTTP response from a ListStoredCollisionToolsWithResponse call
func ParseListStoredCollisionToolsResp(rsp *http.Response) (*ListStoredCollisionToolsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStoredCollisionToolsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]Tool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteStoredCollisionToolResp parses an HTTP response from a DeleteStoredCollisionToolWithResponse call
func ParseDeleteStoredCollisionToolResp(rsp *http.Response) (*DeleteStoredCollisionToolResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoredCollisionToolResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetStoredCollisionToolResp parses an HTTP response from a GetStoredCollisionToolWithResponse call
func ParseGetStoredCollisionToolResp(rsp *http.Response) (*GetStoredCollisionToolResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoredCollisionToolResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreCollisionToolResp parses an HTTP response from a StoreCollisionToolWithResponse call
func ParseStoreCollisionToolResp(rsp *http.Response) (*StoreCollisionToolResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreCollisionToolResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClearAllObjectsResp parses an HTTP response from a ClearAllObjectsWithResponse call
func ParseClearAllObjectsResp(rsp *http.Response) (*ClearAllObjectsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearAllObjectsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListAllObjectKeysResp parses an HTTP response from a ListAllObjectKeysWithResponse call
func ParseListAllObjectKeysResp(rsp *http.Response) (*ListAllObjectKeysResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllObjectKeysResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteObjectResp parses an HTTP response from a DeleteObjectWithResponse call
func ParseDeleteObjectResp(rsp *http.Response) (*DeleteObjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetObjectResp parses an HTTP response from a GetObjectWithResponse call
func ParseGetObjectResp(rsp *http.Response) (*GetObjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetObjectMetadataResp parses an HTTP response from a GetObjectMetadataWithResponse call
func ParseGetObjectMetadataResp(rsp *http.Response) (*GetObjectMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetObjectMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStoreObjectResp parses an HTTP response from a StoreObjectWithResponse call
func ParseStoreObjectResp(rsp *http.Response) (*StoreObjectResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreObjectResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteProgramListResp parses an HTTP response from a DeleteProgramListWithResponse call
func ParseDeleteProgramListResp(rsp *http.Response) (*DeleteProgramListResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProgramListResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProgramMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 404:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseListProgramMetadataResp parses an HTTP response from a ListProgramMetadataWithResponse call
func ParseListProgramMetadataResp(rsp *http.Response) (*ListProgramMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProgramMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProgramMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateProgramResp parses an HTTP response from a CreateProgramWithResponse call
func ParseCreateProgramResp(rsp *http.Response) (*CreateProgramResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProgramResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 404:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseDeleteProgramResp parses an HTTP response from a DeleteProgramWithResponse call
func ParseDeleteProgramResp(rsp *http.Response) (*DeleteProgramResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProgramResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 404:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetProgramResp parses an HTTP response from a GetProgramWithResponse call
func ParseGetProgramResp(rsp *http.Response) (*GetProgramResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 404:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseUpdateProgramResp parses an HTTP response from a UpdateProgramWithResponse call
func ParseUpdateProgramResp(rsp *http.Response) (*UpdateProgramResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProgramResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 404:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetProgramMetadataResp parses an HTTP response from a GetProgramMetadataWithResponse call
func ParseGetProgramMetadataResp(rsp *http.Response) (*GetProgramMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateProgramMetadataResp parses an HTTP response from a UpdateProgramMetadataWithResponse call
func ParseUpdateProgramMetadataResp(rsp *http.Response) (*UpdateProgramMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProgramMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUploadProgramMetadataImageResp parses an HTTP response from a UploadProgramMetadataImageWithResponse call
func ParseUploadProgramMetadataImageResp(rsp *http.Response) (*UploadProgramMetadataImageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadProgramMetadataImageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProgramMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteRecipeListResp parses an HTTP response from a DeleteRecipeListWithResponse call
func ParseDeleteRecipeListResp(rsp *http.Response) (*DeleteRecipeListResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecipeListResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRecipeMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListRecipeMetadataResp parses an HTTP response from a ListRecipeMetadataWithResponse call
func ParseListRecipeMetadataResp(rsp *http.Response) (*ListRecipeMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRecipeMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRecipeMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRecipeResp parses an HTTP response from a CreateRecipeWithResponse call
func ParseCreateRecipeResp(rsp *http.Response) (*CreateRecipeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRecipeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteRecipeResp parses an HTTP response from a DeleteRecipeWithResponse call
func ParseDeleteRecipeResp(rsp *http.Response) (*DeleteRecipeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecipeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetRecipeResp parses an HTTP response from a GetRecipeWithResponse call
func ParseGetRecipeResp(rsp *http.Response) (*GetRecipeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecipeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateRecipeResp parses an HTTP response from a UpdateRecipeWithResponse call
func ParseUpdateRecipeResp(rsp *http.Response) (*UpdateRecipeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRecipeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetRecipeMetadataResp parses an HTTP response from a GetRecipeMetadataWithResponse call
func ParseGetRecipeMetadataResp(rsp *http.Response) (*GetRecipeMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecipeMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateRecipeMetadataResp parses an HTTP response from a UpdateRecipeMetadataWithResponse call
func ParseUpdateRecipeMetadataResp(rsp *http.Response) (*UpdateRecipeMetadataResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRecipeMetadataResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUploadRecipeMetadataImageResp parses an HTTP response from a UploadRecipeMetadataImageWithResponse call
func ParseUploadRecipeMetadataImageResp(rsp *http.Response) (*UploadRecipeMetadataImageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadRecipeMetadataImageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest HTTPExceptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeactivateLicenseResp parses an HTTP response from a DeactivateLicenseWithResponse call
func ParseDeactivateLicenseResp(rsp *http.Response) (*DeactivateLicenseResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeactivateLicenseResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetLicenseResp parses an HTTP response from a GetLicenseWithResponse call
func ParseGetLicenseResp(rsp *http.Response) (*GetLicenseResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActivateLicenseResp parses an HTTP response from a ActivateLicenseWithResponse call
func ParseActivateLicenseResp(rsp *http.Response) (*ActivateLicenseResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateLicenseResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetLicenseStatusResp parses an HTTP response from a GetLicenseStatusWithResponse call
func ParseGetLicenseStatusResp(rsp *http.Response) (*GetLicenseStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLicenseStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LicenseStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest LicenseStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetDiagnosePackageResp parses an HTTP response from a GetDiagnosePackageWithResponse call
func ParseGetDiagnosePackageResp(rsp *http.Response) (*GetDiagnosePackageResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDiagnosePackageResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSystemStatusResp parses an HTTP response from a GetSystemStatusWithResponse call
func ParseGetSystemStatusResp(rsp *http.Response) (*GetSystemStatusResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemStatusResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckNovaVersionUpdateResp parses an HTTP response from a CheckNovaVersionUpdateWithResponse call
func ParseCheckNovaVersionUpdateResp(rsp *http.Response) (*CheckNovaVersionUpdateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckNovaVersionUpdateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateNovaVersionResp parses an HTTP response from a UpdateNovaVersionWithResponse call
func ParseUpdateNovaVersionResp(rsp *http.Response) (*UpdateNovaVersionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNovaVersionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSystemVersionResp parses an HTTP response from a GetSystemVersionWithResponse call
func ParseGetSystemVersionResp(rsp *http.Response) (*GetSystemVersionResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSystemVersionResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
