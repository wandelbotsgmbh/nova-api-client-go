openapi: 3.1.0
info:
  title: Wandelbots Nova API
  license:
    name: Apache 2.0
    url: https://www.apache.org/licenses/LICENSE-2.0.html
  description: |
    Interact with robots in an easy and intuitive way.
  contact:
    name: Copyright (c) 2024 Wandelbots GmbH
    url: https://www.wandelbots.com
  version: 1.0.0 beta
servers:
  - url: /api/v1
security:
  - BasicAuth: []
tags:
  - name: Device Configuration
  - name: Motion Group
  - name: Motion Group Infos
  - name: Controller
  - name: Program
  - name: Program Values
  - name: Controller I/Os
  - name: Motion Group Kinematic
  - name: Motion
  - name: Coordinate Systems
  - name: Motion Group Jogging
  - name: Virtual Robot
  - name: Virtual Robot Setup
  - name: Virtual Robot Mode
  - name: Virtual Robot Behavior
  - name: Library Program Metadata
  - name: Library Program
  - name: Library Recipe Metadata
  - name: Library Recipe
  - name: Internal Service Manager Cell
  - name: Internal Service Manager Robot
  - name: Internal Service Manager App
  - name: Internal System
  - name: Internal RAE
  - name: Internal Wandelengine
paths:
  /cells/{cell}/controllers:
    get:
      tags:
        - Controller
      summary: List
      description: |
        List all configured robot controllers.
      operationId: listControllers
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ControllerInstanceList'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/controller-capabilities:
    get:
      tags:
        - Controller
      summary: Supported Motion Modes
      description: |
        Lists supported operating modes.
        Usually cobots support free drive and control, industrial robots only support control.
      operationId: getSupportedModes
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ControllerCapabilities'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/free-drive-stream:
    get:
      tags:
        - Controller
      summary: Stream Free Drive Mode
      description: |-
        Sets the robot controller into freedrive mode and stays in freedrive until the websocket connection is closed by the client. In freedrive mode, it is possible to move the attached motion groups by hand. This is a blocking call. As long as the websocket connection is open, no other endpoint can control or move the robot.
        DANGER: Danger caused by robot. Improper assessment by the integrator of the application-specific hazards can result in people being crushed, drawn in or caught due to the robot's complex movement sequences. Before opening the websocket, ensure that
          - The robot is in a safe state,
          - The right payload is set (e.g by using the (getActivePayload)[getActivePayload] endpoint),
          - No humans or object are within the robot's reach or within the cell.

        As long as the websocket connection is open you will get the current state of the robot system in the response in the specified response_rate. If the activation failed, the returned status will return possible reasons for the failure.
        Free drive mode is only available for robot controllers that support it, in particular Collobarative Robots ("Cobots"). Use the (getSupportedModes)[getSupportedModes] endpoint to check if the robot controller supports free drive mode.
      operationId: streamFreeDrive
      x-serverstream: true
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - name: response_rate
          in: query
          schema:
            type: integer
            format: uint32
            description: Update rate for the response message in ms. If not set 200ms are used.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RobotControllerState'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/ios/description:
    get:
      tags:
        - Controller I/Os
      summary: List Descriptions
      description: |-
        Lists the I/O descriptions of the robot controller.
        The I/O descriptions contain information such as the name of the I/O, the I/O type and the I/O unit. The set of available I/Os is defined by the robot controller. Each I/O has a unique identifier. If no identifiers are specified in the request, retrieve the full list of available I/Os in this endpoint.
      operationId: listIODescriptions
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - name: ios
          in: query
          schema:
            type: array
            description: |
              Array of io_ids to retrieve the descriptions for.
              If empty or not provided, descriptions of all available I/Os for the requested robot controller will be returned.
            items:
              type: string
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListIODescriptionsResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/ios/stream:
    get:
      tags:
        - Controller I/Os
      summary: Stream Values
      description: |-
        Continuously receive updates of I/O values via websocket. Updates are sent in the update rate of the controller.
        TIP: Do not request too many values simultaneously as the request is then likely to fail. The amount of values that can be streamed simultaneously depends on the specific robot controller.
        TIP: The ios are sent in the update rate of the controller to prevent losing any values. Consider that this might lead to a high amount of data transmitted.
      operationId: streamIOValues
      x-serverstream: true
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - name: ios
          in: query
          schema:
            type: array
            items:
              type: string
            description: |
              Array of I/O identifiers to retrieve the values for.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListIOValuesResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/ios/values:
    get:
      tags:
        - Controller I/Os
      summary: Values
      description: |-
        Retrieves the current values of I/Os.
        The identifiers of the I/Os must be provided in the request. Request all available I/O identifiers via [listIODescriptions](listIODescriptions).
      operationId: listIOValues
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - name: ios
          in: query
          schema:
            type: array
            items:
              type: string
            description: |
              Array of I/O identifiers to retrieve the values for.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListIOValuesResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    put:
      tags:
        - Controller I/Os
      summary: Set Values
      description: |-
        Set the values of outputs.
        All available I/O identifiers and possible value ranges are requestable via [listIODescriptions](listIODescriptions).
        The call will return once the values have been set on and accepted by the robot. This might take up to 200 milliseconds.
        TIP: Do not call this endoint while another request is still in progress. The second call will fail.
      operationId: setOutputValues
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      requestBody:
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/IOValue'
        required: true
      responses:
        '200':
          description: OK
          content: {}
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/ios/wait-for:
    get:
      tags:
        - Controller I/Os
      summary: Wait For
      description: |-
        Wait until an I/O reaches a certain value. This call returns as soon as the condition is met or the request fails.
        The comparison_type value is used to define how the current value of the I/O is compared with given value. Only set the value that corresponds to the value_type of the I/O, see (listIODescriptions)[listIODescriptions] for more information. Examples: If you want to wait until an analog input ("AI_1") is less than 10, you would set io to "AI_1" comparison_type to COMPARISON_LESS and only integer_value to 10. If you want to wait until an analog input ("AI_2") is greater than 5.0, you would set io to "AI_2" comparison_type to COMPARISON_GREATER and only floating_value to 5.0. If you want to wait until a digital input ("DI_3") is true, you would set io to "DI_3" comparison_type to COMPARISON_EQUAL and only boolean_value to true.
      operationId: waitForIOEvent
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - name: io
          in: query
          required: true
          schema:
            type: string
            description: Identifier of the I/O to wait for.
        - name: comparison_type
          in: query
          required: true
          schema:
            enum:
              - COMPARISON_TYPE_EQUAL
              - COMPARISON_TYPE_GREATER
              - COMPARISON_TYPE_LESS
            type: string
            format: enum
        - name: boolean_value
          in: query
          schema:
            type: boolean
            description: The value to compare with the current value of the I/O if the I/O is of type IO_VALUE_DIGITAL.
        - name: integer_value
          in: query
          schema:
            type: string
            description: The value to compare with the current value of the I/O if the I/O is of type IO_VALUE_ANALOG_INTEGER.
        - name: floating_value
          in: query
          schema:
            type: number
            format: double
            description: The value to compare with the current value of the I/O if the I/O is of type IO_VALUE_ANALOG_FLOATING.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: boolean
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/mode:
    get:
      tags:
        - Controller
      summary: Current Mode
      description: |
        Get the current robot system mode of a registered robot controller.
        The robot system mode indicates if a robot controller can be used. See [setDefaultMode](setDefaultMode) for more information about the different modes.
        The mode is influenced by the operating mode of the robot controller. The operating mode can be changed via [setDefaultMode](setDefaultMode).
        Request the current operating mode of the robot controller via [getCurrentRobotControllerState](getCurrentRobotControllerState).
      operationId: getMode
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetModeResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    put:
      tags:
        - Controller
      summary: Set Default Mode
      description: |
        Switch between monitor and control usage as default for a robot controller.
        Monitoring mode is used to read information from the robot controller and control mode is used to command the robot system.
        As long as the robot controller is connected via network monitoring mode is always possible. To switch to control mode
        the robot controller must be in `automatic` or `manual` operating mode. If the robot controller is in `manual` operating mode,
        you have manually confirm the control usage activation on the robot control panel. This manual confirmation can't be replaced with this API.
        Without manual confirmation the robot controller will stay in monitor mode.

        The robot system will try to activate the required operation mode for the requested usage unless no active call requires a different mode.
        Note: Some robot controllers prevent the external activation of automatic operating mode. In this case, changing the operating mode manually at the robot controller is mandatory.
        If a mode change is not possible, the response lists reasons for the failed change.
      operationId: setDefaultMode
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - name: mode
          in: query
          required: true
          schema:
            enum:
              - MODE_MONITOR
              - MODE_CONTROL
            type: string
            format: enum
      responses:
        '200':
          description: OK
          content: {}
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/mode-stream:
    get:
      tags:
        - Controller
      summary: Stream Mode Change
      description: |
        Receive updates of the current robot system mode of a robot controller via websocket upon robot system mode change.
        See [setDefaultMode](setDefaultMode) for more information about the different modes.
      operationId: streamModeChange
      x-serverstream: true
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ModeChangeResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/state:
    get:
      tags:
        - Controller
      summary: State of Device
      description: Get the current state of a robot controller.
      operationId: getCurrentRobotControllerState
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RobotControllerState'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/state-stream:
    get:
      tags:
        - Controller
      summary: Stream State of Device
      description: Receive updates of the state of a robot controller.
      operationId: streamRobotControllerState
      x-serverstream: true
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - name: response_rate
          in: query
          schema:
            type: integer
            format: uint32
            description: Update rate for the response message in ms. If not set 200ms are used.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RobotControllerState'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/virtual-robot-configuration:
    get:
      tags:
        - Controller
      summary: Virtual Robot Configuration
      description: |
        Receive the configuration for a virtual robot controller.
        Used to configure a virtual robot controller via [addRobotController](addRobotController).
      operationId: getVirtualRobotConfiguration
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/VirtualRobotConfiguration'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/coordinate-systems:
    get:
      tags:
        - Coordinate Systems
      summary: List
      description: |
        Lists all specifications of coordinate systems from robot controllers and user coordinate systems added to the system via the [addCoordinateSystem](addCoordinateSystem) endpoint.
        Use parameter rotation_type to get the orientation part of the transformation offset of the coordinate system returned in the requested rotation angle type.
        If parameter rotation_type is not set, the orientation part of the transformation offset of the coordinate system is returned in the rotation angle type used on the robot controller.
        This can be useful for visualization purposes in the client application due to equivalent numbers with robot control panel visualization.

        The coordinate systems from the robot controller are loaded when the motion group associated with the coordinate system is activated.
        With deactivation of the motion group, the associated coordinate systems are removed from Nova. The unique identifier of the coordinate systems from the robot controllers
        are suffixed with "On" + the unique identifier of the robot controller.

        Updating the robot controller's configuration either requires credentials or is not possible. With the endpoint [addCoordinateSystem](addCoordinateSystem) you can create a
        coordinate system without changing the robot controller's configuration.
      operationId: listCoordinateSystems
      parameters:
        - $ref: '#/components/parameters/Cell'
        - name: rotation_type
          in: query
          schema:
            $ref: '#/components/schemas/RotationAngleTypes'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    put:
      tags:
        - Coordinate Systems
      summary: Add
      description: |
        Add a user coordinate system to the list of coordinate systems but not on a robot controller.

        The coordinate system is defined by a name and an offset in another coordinate system referenced by the unique identifier of the reference coordinate system.

        Will return the specification of the added coordinate systems which includes the unique identifier of the added coordinate system.

        All available coordinate systems can be listed via the [listCoordinateSystems](listCoordinateSystems) endpoint.
      operationId: addCoordinateSystem
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AddRequest'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CoordinateSystem'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/coordinate-systems/{coordinate-system}:
    get:
      tags:
        - Coordinate Systems
      summary: Description
      description: |
        Request a coordinate system specification for a given identifier.

        Use parameter rotation_type to get the orientation part of the transformation offset of the coordinate system returned in the requested rotation angle type.
        If parameter rotation_type is not set, the orientation part of the transformation offset of the coordinate system is returned in the rotation angle type used on the robot controller.
        This can be useful for visualization purposes in the client application due to equivalent numbers with robot control panel visualization.

        User coordinate systems can be configured on a robot controller during setup or added to the system via the [addCoordinateSystem](addCoordinateSystem) endpoint.

        Updating the robot controller's configuration either requires credentials or is not possible. With the endpoint [addCoordinateSystem](addCoordinateSystem) you can create a
        coordinate system without changing the robot controller's configuration.
      operationId: getCoordinateSystem
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/CoordinateSystem'
        - name: rotation_type
          in: query
          schema:
            $ref: '#/components/schemas/RotationAngleTypes'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CoordinateSystem'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    delete:
      tags:
        - Coordinate Systems
      summary: Delete
      description: |
        Removes a user coordinate system specified by the given identifier.

        TIP: If the coordinate system has originally been configured on the robot controller, it will remain on the controller even after this endpoint
        has been executed successfully..

        This will remove the user coordinate system from the list of user coordinate systems but keep
        all dependent coordinate systems which use the deleted coordinate system as reference.
        Coordinate systems on the robot controller are not affected by this operation. They can be removed via the robot control panel only
        and will be removed in NOVA when the controller is removed. On virtual controllers, use the
        [deleteVirtualRobotCoordinateSystem](deleteVirtualRobotCoordinateSystem) endpoint to remove coordinate systems from NOVA and the virtual controller.

        All available coordinate systems can be listed via the [listCoordinateSystems](listCoordinateSystems) endpoint.
      operationId: deleteCoordinateSystem
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/CoordinateSystem'
      responses:
        '200':
          description: OK
          content: {}
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/coordinate-systems/{coordinate-system}/transform:
    post:
      tags:
        - Coordinate Systems
      summary: Transform
      description: Transform a pose to another base.
      operationId: transformInCoordinateSystem
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/CoordinateSystem'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Pose'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Pose'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups:
    get:
      tags:
        - Motion Group
      summary: List Active
      description: |
        List all active motion groups. A motion group is active if it is currently
        used by a controller.
      operationId: listMotionGroups
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MotionGroupInstanceList'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    post:
      tags:
        - Motion Group
      summary: Activate
      description: |
        Activate the motion group and keeps the motion group in an active status.
        To manually activate a motion group, use this endpoint.

        When activating a motion group, interacting with the controller in other ways is not possible.

        To deactivate a motion group, use [deactivateMotionGroup](deactivateMotionGroup).
      operationId: activateMotionGroup
      parameters:
        - $ref: '#/components/parameters/Cell'
        - name: motion_group
          in: query
          required: true
          schema:
            type: string
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MotionGroupInstance'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/all:
    post:
      tags:
        - Motion Group
      summary: Activate All
      description: |
        Activate the motion group and keeps the motion group in an active status.
        To activate all motion groups of a robot controller, use this endpoint. It will return all activated motion groups
        of that controller.

        When activating motion groups, it is not possible to interact with the controller in any other way.

        To deactivate a motion group, use [deactivateMotionGroup](deactivateMotionGroup).
      operationId: activateAllMotionGroups
      parameters:
        - $ref: '#/components/parameters/Cell'
        - name: controller
          in: query
          required: true
          schema:
            type: string
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MotionGroupInstanceList'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}:
    delete:
      tags:
        - Motion Group
      summary: Deactivate
      description: |
        Deactivate a motion group. Activate the motion group and keeps the motion group in an active status.

        The robot controller streams information about all active motion groups. Deactivate motion groups that you no longer use.

        When deactivating motion groups, it is not possible to interact with the controller in any other way.
      operationId: deactivateMotionGroup
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      responses:
        '200':
          description: OK
          content: {}
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/info-capabilities:
    get:
      tags:
        - Motion Group Infos
      summary: Capabilities
      description: |
        Shows the options the motion group offers in regard to the information service.

        Some motion groups may not provide all information services, e.g. some manufacturers don't have a blending zone concept.
      operationId: getInfoCapabilities
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InfoServiceCapabilities'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/kinematic-capabilities:
    get:
      tags:
        - Motion Group Kinematic
      summary: Capabilities
      description: |
        Get the kinematic endpoints provided for the specified motion-group.
      operationId: getKinematicCapabilities
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/KinematicServiceCapabilities'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/kinematic/calculate-all-joint-positions:
    post:
      tags:
        - Motion Group Kinematic
      summary: All Joint Positions from TCP Pose
      description: |
        Calculate the joint positions of a motion group in order to move its TCP to a specific pose (Inverse Kinematic Solutions).
        All solutions are within the configured joint limits of the robot and not in a singular position of the robot.

        Return all joint positions as list of distinct joint positions in [rad] with
        their respective inverse feedback.

        Will be empty when unreachable, e.g. outside joint position limits, singular.

        Does not include multiple solutions where the robot links are in the same postition.
        Those can occur when single joints are allowed to move in a range larger than 360 degrees.
      operationId: calculateAllInverseKinematic
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AllJointPositionsRequest'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AllJointPositionsResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/kinematic/calculate-joint-position:
    post:
      tags:
        - Motion Group Kinematic
      summary: Nearest JointPosition from TcpPose
      description: |
        Calculate the joint positions the motion-group needs to apply for its TCP to be in a specified pose (Inverse Kinematic Solution).

        If multiple solutions are found, the one nearest to the given specified joint position is picked.
        * For all supported robot models, except the Fanuc CRX line, the returned joint position is guaranteed to have the same configuration
        (often referred to as ELBOW_UP, WRIST_DOWN, SHOULDER_RIGHT, f.e.) as the specified reference joint position.
        If the position limit of any single joint allows it to be in a range larger than 2 PI,
        the respective joint value in the result will be as close as possible to its reference value.
        * For the Fanuc CRX line the solution is selected to have the smallest distance measured by the norm of its difference to the reference joint position.

        The returned joint position is guaranteed to be within the joint limits and not in a singular position of the robot.
      operationId: calculateInverseKinematic
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/JointPositionRequest'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Joints'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/kinematic/calculate-tcp-pose:
    post:
      tags:
        - Motion Group Kinematic
      summary: TcpPose from JointPosition
      description: |
        Calculates the TCP pose from a joint position sample using the forward kinematics of the motion-group.
      operationId: calculateForwardKinematic
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TcpPoseRequest'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Pose'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/mounting:
    get:
      tags:
        - Motion Group Infos
      summary: Device Mounting
      description: |
        Returns the configured mounting pose offset in relation to world coordinate system and the motion groups coordinate system.
      operationId: getMounting
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Mounting'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/jogging-capabilities:
    get:
      tags:
        - Motion Group Jogging
      summary: Capabilities
      description: |-
        Shows the options the motion group offers in regard to jogging.
        Some motion groups may not provide all information services, e.g. it is physically not possible to move a one-axis-turntable in a linear way.
      operationId: getJoggingCapabilities
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/JoggingServiceCapabilities'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/optimizer-setup:
    get:
      tags:
        - Motion Group Infos
      summary: Optimizer Configuration
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Get the complete configuration which can be passed to the planner-optimizer
        (incl. motion group description, limits etc.)
      operationId: getOptimizerConfiguration
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
        - name: tcp
          in: query
          schema:
            type: string
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OptimizerSetup'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/payloads:
    get:
      tags:
        - Motion Group Infos
      summary: List Payloads
      description: |
        Lists all defined payloads of the motion group.
        The payload is defined as the sum of all weights attached to the
        flange/endpoint of the motion group, e.g. sum of the tools and workpiece weight that are currently attached.
      operationId: listPayloads
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListPayloadsResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/payloads/current:
    get:
      tags:
        - Motion Group Infos
      summary: Selected Payload
      description: |
        Gets the currently selected payload of the motion group.
        The payload is defined as the sum of all weights attached to the
        flange/endpoint of the motion group, e.g. sum of the tools and workpiece weight that are currently attached.
      operationId: getActivePayload
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Payload'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/safety-setup:
    get:
      tags:
        - Motion Group Infos
      summary: Safety Setup and Limitations
      description: |-
        Get the safety setup and limitations of a connected device, which restricts the device.
        Safety settings are configured globally on the robot controller and are valid for all the connected devices (like robots).
      operationId: getSafetySetup
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SafetySetup'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/specification:
    get:
      tags:
        - Motion Group Infos
      summary: Get Static Properties
      description: |
        Get static properties of the motion group.
        Those properties are used internally for motion group plannning.
        Only supported motion groups will return a valid response.
      operationId: getMotionGroupSpecification
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MotionGroupSpecification'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/state:
    get:
      tags:
        - Motion Group Infos
      summary: State of Device
      description: |
        Returns the current state of the selected motion group including the current joint position, velocity, pose, and more.
      operationId: getCurrentMotionGroupState
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
        - name: tcp
          in: query
          schema:
            type: string
          description: |
            The identifier of the tool center point (TCP) to be used for tcp_pose in response.
            If not set, the flange pose is returned as tcp_pose.
        - name: response_coordinate_system
          in: query
          schema:
            type: string
          description: |
            Unique identifier addressing a coordinate system to which the responses should be converted.
            If not set, world coordinate system is used.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MotionGroupStateResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/state-stream:
    get:
      tags:
        - Motion Group Infos
      summary: Stream State of Device
      description: |
        Receive updates of the motion group state.
        The stream will be closed from the server if the controller is disconnected.
      operationId: streamMotionGroupState
      x-serverstream: true
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                tcp:
                  type: string
                  description: |
                    The identifier of the tool center point (TCP) to be used for tcp_pose in response.
                    If not set, the flange pose is returned as tcp_pose.
                response_coordinate_system:
                  type: string
                  description: |
                    Unique identifier addressing a coordinate system to which the responses should be converted.
                    If not set, world coordinate system is used.
                response_rate:
                  type: integer
                  format: uint32
                  description: |
                    In milliseconds (ms). Unit transfer: 200 ms = 5 Hz, 4 ms = 250 Hz
                    If not set, the default rate is 200 ms | 5 Hz.
              additionalProperties: false
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MotionGroupStateResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/stop:
    put:
      tags:
        - Motion Group Jogging
      summary: Stop
      description: |
        Stops an ongoing jogging movement as fast as possible. Until the motion group reaches standstill, it decelerates and keeps the last specified direction.

        This call will immediately return even if the deceleration is still in progress.
        After a stop request has been received, no further updates to the ongoing jogging movement are possible.

        State responses will be sent via the jogging stream until the motion group reaches standstill.
      operationId: stopJogging
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
      responses:
        '200':
          description: OK
          content: {}
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/tcps:
    get:
      tags:
        - Motion Group Infos
      summary: List TCPs
      description: Get all internal configured TCPs of a connected device.
      operationId: listTcps
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
        - name: rotation_type
          in: query
          schema:
            $ref: '#/components/schemas/RotationAngleTypes'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListTcpsResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/{motion-group}/tcps/current:
    get:
      tags:
        - Motion Group Infos
      summary: Selected Tcp
      description: Get the internal selected TCP of a connected device.
      operationId: getActiveTcp
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/MotionGroup'
        - name: rotation_type
          in: query
          schema:
            $ref: '#/components/schemas/RotationAngleTypes'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RobotTcp'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/move-joint:
    get:
      tags:
        - Motion Group Jogging
      summary: Stream Joints
      description: |
        Move one or more joints of a motion group with specified velocities via a websocket.

        The purpose of a joint jogging motion is to maneuver a motion group in one or more joints with a specified velocity for each joint.
        The sign of the velocity determines the direction of the joint movement. The velocity is given in [rad/s].
        In contrast to a planned motion, a jogging motion can be changed dynamically while the motion group is in motion.

        Only one single client at a time can jog a particular motion group.
        If another client tries to jog the same motion group at the same time, the second call will fail.

        The movement of the motion group will start as soon as:
        * the motion group is not in motion
        * the websocket connection is established
        * the first request has been sent

        As long as the jogging motion is ongoing, responses will be sent continuously and contain the current state of the motion group.
        The responses will be sent with the specified rate according to the *response_rate* parameter of the initial websocket request.
        While in motion, the desired joint velocity can be changed by sending a new request to the same websocket.
        The motion and sending of the replies will stop when:
        * a [stopJogging](stopJogging) request was received, processed, and the movement stopped
          Motion group state will be published in the original command stream until the motion group has fully stopped.
        * the client cancels the stream (not recommended, because final stopping position will not be returned from the stream)

        When a physical limit (e.g. joint limit) is reached, the motion group will stop moving in the desired direction.
        The stream, howewer, will continue to send the state until the client cancels the stream or sends the [stopJogging](stopJogging) request.

        **Usage example:**

        1. Open a websocket via python and start the jogging motion:
        ```bash
        > python -m websockets "ws://<IP of Wandelbots Nova API>/api/v1/cells/<your cell id>/motion-groups/move-joint"
        ```
        2. Send the following message to move with a velocity of 0.1 rad/s (negative) for joint 5 and 0.2 rad/s for joint 6:
        ```json
        {
          "motion_group": "<your motion group id>",
          "joint_velocities": [0, 0, 0, 0, -0.1, 0.2],
          "response_rate": 500
        }
        ```
        The provided NOVA API clients also natively support jogging motions, without the need to manually open a websocket.

        TIP:
        If the jogging movement is stopped immediately, ensure that
          - A websocket connection is established. Websockets can be kept open until the robot's movement is done as opposed to a simple HTTP GET request.
          - The motion group is not in motion by another jogging movement or a planned movement.

        TIP:
        If the robot does not move, ensure that
          - The joint velocity values are not zero,
          - The motion group is not in a state where it cannot move further (e.g. joint limit reached).

        TIP:
        If the specified velocities are higher than the maximum allowed by the robot controller, the motion group will move with the maximum allowed velocities.
      operationId: jointJogging
      x-bidistream: true
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/JointJoggingRequest'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/JoggingResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motion-groups/move-tcp:
    get:
      tags:
        - Motion Group Jogging
      summary: Stream Cartesian
      description: |
        Move TCP along/around a specified direction vector with a specified velocity via a websocket.

        The purpose of a direction jogging motion is to move a device in exactly one direction with a specified maximum velocity.
        The sign of the velocity determines the direction of the movement: Positive [+] or Negative [-]. The velocity is given in [mm/s].
        In contrast to a planned motion, a jogging motion can be changed dynamically while the motion group is in motion.

        Only one single client at a time can jog a particular motion group.
        If another client tries to jog the same motion group at the same time, the second call will fail.

        The movement of the motion group will start as soon as:
        * the motion group is not in motion
        * the websocket connection is established
        * the first request has been sent

        As long as the jogging motion is ongoing, responses will be sent continuously and contain the current state of the motion group.
        The responses will be sent with the specified rate according to the *response_rate* parameter of the initial websocket request.
        While in motion, the desired direction and velocity can be changed by sending a new request to the same websocket.
        The motion and sending of the replies will stop when:
        * a [stopJogging](stopJogging) request was received, processed, and the movement stopped
          The motion group state will be published in the original command stream until the motion group has stopped.
        * the client cancels the stream (not recommended, because final stopping position will not be returned from the stream)

        When a physical limit (e.g. workspace boundary) is reached, the motion group will stop moving in the desired direction.
        The stream, howewer, will continue to send the state until the client cancels the stream or sends the [stopJogging](stopJogging) request.

        Singularities are avoided during a jogging motion. This avoidance can result in deviations from the specified direction. The amount of deviation depends on the robot type and current velocity.
        These mechanisms can lead to a small deviation from the specified direction. The size of deviation is depending on robot type and current velocity.

         **Usage example:**

        1. Open a websocket via python and start the jogging motion:
        ```bash
        > python -m websockets "ws://<IP of Wandelbots Nova API>/api/v1/cells/<your cell id>/motion-groups/move-tcp"
        ```
        2. Send the following message to the server to move current TCP 2 parts up in z direction and one part in negative y direction
        with 0.2 mm/s along the specified direction vector:
        ```json
        {
          "motion_group": "<your motion group id>",
          "position_direction": {
            "y": -0.5,
            "z": 1
          },
          "rotation_direction": {},
          "position_velocity": 0.2,
          "response_rate": 500
        }
        ```
        The NOVA API clients support jogging motions without the need to manually open a websocket.

        TIP:
        If the jogging movement is stopped immediately, ensure that:
          - A websocket connection is established. Websockets can be kept open until the robot's movement is done as opposed to a simple HTTP GET request.
          - The motion group is not in motion by another jogging movement or a planned movement.

        TIP:
        If the robot does not move, ensure that
          - The joint velocity values are not zero,
          - The motion group is not in a state where it cannot move further (e.g. joint limit reached).

        TIP:
        If the specified velocities are higher than the maximum allowed by the robot controller, the motion group will move with the maximum allowed velocities.
      operationId: directionJogging
      x-bidistream: true
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/DirectionJoggingRequest'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/JoggingResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motions:
    get:
      tags:
        - Motion
      summary: List All Motions
      description: |-
        List all currently planned and available motions.
        Use [planMotion](planMotion) to plan a new motion.
        Motions are removed if the corresponding motion group or controller disconnects.
      operationId: listMotions
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MotionIdsListResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    post:
      tags:
        - Motion
      summary: Plan
      description: |-
        This endpoint plans a new motion for a single previously configured [motion group](listMotionGroups). Motions are described by a sequence of motion commands starting with start joints.
        A motion is planned from standstill to standstill. A single motion has constant TCP and payload.
        Currently, I/O actions can't be attached to a motion to execute the action in realtime while a motion is executed.
        If an I/O is needed at a specific point, multiple motions need to be planned.
        If an I/O is needed to be set while a motion is executed, the enpoint [setOutputValues](setOutputValues) could be used.
      operationId: planMotion
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PlanRequest'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PlanResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    delete:
      tags:
        - Motion
      summary: All Motions
      description: Delete all registered motions.
      operationId: deleteAllMotions
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: OK
          content: {}
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motions/{motion}/delete:
    delete:
      tags:
        - Motion
      summary: Remove
      description: |-
        Remove a previously created motion from cache. Use [listMotions](listMotions) to list all available motions.
        Motions are removed automatically if the motion group or the corresponding controller is disconnected.
      operationId: deleteMotion
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Motion'
      responses:
        '200':
          description: OK
          content: {}
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motions/{motion}/executebackward:
    get:
      tags:
        - Motion
      summary: Stream Backward
      description: |-
        Request to move the motion group backward along a previously planned motion.
        Once started, you can stop a motion using the [stopExecution](stopExecution) endpoint.
        Prerequisites, before starting the motion execution:
         - The motion group is currently at the endpoint of the planned motion. OR
         - The motion was stopped using [stopExecution](stopExecution) endpoint. Then it is possible to resume the motion exection from where it stopped. OR
         - The motion group was moved onto the motion using the [streamMoveToTrajectoryViaJointP2P](streamMoveToTrajectoryViaJointP2P) endpoint.
      operationId: streamMoveBackward
      x-serverstream: true
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Motion'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MoveRequest'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StreamMoveResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motions/{motion}/executeforward:
    get:
      tags:
        - Motion
      summary: Stream Forward
      description: |-
        Moves the motion group forward along a previously planned motion.
        Once started, you can stop a motion using the [stopExecution](stopExecution) endpoint.
        Prerequisites, before starting the motion execution:
         - The motion group is currently at the startpoint of the planned motion. OR
         - The motion was stopped using [stopExecution](stopExecution) endpoint. Then it is possible to resume the motion exection from where it stopped. OR
         - The motion group was moved onto the motion using the [streamMoveToTrajectoryViaJointP2P](streamMoveToTrajectoryViaJointP2P) endpoint.
      operationId: streamMoveForward
      x-serverstream: true
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Motion'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MoveRequest'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StreamMoveResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motions/{motion}/executetotrajectory:
    get:
      tags:
        - Motion
      summary: Stream to Trajectory
      description: Request to move the motion group via joint point-to-point to a given location on a planned motion. You must use this endpoint in order to start moving from an arbritrary location of the trajectory. Afterwards, you are able to call [streamMoveForward](streamMoveForward) or [streamMoveBackward](streamMoveBackward) to move along planned motion. Use the [stopExecution](stopExecution) endpoint to stop the motion gracefully.
      operationId: streamMoveToTrajectoryViaJointPTP
      x-serverstream: true
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Motion'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ExecuteToTrajectoryRequest'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/StreamMoveResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motions/{motion}/stop:
    put:
      tags:
        - Motion
      summary: Stop
      description: |-
        Stops an active motion gracefully with deceleration until standstill while staying on the planned trajectory.
        When an active movement is stopped any further update request will be rejected.
        The active movement request returns until the robot has reached standstill.
        Currently it is not possible to restart the motion. Please send in a feature request if you need to restart/continue the motion.
      operationId: stopExecution
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Motion'
      responses:
        '200':
          description: OK
          content: {}
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motions/{motion}/trajectory:
    get:
      tags:
        - Motion
      summary: Get Trajectory
      description: |-
        Get the trajectory of a planned motion with defined `sample_time` in milliseconds (ms).
        The trajectory is a list of points containing cartesian and joint data. The cartesian data is in the requested coordinate system.
        To get a single point of the trajectory, please use the [getMotionTrajectorySample](getMotionTrajectorySample) endpoint.
      operationId: getMotionTrajectory
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Motion'
        - name: sample_time
          in: query
          schema:
            type: integer
            format: uint32
          required: true
          description: '-| The value of `sample_time` is the time in milliseconds (ms) between each point in the trajectory.'
        - name: responses_coordinate_system
          in: query
          schema:
            type: string
          description: |-
            Unique identifier addressing a coordinate system to which the cartesian data of the responses should be converted.
            Default is the world coordinate system.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetTrajectoryResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/motions/{motion}/trajectorysample:
    get:
      tags:
        - Motion
      summary: Get Trajectory Sample
      description: |-
        -| Get a single point at a certain location of a planned motion.
        To get the whole trajectory, use the [getMotionTrajectory](getMotionTrajectory) endpoint.
      operationId: getMotionTrajectorySample
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Motion'
        - name: location_on_trajectory
          in: query
          schema:
            type: number
            format: double
        - name: response_coordinate_system
          in: query
          schema:
            type: string
          description: |-
            Unique identifier addressing a coordinate system in which the cartesian data of the response should be converted to.
            Default is the world coordinate system.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GetTrajectorySampleResponse'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/homejoints:
    get:
      tags:
        - Internal Service Manager Robot
      summary: Default Home Joints
      description: Provides suggested initial joint values for the available virtual robots.
      operationId: defaultHomeJoints
      parameters:
        - $ref: '#/components/parameters/Cell'
        - name: virtual_robot_model
          in: query
          required: true
          schema:
            type: string
            description: The virtual robot type as described in examples of the [addRobotController](addRobotController) endpoint for a virtual robot.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Joints'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/programs/runners:
    get:
      tags:
        - Program
      summary: List Program Runners
      description: Get details about all existing program runners.
      operationId: listProgramRunners
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                items:
                  $ref: '#/components/schemas/ProgramRunnerReference'
                type: array
                title: Response Getprogramrunners Programs Runners Get
        '400':
          description: Either a syntax or a runtime error
        '404':
          description: Not found
        '452':
          description: |
            Robot is not able to perform the motion due to hard or soft restrictions.
            This can be due to a variety of reasons:

            - The robot is too close to a singularity,
            - The robot is too close to a joint limit,
            - Robot operating mode could not be set to the desired mode,
            - An operating mode change occurred during the motion.

            In the case of an error, the full error will be returned in the response body.
        '500':
          description: Internal server error
    post:
      tags:
        - Program
      summary: Create Program Runner
      description: |-
        This endpoint accepts a program written in Wandelscript and if desired, initial arguments (in the form of a dict). It will then execute this Wandelscript asynchronously.
        It returns a program runner reference which can be used to query the state of the program runner.

        ## Parameters
        See the **Schema** tab for information about the request body.

        ## Returns
        A program runner reference which can be used to query the state of the program runner.

        ## Receiving state updates
        Receive state updates of the program runner via polling the `/programs/runners/{runner_id}/`

        ### Via polling
        You can receive updates about the state of the program runner by polling the `/programs/runners/{runner_id}/` endpoint. ```
      operationId: createProgramRunner
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        content:
          text/plain:
            schema:
              anyOf:
                - type: string
                  description: Wandelscript code string which describes a Program as text/plain
                - $ref: '#/components/schemas/CodeWithArguments'
              title: Request
              description: Wandelscript code string which describes a Program as text/plain
            examples:
              default:
                value: |
                  home = [-189, -600, 260, 0, -pi, 0]

                  for i = 0..5:
                      move via p2p() to home
                      move via line() to [50, 20, 30, 0, 0, 0.3] :: home
                      move via line() to [150, 20, 30, 0, 0, 0.3] :: home
                      move via line() to [50, 20, 30, 0, 0, 0.3] :: home
                      move via p2p() to home
              whitespaces:
                value: |
                  a = 1
                  b = 2

                  c = 3
              interpolation:
                value: |
                  a = [0, 0, 10, 0, 0, 0]
                  b = [0, 0, 20, 0, 0, 0]
                  c = interpolate(a, b, 0.5)
                  d = [0, 0, 0, 0, 0, 0]
                  e = [0, 0, 20, 1, 2, 0]
                  f = interpolate(d, e, 0.5)
              ifelse:
                value: |
                  s = "c"
                  if s == "a":
                      a = 2
                  elif s == "b":
                      a = 3
                  elif s == "c":
                      a = 4
                  elif s == "c":
                      a = 5
                  else:
                      a = 6
              tcp_change:
                value: |-
                  flange = frame("flange")
                  tool = frame("tool")
                  move via p2p() to [0, 0, 0, 0, 0, 0]
                  move flange to [1, 2, 0]
                  a = planned_pose()
                  sync
                  move tool to [1, 2, 0]
                  b = planned_pose()
              loops:
                value: |-
                  a = 0
                  for i in 0..10:
                      a = a + i
                  b = 0
                  for i = 0..10: b = b + i
                  c = 0
                  for i = 0..<10:
                      c = c + i
                      c = c + 0
                  d = 0
                  i = 0
                  while i < 10:
                      d = d + i
                      i = i + 1
              try:
                value: |
                  do:
                      move via p2p() to [0, 0, 1, 0, 0, 0]
                      move via p2p() to [0, 0, 2, 0, 0, 0]
                      raise "some artificial error"
                      move via p2p() to [0, 0, 4, 0, 0, 0]
                  sync:
                      print("Hello World")
                  except:
                      stopped_pose = read(robot, 'pose')
                      move via p2p() to [0, 0, 10, 0, 0, 0]
                      final_pose = read(robot, 'pose')
              get_pose:
                value: |-
                  move via p2p() to [1, 2, 3, 2, 2, 0]
                  move via line() to [10, 2, 3, 2, 2, 0]
                  a = planned_pose()
                  python_print(a)
                  b = read(robot, 'pose')
                  python_print(b)
              move_with_velocity:
                value: |
                  with velocity(100):
                      velocity_uninitialized_global_inside_context = __ms_velocity
                      move via p2p() to [243, -440, 241, 0, 3, 0]
                  velocity_global_default = __ms_velocity
                  velocity(200)
                  velocity_global_set = __ms_velocity
                  move via p2p() to [150, -355, 389, 0, 3, 0]
                  move via line() to [150, -355, 392, 0, 3, 0]
                  move via line() to [-95, -363, 387] with velocity(300)
                  velocity_global_after_motion_modifier = __ms_velocity
                  with velocity(400):
                      velocity_global_inside_context = __ms_velocity
                      move via line() to [243, -440, 241]
                  velocity_global_after_context = __ms_velocity
                  a = planned_pose()
              empty:
                value: ''
              expressions:
                value: |-
                  a = 1 + 4
                  b = 4 * 2 + 3
                  c = 3 + 4 * 2
                  d = (3 + 4) * 2
                  e = a * 4
                  f = 4 - 6
                  g = 3 - 2
                  h = - 8 + 5
                  i = - (8 + 5)
                  k = 3 < 4
                  l, m = {1, 4}
              palletizing-ur10e-liftkit:
                value: |
                  liftkit_position = "2:EwellixLiftkit0S/Position"
                  liftkit_status = "2:EwellixLiftkit0S/Status"
                  liftkit_move = "2:EwellixLiftkit0S/Move(newPosition)"
                  liftkit_connect = "2:EwellixLiftkit0S/Connect(host)"
                  liftkit_host = "192.168.1.100"

                  box_length = read(database, "box_length")
                  box_width = read(database, "box_width")
                  box_height = read(database, "box_height")
                  pallet_length = box_length * 3
                  pallet_width = box_width * 2
                  pallet_layers = 1
                  box_offset = read(database, "box_offset")

                  home = [-536, -399, 621, 2.88, -1.25507, 0]
                  pick_pose = [-925, 207, -243, 2.88, -1.2, -0.11] # read(database, "pickup_base")
                  pre_drop_pose = [404, -632, 587, 2.88, -1.25507, 0]
                  drop_pose = [320, -1074, -250, 2.88, -1.25507, 0]
                  # drop_pose = [966, -420, -256, 2.88, -1.25507, 0] # read(database, "dropoff_base")
                  # other drop pose [-30, -701, -246, 2.88, -1.2, -0.11]

                  approach_vector = [0, 0, -300]
                  liftkit_pick_position = 0.0
                  cols = floor(pallet_width / box_width)
                  rows = floor(pallet_length / box_length)

                  def toggle_gripper(vacuum):
                      if vacuum:
                          write(io, False, "tool_out[0]")
                          write(io, False, "tool_out[1]")
                      else:
                          write(io, True, "tool_out[0]")
                          write(io, True, "tool_out[1]")
                          #wait 1000
                          #write(io, False, "tool_out[0]")
                          #write(io, True, "tool_out[1]")

                  def gripper_off():
                      write(io, False, "tool_out[0]")
                      write(io, True, "tool_out[1]")

                  def get_axis_position():
                      return read(opcua, liftkit_position)

                  def move_axis(position_in_mm):
                      move via p2p() to home
                      sync
                      call(opcua, liftkit_move, position_in_mm + 0.01)
                      wait 1500
                      while read(opcua, liftkit_status) == "MOVING":
                          wait 500

                  def calculate_drop_poses(initial_drop_pose):
                      poses = {}
                      for c = 0..<cols:
                          for r = 0..<rows:
                              offset_x = r * box_offset
                              offset_y = c * box_offset
                              drop_pose = initial_drop_pose :: [0, 0, 0, 0, 0, 0 * pi / 4] :: [-c * box_width - offset_y, -r * box_length - offset_x, 0, 0, 0, 0] :: [0, 0, 0, 0, 0, 0 * pi / 4]
                              poses = poses + {drop_pose}
                      return poses

                  def pick_next_box():
                      move via p2p() to pick_pose :: [0, 0, -300]
                      move via line() to pick_pose
                      sync
                      toggle_gripper(True)
                      move via line() to pick_pose :: [0, 0, -300]
                      move via p2p() to home

                  def drop_box(drop_pose):
                      move via p2p() to pre_drop_pose
                      sync
                      move via p2p() to drop_pose :: approach_vector
                      move via line() to drop_pose
                      sync
                      wait 200
                      # BUG: does not respect the wait without the movement
                      toggle_gripper(False)
                      move via p2p() to [0, 0, 1, 0, 0, 0] :: drop_pose
                      sync
                      wait 1000
                      sync
                      move via p2p() to [0, 0, 0, 0, 0, 0] :: drop_pose
                      sync
                      gripper_off()
                      move via line() to drop_pose :: approach_vector
                      move via p2p() to pre_drop_pose
                      move via p2p() to home

                  poses = calculate_drop_poses(drop_pose)

                  gripper_off()
                  # call(opcua, liftkit_connect, liftkit_host)
                  velocity(1200)
                  move via p2p() to home
                  # move_axis(liftkit_pick_position)

                  for h = 0..<1:
                      # height_offset = box_height * h
                      for i = 0..len(poses) - 1:
                          # move_axis(liftkit_pick_position)
                          pick_next_box()
                          #move_axis(height_offset)
                          drop_box(poses[i])
                      move via p2p() to home

                  move via p2p() to home
                  # move_axis(liftkit_pick_position)
                  gripper_off()
              print:
                value: |
                  pos = 42.0
                  print(pos)
              assignment:
                value: |
                  int = 1
                  float = 2.0
                  str = "A string"
                  bool_true = True
                  bool_false = False
                  pose = [100, 0, 0, 0, 3.14, 0]
                  vec = [200, 100, 0]
                  arr = {1, 2, 3, 4}
              context:
                value: |-
                  def modifier(pose):
                      tmp = __default_orientation
                      __default_orientation = pose
                      def on_exit():
                          __default_orientation = tmp
                      return on_exit
                  __default_orientation = 'last'
                  a = __default_orientation
                  with modifier([0, 0, 0, 0, 0, 0]):
                      b = __default_orientation
                  c = a
              wp469:
                value: |
                  home = [1200, -100, 300, 0, pi, 0]

                  velocity(2000)
                  move via p2p() to home
                  move via p2p() to home :: [0, 0, 100, 0, 0, 0]
                  move via p2p() to home :: [0, 0, -100, 0, 0, 0]
                  with velocity(100):
                      move via arc(home :: [0, 100, 200, 0, 0, 0]) to home :: [0, 0, 400, 0, 0, 0] with velocity(100)
              comments:
                value: |
                  a = 0 # This is an end of line comment
                  b = 1 # This as well # and it has the comment marker inside
                  # This is a full line comment which should not reassign b  b = 2

                  # This is a comment with an empty line before
                  c = 1
                  # This is a comment with an empty line after

                  d = 1

                  # This is a comment with empty lines before and after

                      # We also allow indented comments

                  def foo():
                      # And comments inside of functions
                      a = 2
                      def bar():
                          # In nested functions even
                          a = 3
                          pass  # End of line comments still work here too
              switch:
                value: |
                  s = "c"
                  b = 0
                  switch s:
                  case "a": b = 2
                  case "b": b = 3
                  case "c": b = 4
                  case "c": b = 5
                  default: b = 6
              pose_handling:
                value: |-
                  [tcp | flange] = [0, 0, 100, 0, 0, 0]
                  [object | tcp] = [100, 30, 0, pi, 0, 0]
                  [robot2 | object] = [0, -300, 0, 0, 0, 0]
                  flange2robot = [robot2 | flange]
              vision_move:
                value: |-
                  [flange | tool] = [0, 0, 1, 0, 0, 0]
                  [robot_ | object] = [1, 0, 0, 0, 0, 0]
                  move [object | tool] via p2p() to [10, 20, 30, 0, 0, 0]
                  b = [robot_ | flange]
                  move [robot_ | flange] via p2p() to [0, 0, 10, 0, 0, 0] :: [robot_ | flange]
                  c = [robot_ | flange]
              edge_pattern_line:
                value: |-

                  start_left = [775.2, -473.7, 262.2, 2.916, -0.062, 1.195]  # pose whose xy-plane is parallel to the left surface and the origin is close to start position
                  end_left = [795.4, 60.7, 272.7, 2.92, -0.062, 1.185]  # pose whose xy-plane is parallel to the left surface and the origin is close to end position
                  start_right = [799.8, -467.0, 265.4, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to start position
                  end_right = [817.1, 54.6, 255.7, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to end position
                  radius = 8  # the desired radius of the final edge
                  spacing = 40  #  the distance between to zig-zag corners
                  edge_poses = find_edge_from_4_poses(start_left, end_left, start_right, end_right)
                  start  = to_position(edge_poses[0])
                  end = to_position(edge_poses[1])
                  n = int(distance(start, end) / spacing)
                  plane_orientations = {to_orientation(edge_poses[0]), to_orientation(edge_poses[1])}
                  center_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)
                  offset = [0, 0, -radius, 0, 0, 0]
                  offset_from_axis = center_rotation ::[0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0]:: ~center_rotation
                  b = 0

                  start_poses = {}
                  end_poses = {}
                  steps = {}

                  for i = 0..10:
                      steps = steps + {i * 0.1}

                  for i = 0..<len(steps):
                      p = steps[i]
                      interpolated_rotation = interpolate(plane_orientations[0], plane_orientations[1], p)
                      start_poses = start_poses + {to_pose(start) :: offset_from_axis :: interpolated_rotation :: offset}
                      end_poses = end_poses + {to_pose(end) :: offset_from_axis :: interpolated_rotation :: offset}

                  move via p2p() to [0, 0, 100, 0, 0, 0]::to_pose(start)::offset_from_axis :: plane_orientations[0] :: offset::[0, 0, -100, 0, 0, 0]
                  sync
                  ci = 0
                  for i = 0..<(int(len(steps) / 2) + 1):
                      move via line() to start_poses[ci]
                      move via line() to end_poses[ci]

                      if (ci + 1) < len(steps):
                          move via line() to end_poses[ci + 1]
                          move via line() to start_poses[ci + 1]

                          if (ci + 2) < len(steps):
                              move via line() to start_poses[ci + 2]

                      ci = ci + 2

                      if i == 1:
                          python_print(planned_pose())
                          test_pose = planned_pose()

                  sync
              edge_pattern_manhatten:
                value: |-
                  start_left = [775.2, -473.7, 262.2, 2.916, -0.062, 1.195]  # pose whose xy-plane is parallel to the left surface and the origin is close to start position
                  end_left = [795.4, 60.7, 272.7, 2.92, -0.062, 1.185]  # pose whose xy-plane is parallel to the left surface and the origin is close to end position
                  start_right = [799.8, -467.0, 265.4, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to start position
                  end_right = [817.1, 54.6, 255.7, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to end position
                  radius = 8  # the desired radius of the final edge
                  spacing = 40  #  the distance between to zig-zag corners
                  edge_poses = find_edge_from_4_poses(start_left, end_left, start_right, end_right)
                  start  = to_position(edge_poses[0])
                  end  = to_position(edge_poses[1])
                  n = int(distance(start, end) / spacing)
                  plane_orientations = {to_orientation(edge_poses[0]), to_orientation(edge_poses[1])}
                  center_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)
                  offset = [0, 0, -radius, 0, 0, 0]
                  offset_from_axis = center_rotation ::[0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0]:: ~center_rotation

                  move via p2p() to [0, 0, 100, 0, 0, 0]::to_pose(start)::offset_from_axis :: plane_orientations[0] :: offset::[0, 0, -100, 0, 0, 0]
                  move via line() to to_pose(start)::offset_from_axis :: plane_orientations[0] :: offset
                  for i = 0..<int(n / 2):
                      a = interpolate(to_pose(start), to_pose(end), (2 * i) / n )  :: offset_from_axis :: center_rotation :: offset
                      b = interpolate(to_pose(start), to_pose(end), (2 * i) / n )  :: offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset
                      c = interpolate(to_pose(start), to_pose(end), (2 * i + 2) / n )  :: offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset
                      move via arc(a) to b
                      move via line() to c

                      if i == 1:
                          python_print(planned_pose())
                          test_pose = planned_pose()
              async_write:
                value: |
                  write(io, True, 'tool_out[0]')
                  move via p2p() to [-200, -600, 300, 0, -3, 0]
                  write(io, False, 'tool_out[0]')
                  move via line() to [-200, -600, 100]
                  a = read(io, 'tool_out[0]')
                  write(io, True, 'tool_out[0]')
                  move via line() to [-200, -600, 150]
                  b = read(io, 'tool_out[0]')
              coordinate_systems:
                value: |-
                  g = 1
                  [a | b] = [0, 0, 10, 0, 0, 0]
                  [b | c] = [0, 5, 0, 0, 0, 0]
                  d = [c | a]
              wp393:
                value: |
                  home = [100, -300, 500, 0, pi, 0]

                  velocity(50)
                  move via p2p() to home
                  move via line() to home :: [0, 0, 100]
                  sync
                  move via line() to home :: [100, 0, 0]
                  # move via line() to home :: [100, 0, 0]
              wait:
                value: wait 10
              scope:
                value: |-
                  # This is the global scope
                  g = "global"

                  def get_global():
                      return g

                  def set_global(value):
                      g = value

                  def local_modified_by_local_setter():
                      outer_var = "outer value"

                      def get_outer():
                          return outer_var

                      def set_outer(value):
                          outer_var = value

                      set_outer("outer modified")
                      return get_outer

                  def local_modified_by_2nd_level_local_setter():
                      outer_var = "outer value"

                      def get_outer():
                          return outer_var

                      def get_setter():
                          def set_outer(value):
                              outer_var = value
                          return set_outer

                      set_outer = get_setter()
                      set_outer("outer modified")
                      return get_outer

                  def definition_order_inside_closure():
                      def get_outer():
                          return outer_var

                      def set_outer(value):
                          outer_var = value

                      set_outer("outer modified")
                      outer_var = "outer value"
                      return get_outer


                  global_before_modification = get_global()
                  set_global("global modified")
                  global_after_modification = get_global()

                  getter = local_modified_by_local_setter()
                  g_local_modified_by_local_setter = getter()

                  getter = local_modified_by_2nd_level_local_setter()
                  g_local_modified_by_2nd_level_local_setter = getter()

                  getter = definition_order_inside_closure()
                  g_definition_order_inside_closure = getter()
              find_edge_from_4_poses:
                value: |-
                  start_left = [775.2, -473.7, 262.2, 2.916, -0.062, 1.195]  # pose whose xy-plane is parallel to the left surface and the origin is close to start position
                  end_left = [795.4, 60.7, 272.7, 2.92, -0.062, 1.185]  # pose whose xy-plane is parallel to the left surface and the origin is close to end position
                  start_right = [799.8, -467.0, 265.4, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to start position
                  end_right = [817.1, 54.6, 255.7, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to end position
                  radius = 8  # the desired radius of the final edge
                  spacing = 40  #  the distance between to zig-zag corners

                  edge_poses = find_edge_from_4_poses(start_left, end_left, start_right, end_right)
                  start  = to_position(edge_poses[0])
                  end  = to_position(edge_poses[1])
                  n = int(distance(start, end) / spacing)
                  plane_orientations = {to_orientation(edge_poses[0]), to_orientation(edge_poses[1])}
                  center_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)

                  offset = [0, 0, -radius, 0, 0, 0]
                  offset_from_axis =  center_rotation ::[0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0]:: ~center_rotation
                  b = 0

                  move via p2p() to [0, 0, 100, 0, 0, 0] :: to_pose(start) :: offset_from_axis :: plane_orientations[0] :: offset :: [0, 0, -100, 0, 0, 0]
                  move via line() to to_pose(start) :: offset_from_axis :: plane_orientations[0] :: offset
                  sync
                  write(io, True, "10020#0009")
                  sync
                  for i = 0..<int(n / 2):
                      c = b
                      a = interpolate(to_pose(start), to_pose(end),(2 * i + 1) / n )  ::offset_from_axis :: center_rotation :: offset
                      b = interpolate(to_pose(start), to_pose(end),(2 * i + 2) / n )  ::offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset
                      python_print(to_position(b))
                      move via arc(a) to b
                      # FIX: without the following line the last motion is a circular and the first motion cannot be a circular
                      move via p2p() to b
                      if i == 1:
                          test_pose = planned_pose()
                  sync
                  write(io, False, "10020#0009")
                  sync
              move:
                value: |-
                  move via p2p() to [0, 0, 0, 0, 0, 0]
                  move frame("flange") to [1, 2, 0]
                  move via line() to [1, 1, 0]
                  a = planned_pose()
              spline:
                value: |-
                  a = {}
                  a = a + {{0, [1,2,3,2,2,1]}}
                  a = a + {{1, [2,2,3,4,5,6]}}
                  a = a + {{2, [3,2,3,4,5,6]}}
                  a = a + {{3, [4,2,3,4,5,6]}}
                  a = a + {{4, [5,2,3,4,5,6]}}
                  a = a + {{3, [4,2,3,4,5,6]}}
                  a = a + {{3, [4,6,3,4,5,6]}}
                  a = a + {{3, [4,5,3,4,5,6]}}
                  a = a + {{3, [4,2,8,4,5,6]}}
                  a = a + {{3, [4,2,3,9,5,6]}}
                  move via p2p() to [1,2,3,2,2,1]
                  move via spline(a) to {}
              move_via_expression:
                value: |-
                  move via p2p() to [0, 0, 0 + 3, 0, 2 - 3, 0 + 2]
                  move via line() to [1, 1, 0]
                  a = planned_pose()
              array:
                value: |
                  a = {1, 2, 3, 4, {5, 6}}
                  b = a[2]
                  c = a[4]
                  d = c[1]
                  e = c[1]
                  empty = {}
              interrupt:
                value: |-
                  a = {}
                  interrupt inter1(param, pose) when on_robot_moves():
                      a = a + {pose}
                  home = [832, -452, 289, 0, pi, 0]
                  activate inter1
                  move via p2p() to home
                  move via line() to [0, 0, 100, 0, 0, 0] :: home
                  move via line() to [0, 50, 0, 0, 0, 0] :: home
                  sync
                  l = len(a)
                  deactivate inter1
              tower_of_hanoi:
                value: |-
                  # Global reference positions
                  home = [-145.5, -578.3, 77, 0.000, 3.142, 0.000]
                  approach = [0, 0, -100, 0, 0, 0]
                  rod_left = [-247.1, -726.4, -94, 0.000, pi, 0.000]
                  rod_right = [-39.9, -726.4, -94, 0.000, pi, 0.000]
                  rod_center = interpolate(rod_left, rod_right, 0.5)
                  rods = {rod_left, rod_center, rod_center}
                  disk_height = (158.0 - 125) / 4
                  state = {3, 0, 0}
                  write(hanoi_state, 5, 0)
                  write(hanoi_state, 0, 1)
                  write(hanoi_state, 0, 2)

                  velocity(300)

                  def set_gripper(close):
                      sync
                      write(io, close == False, "tool_out[0]")
                      write(io, close, "tool_out[1]")
                      wait(500)

                  def action(pose, close):
                      move via line() to pose :: approach
                      move via line() to pose
                      set_gripper(close)
                      velocity(100)
                      move via line() to pose :: approach
                      velocity(300)

                  def move_disk(source, target):
                      write(hanoi_state, read(hanoi_state, source) - 1, source)
                      action(rods[source]:: [0, 0, - disk_height * read(hanoi_state, source), 0, 0, 0], True)
                      action(rods[target]:: [0, 0, - disk_height * read(hanoi_state, target), 0, 0, 0], False)
                      write(hanoi_state, read(hanoi_state, target) + 1, target)
                  def tower_of_hanoi(n , source, destination, auxiliary):
                      if n == 1:
                          move_disk(source, destination)
                      else:
                          tower_of_hanoi(n - 1, source, auxiliary, destination)
                          move_disk(source, destination)
                          tower_of_hanoi(n - 1, auxiliary, destination, source)
                  move via p2p() to home
                  tower_of_hanoi(5, 0, 1, 2)
                  state = {read(hanoi_state, 0), read(hanoi_state, 1), read(hanoi_state, 2)}
                  move via line() to home
              io:
                value: |-
                  write(io, 1, "tool0")
                  a = read(io, "tool0")
                  write(io, 2, "tool0")
                  b = read(io, "tool0")
              edge_pattern:
                value: |-
                  start = [832, -452, 289]  # The start position of the edge
                  end = [817, 168, 288]  # The end position of the edge
                  point_a = [602, 163, -100]  # Any point on the left plane (looking from start to end)
                  point_b = [1033, 173, -100]  # Any point on the right plane (looking from start to end)
                  radius = 20  # the desired radius of the final edge
                  spacing = 10  #  the distance between to zig-zag corners

                  n = int(distance(start, end) / spacing)

                  edge_poses = find_edge(start, end, point_a, start, end,point_b)
                  plane_orientations = {to_orientation(edge_poses[0]), to_orientation(edge_poses[1])}
                  center_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)

                  offset = [0, 0, -radius, 0, 0, 0]
                  offset_from_axis =  center_rotation ::[0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0]:: ~center_rotation

                  move via p2p() to to_pose(start)::offset_from_axis :: plane_orientations[0] :: offset
                  for i = 0..<int(n / 2) - 1:
                      a = interpolate(to_pose(start), to_pose(end),(2 * i + 1) / n )  ::offset_from_axis :: center_rotation :: offset
                      b = interpolate(to_pose(start), to_pose(end),(2 * i + 2) / n )  ::offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset
                      move via arc(a) to b
                      if i == 10:
                          test_pose = planned_pose()
              pose:
                value: |
                  a = [4, 5, 6, 1, 2, 3]
                  b = a
                  c = [7, 8, 9]
                  d = a :: c

                  # read pose components
                  a_x = a[0]
                  a_rz = a[5]

                  # using negative indices
                  a_rx = a[-3]

                  # read position/orientation vector components)
                  c_y = c[1]

                  # "setting" pose/position/orientation components
                  a_new_y = assoc(a, 1, 0)
                  c_new_z = assoc(c, 2, c[0])

                  # also using negative indices
                  c_new_y = assoc(c, -2, 42)
              function:
                value: |-
                  def square(a):
                      return a * a
                  a = square(12)
                  def power2(c, e):
                      if e:
                          result = c * power2(c, e - 1)
                      else:
                          result = 1
                      return result
                  b = power2(3, 4)
              blending:
                value: |
                  home = [-200, -600, 250, 0, -pi, 0]

                  velocity(1000)

                  move via p2p() to home
                  move via line() to [0, 200, 0, 0, 0, 0] :: home with blending(500)
                  move via line() to [200, 200, 0, 0, 0, 0] :: home
                  move via line() to [0, 200, 0, 0, 0, 0] :: home
                  move via p2p() to home
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProgramRunnerReference'
        '400':
          description: Either a syntax or a runtime error
        '404':
          description: Not found
        '406':
          description: A program runner is already running
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
        '452':
          description: |
            Robot is not able to perform the motion due to hard or soft restrictions.

            This can be due to a variety of reasons:

            - The robot is too close to a singularity
            - The robot is too close to a joint limit
            - Robot control could not be enabled
            - A Robot Control mode change occured during the motion

            In the case of an error, the full error will be returned in the response body.
        '500':
          description: Internal server error
  /cells/{cell}/programs/runners/stop:
    post:
      tags:
        - Program
      summary: Stop All Program Runners
      description: Stop all runners.
      operationId: stopAllProgramRunner
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema: {}
        '400':
          description: Either a syntax or a runtime error
        '404':
          description: Not found
        '452':
          description: |
            Robot is not able to perform the motion due to hard or soft restrictions.
            This can be due to a variety of reasons:

            - The robot is too close to a singularity,
            - The robot is too close to a joint limit,
            - Robot operating mode could not be set to the desired mode,
            - An operating mode change occurred during the motion.

            In the case of an error, the full error will be returned in the response body.
        '500':
          description: Internal server error
  /cells/{cell}/programs/runners/{runner}:
    get:
      tags:
        - Program
      summary: Get Program Runner
      description: |-
        Returns information about a program currently executed.
        When a program is finished: Program response, result, collected Wandelscript logs, ..
        When a program is running: Running status, current executed line, ...

        ## Parameters
        - **runner_id**: The id of the program runner
      operationId: getProgramRunner
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Runner'
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProgramRun'
        '400':
          description: Either a syntax or a runtime error
        '404':
          description: Not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
        '452':
          description: |
            Robot is not able to perform the motion due to hard or soft restrictions.
            This can be due to a variety of reasons:

            - The robot is too close to a singularity,
            - The robot is too close to a joint limit,
            - Robot operating mode could not be set to the desired mode,
            - An operating mode change occurred during the motion.

            In the case of an error, the full error will be returned in the response body.
        '500':
          description: Internal server error
  /cells/{cell}/programs/runners/{runner}/stop:
    post:
      tags:
        - Program
      summary: Stop Program Runner
      description: |-
        Stop a specific program runner.
        Note: A 204 will also be thrown if the runner is not running.

        ## Parameters
        - **runner_id**: The id of the program runner
      operationId: stopProgramRunner
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Runner'
      responses:
        '204':
          description: Successful Response
        '400':
          description: Either a syntax or a runtime error
        '404':
          description: Not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
        '452':
          description: |
            Robot is not able to perform the motion due to hard or soft restrictions.
            This can be due to a variety of reasons:

            - The robot is too close to a singularity,
            - The robot is too close to a joint limit,
            - Robot operating mode could not be set to the desired mode,
            - An operating mode change occurred during the motion.

            In the case of an error, the full error will be returned in the response body.
        '500':
          description: Internal server error
  /cells/{cell}/programs/execute:
    post:
      tags:
        - Program
      summary: Execute Program
      description: |
        Execute a program in Wandelscript. The Wandelscript can also move multiple robots by using the 'do with' syntax.

        The execute operation will be started from the current joint configuration of any addressed robot(s).

        Addressed robots have to be in control mode for the execute operation to succeed.

        A request to this endpoint will block this endpoint until the program has been executed, or until an error occurs.

        The executed movement is returned in case of a succesful execution.
        Otherwise an error (e.g. out of reach, singularity), is returned.

        The Wandelscript can either be submitted as is, using Content-type text/plain,
        or as content-type application/json with the Wandelscript under "code" alongside a set of values provided under "initial_state".

        * [WandelEngine & Wandelscript Documentation](/docs/docs/wandelscript)
      operationId: executeProgram
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CodeWithArguments'
            examples:
              default:
                value:
                  code: |
                    home = read(arguments, "home")
                    for i = 0..5:
                        move via p2p() to home
                        move via line() to [50, 20, 30, 0, 0, 0.3] :: home
                        move via line() to [150, 20, 30, 0, 0, 0.3] :: home
                        move via line() to [50, 20, 30, 0, 0, 0.3] :: home
                        move via p2p() to home
                  initial_state:
                    home:
                      pose:
                        - -189
                        - -600
                        - 260
                        - 0
                        - -3.156
                        - 0
          text/plain:
            schema:
              anyOf:
                - type: string
                  description: Wandelscript code string which describes a Program as text/plain
                - $ref: '#/components/schemas/CodeWithArguments'
              title: Request
              description: Wandelscript code string which describes a Program as text/plain
            examples:
              default:
                value: |
                  home = [-189, -600, 260, 0, -pi, 0]

                  for i = 0..5:
                      move via p2p() to home
                      move via line() to [50, 20, 30, 0, 0, 0.3] :: home
                      move via line() to [150, 20, 30, 0, 0, 0.3] :: home
                      move via line() to [50, 20, 30, 0, 0, 0.3] :: home
                      move via p2p() to home
              whitespaces:
                value: |
                  a = 1
                  b = 2

                  c = 3
              interpolation:
                value: |
                  a = [0, 0, 10, 0, 0, 0]
                  b = [0, 0, 20, 0, 0, 0]
                  c = interpolate(a, b, 0.5)
                  d = [0, 0, 0, 0, 0, 0]
                  e = [0, 0, 20, 1, 2, 0]
                  f = interpolate(d, e, 0.5)
              ifelse:
                value: |
                  s = "c"
                  if s == "a":
                      a = 2
                  elif s == "b":
                      a = 3
                  elif s == "c":
                      a = 4
                  elif s == "c":
                      a = 5
                  else:
                      a = 6
              tcp_change:
                value: |-
                  flange = frame("flange")
                  tool = frame("tool")
                  move via p2p() to [0, 0, 0, 0, 0, 0]
                  move flange to [1, 2, 0]
                  a = planned_pose()
                  sync
                  move tool to [1, 2, 0]
                  b = planned_pose()
              loops:
                value: |-
                  a = 0
                  for i in 0..10:
                      a = a + i
                  b = 0
                  for i = 0..10: b = b + i
                  c = 0
                  for i = 0..<10:
                      c = c + i
                      c = c + 0
                  d = 0
                  i = 0
                  while i < 10:
                      d = d + i
                      i = i + 1
              try:
                value: |
                  do:
                      move via p2p() to [0, 0, 1, 0, 0, 0]
                      move via p2p() to [0, 0, 2, 0, 0, 0]
                      raise "some artificial error"
                      move via p2p() to [0, 0, 4, 0, 0, 0]
                  sync:
                      print("Hello World")
                  except:
                      stopped_pose = read(robot, 'pose')
                      move via p2p() to [0, 0, 10, 0, 0, 0]
                      final_pose = read(robot, 'pose')
              get_pose:
                value: |-
                  move via p2p() to [1, 2, 3, 2, 2, 0]
                  move via line() to [10, 2, 3, 2, 2, 0]
                  a = planned_pose()
                  python_print(a)
                  b = read(robot, 'pose')
                  python_print(b)
              move_with_velocity:
                value: |
                  with velocity(100):
                      velocity_uninitialized_global_inside_context = __ms_velocity
                      move via p2p() to [243, -440, 241, 0, 3, 0]
                  velocity_global_default = __ms_velocity
                  velocity(200)
                  velocity_global_set = __ms_velocity
                  move via p2p() to [150, -355, 389, 0, 3, 0]
                  move via line() to [150, -355, 392, 0, 3, 0]
                  move via line() to [-95, -363, 387] with velocity(300)
                  velocity_global_after_motion_modifier = __ms_velocity
                  with velocity(400):
                      velocity_global_inside_context = __ms_velocity
                      move via line() to [243, -440, 241]
                  velocity_global_after_context = __ms_velocity
                  a = planned_pose()
              empty:
                value: ''
              expressions:
                value: |-
                  a = 1 + 4
                  b = 4 * 2 + 3
                  c = 3 + 4 * 2
                  d = (3 + 4) * 2
                  e = a * 4
                  f = 4 - 6
                  g = 3 - 2
                  h = - 8 + 5
                  i = - (8 + 5)
                  k = 3 < 4
                  l, m = {1, 4}
              palletizing-ur10e-liftkit:
                value: |
                  liftkit_position = "2:EwellixLiftkit0S/Position"
                  liftkit_status = "2:EwellixLiftkit0S/Status"
                  liftkit_move = "2:EwellixLiftkit0S/Move(newPosition)"
                  liftkit_connect = "2:EwellixLiftkit0S/Connect(host)"
                  liftkit_host = "192.168.1.100"

                  box_length = read(database, "box_length")
                  box_width = read(database, "box_width")
                  box_height = read(database, "box_height")
                  pallet_length = box_length * 3
                  pallet_width = box_width * 2
                  pallet_layers = 1
                  box_offset = read(database, "box_offset")

                  home = [-536, -399, 621, 2.88, -1.25507, 0]
                  pick_pose = [-925, 207, -243, 2.88, -1.2, -0.11] # read(database, "pickup_base")
                  pre_drop_pose = [404, -632, 587, 2.88, -1.25507, 0]
                  drop_pose = [320, -1074, -250, 2.88, -1.25507, 0]
                  # drop_pose = [966, -420, -256, 2.88, -1.25507, 0] # read(database, "dropoff_base")
                  # other drop pose [-30, -701, -246, 2.88, -1.2, -0.11]

                  approach_vector = [0, 0, -300]
                  liftkit_pick_position = 0.0
                  cols = floor(pallet_width / box_width)
                  rows = floor(pallet_length / box_length)

                  def toggle_gripper(vacuum):
                      if vacuum:
                          write(io, False, "tool_out[0]")
                          write(io, False, "tool_out[1]")
                      else:
                          write(io, True, "tool_out[0]")
                          write(io, True, "tool_out[1]")
                          #wait 1000
                          #write(io, False, "tool_out[0]")
                          #write(io, True, "tool_out[1]")

                  def gripper_off():
                      write(io, False, "tool_out[0]")
                      write(io, True, "tool_out[1]")

                  def get_axis_position():
                      return read(opcua, liftkit_position)

                  def move_axis(position_in_mm):
                      move via p2p() to home
                      sync
                      call(opcua, liftkit_move, position_in_mm + 0.01)
                      wait 1500
                      while read(opcua, liftkit_status) == "MOVING":
                          wait 500

                  def calculate_drop_poses(initial_drop_pose):
                      poses = {}
                      for c = 0..<cols:
                          for r = 0..<rows:
                              offset_x = r * box_offset
                              offset_y = c * box_offset
                              drop_pose = initial_drop_pose :: [0, 0, 0, 0, 0, 0 * pi / 4] :: [-c * box_width - offset_y, -r * box_length - offset_x, 0, 0, 0, 0] :: [0, 0, 0, 0, 0, 0 * pi / 4]
                              poses = poses + {drop_pose}
                      return poses

                  def pick_next_box():
                      move via p2p() to pick_pose :: [0, 0, -300]
                      move via line() to pick_pose
                      sync
                      toggle_gripper(True)
                      move via line() to pick_pose :: [0, 0, -300]
                      move via p2p() to home

                  def drop_box(drop_pose):
                      move via p2p() to pre_drop_pose
                      sync
                      move via p2p() to drop_pose :: approach_vector
                      move via line() to drop_pose
                      sync
                      wait 200
                      # BUG: does not respect the wait without the movement
                      toggle_gripper(False)
                      move via p2p() to [0, 0, 1, 0, 0, 0] :: drop_pose
                      sync
                      wait 1000
                      sync
                      move via p2p() to [0, 0, 0, 0, 0, 0] :: drop_pose
                      sync
                      gripper_off()
                      move via line() to drop_pose :: approach_vector
                      move via p2p() to pre_drop_pose
                      move via p2p() to home

                  poses = calculate_drop_poses(drop_pose)

                  gripper_off()
                  # call(opcua, liftkit_connect, liftkit_host)
                  velocity(1200)
                  move via p2p() to home
                  # move_axis(liftkit_pick_position)

                  for h = 0..<1:
                      # height_offset = box_height * h
                      for i = 0..len(poses) - 1:
                          # move_axis(liftkit_pick_position)
                          pick_next_box()
                          #move_axis(height_offset)
                          drop_box(poses[i])
                      move via p2p() to home

                  move via p2p() to home
                  # move_axis(liftkit_pick_position)
                  gripper_off()
              print:
                value: |
                  pos = 42.0
                  print(pos)
              assignment:
                value: |
                  int = 1
                  float = 2.0
                  str = "A string"
                  bool_true = True
                  bool_false = False
                  pose = [100, 0, 0, 0, 3.14, 0]
                  vec = [200, 100, 0]
                  arr = {1, 2, 3, 4}
              context:
                value: |-
                  def modifier(pose):
                      tmp = __default_orientation
                      __default_orientation = pose
                      def on_exit():
                          __default_orientation = tmp
                      return on_exit
                  __default_orientation = 'last'
                  a = __default_orientation
                  with modifier([0, 0, 0, 0, 0, 0]):
                      b = __default_orientation
                  c = a
              wp469:
                value: |
                  home = [1200, -100, 300, 0, pi, 0]

                  velocity(2000)
                  move via p2p() to home
                  move via p2p() to home :: [0, 0, 100, 0, 0, 0]
                  move via p2p() to home :: [0, 0, -100, 0, 0, 0]
                  with velocity(100):
                      move via arc(home :: [0, 100, 200, 0, 0, 0]) to home :: [0, 0, 400, 0, 0, 0] with velocity(100)
              comments:
                value: |
                  a = 0 # This is an end of line comment
                  b = 1 # This as well # and it has the comment marker inside
                  # This is a full line comment which should not reassign b  b = 2

                  # This is a comment with an empty line before
                  c = 1
                  # This is a comment with an empty line after

                  d = 1

                  # This is a comment with empty lines before and after

                      # We also allow indented comments

                  def foo():
                      # And comments inside of functions
                      a = 2
                      def bar():
                          # In nested functions even
                          a = 3
                          pass  # End of line comments still work here too
              switch:
                value: |
                  s = "c"
                  b = 0
                  switch s:
                  case "a": b = 2
                  case "b": b = 3
                  case "c": b = 4
                  case "c": b = 5
                  default: b = 6
              pose_handling:
                value: |-
                  [tcp | flange] = [0, 0, 100, 0, 0, 0]
                  [object | tcp] = [100, 30, 0, pi, 0, 0]
                  [robot2 | object] = [0, -300, 0, 0, 0, 0]
                  flange2robot = [robot2 | flange]
              vision_move:
                value: |-
                  [flange | tool] = [0, 0, 1, 0, 0, 0]
                  [robot_ | object] = [1, 0, 0, 0, 0, 0]
                  move [object | tool] via p2p() to [10, 20, 30, 0, 0, 0]
                  b = [robot_ | flange]
                  move [robot_ | flange] via p2p() to [0, 0, 10, 0, 0, 0] :: [robot_ | flange]
                  c = [robot_ | flange]
              edge_pattern_line:
                value: |-

                  start_left = [775.2, -473.7, 262.2, 2.916, -0.062, 1.195]  # pose whose xy-plane is parallel to the left surface and the origin is close to start position
                  end_left = [795.4, 60.7, 272.7, 2.92, -0.062, 1.185]  # pose whose xy-plane is parallel to the left surface and the origin is close to end position
                  start_right = [799.8, -467.0, 265.4, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to start position
                  end_right = [817.1, 54.6, 255.7, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to end position
                  radius = 8  # the desired radius of the final edge
                  spacing = 40  #  the distance between to zig-zag corners
                  edge_poses = find_edge_from_4_poses(start_left, end_left, start_right, end_right)
                  start  = to_position(edge_poses[0])
                  end = to_position(edge_poses[1])
                  n = int(distance(start, end) / spacing)
                  plane_orientations = {to_orientation(edge_poses[0]), to_orientation(edge_poses[1])}
                  center_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)
                  offset = [0, 0, -radius, 0, 0, 0]
                  offset_from_axis = center_rotation ::[0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0]:: ~center_rotation
                  b = 0

                  start_poses = {}
                  end_poses = {}
                  steps = {}

                  for i = 0..10:
                      steps = steps + {i * 0.1}

                  for i = 0..<len(steps):
                      p = steps[i]
                      interpolated_rotation = interpolate(plane_orientations[0], plane_orientations[1], p)
                      start_poses = start_poses + {to_pose(start) :: offset_from_axis :: interpolated_rotation :: offset}
                      end_poses = end_poses + {to_pose(end) :: offset_from_axis :: interpolated_rotation :: offset}

                  move via p2p() to [0, 0, 100, 0, 0, 0]::to_pose(start)::offset_from_axis :: plane_orientations[0] :: offset::[0, 0, -100, 0, 0, 0]
                  sync
                  ci = 0
                  for i = 0..<(int(len(steps) / 2) + 1):
                      move via line() to start_poses[ci]
                      move via line() to end_poses[ci]

                      if (ci + 1) < len(steps):
                          move via line() to end_poses[ci + 1]
                          move via line() to start_poses[ci + 1]

                          if (ci + 2) < len(steps):
                              move via line() to start_poses[ci + 2]

                      ci = ci + 2

                      if i == 1:
                          python_print(planned_pose())
                          test_pose = planned_pose()

                  sync
              edge_pattern_manhatten:
                value: |-
                  start_left = [775.2, -473.7, 262.2, 2.916, -0.062, 1.195]  # pose whose xy-plane is parallel to the left surface and the origin is close to start position
                  end_left = [795.4, 60.7, 272.7, 2.92, -0.062, 1.185]  # pose whose xy-plane is parallel to the left surface and the origin is close to end position
                  start_right = [799.8, -467.0, 265.4, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to start position
                  end_right = [817.1, 54.6, 255.7, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to end position
                  radius = 8  # the desired radius of the final edge
                  spacing = 40  #  the distance between to zig-zag corners
                  edge_poses = find_edge_from_4_poses(start_left, end_left, start_right, end_right)
                  start  = to_position(edge_poses[0])
                  end  = to_position(edge_poses[1])
                  n = int(distance(start, end) / spacing)
                  plane_orientations = {to_orientation(edge_poses[0]), to_orientation(edge_poses[1])}
                  center_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)
                  offset = [0, 0, -radius, 0, 0, 0]
                  offset_from_axis = center_rotation ::[0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0]:: ~center_rotation

                  move via p2p() to [0, 0, 100, 0, 0, 0]::to_pose(start)::offset_from_axis :: plane_orientations[0] :: offset::[0, 0, -100, 0, 0, 0]
                  move via line() to to_pose(start)::offset_from_axis :: plane_orientations[0] :: offset
                  for i = 0..<int(n / 2):
                      a = interpolate(to_pose(start), to_pose(end), (2 * i) / n )  :: offset_from_axis :: center_rotation :: offset
                      b = interpolate(to_pose(start), to_pose(end), (2 * i) / n )  :: offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset
                      c = interpolate(to_pose(start), to_pose(end), (2 * i + 2) / n )  :: offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset
                      move via arc(a) to b
                      move via line() to c

                      if i == 1:
                          python_print(planned_pose())
                          test_pose = planned_pose()
              async_write:
                value: |
                  write(io, True, 'tool_out[0]')
                  move via p2p() to [-200, -600, 300, 0, -3, 0]
                  write(io, False, 'tool_out[0]')
                  move via line() to [-200, -600, 100]
                  a = read(io, 'tool_out[0]')
                  write(io, True, 'tool_out[0]')
                  move via line() to [-200, -600, 150]
                  b = read(io, 'tool_out[0]')
              coordinate_systems:
                value: |-
                  g = 1
                  [a | b] = [0, 0, 10, 0, 0, 0]
                  [b | c] = [0, 5, 0, 0, 0, 0]
                  d = [c | a]
              wp393:
                value: |
                  home = [100, -300, 500, 0, pi, 0]

                  velocity(50)
                  move via p2p() to home
                  move via line() to home :: [0, 0, 100]
                  sync
                  move via line() to home :: [100, 0, 0]
                  # move via line() to home :: [100, 0, 0]
              wait:
                value: wait 10
              scope:
                value: |-
                  # This is the global scope
                  g = "global"

                  def get_global():
                      return g

                  def set_global(value):
                      g = value

                  def local_modified_by_local_setter():
                      outer_var = "outer value"

                      def get_outer():
                          return outer_var

                      def set_outer(value):
                          outer_var = value

                      set_outer("outer modified")
                      return get_outer

                  def local_modified_by_2nd_level_local_setter():
                      outer_var = "outer value"

                      def get_outer():
                          return outer_var

                      def get_setter():
                          def set_outer(value):
                              outer_var = value
                          return set_outer

                      set_outer = get_setter()
                      set_outer("outer modified")
                      return get_outer

                  def definition_order_inside_closure():
                      def get_outer():
                          return outer_var

                      def set_outer(value):
                          outer_var = value

                      set_outer("outer modified")
                      outer_var = "outer value"
                      return get_outer


                  global_before_modification = get_global()
                  set_global("global modified")
                  global_after_modification = get_global()

                  getter = local_modified_by_local_setter()
                  g_local_modified_by_local_setter = getter()

                  getter = local_modified_by_2nd_level_local_setter()
                  g_local_modified_by_2nd_level_local_setter = getter()

                  getter = definition_order_inside_closure()
                  g_definition_order_inside_closure = getter()
              find_edge_from_4_poses:
                value: |-
                  start_left = [775.2, -473.7, 262.2, 2.916, -0.062, 1.195]  # pose whose xy-plane is parallel to the left surface and the origin is close to start position
                  end_left = [795.4, 60.7, 272.7, 2.92, -0.062, 1.185]  # pose whose xy-plane is parallel to the left surface and the origin is close to end position
                  start_right = [799.8, -467.0, 265.4, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to start position
                  end_right = [817.1, 54.6, 255.7, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to end position
                  radius = 8  # the desired radius of the final edge
                  spacing = 40  #  the distance between to zig-zag corners

                  edge_poses = find_edge_from_4_poses(start_left, end_left, start_right, end_right)
                  start  = to_position(edge_poses[0])
                  end  = to_position(edge_poses[1])
                  n = int(distance(start, end) / spacing)
                  plane_orientations = {to_orientation(edge_poses[0]), to_orientation(edge_poses[1])}
                  center_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)

                  offset = [0, 0, -radius, 0, 0, 0]
                  offset_from_axis =  center_rotation ::[0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0]:: ~center_rotation
                  b = 0

                  move via p2p() to [0, 0, 100, 0, 0, 0] :: to_pose(start) :: offset_from_axis :: plane_orientations[0] :: offset :: [0, 0, -100, 0, 0, 0]
                  move via line() to to_pose(start) :: offset_from_axis :: plane_orientations[0] :: offset
                  sync
                  write(io, True, "10020#0009")
                  sync
                  for i = 0..<int(n / 2):
                      c = b
                      a = interpolate(to_pose(start), to_pose(end),(2 * i + 1) / n )  ::offset_from_axis :: center_rotation :: offset
                      b = interpolate(to_pose(start), to_pose(end),(2 * i + 2) / n )  ::offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset
                      python_print(to_position(b))
                      move via arc(a) to b
                      # FIX: without the following line the last motion is a circular and the first motion cannot be a circular
                      move via p2p() to b
                      if i == 1:
                          test_pose = planned_pose()
                  sync
                  write(io, False, "10020#0009")
                  sync
              move:
                value: |-
                  move via p2p() to [0, 0, 0, 0, 0, 0]
                  move frame("flange") to [1, 2, 0]
                  move via line() to [1, 1, 0]
                  a = planned_pose()
              spline:
                value: |-
                  a = {}
                  a = a + {{0, [1,2,3,2,2,1]}}
                  a = a + {{1, [2,2,3,4,5,6]}}
                  a = a + {{2, [3,2,3,4,5,6]}}
                  a = a + {{3, [4,2,3,4,5,6]}}
                  a = a + {{4, [5,2,3,4,5,6]}}
                  a = a + {{3, [4,2,3,4,5,6]}}
                  a = a + {{3, [4,6,3,4,5,6]}}
                  a = a + {{3, [4,5,3,4,5,6]}}
                  a = a + {{3, [4,2,8,4,5,6]}}
                  a = a + {{3, [4,2,3,9,5,6]}}
                  move via p2p() to [1,2,3,2,2,1]
                  move via spline(a) to {}
              move_via_expression:
                value: |-
                  move via p2p() to [0, 0, 0 + 3, 0, 2 - 3, 0 + 2]
                  move via line() to [1, 1, 0]
                  a = planned_pose()
              array:
                value: |
                  a = {1, 2, 3, 4, {5, 6}}
                  b = a[2]
                  c = a[4]
                  d = c[1]
                  e = c[1]
                  empty = {}
              interrupt:
                value: |-
                  a = {}
                  interrupt inter1(param, pose) when on_robot_moves():
                      a = a + {pose}
                  home = [832, -452, 289, 0, pi, 0]
                  activate inter1
                  move via p2p() to home
                  move via line() to [0, 0, 100, 0, 0, 0] :: home
                  move via line() to [0, 50, 0, 0, 0, 0] :: home
                  sync
                  l = len(a)
                  deactivate inter1
              tower_of_hanoi:
                value: |-
                  # Global reference positions
                  home = [-145.5, -578.3, 77, 0.000, 3.142, 0.000]
                  approach = [0, 0, -100, 0, 0, 0]
                  rod_left = [-247.1, -726.4, -94, 0.000, pi, 0.000]
                  rod_right = [-39.9, -726.4, -94, 0.000, pi, 0.000]
                  rod_center = interpolate(rod_left, rod_right, 0.5)
                  rods = {rod_left, rod_center, rod_center}
                  disk_height = (158.0 - 125) / 4
                  state = {3, 0, 0}
                  write(hanoi_state, 5, 0)
                  write(hanoi_state, 0, 1)
                  write(hanoi_state, 0, 2)

                  velocity(300)

                  def set_gripper(close):
                      sync
                      write(io, close == False, "tool_out[0]")
                      write(io, close, "tool_out[1]")
                      wait(500)

                  def action(pose, close):
                      move via line() to pose :: approach
                      move via line() to pose
                      set_gripper(close)
                      velocity(100)
                      move via line() to pose :: approach
                      velocity(300)

                  def move_disk(source, target):
                      write(hanoi_state, read(hanoi_state, source) - 1, source)
                      action(rods[source]:: [0, 0, - disk_height * read(hanoi_state, source), 0, 0, 0], True)
                      action(rods[target]:: [0, 0, - disk_height * read(hanoi_state, target), 0, 0, 0], False)
                      write(hanoi_state, read(hanoi_state, target) + 1, target)
                  def tower_of_hanoi(n , source, destination, auxiliary):
                      if n == 1:
                          move_disk(source, destination)
                      else:
                          tower_of_hanoi(n - 1, source, auxiliary, destination)
                          move_disk(source, destination)
                          tower_of_hanoi(n - 1, auxiliary, destination, source)
                  move via p2p() to home
                  tower_of_hanoi(5, 0, 1, 2)
                  state = {read(hanoi_state, 0), read(hanoi_state, 1), read(hanoi_state, 2)}
                  move via line() to home
              io:
                value: |-
                  write(io, 1, "tool0")
                  a = read(io, "tool0")
                  write(io, 2, "tool0")
                  b = read(io, "tool0")
              edge_pattern:
                value: |-
                  start = [832, -452, 289]  # The start position of the edge
                  end = [817, 168, 288]  # The end position of the edge
                  point_a = [602, 163, -100]  # Any point on the left plane (looking from start to end)
                  point_b = [1033, 173, -100]  # Any point on the right plane (looking from start to end)
                  radius = 20  # the desired radius of the final edge
                  spacing = 10  #  the distance between to zig-zag corners

                  n = int(distance(start, end) / spacing)

                  edge_poses = find_edge(start, end, point_a, start, end,point_b)
                  plane_orientations = {to_orientation(edge_poses[0]), to_orientation(edge_poses[1])}
                  center_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)

                  offset = [0, 0, -radius, 0, 0, 0]
                  offset_from_axis =  center_rotation ::[0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0]:: ~center_rotation

                  move via p2p() to to_pose(start)::offset_from_axis :: plane_orientations[0] :: offset
                  for i = 0..<int(n / 2) - 1:
                      a = interpolate(to_pose(start), to_pose(end),(2 * i + 1) / n )  ::offset_from_axis :: center_rotation :: offset
                      b = interpolate(to_pose(start), to_pose(end),(2 * i + 2) / n )  ::offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset
                      move via arc(a) to b
                      if i == 10:
                          test_pose = planned_pose()
              pose:
                value: |
                  a = [4, 5, 6, 1, 2, 3]
                  b = a
                  c = [7, 8, 9]
                  d = a :: c

                  # read pose components
                  a_x = a[0]
                  a_rz = a[5]

                  # using negative indices
                  a_rx = a[-3]

                  # read position/orientation vector components)
                  c_y = c[1]

                  # "setting" pose/position/orientation components
                  a_new_y = assoc(a, 1, 0)
                  c_new_z = assoc(c, 2, c[0])

                  # also using negative indices
                  c_new_y = assoc(c, -2, 42)
              function:
                value: |-
                  def square(a):
                      return a * a
                  a = square(12)
                  def power2(c, e):
                      if e:
                          result = c * power2(c, e - 1)
                      else:
                          result = 1
                      return result
                  b = power2(3, 4)
              blending:
                value: |
                  home = [-200, -600, 250, 0, -pi, 0]

                  velocity(1000)

                  move via p2p() to home
                  move via line() to [0, 200, 0, 0, 0, 0] :: home with blending(500)
                  move via line() to [200, 200, 0, 0, 0, 0] :: home
                  move via line() to [0, 200, 0, 0, 0, 0] :: home
                  move via p2p() to home
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProgramRun'
        '400':
          description: Either a syntax or a runtime error
        '404':
          description: Not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
        '452':
          description: |
            Robot is not able to perform the motion due to hard or soft restrictions.
            This can be due to a variety of reasons:

            - The robot is too close to a singularity,
            - The robot is too close to a joint limit,
            - Robot operating mode could not be set to the desired mode,
            - An operating mode change occurred during the motion.

            In the case of an error, the full error will be returned in the response body.
        '500':
          description: Internal server error
  /cells/{cell}/programs/plan:
    post:
      tags:
        - Program
      summary: Plan Program
      description: |
        Plan a program based on the specified robot type.

        The plan operation can be used to check if a Wandelscript is executable,
        given the current joint configuration of the robot.

        If the Wandelscript is executable, the result contains the motion path.
        If the Wandelscript is not executable, e.g. points that are out of reach, or the joints encounter a singularity, the
        reason is returned.

        The plan operation can be used in other operating modes besides control mode.

        The Wandelscript can either be submitted as is, using Content-type text/plain,
        or as content-type application/json with the Wandelscript under "code" alongside a set of values provided under "initial_state".

        The plan operation can be used in other operating modes besides control mode.

        The Wandelscript can either be submitted as is, using Content-type text/plain,
        or as Content-type application/json with the Wandelscript under "code" alongside a set of values provided under "initial_state".

        * [WandelEngine & Wandelscript Documentation](/docs/docs/wandelscript)
      operationId: planProgram
      parameters:
        - $ref: '#/components/parameters/Cell'
        - name: identifier
          in: query
          required: false
          schema:
            type: string
            default: robot
            title: Identifier
      requestBody:
        required: true
        content:
          text/plain:
            schema:
              anyOf:
                - type: string
                  description: Wandelscript code string which describes a Program as text/plain
                - $ref: '#/components/schemas/CodeWithArguments'
              description: Wandelscript code string which describes a Program as text/plain
              title: Request
            examples:
              default:
                value: |
                  home = [-189, -600, 260, 0, -pi, 0]

                  for i = 0..5:
                      move via p2p() to home
                      move via line() to [50, 20, 30, 0, 0, 0.3] :: home
                      move via line() to [150, 20, 30, 0, 0, 0.3] :: home
                      move via line() to [50, 20, 30, 0, 0, 0.3] :: home
                      move via p2p() to home
              whitespaces:
                value: |
                  a = 1
                  b = 2

                  c = 3
              interpolation:
                value: |
                  a = [0, 0, 10, 0, 0, 0]
                  b = [0, 0, 20, 0, 0, 0]
                  c = interpolate(a, b, 0.5)
                  d = [0, 0, 0, 0, 0, 0]
                  e = [0, 0, 20, 1, 2, 0]
                  f = interpolate(d, e, 0.5)
              ifelse:
                value: |
                  s = "c"
                  if s == "a":
                      a = 2
                  elif s == "b":
                      a = 3
                  elif s == "c":
                      a = 4
                  elif s == "c":
                      a = 5
                  else:
                      a = 6
              tcp_change:
                value: |-
                  flange = frame("flange")
                  tool = frame("tool")
                  move via p2p() to [0, 0, 0, 0, 0, 0]
                  move flange to [1, 2, 0]
                  a = planned_pose()
                  sync
                  move tool to [1, 2, 0]
                  b = planned_pose()
              loops:
                value: |-
                  a = 0
                  for i in 0..10:
                      a = a + i
                  b = 0
                  for i = 0..10: b = b + i
                  c = 0
                  for i = 0..<10:
                      c = c + i
                      c = c + 0
                  d = 0
                  i = 0
                  while i < 10:
                      d = d + i
                      i = i + 1
              try:
                value: |
                  do:
                      move via p2p() to [0, 0, 1, 0, 0, 0]
                      move via p2p() to [0, 0, 2, 0, 0, 0]
                      raise "some artificial error"
                      move via p2p() to [0, 0, 4, 0, 0, 0]
                  sync:
                      print("Hello World")
                  except:
                      stopped_pose = read(robot, 'pose')
                      move via p2p() to [0, 0, 10, 0, 0, 0]
                      final_pose = read(robot, 'pose')
              get_pose:
                value: |-
                  move via p2p() to [1, 2, 3, 2, 2, 0]
                  move via line() to [10, 2, 3, 2, 2, 0]
                  a = planned_pose()
                  python_print(a)
                  b = read(robot, 'pose')
                  python_print(b)
              move_with_velocity:
                value: |
                  with velocity(100):
                      velocity_uninitialized_global_inside_context = __ms_velocity
                      move via p2p() to [243, -440, 241, 0, 3, 0]
                  velocity_global_default = __ms_velocity
                  velocity(200)
                  velocity_global_set = __ms_velocity
                  move via p2p() to [150, -355, 389, 0, 3, 0]
                  move via line() to [150, -355, 392, 0, 3, 0]
                  move via line() to [-95, -363, 387] with velocity(300)
                  velocity_global_after_motion_modifier = __ms_velocity
                  with velocity(400):
                      velocity_global_inside_context = __ms_velocity
                      move via line() to [243, -440, 241]
                  velocity_global_after_context = __ms_velocity
                  a = planned_pose()
              empty:
                value: ''
              expressions:
                value: |-
                  a = 1 + 4
                  b = 4 * 2 + 3
                  c = 3 + 4 * 2
                  d = (3 + 4) * 2
                  e = a * 4
                  f = 4 - 6
                  g = 3 - 2
                  h = - 8 + 5
                  i = - (8 + 5)
                  k = 3 < 4
                  l, m = {1, 4}
              palletizing-ur10e-liftkit:
                value: |
                  liftkit_position = "2:EwellixLiftkit0S/Position"
                  liftkit_status = "2:EwellixLiftkit0S/Status"
                  liftkit_move = "2:EwellixLiftkit0S/Move(newPosition)"
                  liftkit_connect = "2:EwellixLiftkit0S/Connect(host)"
                  liftkit_host = "192.168.1.100"

                  box_length = read(database, "box_length")
                  box_width = read(database, "box_width")
                  box_height = read(database, "box_height")
                  pallet_length = box_length * 3
                  pallet_width = box_width * 2
                  pallet_layers = 1
                  box_offset = read(database, "box_offset")

                  home = [-536, -399, 621, 2.88, -1.25507, 0]
                  pick_pose = [-925, 207, -243, 2.88, -1.2, -0.11] # read(database, "pickup_base")
                  pre_drop_pose = [404, -632, 587, 2.88, -1.25507, 0]
                  drop_pose = [320, -1074, -250, 2.88, -1.25507, 0]
                  # drop_pose = [966, -420, -256, 2.88, -1.25507, 0] # read(database, "dropoff_base")
                  # other drop pose [-30, -701, -246, 2.88, -1.2, -0.11]

                  approach_vector = [0, 0, -300]
                  liftkit_pick_position = 0.0
                  cols = floor(pallet_width / box_width)
                  rows = floor(pallet_length / box_length)

                  def toggle_gripper(vacuum):
                      if vacuum:
                          write(io, False, "tool_out[0]")
                          write(io, False, "tool_out[1]")
                      else:
                          write(io, True, "tool_out[0]")
                          write(io, True, "tool_out[1]")
                          #wait 1000
                          #write(io, False, "tool_out[0]")
                          #write(io, True, "tool_out[1]")

                  def gripper_off():
                      write(io, False, "tool_out[0]")
                      write(io, True, "tool_out[1]")

                  def get_axis_position():
                      return read(opcua, liftkit_position)

                  def move_axis(position_in_mm):
                      move via p2p() to home
                      sync
                      call(opcua, liftkit_move, position_in_mm + 0.01)
                      wait 1500
                      while read(opcua, liftkit_status) == "MOVING":
                          wait 500

                  def calculate_drop_poses(initial_drop_pose):
                      poses = {}
                      for c = 0..<cols:
                          for r = 0..<rows:
                              offset_x = r * box_offset
                              offset_y = c * box_offset
                              drop_pose = initial_drop_pose :: [0, 0, 0, 0, 0, 0 * pi / 4] :: [-c * box_width - offset_y, -r * box_length - offset_x, 0, 0, 0, 0] :: [0, 0, 0, 0, 0, 0 * pi / 4]
                              poses = poses + {drop_pose}
                      return poses

                  def pick_next_box():
                      move via p2p() to pick_pose :: [0, 0, -300]
                      move via line() to pick_pose
                      sync
                      toggle_gripper(True)
                      move via line() to pick_pose :: [0, 0, -300]
                      move via p2p() to home

                  def drop_box(drop_pose):
                      move via p2p() to pre_drop_pose
                      sync
                      move via p2p() to drop_pose :: approach_vector
                      move via line() to drop_pose
                      sync
                      wait 200
                      # BUG: does not respect the wait without the movement
                      toggle_gripper(False)
                      move via p2p() to [0, 0, 1, 0, 0, 0] :: drop_pose
                      sync
                      wait 1000
                      sync
                      move via p2p() to [0, 0, 0, 0, 0, 0] :: drop_pose
                      sync
                      gripper_off()
                      move via line() to drop_pose :: approach_vector
                      move via p2p() to pre_drop_pose
                      move via p2p() to home

                  poses = calculate_drop_poses(drop_pose)

                  gripper_off()
                  # call(opcua, liftkit_connect, liftkit_host)
                  velocity(1200)
                  move via p2p() to home
                  # move_axis(liftkit_pick_position)

                  for h = 0..<1:
                      # height_offset = box_height * h
                      for i = 0..len(poses) - 1:
                          # move_axis(liftkit_pick_position)
                          pick_next_box()
                          #move_axis(height_offset)
                          drop_box(poses[i])
                      move via p2p() to home

                  move via p2p() to home
                  # move_axis(liftkit_pick_position)
                  gripper_off()
              print:
                value: |
                  pos = 42.0
                  print(pos)
              assignment:
                value: |
                  int = 1
                  float = 2.0
                  str = "A string"
                  bool_true = True
                  bool_false = False
                  pose = [100, 0, 0, 0, 3.14, 0]
                  vec = [200, 100, 0]
                  arr = {1, 2, 3, 4}
              context:
                value: |-
                  def modifier(pose):
                      tmp = __default_orientation
                      __default_orientation = pose
                      def on_exit():
                          __default_orientation = tmp
                      return on_exit
                  __default_orientation = 'last'
                  a = __default_orientation
                  with modifier([0, 0, 0, 0, 0, 0]):
                      b = __default_orientation
                  c = a
              wp469:
                value: |
                  home = [1200, -100, 300, 0, pi, 0]

                  velocity(2000)
                  move via p2p() to home
                  move via p2p() to home :: [0, 0, 100, 0, 0, 0]
                  move via p2p() to home :: [0, 0, -100, 0, 0, 0]
                  with velocity(100):
                      move via arc(home :: [0, 100, 200, 0, 0, 0]) to home :: [0, 0, 400, 0, 0, 0] with velocity(100)
              comments:
                value: |
                  a = 0 # This is an end of line comment
                  b = 1 # This as well # and it has the comment marker inside
                  # This is a full line comment which should not reassign b  b = 2

                  # This is a comment with an empty line before
                  c = 1
                  # This is a comment with an empty line after

                  d = 1

                  # This is a comment with empty lines before and after

                      # We also allow indented comments

                  def foo():
                      # And comments inside of functions
                      a = 2
                      def bar():
                          # In nested functions even
                          a = 3
                          pass  # End of line comments still work here too
              switch:
                value: |
                  s = "c"
                  b = 0
                  switch s:
                  case "a": b = 2
                  case "b": b = 3
                  case "c": b = 4
                  case "c": b = 5
                  default: b = 6
              pose_handling:
                value: |-
                  [tcp | flange] = [0, 0, 100, 0, 0, 0]
                  [object | tcp] = [100, 30, 0, pi, 0, 0]
                  [robot2 | object] = [0, -300, 0, 0, 0, 0]
                  flange2robot = [robot2 | flange]
              vision_move:
                value: |-
                  [flange | tool] = [0, 0, 1, 0, 0, 0]
                  [robot_ | object] = [1, 0, 0, 0, 0, 0]
                  move [object | tool] via p2p() to [10, 20, 30, 0, 0, 0]
                  b = [robot_ | flange]
                  move [robot_ | flange] via p2p() to [0, 0, 10, 0, 0, 0] :: [robot_ | flange]
                  c = [robot_ | flange]
              edge_pattern_line:
                value: |-

                  start_left = [775.2, -473.7, 262.2, 2.916, -0.062, 1.195]  # pose whose xy-plane is parallel to the left surface and the origin is close to start position
                  end_left = [795.4, 60.7, 272.7, 2.92, -0.062, 1.185]  # pose whose xy-plane is parallel to the left surface and the origin is close to end position
                  start_right = [799.8, -467.0, 265.4, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to start position
                  end_right = [817.1, 54.6, 255.7, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to end position
                  radius = 8  # the desired radius of the final edge
                  spacing = 40  #  the distance between to zig-zag corners
                  edge_poses = find_edge_from_4_poses(start_left, end_left, start_right, end_right)
                  start  = to_position(edge_poses[0])
                  end = to_position(edge_poses[1])
                  n = int(distance(start, end) / spacing)
                  plane_orientations = {to_orientation(edge_poses[0]), to_orientation(edge_poses[1])}
                  center_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)
                  offset = [0, 0, -radius, 0, 0, 0]
                  offset_from_axis = center_rotation ::[0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0]:: ~center_rotation
                  b = 0

                  start_poses = {}
                  end_poses = {}
                  steps = {}

                  for i = 0..10:
                      steps = steps + {i * 0.1}

                  for i = 0..<len(steps):
                      p = steps[i]
                      interpolated_rotation = interpolate(plane_orientations[0], plane_orientations[1], p)
                      start_poses = start_poses + {to_pose(start) :: offset_from_axis :: interpolated_rotation :: offset}
                      end_poses = end_poses + {to_pose(end) :: offset_from_axis :: interpolated_rotation :: offset}

                  move via p2p() to [0, 0, 100, 0, 0, 0]::to_pose(start)::offset_from_axis :: plane_orientations[0] :: offset::[0, 0, -100, 0, 0, 0]
                  sync
                  ci = 0
                  for i = 0..<(int(len(steps) / 2) + 1):
                      move via line() to start_poses[ci]
                      move via line() to end_poses[ci]

                      if (ci + 1) < len(steps):
                          move via line() to end_poses[ci + 1]
                          move via line() to start_poses[ci + 1]

                          if (ci + 2) < len(steps):
                              move via line() to start_poses[ci + 2]

                      ci = ci + 2

                      if i == 1:
                          python_print(planned_pose())
                          test_pose = planned_pose()

                  sync
              edge_pattern_manhatten:
                value: |-
                  start_left = [775.2, -473.7, 262.2, 2.916, -0.062, 1.195]  # pose whose xy-plane is parallel to the left surface and the origin is close to start position
                  end_left = [795.4, 60.7, 272.7, 2.92, -0.062, 1.185]  # pose whose xy-plane is parallel to the left surface and the origin is close to end position
                  start_right = [799.8, -467.0, 265.4, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to start position
                  end_right = [817.1, 54.6, 255.7, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to end position
                  radius = 8  # the desired radius of the final edge
                  spacing = 40  #  the distance between to zig-zag corners
                  edge_poses = find_edge_from_4_poses(start_left, end_left, start_right, end_right)
                  start  = to_position(edge_poses[0])
                  end  = to_position(edge_poses[1])
                  n = int(distance(start, end) / spacing)
                  plane_orientations = {to_orientation(edge_poses[0]), to_orientation(edge_poses[1])}
                  center_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)
                  offset = [0, 0, -radius, 0, 0, 0]
                  offset_from_axis = center_rotation ::[0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0]:: ~center_rotation

                  move via p2p() to [0, 0, 100, 0, 0, 0]::to_pose(start)::offset_from_axis :: plane_orientations[0] :: offset::[0, 0, -100, 0, 0, 0]
                  move via line() to to_pose(start)::offset_from_axis :: plane_orientations[0] :: offset
                  for i = 0..<int(n / 2):
                      a = interpolate(to_pose(start), to_pose(end), (2 * i) / n )  :: offset_from_axis :: center_rotation :: offset
                      b = interpolate(to_pose(start), to_pose(end), (2 * i) / n )  :: offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset
                      c = interpolate(to_pose(start), to_pose(end), (2 * i + 2) / n )  :: offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset
                      move via arc(a) to b
                      move via line() to c

                      if i == 1:
                          python_print(planned_pose())
                          test_pose = planned_pose()
              async_write:
                value: |
                  write(io, True, 'tool_out[0]')
                  move via p2p() to [-200, -600, 300, 0, -3, 0]
                  write(io, False, 'tool_out[0]')
                  move via line() to [-200, -600, 100]
                  a = read(io, 'tool_out[0]')
                  write(io, True, 'tool_out[0]')
                  move via line() to [-200, -600, 150]
                  b = read(io, 'tool_out[0]')
              coordinate_systems:
                value: |-
                  g = 1
                  [a | b] = [0, 0, 10, 0, 0, 0]
                  [b | c] = [0, 5, 0, 0, 0, 0]
                  d = [c | a]
              wp393:
                value: |
                  home = [100, -300, 500, 0, pi, 0]

                  velocity(50)
                  move via p2p() to home
                  move via line() to home :: [0, 0, 100]
                  sync
                  move via line() to home :: [100, 0, 0]
                  # move via line() to home :: [100, 0, 0]
              wait:
                value: wait 10
              scope:
                value: |-
                  # This is the global scope
                  g = "global"

                  def get_global():
                      return g

                  def set_global(value):
                      g = value

                  def local_modified_by_local_setter():
                      outer_var = "outer value"

                      def get_outer():
                          return outer_var

                      def set_outer(value):
                          outer_var = value

                      set_outer("outer modified")
                      return get_outer

                  def local_modified_by_2nd_level_local_setter():
                      outer_var = "outer value"

                      def get_outer():
                          return outer_var

                      def get_setter():
                          def set_outer(value):
                              outer_var = value
                          return set_outer

                      set_outer = get_setter()
                      set_outer("outer modified")
                      return get_outer

                  def definition_order_inside_closure():
                      def get_outer():
                          return outer_var

                      def set_outer(value):
                          outer_var = value

                      set_outer("outer modified")
                      outer_var = "outer value"
                      return get_outer


                  global_before_modification = get_global()
                  set_global("global modified")
                  global_after_modification = get_global()

                  getter = local_modified_by_local_setter()
                  g_local_modified_by_local_setter = getter()

                  getter = local_modified_by_2nd_level_local_setter()
                  g_local_modified_by_2nd_level_local_setter = getter()

                  getter = definition_order_inside_closure()
                  g_definition_order_inside_closure = getter()
              find_edge_from_4_poses:
                value: |-
                  start_left = [775.2, -473.7, 262.2, 2.916, -0.062, 1.195]  # pose whose xy-plane is parallel to the left surface and the origin is close to start position
                  end_left = [795.4, 60.7, 272.7, 2.92, -0.062, 1.185]  # pose whose xy-plane is parallel to the left surface and the origin is close to end position
                  start_right = [799.8, -467.0, 265.4, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to start position
                  end_right = [817.1, 54.6, 255.7, 2.866, -0.213, -1.158]  # pose whose xy-plane is parallel to the right surface and the origin is close to end position
                  radius = 8  # the desired radius of the final edge
                  spacing = 40  #  the distance between to zig-zag corners

                  edge_poses = find_edge_from_4_poses(start_left, end_left, start_right, end_right)
                  start  = to_position(edge_poses[0])
                  end  = to_position(edge_poses[1])
                  n = int(distance(start, end) / spacing)
                  plane_orientations = {to_orientation(edge_poses[0]), to_orientation(edge_poses[1])}
                  center_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)

                  offset = [0, 0, -radius, 0, 0, 0]
                  offset_from_axis =  center_rotation ::[0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0]:: ~center_rotation
                  b = 0

                  move via p2p() to [0, 0, 100, 0, 0, 0] :: to_pose(start) :: offset_from_axis :: plane_orientations[0] :: offset :: [0, 0, -100, 0, 0, 0]
                  move via line() to to_pose(start) :: offset_from_axis :: plane_orientations[0] :: offset
                  sync
                  write(io, True, "10020#0009")
                  sync
                  for i = 0..<int(n / 2):
                      c = b
                      a = interpolate(to_pose(start), to_pose(end),(2 * i + 1) / n )  ::offset_from_axis :: center_rotation :: offset
                      b = interpolate(to_pose(start), to_pose(end),(2 * i + 2) / n )  ::offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset
                      python_print(to_position(b))
                      move via arc(a) to b
                      # FIX: without the following line the last motion is a circular and the first motion cannot be a circular
                      move via p2p() to b
                      if i == 1:
                          test_pose = planned_pose()
                  sync
                  write(io, False, "10020#0009")
                  sync
              move:
                value: |-
                  move via p2p() to [0, 0, 0, 0, 0, 0]
                  move frame("flange") to [1, 2, 0]
                  move via line() to [1, 1, 0]
                  a = planned_pose()
              spline:
                value: |-
                  a = {}
                  a = a + {{0, [1,2,3,2,2,1]}}
                  a = a + {{1, [2,2,3,4,5,6]}}
                  a = a + {{2, [3,2,3,4,5,6]}}
                  a = a + {{3, [4,2,3,4,5,6]}}
                  a = a + {{4, [5,2,3,4,5,6]}}
                  a = a + {{3, [4,2,3,4,5,6]}}
                  a = a + {{3, [4,6,3,4,5,6]}}
                  a = a + {{3, [4,5,3,4,5,6]}}
                  a = a + {{3, [4,2,8,4,5,6]}}
                  a = a + {{3, [4,2,3,9,5,6]}}
                  move via p2p() to [1,2,3,2,2,1]
                  move via spline(a) to {}
              move_via_expression:
                value: |-
                  move via p2p() to [0, 0, 0 + 3, 0, 2 - 3, 0 + 2]
                  move via line() to [1, 1, 0]
                  a = planned_pose()
              array:
                value: |
                  a = {1, 2, 3, 4, {5, 6}}
                  b = a[2]
                  c = a[4]
                  d = c[1]
                  e = c[1]
                  empty = {}
              interrupt:
                value: |-
                  a = {}
                  interrupt inter1(param, pose) when on_robot_moves():
                      a = a + {pose}
                  home = [832, -452, 289, 0, pi, 0]
                  activate inter1
                  move via p2p() to home
                  move via line() to [0, 0, 100, 0, 0, 0] :: home
                  move via line() to [0, 50, 0, 0, 0, 0] :: home
                  sync
                  l = len(a)
                  deactivate inter1
              tower_of_hanoi:
                value: |-
                  # Global reference positions
                  home = [-145.5, -578.3, 77, 0.000, 3.142, 0.000]
                  approach = [0, 0, -100, 0, 0, 0]
                  rod_left = [-247.1, -726.4, -94, 0.000, pi, 0.000]
                  rod_right = [-39.9, -726.4, -94, 0.000, pi, 0.000]
                  rod_center = interpolate(rod_left, rod_right, 0.5)
                  rods = {rod_left, rod_center, rod_center}
                  disk_height = (158.0 - 125) / 4
                  state = {3, 0, 0}
                  write(hanoi_state, 5, 0)
                  write(hanoi_state, 0, 1)
                  write(hanoi_state, 0, 2)

                  velocity(300)

                  def set_gripper(close):
                      sync
                      write(io, close == False, "tool_out[0]")
                      write(io, close, "tool_out[1]")
                      wait(500)

                  def action(pose, close):
                      move via line() to pose :: approach
                      move via line() to pose
                      set_gripper(close)
                      velocity(100)
                      move via line() to pose :: approach
                      velocity(300)

                  def move_disk(source, target):
                      write(hanoi_state, read(hanoi_state, source) - 1, source)
                      action(rods[source]:: [0, 0, - disk_height * read(hanoi_state, source), 0, 0, 0], True)
                      action(rods[target]:: [0, 0, - disk_height * read(hanoi_state, target), 0, 0, 0], False)
                      write(hanoi_state, read(hanoi_state, target) + 1, target)
                  def tower_of_hanoi(n , source, destination, auxiliary):
                      if n == 1:
                          move_disk(source, destination)
                      else:
                          tower_of_hanoi(n - 1, source, auxiliary, destination)
                          move_disk(source, destination)
                          tower_of_hanoi(n - 1, auxiliary, destination, source)
                  move via p2p() to home
                  tower_of_hanoi(5, 0, 1, 2)
                  state = {read(hanoi_state, 0), read(hanoi_state, 1), read(hanoi_state, 2)}
                  move via line() to home
              io:
                value: |-
                  write(io, 1, "tool0")
                  a = read(io, "tool0")
                  write(io, 2, "tool0")
                  b = read(io, "tool0")
              edge_pattern:
                value: |-
                  start = [832, -452, 289]  # The start position of the edge
                  end = [817, 168, 288]  # The end position of the edge
                  point_a = [602, 163, -100]  # Any point on the left plane (looking from start to end)
                  point_b = [1033, 173, -100]  # Any point on the right plane (looking from start to end)
                  radius = 20  # the desired radius of the final edge
                  spacing = 10  #  the distance between to zig-zag corners

                  n = int(distance(start, end) / spacing)

                  edge_poses = find_edge(start, end, point_a, start, end,point_b)
                  plane_orientations = {to_orientation(edge_poses[0]), to_orientation(edge_poses[1])}
                  center_rotation = interpolate(plane_orientations[0], plane_orientations[1], 0.5)

                  offset = [0, 0, -radius, 0, 0, 0]
                  offset_from_axis =  center_rotation ::[0, 0, distance_from_corner(edge_poses[0], edge_poses[1], radius), 0, 0, 0]:: ~center_rotation

                  move via p2p() to to_pose(start)::offset_from_axis :: plane_orientations[0] :: offset
                  for i = 0..<int(n / 2) - 1:
                      a = interpolate(to_pose(start), to_pose(end),(2 * i + 1) / n )  ::offset_from_axis :: center_rotation :: offset
                      b = interpolate(to_pose(start), to_pose(end),(2 * i + 2) / n )  ::offset_from_axis :: plane_orientations[modulo(i + 1, 2)] :: offset
                      move via arc(a) to b
                      if i == 10:
                          test_pose = planned_pose()
              pose:
                value: |
                  a = [4, 5, 6, 1, 2, 3]
                  b = a
                  c = [7, 8, 9]
                  d = a :: c

                  # read pose components
                  a_x = a[0]
                  a_rz = a[5]

                  # using negative indices
                  a_rx = a[-3]

                  # read position/orientation vector components)
                  c_y = c[1]

                  # "setting" pose/position/orientation components
                  a_new_y = assoc(a, 1, 0)
                  c_new_z = assoc(c, 2, c[0])

                  # also using negative indices
                  c_new_y = assoc(c, -2, 42)
              function:
                value: |-
                  def square(a):
                      return a * a
                  a = square(12)
                  def power2(c, e):
                      if e:
                          result = c * power2(c, e - 1)
                      else:
                          result = 1
                      return result
                  b = power2(3, 4)
              blending:
                value: |
                  home = [-200, -600, 250, 0, -pi, 0]

                  velocity(1000)

                  move via p2p() to home
                  move via line() to [0, 200, 0, 0, 0, 0] :: home with blending(500)
                  move via line() to [200, 200, 0, 0, 0, 0] :: home
                  move via line() to [0, 200, 0, 0, 0, 0] :: home
                  move via p2p() to home
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProgramRun'
        '400':
          description: Either a syntax or a runtime error
        '404':
          description: Not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
        '452':
          description: |
            Robot is not able to perform the motion due to hard or soft restrictions.
            This can be due to a variety of reasons:

            - The robot is too close to a singularity,
            - The robot is too close to a joint limit,
            - Robot operating mode could not be set to the desired mode,
            - An operating mode change occurred during the motion.

            In the case of an error, the full error will be returned in the response body.
        '500':
          description: Internal server error
  /cells/{cell}/programs/values:
    get:
      tags:
        - Program Values
      summary: Get Values
      description: |
        Gets all values that are stored in the database.

        PREREQUISITE: The database has been added as a device. Add the database with [createDevice](createDevice).

        The database itself is a key-value storage. For reference of possible data types see:

        * [Documentation for elementary data types](/docs/docs/wandelscript/data-types/#elementary-types)
      operationId: listProgramsValues
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                additionalProperties:
                  anyOf:
                    - type: number
                    - type: integer
                    - type: string
                    - type: string
                      format: binary
                    - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Pose'
                    - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Position'
                    - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Orientation'
                    - $ref: '#/components/schemas/Capture'
                    - $ref: '#/components/schemas/PointCloud'
                    - $ref: '#/components/schemas/Array-Output'
                type: object
                title: Response Get Values Programs Values Get
        '404':
          description: Value not found
    post:
      tags:
        - Program Values
      summary: Add Value(s)
      description: |
        Add or overwrite one or more values in the database.

        PREREQUISITE: The database has been added as a device. Add the database with [createDevice](createDevice).

        The database itself is a key-value store.  For reference of possible data types see:

        * [Documentation for elementary data types](/docs/docs/wandelscript/data-types/#elementary-types)
      operationId: createProgramsValue
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        content:
          application/json:
            schema:
              additionalProperties:
                anyOf:
                  - type: number
                  - type: integer
                  - type: string
                  - type: string
                    format: binary
                  - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Pose'
                  - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Position'
                  - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Orientation'
                  - $ref: '#/components/schemas/Capture'
                  - $ref: '#/components/schemas/PointCloud'
                  - $ref: '#/components/schemas/Array-Input'
              type: object
              title: Collection
        required: true
      responses:
        '204':
          description: Successful Response
        '404':
          description: Value not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    delete:
      tags:
        - Program Values
      summary: Delete All Values
      description: Delete **all** values from the database
      operationId: clearProgramsValues
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '204':
          description: Successful Response
        '404':
          description: Value not found
  /cells/{cell}/programs/values/{key}:
    delete:
      tags:
        - Program Values
      summary: Delete Value
      description: Delete a value from the database.
      operationId: deleteProgramValue
      parameters:
        - $ref: '#/components/parameters/Cell'
        - name: key
          in: path
          required: true
          schema:
            type: string
            title: Key
      responses:
        '204':
          description: Successful Response
        '404':
          description: Value not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    get:
      tags:
        - Program Values
      summary: Get Value
      description: |
        Return a value stored in the database.

        PREREQUISITE: The database has been added as a device. Add the database with [createDevice](createDevice).

        The database itself is a key-value store.  For reference of possible data types see:

        * [Documentation for elementary data types](/docs/docs/wandelscript/data-types/#elementary-types)
      operationId: getProgramValue
      parameters:
        - $ref: '#/components/parameters/Cell'
        - name: key
          in: path
          required: true
          schema:
            type: string
            title: Key
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                anyOf:
                  - type: number
                  - type: integer
                  - type: string
                  - type: string
                    format: binary
                  - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Pose'
                  - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Position'
                  - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Orientation'
                  - $ref: '#/components/schemas/Capture'
                  - $ref: '#/components/schemas/PointCloud'
                  - $ref: '#/components/schemas/Array-Output'
                title: Response Get Value Programs Values  Key  Get
        '404':
          description: Value not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    put:
      tags:
        - Program Values
      summary: Create or Update Value
      description: |
        Creates or updates a value in the database.

        PREREQUISITE: The database has been added as a device. Add the database with [createDevice](createDevice).

        The database itself is a key-value store.  For reference of possible data types see:

        * [Documentation for elementary data types](/docs/docs/wandelscript/data-types/#elementary-types)
      operationId: updateProgramValue
      parameters:
        - $ref: '#/components/parameters/Cell'
        - name: key
          in: path
          required: true
          schema:
            type: string
            title: Key
      requestBody:
        required: true
        content:
          application/json:
            schema:
              anyOf:
                - type: number
                - type: integer
                - type: string
                - type: string
                  format: binary
                - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Pose'
                - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Position'
                - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Orientation'
                - $ref: '#/components/schemas/Capture'
                - $ref: '#/components/schemas/PointCloud'
                - $ref: '#/components/schemas/Array-Input'
              title: Value
      responses:
        '204':
          description: Successful Response
        '404':
          description: Value not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /cells/{cell}/devices:
    get:
      tags:
        - Device Configuration
      summary: List All Devices
      description: |
        Lists all devices which are configured in the cell:
        - Robots
        - Databases
        - OPCUA devices
      operationId: listDevices
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                type: array
                items:
                  anyOf:
                    - $ref: '#/components/schemas/pyriphery__robotics__robotcell__Timer__Configuration'
                    - $ref: '#/components/schemas/pyriphery__etcd__ETCD__Configuration'
                    - $ref: '#/components/schemas/pyriphery__hardware__isaac__Isaac__Configuration'
                    - $ref: '#/components/schemas/pyriphery__pyrae__robot__Robot__Configuration'
                    - $ref: '#/components/schemas/pyriphery__pyrae__controller__Controller__Configuration'
                    - $ref: '#/components/schemas/pyriphery__opcua__OPCUA__Configuration'
                    - $ref: '#/components/schemas/pyriphery__robotics__simulation__SimulatedOPCUA__Configuration'
                    - $ref: '#/components/schemas/pyriphery__robotics__simulation__RobotWithViewOpen3d__Configuration'
                    - $ref: '#/components/schemas/pyriphery__robotics__simulation__SimulatedIO__Configuration'
                    - $ref: '#/components/schemas/pyriphery__robotics__configurable_collision_scene__ConfigurableCollisionScene__Configuration-Output'
                title: Response Get Devices Devices Get
    post:
      tags:
        - Device Configuration
      summary: Create Devices
      description: |-
        Overwrite existing devices in an existing robot cell. The devices are added to the robot cell in the order they are specified in the request body.
        Each device needs to have a unique identifier which is used to reference the device in Wandelscript.
        Devices which can be configured in the cell:
        - Robots - OPCUA devices
        ## Parameters
        - For more information about the available device configurations have a look at the **Schema** tab or in the
        provided examples.
      operationId: createDevice
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: array
              items:
                anyOf:
                  - $ref: '#/components/schemas/pyriphery__robotics__robotcell__Timer__Configuration'
                  - $ref: '#/components/schemas/pyriphery__etcd__ETCD__Configuration'
                  - $ref: '#/components/schemas/pyriphery__hardware__isaac__Isaac__Configuration'
                  - $ref: '#/components/schemas/pyriphery__pyrae__robot__Robot__Configuration'
                  - $ref: '#/components/schemas/pyriphery__pyrae__controller__Controller__Configuration'
                  - $ref: '#/components/schemas/pyriphery__opcua__OPCUA__Configuration'
                  - $ref: '#/components/schemas/pyriphery__robotics__simulation__SimulatedOPCUA__Configuration'
                  - $ref: '#/components/schemas/pyriphery__robotics__simulation__RobotWithViewOpen3d__Configuration'
                  - $ref: '#/components/schemas/pyriphery__robotics__simulation__SimulatedIO__Configuration'
                  - $ref: '#/components/schemas/pyriphery__robotics__configurable_collision_scene__ConfigurableCollisionScene__Configuration-Input'
              description: The devices that can be added to the environment
              title: Devices
            examples:
              all:
                summary: All devices that can be added to the environment
                value:
                  - type: timer
                    identifier: timer
                  - type: etcd
                    identifier: database
                    host: localhost
                    port: 2379
                  - type: isaac
                    identifier: isaac
                    host: 0.0.0.0
                    prim_paths: {}
                  - type: controller
                    identifier: controller
                    controller_model_name: UniversalRobots::Controller
                    host: virtual-ur10e
                    rae_host: rae
                    rae_port: 50051
                  - type: robot
                    identifier: robot
                    controller_model_name: UniversalRobots::Controller
                    rae_host: rae
                    rae_port: 50051
                    host: virtual-ur10e
                  - type: opc_ua
                    identifier: opc_ua
                    url: opc.tcp://localhost:4840/wandelbots
                  - type: simulated_opcua
                    identifier: opcua
                  - type: simulated_robot_with_view
                    identifier: robot
                  - type: simulated_io
                    identifier: io
                  - type: collision_scene
                    identifier: scene
                    robot_configurations:
                      robot:
                        use_default_link_shapes: true
              robot:
                summary: Robot configuration only
                value:
                  - type: robot
                    identifier: robot
                    controller_model_name: UniversalRobots::Controller
                    rae_host: rae
                    rae_port: 50051
                    host: virtual-ur10e
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema: {}
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    delete:
      tags:
        - Device Configuration
      summary: Delete Devices
      description: Deletes **all** devices from the cell
      operationId: clearDevices
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '204':
          description: Successful Response
  /cells/{cell}/devices/{identifier}:
    get:
      tags:
        - Device Configuration
      summary: Device Information
      description: Returns information about a device.
      operationId: getDevice
      parameters:
        - $ref: '#/components/parameters/Cell'
        - name: identifier
          in: path
          required: true
          schema:
            type: string
            title: Identifier
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema: {}
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    delete:
      tags:
        - Device Configuration
      summary: Delete Device
      description: Deletes a specific device from the cell.
      operationId: deleteDevice
      parameters:
        - $ref: '#/components/parameters/Cell'
        - name: identifier
          in: path
          required: true
          schema:
            type: string
            title: Identifier
      responses:
        '204':
          description: Successful Response
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /cells/{cell}/controllers/{controller}/teach-pendant/motiongroups:
    get:
      tags:
        - Virtual Robot
      summary: Motion Group Description
      description: |
        Gets information on the motion group.
      operationId: getMotionGroups
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MotionGroupInfos'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/ios:
    get:
      tags:
        - Virtual Robot
      summary: List I/Os
      description: |
        Lists all I/Os of the virtual controller. Every I/O contains the description and the value.

        As a virtual robot can have up to thousand I/Os, be ready to handle a large response.
        Use [List Descriptions](List Descriptions) to get a detailed description of an I/O.
      operationId: listIOs
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IOs'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/ios/{io}:
    get:
      tags:
        - Virtual Robot
      summary: Get I/O
      description: |
        Gets the description and value of a virtual controller I/O.
      operationId: getVirtualRobotIOValue
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - $ref: '#/components/parameters/IO'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/IO'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    put:
      tags:
        - Virtual Robot
      summary: Set I/O
      description: |
        Sets the value of a virtual controller I/O.
      operationId: setVirtualRobotIOValue
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - $ref: '#/components/parameters/IO'
        - name: bool
          in: query
          schema:
            type: boolean
        - name: integer
          in: query
          schema:
            type: string
        - name: double
          in: query
          schema:
            type: number
            format: double
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Empty'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/motion-groups/{id}:
    get:
      tags:
        - Virtual Robot
      summary: Get Motion Group State
      description: |
        Get the current motion group state which provides values for the joints' position, velocity and acceleration.
      operationId: getMotionGroupState
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - $ref: '#/components/parameters/Id'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MotionGroupJoints'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    put:
      tags:
        - Virtual Robot
      summary: Set Motion Group State
      description: |
        Sets the values for joint position, joint velocity or joint acceleration of a motion group state. The values are immediately applied to the joints of the motion group.
        We recommend to only use the endpoint when the motion group is in monitor mode.
        In case the motion group is controlled, currently jogging or planning motions, the values are overridden by the controller or an error may occur.
      operationId: setMotionGroupState
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - $ref: '#/components/parameters/Id'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MotionGroupJoints'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Empty'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/coordinate-systems:
    get:
      tags:
        - Virtual Robot Setup
      summary: List Coordinate Systems
      description: |
        Lists all coordinate systems on the robot controller.
      operationId: listVirtualRobotCoordinateSystems
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CoordinateSystems'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    put:
      tags:
        - Virtual Robot Setup
      summary: Add Coordinate Systems
      description: |
        Adds a coordinate system to the robot controller.
      operationId: addVirtualRobotCoordinateSystem
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CoordinateSystem'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Empty'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/coordinate-systems/{coordinate-system}:
    delete:
      tags:
        - Virtual Robot Setup
      summary: Remove Coordinate System
      description: |
        Deletes a coordinate system from the virtual controller. This will remove the coordinate system from the list of coordinate systems and remove
        all dependent coordinate systems which use the deleted coordinate system as reference.
      operationId: deleteVirtualRobotCoordinateSystem
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - $ref: '#/components/parameters/CoordinateSystem'
        - name: delete_dependent
          in: query
          schema:
            type: boolean
            default: false
          description: If true, all dependent coordinate systems will be deleted as well.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Empty'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/motion-groups/{id}/mounting:
    get:
      tags:
        - Virtual Robot Setup
      summary: Get Mounting
      description: |
        Gets motion group mounting. The motion group is based on the origin of the returned coordinate system.
      operationId: getVirtualRobotMounting
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - $ref: '#/components/parameters/Id'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CoordinateSystem'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    put:
      tags:
        - Virtual Robot Setup
      summary: Set Mounting
      description: |
        Sets motion group mounting by specifying a coordinate system. The motion group will be based on the coordinate system's origin.
        The coordinate system defines a transformation offset. The transformation offset is defined by a unique identifier,
        a name for front end usage and an offset in another coordinate system referenced by the
        unique identifier of the reference coordinate system.
      operationId: setVirtualRobotMounting
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - $ref: '#/components/parameters/Id'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CoordinateSystem'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CoordinateSystem'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/motion-groups/{id}/tcps:
    get:
      tags:
        - Virtual Robot Setup
      summary: List TCPs
      description: |
        Lists TCPs of the motion group. An empty TCP list is valid, for example for external axes.
      operationId: listVirtualRobotTcps
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - $ref: '#/components/parameters/Id'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RobotTcps'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    put:
      tags:
        - Virtual Robot Setup
      summary: Add TCP
      description: |
        Adds the new TCP or modifies the existing TCP of the motion group.

        TIP: Ensure that the position of the TCP is reachable. Refer to the robot description or its data sheet, e.g. for robot joint limits or robot reach.
      operationId: addVirtualRobotTcp
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - $ref: '#/components/parameters/Id'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RobotTcp'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Empty'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/motion-groups/{id}/tcps/{tcp}:
    delete:
      tags:
        - Virtual Robot Setup
      summary: Remove TCP
      description: |
        Removes the TCP from the motion group. An unknown TCP id is a valid input.
      operationId: deleteVirtualRobotTcp
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - $ref: '#/components/parameters/Id'
        - $ref: '#/components/parameters/Tcp'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Empty'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/estop:
    get:
      tags:
        - Virtual Robot Mode
      summary: Get E-Stop State
      description: |
        Requests the Emergency Stop state of the virtual robot controller.

        Use [getCurrentMotionGroupState](getCurrentMotionGroupState) to get the Emergency Stop state regardless of the controller type.
        There the Emergency Stop state is visible as the `safety_state`.

        **Note:**
        The Emergency Stop state can only be changed when using virtual robot controllers.
      operationId: getEStop
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Flag'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/estop/push:
    put:
      tags:
        - Virtual Robot Mode
      summary: Push E-Stop
      description: |
        Activates the Emergency Stop on the virtual robot controller.

        Activating the Emergency Stop stops the execution of all motions on virtual and physical robot controllers.
        To return to normal operation the Emergency Stop needs to be released.

        Use [getCurrentMotionGroupState](getCurrentMotionGroupState) to get the Emergency Stop state regardless of the controller type.
        There the Emergency Stop state is visible as the `safety_state`.

        **Note:**
        The Emergency Stop state can only be changed via API when using virtual robot controllers.
      operationId: pushEStop
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Empty'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/estop/release:
    put:
      tags:
        - Virtual Robot Mode
      summary: Release E-Stop
      description: |
        Releases the Emergency Stop on the virtual robot controller.

         Activating the Emergency Stop stops the execution of all motions on virtual and physical robot controllers.
        To return to normal operation the Emergency Stop needs to be released.

        Use [getCurrentMotionGroupState](getCurrentMotionGroupState) to get the Emergency Stop state regardless of the controller type.
        There the Emergency Stop state is visible as the `safety_state`.

        **Note:**
        The Emergency Stop state can only be changed via API when using virtual robot controllers.
      operationId: releaseEStop
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Empty'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/operationmode:
    get:
      tags:
        - Virtual Robot Mode
      summary: Get Operation Mode
      description: |
        Requests the Operation Mode of the virtual robot controller.

        To get the Operation Mode regardless of the controller type use [getCurrentMotionGroupState](getCurrentMotionGroupState).

        **Note:**
        The Operating Mode can only change be changed via API when using virtual robot controllers.
      operationId: getOperationMode
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/OpMode'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    put:
      tags:
        - Virtual Robot Mode
      summary: Set Operation Mode
      description: |
        Changes the Operation Mode of the virtual robot controller to the specified value.

        To get the Operation Mode regardless of the controller type use [getCurrentMotionGroupState](getCurrentMotionGroupState).

        **Note:**
         The Operating Mode can only change be changed via API when using virtual robot controllers.
      operationId: setOperationMode
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - name: mode
          in: query
          required: true
          schema:
            description: |
              Controllers have two operating modes: AUTOMATIC and MANUAL.
              MANUAL mode is mainly used for teaching a robot application.
              To ensure safe operation the velocity of the robot is limited to 250 mm/s.
              Running the finished application is done in AUTOMATIC operating mode without the limited velocity of the MANUAL mode.
            enum:
              - OPERATION_MODE_MANUAL
              - OPERATION_MODE_AUTO
            type: string
            format: enum
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Empty'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/motion-groups/{id}/behavior:
    get:
      tags:
        - Virtual Robot Behavior
      summary: Behavior
      description: Get the current robot motion group behavior - please see the setter [setMotionGroupBehavior](setMotionGroupBehavior) and the enum for details.
      operationId: getMotionGroupBehavior
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - $ref: '#/components/parameters/Id'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MotionGroupBehaviorGetter'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    put:
      tags:
        - Virtual Robot Behavior
      summary: Switch Behavior
      description: |
        Switch robot motion group behavior.
      operationId: setMotionGroupBehavior
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
        - $ref: '#/components/parameters/Id'
        - name: behavior
          in: query
          schema:
            $ref: '#/components/schemas/Behavior'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Empty'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/controllers/{controller}/teach-pendant/motion-groups/externalJointsStream:
    get:
      tags:
        - Virtual Robot Behavior
      summary: Stream Joint Configuration
      description: |
        This stream provides the commanded joint state
        and sets a motion groups joint configuration, e.g. to move a motion group.
        The concept is that an application is using the Motion Service to move a motion group.
        The Motion Service is commanding the desired joint
        configuration of a motion group.

        Physical motion groups move to this joint configuration.

        With physical motion groups, this takes some time and only works if
        possible.

        And you have the *actual* joint state - the current real motion group
        configuration.

        Again, this stream is providing *commanded* joint state!
        It is __not__ providing the *actual* joint state!
        (Please file a request - if you need a stream of the *actual* joint state)

        When the virtual controller receives joint commands the joint configuration is immediately adapted to match the incoming joint configurations.
        CAUTION: Incoming joint configurations are not visualized and their velocity limits are not checked.
        we don't even check limits!

        Possible use cases are:
        1. Creating a robotic application that dynamically adapts to the configured joints on the robot controller, using this stream to feed
        new joint configurations back to the motion group.

        The stream only sends data to the robot controller if a motion is executed.

        If the robot controller's joint configuration differs too much from the incoming joint configuration, a following error occurs.
        Joint configurations that result in following errors are executed only for motions with a low velocity.

        2. Mimic Freedrive motions.
        DANGER: If the incoming joint configuration is set to maximum velocity, the movement to reach this incoming joint configuration
        will be executed with maximum speed regardless of safety zones and mechanical limits.
      operationId: externalJointsStream
      x-bidistream: true
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ExternalJointStreamDatapoint'
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MotionGroupJoints'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /cells/{cell}/store/programs:
    get:
      tags:
        - Library Program Metadata
      summary: List Program Metadata
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Returns a list of all the stored programs, represented by their metadata.
      operationId: listProgramMetadata
      parameters:
        - $ref: '#/components/parameters/Cell'
        - description: |
            If true, hidden programs, where the `is_hidden` flag is active, are included in the list.
          required: false
          schema:
            type: boolean
            title: Show hidden
            description: |
              If true, hidden programs, where the `is_hidden` flag is active, are included in the list.
            default: false
          name: show_hidden
          in: query
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListProgramMetadataResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    post:
      tags:
        - Library Program
      summary: Create Program
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Creates a new program. The corresponding metadata is created as well.

        ## Examples

        ```
        move via p2p() to [0, 0, 0, 0, 0, 0]
        move frame("flange") to [1, 2, 0]
        move via line() to [1, 1, 0]
        a := planned_pose()
        ```

        ```
        {% from 'schneider_conveyor_v1.j2' import schneider_conveyor_library -%}

        {{ schneider_conveyor_library() }}

        def start_main():
            conveyor_speed_percentage = {{ conveyor_speed_percentage | round(4) }}
            conveyer_speed = conveyor_speed_percentage*1500
            schneider_conveyor_start(conveyer_speed)
        end
        ```
      operationId: createProgram
      parameters:
        - $ref: '#/components/parameters/Cell'
        - required: false
          schema:
            type: string
            title: Program name
            default: ''
          name: name
          in: query
      requestBody:
        content:
          text/plain:
            schema:
              type: string
              title: Program content
              description: The content of the program.
            example: |
              move via p2p() to [0, 0, 0, 0, 0, 0]
              move frame("flange") to [1, 2, 0]
              move via line() to [1, 1, 0]
              a := planned_pose()
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProgramMetadata'
        '404':
          description: Program with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Program with id `program` not found
            text/plain:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    delete:
      tags:
        - Library Program
      summary: Delete Program List
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Deletes the provided list of programs with the corresponding metadata. This action is irreversible. Does not delete the associated recipes.
      operationId: deleteProgramList
      parameters:
        - $ref: '#/components/parameters/Cell'
        - description: |
            Recieved from [listProgramMetadata](listProgramMetadata) or from the response of [createProgram](createProgram).
          required: true
          schema:
            items:
              type: string
            type: array
            title: List of program identifiers
            description: |
              Recieved from [listProgramMetadata](listProgramMetadata) or from the response of [createProgram](createProgram).
          name: program_ids
          in: query
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListProgramMetadataResponse'
        '404':
          description: Program with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Program with id `program` not found
            text/plain:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /cells/{cell}/store/programs/{program}/metadata:
    get:
      tags:
        - Library Program Metadata
      summary: Get Program Metadata
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Returns metadata of the corresponding program.
      operationId: getProgramMetadata
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Program'
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProgramMetadata'
        '404':
          description: Program with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Program with id `program` not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    put:
      tags:
        - Library Program Metadata
      summary: Update Program Metadata
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Updates the metadata of the corresponding program. The update is partial, only the set fields get updated.
      operationId: updateProgramMetadata
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Program'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpdateProgramMetadataRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProgramMetadata'
        '404':
          description: Program with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Program with id `program` not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /cells/{cell}/store/programs/{program}/metadata/image:
    post:
      tags:
        - Library Program Metadata
      summary: Upload Program Metadata Image
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Uploads an image for the corresponding program. The image is served as a static file. The path to the image is stored in the metadata.
      operationId: uploadProgramMetadataImage
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Program'
      requestBody:
        content:
          multipart/form-data:
            schema:
              $ref: '#/components/schemas/Body_uploadProgramMetadataImage'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProgramMetadata'
        '404':
          description: Program with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Program with id `program` not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /cells/{cell}/store/programs/{program}:
    get:
      tags:
        - Library Program
      summary: Get Program
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Returns the content of the program. The identifier of the program is received upon creation or from the metadata list of all the programs.
      operationId: getProgram
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Program'
      responses:
        '200':
          description: The content of the program.
          content:
            text/plain:
              schema:
                type: string
                title: Response 200 Getprogram
              example: |
                move via p2p() to [0, 0, 0, 0, 0, 0]
                move frame("flange") to [1, 2, 0]
                move via line() to [1, 1, 0]
                a := planned_pose()
        '404':
          description: Program with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Program with id `program` not found
            text/plain:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    put:
      tags:
        - Library Program
      summary: Update Program
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Updates the content of the program. The update overwrites the existing content. The metadata is updated in correspondence.

        ## Examples

        ```
        move via p2p() to [0, 0, 0, 0, 0, 0]

        move frame("flange") to [1, 2, 0]

        move via line() to [1, 1, 0]

        a := planned_pose()

        ```

        ```
        {% from 'schneider_conveyor_v1.j2' import schneider_conveyor_library -%}

        {{ schneider_conveyor_library() }}

        def start_main():
            conveyor_speed_percentage = {{ conveyor_speed_percentage | round(4) }}
            conveyer_speed = conveyor_speed_percentage*1500
            schneider_conveyor_start(conveyer_speed)
        end
        ```
      operationId: updateProgram
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Program'
      requestBody:
        content:
          text/plain:
            schema:
              type: string
              title: Updated program content
              description: |
                The updated content of the program. The update overwrites the existing content.
            example: |
              move via p2p() to [0, 0, 0, 0, 0, 0]
              move frame("flange") to [1, 2, 0]
              move via line() to [1, 1, 0]
              a := planned_pose()
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProgramMetadata'
        '404':
          description: Program with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Program with id `program` not found
            text/plain:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    delete:
      tags:
        - Library Program
      summary: Delete Program
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Deletes the program with the corresponding metadata. This action is irreversible. Does not delete the associated recipes.
      operationId: deleteProgram
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Program'
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProgramMetadata'
        '404':
          description: Program with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Program with id `program` not found
            text/plain:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /cells/{cell}/store/recipes:
    get:
      tags:
        - Library Recipe Metadata
      summary: List Recipe Metadata
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        List of all the stored recipes, represented by their metadata.
      operationId: listRecipeMetadata
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListRecipeMetadataResponse'
      parameters:
        - $ref: '#/components/parameters/Cell'
    post:
      tags:
        - Library Recipe
      summary: Create Recipe
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Creates a new recipe. The corresponding metadata is created as well.
      operationId: createRecipe
      parameters:
        - $ref: '#/components/parameters/Cell'
        - description: The identifier of the program the recipe will be associated with.
          required: true
          schema:
            type: string
            title: Program Identifier
            description: The identifier of the program the recipe will be associated with.
          name: program_id
          in: query
        - description: |
            If no inital name is set a default name based on the program and timestamp is created.
          required: false
          schema:
            type: string
            title: Inital name
            description: |
              If no inital name is set a default name based on the program and timestamp is created.
          name: name
          in: query
      requestBody:
        content:
          application/json:
            schema:
              type: object
              title: Recipe properties
              description: The properties of the recipe.
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RecipeMetadata'
        '404':
          description: Program with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Program with id `program` not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    delete:
      tags:
        - Library Recipe
      summary: Delete Recipe List
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Deletes the provided list of recipes. This action is irreversible.
      operationId: deleteRecipeList
      parameters:
        - $ref: '#/components/parameters/Cell'
        - description: Recieved from [listRecipeMetadata](listRecipeMetadata) or from the response of [createRecipe](createRecipe)
          required: true
          schema:
            items:
              type: string
            type: array
            title: List of recipe Identifiers
            description: Recieved from [listRecipeMetadata](listRecipeMetadata) or from the response of [createRecipe](createRecipe)
          name: recipe_ids
          in: query
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ListRecipeMetadataResponse'
        '404':
          description: Recipe with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Recipe with id `recipe` not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /cells/{cell}/store/recipes/{recipe}/metadata:
    get:
      tags:
        - Library Recipe Metadata
      summary: Get Recipe Metadata
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.
        Returns the metadata of the recipe.
      operationId: getRecipeMetadata
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Recipe'
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RecipeMetadata'
        '404':
          description: Recipe with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Recipe with id `recipe` not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    put:
      tags:
        - Library Recipe Metadata
      summary: Update Recipe Metadata
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Updates the metadata of a recipe. The update is partial, only the set fields get updated.
      operationId: updateRecipeMetadata
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Recipe'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpdateRecipeMetadataRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RecipeMetadata'
        '404':
          description: Recipe with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Recipe with id `recipe` not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /cells/{cell}/store/recipes/{recipe}/metadata/image:
    post:
      tags:
        - Library Recipe Metadata
      summary: Upload Recipe Metadata Image
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Uploads an image for a recipe. The image is served as a static file and the path is stored in the metadata.
      operationId: uploadRecipeMetadataImage
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Recipe'
      requestBody:
        content:
          multipart/form-data:
            schema:
              $ref: '#/components/schemas/Body_uploadRecipeMetadataImage'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RecipeMetadata'
        '404':
          description: Recipe with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Recipe with id `recipe` not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /cells/{cell}/store/recipes/{recipe}:
    get:
      tags:
        - Library Recipe
      summary: Get Recipe
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Returns the content of a recipe. The identifier of the recipe is recieved on creation or from the metadata list of all the recipes.
      operationId: getRecipe
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Recipe'
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                type: object
                title: Response Getrecipe
        '404':
          description: Recipe with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Recipe with id `recipe` not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    put:
      tags:
        - Library Recipe
      summary: Update Recipe
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Updates an existing recipe. The update is partial, only the set fields get updated.
      operationId: updateRecipe
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Recipe'
      requestBody:
        content:
          application/json:
            schema:
              type: object
              title: Updated recipe properties
              description: |
                The updated properties of the recipe. Partialy updating the existing values.
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RecipeMetadata'
        '404':
          description: Recipe with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Recipe with id `recipe` not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
    delete:
      tags:
        - Library Recipe
      summary: Delete Recipe
      description: |
        # EXPERIMENTAL

        > **Note:** This endpoint is experimental and might experience functional changes in the future.

        Deletes a recipe. This action is irreversible.
      operationId: deleteRecipe
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Recipe'
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RecipeMetadata'
        '404':
          description: Recipe with provided id not found.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPExceptionResponse'
              example:
                detail: Recipe with id `recipe` not found
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /internal/cells/{cell}/rae/capabilities:
    get:
      tags:
        - Internal RAE
      summary: Instance Description
      description: |
        Get the description of the instance.
      operationId: getDescription
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Description'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /internal/cells/{cell}/rae/controllers:
    post:
      tags:
        - Internal RAE
      summary: Register
      description: |
        Register a robot controller.

        > Developer tooling. Only use this endpoint if you are familiar with the internal processes of the Wandelbots Nova foundation services.
        > Please use the endpoint [addRobotController](addRobotController) for regular cases instead.
      operationId: registerController
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ControllerRequest'
            examples:
              Abb:
                value:
                  model_name: Abb::Controller
                  host: abb-robot
                  allow_software_install_on_controller: true
              Fanuc:
                value:
                  model_name: Fanuc::R30iBPlus
                  host: fanuc-robot
                  allow_software_install_on_controller: true
              Kuka:
                value:
                  model_name: KUKA::KRC
                  host: kuka-robot
                  allow_software_install_on_controller: true
              UniversalRobots:
                value:
                  model_name: UniversalRobots::Controller
                  host: ur-robot
                  allow_software_install_on_controller: true
              Yaskawa:
                value:
                  model_name: Yaskawa::YRC1000
                  host: yaskawa-robot
                  allow_software_install_on_controller: true
        required: true
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ControllerInstance'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /internal/cells/{cell}/rae/controllers/{controller}:
    get:
      tags:
        - Internal RAE
      summary: Description
      description: |
        List all requested configured robot controller.
      operationId: listController
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ControllerInstance'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
    delete:
      tags:
        - Internal RAE
      summary: Unregister
      description: |
        Delete a robot controller by indicating their unique identifier.

        All motion groups attached to this controller will be deleted as well.

        The robot controller's OperationMode will be set accordingly to execute the operation.
        operation.

        > Developer tooling. Only use this endpoint if you are familiar with the internal processes of the Wandelbots Nova foundation services.
        > Use the endpoint [deleteRobotController](deleteRobotController) for regular use cases instead.
      operationId: deleteController
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: OK
          content: {}
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /internal/cells/{cell}/rae/versions:
    get:
      tags:
        - Internal RAE
      summary: Versions Components
      description: Get the versions of all RAE components.
      operationId: getRaeVersion
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Versions'
        default:
          $ref: '#/components/responses/DefaultErrorResponse'
  /internal/cells/{cell}/wandelengine/version:
    get:
      tags:
        - Internal Wandelengine
      summary: Version
      description: Get Version.
      operationId: getWandelengineVersion
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema: {}
  /internal/cells:
    get:
      summary: List Names
      description: |-
        List all deployed cell names.
        If no cells are deployed, an empty list is returned.
      operationId: listCells
      tags:
        - Internal Service Manager Cell
      responses:
        '200':
          description: A Successful operation
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/NameList'
    post:
      summary: Add
      description: |-
        Deploy an entire cell with all its resources.

        A cell can be used to deploy a robot controller, one or more robots, as well as custom applications.

        Refer to the [Wandelbots Nova documentation](docs/wandelbots-nova-api/#create-a-cell) for more information.
      operationId: deployCell
      tags:
        - Internal Service Manager Cell
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Cell'
            examples:
              default:
                $ref: '#/components/examples/DefaultCell'
              Foundation Services Config:
                $ref: '#/components/examples/CellWithFoundationSvc'
              Virtual Robot Only Config:
                $ref: '#/components/examples/CellForVirtualRobots'
              Physical and Virtual Robot Config:
                $ref: '#/components/examples/CellForPhysicalRobots'
      responses:
        '201':
          description: The operation was successful.
        '409':
          description: A cell with this name already exists.
  /internal/cells/{cell}:
    get:
      summary: Configuration
      description: List all cell resources.
      operationId: getCell
      tags:
        - Internal Service Manager Cell
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: The operation was successful.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Cell'
        '404':
          $ref: '#/components/responses/NotFound'
    put:
      summary: Update Configuration
      description: Update the definition of the entire Cell.
      operationId: updateCell
      tags:
        - Internal Service Manager Cell
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Cell'
            examples:
              default:
                $ref: '#/components/examples/DefaultCell'
              Foundation Services Config:
                $ref: '#/components/examples/CellWithFoundationSvc'
              Virtual Robot Only Config:
                $ref: '#/components/examples/CellForVirtualRobots'
              Physical and Virtual Robot Config:
                $ref: '#/components/examples/CellForPhysicalRobots'
      responses:
        '200':
          description: The update was successful.
        '404':
          $ref: '#/components/responses/NotFound'
    delete:
      summary: Remove
      description: Delete an entire cell.
      operationId: deleteCell
      tags:
        - Internal Service Manager Cell
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '202':
          description: Deletion was scheduled with the server.
        '404':
          $ref: '#/components/responses/NotFound'
  /internal/cells/{cell}/foundation-services:
    get:
      summary: Foundation Services Configuration
      description: Get the configuration of the foundation services.
      operationId: getFoundationServices
      tags:
        - Internal Service Manager Cell
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: The operation was successful.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FoundationServices'
        '404':
          $ref: '#/components/responses/NotFound'
    put:
      summary: Update Foundation Services Configuration
      description: Update the configuration of the foundation services.
      operationId: updateFoundationServices
      tags:
        - Internal Service Manager Cell
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/FoundationServices'
            examples:
              full:
                $ref: '#/components/examples/FoundationServices'
      responses:
        '200':
          description: The update was successful.
        '404':
          $ref: '#/components/responses/NotFound'
  /internal/cells/{cell}/controllers:
    get:
      summary: List Robot Controllers
      description: List the names of all deployed robot controllers.
      operationId: listRobotControllers
      tags:
        - Internal Service Manager Robot
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: The operation was successful.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/NameList'
    post:
      summary: Add Robot Controller
      description: |
        Add a new robot controller to the cell.

        **Warning**: this is internal endpoint, using it in conjunction with the settings app may lead to unpredictable behavior.
      operationId: addRobotController
      tags:
        - Internal Service Manager Robot
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RobotController'
            examples:
              Abb:
                $ref: '#/components/examples/AbbController'
              Fanuc:
                $ref: '#/components/examples/FanucController'
              UniversalRobots:
                $ref: '#/components/examples/UrController'
              Virtual:
                $ref: '#/components/examples/VirtualController'
              Yaskawa:
                $ref: '#/components/examples/YaskawaController'
      responses:
        '201':
          description: The operation was successful.
        '404':
          $ref: '#/components/responses/NotFound'
        '409':
          description: A robot controller with this name already exists in the cell.
    delete:
      summary: Clear Robot Controllers
      description: |
        Delete all robot controllers from the cell.

        This can be used together with the 'Add Robot Controller' endpoint to replace all robot controllers in the cell.

        **Warning**: this is internal endpoint, using it in conjunction with the settings app may lead to unpredictable behavior.
      operationId: clearRobotControllers
      tags:
        - Internal Service Manager Robot
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: The deletion was successful.
        '404':
          $ref: '#/components/responses/NotFound'
  /internal/cells/{cell}/controllers/{controller}:
    get:
      summary: Robot Controller Configuration
      description: |
        Get the configuration for a robot controller.
      operationId: getRobotController
      tags:
        - Internal Service Manager Robot
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: The operation was successful.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RobotController'
        '404':
          $ref: '#/components/responses/NotFound'
    put:
      summary: Update Robot Controller Configuration
      description: |
        Update the configuration of a robot controller.

        This can be used to reconfigure certain options of a robot controller, or to deploy a specific container image of a robot controller.

        **Warning**: this is internal endpoint, using it in conjunction with the settings app may lead to unpredictable behavior.
      operationId: updateRobotController
      tags:
        - Internal Service Manager Robot
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/RobotController'
            examples:
              Abb:
                $ref: '#/components/examples/AbbController'
              Fanuc:
                $ref: '#/components/examples/FanucController'
              UniversalRobots:
                $ref: '#/components/examples/UrController'
              Virtual:
                $ref: '#/components/examples/VirtualController'
              Yaskawa:
                $ref: '#/components/examples/YaskawaController'
      responses:
        '200':
          description: The update was successful.
        '404':
          $ref: '#/components/responses/NotFound'
    delete:
      summary: Delete Robot Controller
      description: |
        Delete a robot controller from the cell.

        **Warning**: this is internal endpoint, using it in conjunction with the settings app may lead to unpredictable behavior.
      operationId: deleteRobotController
      tags:
        - Internal Service Manager Robot
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/Controller'
      responses:
        '200':
          description: The deletion was successful.
        '404':
          $ref: '#/components/responses/NotFound'
  /internal/cells/{cell}/apps:
    get:
      summary: List Applications
      description: |-
        This endpoint returns a list of all GUI applications that have been added to the cell
        through the 'Add Application' endpoint.  If no such applications exist an empty list is returned.
      operationId: listApps
      tags:
        - Internal Service Manager App
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: The operation was successful.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/NameList'
    post:
      summary: Add Application
      description: |
        This endpoint can be used to install a basic, containerized web application into the cell.
        This way the user can add their own customized frontend to control robots.

        This requires the user to have a Docker hub account with valid credentials, or an similar container registry account.

        After adding the application to the cell, the user can access the application via the Nova Home Screen.

        See [building your Application](/docs/docs/development/) for more information.
      operationId: addApp
      tags:
        - Internal Service Manager App
      parameters:
        - $ref: '#/components/parameters/Cell'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/App'
            examples:
              swagger-ui:
                $ref: '#/components/examples/AppSwaggerUI'
      responses:
        '201':
          description: The operation was successful.
        '409':
          description: An app with this name already exists in this cell.
    delete:
      summary: Remove All Applications
      description: Delete all GUI applications from the cell.
      operationId: clearApps
      tags:
        - Internal Service Manager App
      parameters:
        - $ref: '#/components/parameters/Cell'
      responses:
        '200':
          description: The deletion was successful.
        '404':
          $ref: '#/components/responses/NotFound'
  /internal/cells/{cell}/apps/{app}:
    get:
      summary: Configuration
      description: |
        Get the configuration for an existing GUI application running in the cell.
        This configuration can be used in combination with the Update Change Configuration endpoint to update a currently running GUI application.
      operationId: getApp
      tags:
        - Internal Service Manager App
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/App'
      responses:
        '200':
          description: The operation was successful.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/App'
        '404':
          $ref: '#/components/responses/NotFound'
    put:
      summary: Update Change Configuration
      description: Update or change the configuration of an existing user provided GUI application.
      operationId: updateApp
      tags:
        - Internal Service Manager App
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/App'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/App'
            examples:
              swagger-ui:
                $ref: '#/components/examples/AppSwaggerUI'
      responses:
        '200':
          description: The update was successful.
        '404':
          $ref: '#/components/responses/NotFound'
    delete:
      summary: Remove
      description: Delete a GUI application from the cell.
      operationId: deleteApp
      tags:
        - Internal Service Manager App
      parameters:
        - $ref: '#/components/parameters/Cell'
        - $ref: '#/components/parameters/App'
      responses:
        '200':
          description: The deletion was successful.
        '404':
          $ref: '#/components/responses/NotFound'
  /internal/system/update:
    put:
      summary: Update Wandelbots Nova version
      description: |
        Update the Wandelbots Nova version and all attached services.

        Sending this API Request will trigger an update of all Nova services that are part of a cell.
        Previous cells and cell configurations will remain on the instance.

        To update to the latest version of Wandelbots Nova, use `x.x.x` .
        To update to a specific version of Wandelbots Nova, provide the version number, e.g. `24.1.4`.
        Downgrading to an older Wandelbots Nova version is not recommended due to risk of data loss, safety and performance issues.

        If an error occurs, the API Request is sent 3 times. If the error persists, the old Wandelbots Nova version is restored.
      operationId: updateNovaVersion
      tags:
        - Internal System
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UpdateRequest'
            examples:
              Latest Version:
                $ref: '#/components/examples/UpdateLatest'
              Specific Version:
                $ref: '#/components/examples/UpdateSpecific'
      responses:
        '200':
          description: The update was triggered successfully.
        '400':
          description: An invalid request was provided.
        '501':
          description: This instance of Wandelbots Nova cannot be updated.
  /internal/system/diagnosis-package/zip:
    get:
      summary: Download Diagnosis Package
      description: |
        Collects information on the current status of all NOVA services and exports them as a .zip file.

        Includes information on all cells on the instance such as the service logs and virtual robot controllers.
        From each cell the logs of all services are included, as well as the configuration of each connected controller to start virtual robots.
      operationId: getDiagnosePackage
      tags:
        - Internal System
      responses:
        '200':
          description: Diagnose package successfully created.
          content:
            application/zip:
              schema:
                type: string
                format: binary
components:
  securitySchemes:
    BasicAuth:
      type: http
      scheme: basic
  parameters:
    Cell:
      name: cell
      in: path
      description: |
        Unique identifier addressing a cell in all API calls.
        Since the cell identifier is used as Kubernetes namespace, the following rules apply:
        * Contain only lowercase alphanumeric characters or '-'.
        * Start with an alphanumeric character.
        * End with an alphanumeric character.
        * A maximum length of 63 characters.
        * The identifier "kube-system", "default" and "wandelbots" are reserved and cannot be used.
      required: true
      schema:
        type: string
        pattern: ^(?!kube-system$|default$|wandelbots$)[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$
        default: cell
      x-go-name: CellID
    Controller:
      name: controller
      in: path
      description: Unique identifier to address a controller in the cell.
      required: true
      schema:
        type: string
      x-go-name: ControllerID
    CoordinateSystem:
      name: coordinate-system
      in: path
      description: Unique identifier addressing a coordinate system.
      required: true
      schema:
        type: string
    MotionGroup:
      name: motion-group
      in: path
      description: The motion-group id.
      required: true
      schema:
        type: string
    Motion:
      name: motion
      in: path
      description: |-
        This represents the UUID of a motion.
        Every executable or partially executable motion is cached and an UUID is returned.
        Indicate the UUID to execute the motion or retrieve information on the motion.
      required: true
      schema:
        type: string
    Runner:
      name: runner
      in: path
      required: true
      schema:
        type: string
        title: Runner Id
    IO:
      name: io
      in: path
      description: The io id.
      required: true
      schema:
        type: string
    Id:
      name: id
      in: path
      required: true
      description: The controller specific motion-group id.
      schema:
        type: integer
        format: uint32
        example: 0
    Tcp:
      name: tcp
      in: path
      description: The unique identifier of a TCP.
      required: true
      schema:
        type: string
        example: TRobUtility/current_tool
    Program:
      name: program
      in: path
      required: true
      description: |
        Recieved from [listProgramMetadata](listProgramMetadata) or from the response of [createProgram](createProgram).
      schema:
        type: string
        title: Program identifier
        description: |
          Recieved from [listProgramMetadata](listProgramMetadata) or from the response of [createProgram](createProgram).
    Recipe:
      name: recipe
      in: path
      required: true
      description: |
        Recieved from [listRecipeMetadata](listRecipeMetadata) or from the response of [createRecipe](createRecipe).
      schema:
        type: string
        title: Recipe identifier
        description: |
          Recieved from [listRecipeMetadata](listRecipeMetadata) or from the response of [createRecipe](createRecipe).
    App:
      name: app
      in: path
      required: true
      schema:
        type: string
        description: |
          The name of the user provided application.
          The name must be unique within the cell and is used as a identifier for addressing the application in all API calls, e.g. when updating the application.
      x-go-name: AppID
  schemas:
    GoogleProtobufAny:
      type: object
      properties:
        '@type':
          type: string
          description: The type of the serialized message.
      additionalProperties: true
      description: Contains an arbitrary serialized message along with a @type that describes the type of the serialized message.
    Status:
      type: object
      properties:
        code:
          type: integer
          description: |
            The status code, which should be an enum value of
            [google.rpc.Code](https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto).
          format: int32
        message:
          type: string
          description: |
            An error message in English.
        details:
          type: array
          items:
            $ref: '#/components/schemas/GoogleProtobufAny'
          description: |
            A list of messages that carry the error details. There is a common set of
            message types for APIs to use.
            > Currently, this is unused.
      description: |
        The `Status` type defines a logical error model that is suitable for different
        programming environments including REST APIs and RPC APIs. It is used by
        [gRPC](https://github.com/grpc). Each `status` message contains three pieces
        of data: error code, error message, and error details. You can find out more
        about this error model and how to work with it in the [API Design
        Guide](https://cloud.google.com/apis/design/errors).
    MotionGroupPhysical:
      required:
        - motion_group
        - name_from_controller
        - active
      type: object
      properties:
        motion_group:
          type: string
          description: The unique identifier to address a motion group.
        name_from_controller:
          type: string
          description: The name the motion group has on the robot controller.
        active:
          type: boolean
          description: |
            True if this motion group is active.
            When a request for a motion group is made, the motion group will be activated and remain activated.
            The robot controller provides the current state and data for all active motion groups.
            See [getCurrentMotionGroupState](getCurrentMotionGroupState).
            To deactivate a motion group, use [deactivateMotionGroup](deactivateMotionGroup).
        model_from_controller:
          type: string
          description: The robot controller model if available. Usable for frontend 3D visualization.
      description: |
        The data type describes the physically connected motion groups on a robot controller.
    VersionNumber:
      required:
        - major_version
      type: object
      properties:
        major_version:
          type: integer
          format: uint32
        minor_version:
          type: integer
          format: uint32
        build_version:
          type: integer
          format: uint32
        bugfix_version:
          type: integer
          format: uint32
        minor_version_wildcard:
          type: boolean
          description: If minor version is a wildcard set to true.
        build_version_wildcard:
          type: boolean
          description: If build version is a wildcard set to true.
        bugfix_version_wildcard:
          type: boolean
          description: If bugfix version is a wildcard set to true.
        string_version:
          type: string
          description: A string representation of the version e.g. 1.1.x.x.
      description: A generic representation of a version number.
    ControllerInstance:
      required:
        - controller
        - model_name
        - host
        - allow_software_install_on_controller
        - physical_motion_groups
        - has_error
      type: object
      properties:
        controller:
          type: string
          description: |
            The unique identifier to address the robot controller in the cell.
        model_name:
          type: string
          description: |
            The unique identifier to address a robot controller model when configuring the robot controller.
            Used for evaluation of the robot controller model and to ensure communication with the expected robot controller type.
        host:
          type: string
          description: |
            Resolvable host name or IP address that connects to the robot controller.
        allow_software_install_on_controller:
          type: boolean
          description: |
            True if the user has actively confirmed that it is allowed
            to install required communication software onto the robot controller.

            NOTE: Installing third party software on a robot controller
            can result in liability issues in regard to the actual certified
            state of the robot system. Please contact your company's legal responsible before installing third party software.
        physical_motion_groups:
          type: array
          items:
            $ref: '#/components/schemas/MotionGroupPhysical'
          description: |
            The list of physical connected motion groups as detected by the controller.
        vendor_software_version:
          $ref: '#/components/schemas/VersionNumber'
        has_error:
          type: boolean
          description: |
            Set to true if there was an error while inspecting this instance,
            e.g. The robot controller is not reachable due to missing network connection or turned off.

            The instance remains configured but can't provide information on the robot controller.
        error_details:
          type: string
          description: |
            If has_error is true, error_details provides detailed background information about the error.
      description: The data type to describe a robot controller.
    ControllerInstanceList:
      required:
        - instances
      type: object
      properties:
        instances:
          type: array
          items:
            $ref: '#/components/schemas/ControllerInstance'
      description: The list of configured robot controllers.
    ControllerCapabilities:
      required:
        - support_freedrive
        - support_control
      type: object
      properties:
        support_freedrive:
          type: boolean
          description: Can this controller be moved through freedrive (true), or not (false).
        support_control:
          type: boolean
          description: Can this controller be controlled with NOVA (true) or is it only possible to read data (false).
    Joints:
      required:
        - joints
      type: object
      properties:
        joints:
          type: array
          items:
            type: number
            format: double
      description: |-
        This structure describes a set of joint values of a motion group.
        We call a set of joint values describing the current position in joint space of a motion group a "joint position". Joint position was chosen as the term to be consistent with the terms "joint velocity" and "joint acceleration".
        `joints` must have as many entries as the motion group's degrees of freedom to be valid.
        Float precision is the default.
    Vector3d:
      required:
        - x
        - 'y'
        - z
      type: object
      properties:
        x:
          type: number
          format: double
        'y':
          type: number
          format: double
        z:
          type: number
          format: double
      description: A 3 dimensional Vector with double precision.
    Pose:
      required:
        - position
      type: object
      properties:
        position:
          $ref: '#/components/schemas/Vector3d'
          description: Position vector, defined in [x, y, z] with floating numbers in millimeters (ms).
        orientation:
          $ref: '#/components/schemas/Vector3d'
          description: 'Rotation vector, defined in [rx, ry, rz] with floating numbers. The rotation is represented in vector3 using an axis-angle representation: axis.normalized * angle (angle in radians).'
        coordinate_system:
          type: string
          description: |-
            Unique identifier addressing the reference coordinate system of the pose.
            Default is the world coordinate system.
      description: |-
        Representing a pose in space with its origin in `coordinate_system`.
        A pose consists of positional coordinates [x, y, z] in millimeters (mm) and orientational coordinates in axis-angle representation [rx, ry, rz] in radian (rad).
    TcpPose:
      required:
        - position
        - orientation
        - tcp
      type: object
      properties:
        position:
          $ref: '#/components/schemas/Vector3d'
        orientation:
          $ref: '#/components/schemas/Vector3d'
        coordinate_system:
          type: string
          description: Unique name of base coordinate system, if empty world is used.
        tcp:
          type: string
          description: Identifier of tcp on controller.
      description: Representing a robot pose in operational space aware of a configured TCP.
    MotionVector:
      type: object
      properties:
        linear:
          $ref: '#/components/schemas/Vector3d'
        angular:
          $ref: '#/components/schemas/Vector3d'
        coordinate_system:
          type: string
          description: optional, unique name of base coordinate system, if empty world is used
    ForceVector:
      type: object
      properties:
        force:
          $ref: '#/components/schemas/Vector3d'
        moment:
          $ref: '#/components/schemas/Vector3d'
        coordinate_system:
          type: string
          description: optional, unique name of base coordinate system, if empty world is used
      description: Representing a force on a specific point in operational space (e.g. on robot flange).
    MotionGroupState_JointLimitReached:
      type: object
      required:
        - limit_reached
      properties:
        limit_reached:
          type: array
          items:
            type: boolean
          description: If true, operational (soft) jointLimit is reached for specific joint.
      description: Indicates which joint of the motion group is in a limit. If a joint is in its limit, only this joint can be moved. Movements that affect any other joints are not executed.
    MotionGroupState:
      required:
        - motion_group
        - controller
        - joint_position
        - joint_velocity
        - tcp_pose
        - velocity
        - joint_limit_reached
      type: object
      properties:
        motion_group:
          type: string
          description: Identifier of the motion group.
        controller:
          type: string
          description: 'Convenience: Identifier of the robot controller the motion group is attached to.'
        joint_position:
          $ref: '#/components/schemas/Joints'
          description: |
            Current joint position of each joint in [rad]
        joint_velocity:
          $ref: '#/components/schemas/Joints'
          description: |
            Current joint velocity of each joint in [rad/s]
        joint_torque:
          $ref: '#/components/schemas/Joints'
          description: |
            Current joint torque of each joint in [Nm].
            Is only available if the robot controller supports it (e.g. available for UR Controllers).
        flange_pose:
          $ref: '#/components/schemas/Pose'
          description: |
            Current position of the Flange (last point of the motion group before the endeffector starts) in [mm].
            The position is relative to the response_coordinate_system that is specified in the request.
            For robot arms a flange pose is always returned, for positioners the flange might not be available, depending on the model.
        tcp_pose:
          $ref: '#/components/schemas/TcpPose'
          description: |
            Current position of the TCP currently selected on the robot control panel.
            Attention: This TCP is not necessarily the same as specified as `tcp` in the request.
            If you need the information for the specified TCP, use the tcp_pose in the outer response.
            Position is in [mm].
            The position is relative to the response_coordinate_system that is specified in the request.
        velocity:
          $ref: '#/components/schemas/MotionVector'
          description: |
            Current velocity at TCP in [mm/s].
            If `tcp` is not specified, the velocity at the flange is returned.
            The velocity is relative to the response_coordinate_system specified in the request.
        force:
          $ref: '#/components/schemas/ForceVector'
          description: |
            Current Force at TCP in [N].
            Is only available if the robot controller supports it, e.g. available for UR Controllers.
            The velocity is relative to the response_coordinate_system specified in the request.
        joint_limit_reached:
          $ref: '#/components/schemas/MotionGroupState_JointLimitReached'
          description: |
            Indicates whether the joint is in a limit for all joints of the motion group.
        joint_current:
          $ref: '#/components/schemas/Joints'
          description: |
            Current Current at TCP in [A].
            Is only available if the robot controller supports it, e.g. available for UR Controllers.
      description: Presents the current state of the motion group.
    RobotControllerState:
      required:
        - controller
        - operation_mode
        - safety_state
        - timestamp
        - motion_groups
      type: object
      properties:
        controller:
          type: string
          default: controller
          description: Identifier of the configured robot controller.
        operation_mode:
          enum:
            - OPERATION_MODE_UNKNOWN
            - OPERATION_MODE_NO_CONTROLLER
            - OPERATION_MODE_DISCONNECTED
            - OPERATION_MODE_POWER_ON
            - OPERATION_MODE_PENDING
            - OPERATION_MODE_MANUAL
            - OPERATION_MODE_MANUAL_T1
            - OPERATION_MODE_MANUAL_T2
            - OPERATION_MODE_AUTO
            - OPERATION_MODE_RECOVERY
          type: string
          format: enum
          description: |
            Current operation mode of the configured robot controller.
            Operation modes in which the attached motion groups can be moved are:
            - OPERATION_MODE_MANUAL (if enabling switch is pressed)
            - OPERATION_MODE_MANUAL_T1 (if enabling switch is pressed)
            - OPERATION_MODE_MANUAL_T2 (if enabling switch is pressed)
            - OPERATION_MODE_AUTO (without needing to press enabling switch)
            All other modes are considered as non-operational.
        safety_state:
          enum:
            - SAFETY_STATE_UNKNOWN
            - SAFETY_STATE_FAULT
            - SAFETY_STATE_NORMAL
            - SAFETY_STATE_MASTERING
            - SAFETY_STATE_CONFIRM_SAFETY
            - SAFETY_STATE_OPERATOR_SAFETY
            - SAFETY_STATE_PROTECTIVE_STOP
            - SAFETY_STATE_REDUCED
            - SAFETY_STATE_STOP
            - SAFETY_STATE_STOP_0
            - SAFETY_STATE_STOP_1
            - SAFETY_STATE_STOP_2
            - SAFETY_STATE_RECOVERY
            - SAFETY_STATE_DEVICE_EMERGENCY_STOP
            - SAFETY_STATE_ROBOT_EMERGENCY_STOP
            - SAFETY_STATE_VIOLATION
          type: string
          format: enum
          description: |
            Current safety state of the configured robot controller.
            Operation modes in which the attached motion groups can be moved are:
            - SAFETY_STATE_NORMAL
            - SAFETY_STATE_REDUCED
            All other modes are considered as non-operational.
        timestamp:
          type: string
          format: date-time
          description: Timestamp indicating when the represented information was received from the robot controller.
        velocity_override:
          type: integer
          description: |
            If made available by the robot controller, returns the current velocity override in
            [percentage] for movements adjusted on robot control panel.
            Valid value range: 1 - 100.
          format: uint32
        motion_groups:
          title: MotionGroupState[]
          type: array
          items:
            $ref: '#/components/schemas/MotionGroupState'
          description: State of indicated motion groups. In case of state request via controller all configured motion groups are returned. In case of executing a motion only the affected motion groups are returned.
      description: Returns the whole current state of robot controller.
    IOValue:
      required:
        - io
      type: object
      properties:
        io:
          type: string
          description: Unique identifier of the I/O.
        boolean_value:
          type: boolean
          description: |
            Value of a digital I/O.
            This field is only set if the I/O is of type IO_VALUE_DIGITAL.
        integer_value:
          type: string
          description: |
            Value of an analog I/O with integer representation.
            This field is only set if the I/O is of type IO_VALUE_ANALOG_INTEGER.

            > The integral value is transmitted as a string to avoid precision loss in conversion to JSON.
            > We recommend to use int64 for implementation. If you want to interact with int64 in numbers,
            > there are some JS bigint libraries availible to parse the string into an integral value.
        floating_value:
          type: number
          description: |
            Value of an analog I/O with floating number representation.
            This field is only set if the I/O is of type IO_VALUE_ANALOG_FLOATING.
          format: double
      description: I/O value representation. Depending on the I/O type, only one of the value fields will be set.
    IODescription:
      required:
        - id
        - name
        - type
        - value_type
        - bit_size
      type: object
      properties:
        id:
          type: string
          description: Unique identifier defined by the controller. Identifiers are only defined uniquely per controller, e.g. I/Os for two different robots on the same controller can have the same identifier.
        name:
          type: string
          description: Name of the I/O. Customize it on the physical controller or in the virtual robot specification.
        group:
          type: string
          description: Name of the I/O group. Customize it on the physical controller or in the virtual robot specification.
        type:
          enum:
            - IO_TYPE_INPUT
            - IO_TYPE_OUTPUT
          type: string
          description: Identifies the I/O type. Possible responses "input" or "output".
          format: enum
        value_type:
          enum:
            - IO_VALUE_DIGITAL
            - IO_VALUE_ANALOG_FLOATING
            - IO_VALUE_ANALOG_INTEGER
          type: string
          description: Data type of the I/O.
          format: enum
        bit_size:
          type: integer
          description: OBSOLETE! Replaced by min/max. Amount of bits the value is encoded in.
          format: uint32
        unit:
          enum:
            - UNIT_NONE
            - UNIT_KILOGRAM
            - UNIT_AMPERE
            - UNIT_KELVIN
            - UNIT_HERTZ
            - UNIT_NEWTON
            - UNIT_VOLT
            - UNIT_CELSIUS
            - UNIT_NEWTON_METER
            - UNIT_METER
          type: string
          description: The unit of I/O value.
          format: enum
        min:
          $ref: '#/components/schemas/IOValue'
        max:
          $ref: '#/components/schemas/IOValue'
    ListIODescriptionsResponse:
      required:
        - io_descriptions
      type: object
      properties:
        io_descriptions:
          type: array
          items:
            $ref: '#/components/schemas/IODescription'
      description: Array of I/O description values.
    ListIOValuesResponse:
      required:
        - io_values
      type: object
      properties:
        io_values:
          type: array
          items:
            $ref: '#/components/schemas/IOValue'
      description: Array of I/O values.
    RobotSystemMode:
      enum:
        - ROBOT_SYSTEM_MODE_UNDEFINED
        - ROBOT_SYSTEM_MODE_DISCONNECT
        - ROBOT_SYSTEM_MODE_MONITOR
        - ROBOT_SYSTEM_MODE_CONTROL
        - ROBOT_SYSTEM_MODE_FREE_DRIVE
      type: string
      description: |
        The system mode of the robot system.

        ### ROBOT_SYSTEM_MODE_UNDEFINED

        Indicates that the robot controller is currently performing a mode transition.

        ### ROBOT_SYSTEM_MODE_DISCONNECT

        There is no communication with the robot controller at all. All connections are closed.
        No command is sent to the robot controller while in this mode. No IO interaction is possible in this mode!
        All move requests will be rejected in this mode!

        ### ROBOT_SYSTEM_MODE_MONITOR

        A connection to the robot controller is established to only read the robot controller state.
        No command is sent to the robot controller while in this mode. It is possible to receive IO information.
        All move requests will be rejected in this mode!

        ### ROBOT_SYSTEM_MODE_CONTROL

        An active connection is established with the robot controller and the robot system is cyclic commanded
        to stay in its actual position. The robot controller state is received in the cycle time of the robot controller.
        Requests via the MotionService and JoggingService will be processed and executed in this mode.
        IO interaction is possible in this mode! **In this mode the robot system can be commanded to move.**

        ### ROBOT_SYSTEM_MODE_FREE_DRIVE

        Like ROBOT_SYSTEM_MODE_MONITOR a connection to the robot controller is established to only read the robot controller state.
        The difference is that the motion groups can be moved by the user (Free Drive). Thus, the servo motors are turned on.
        All move requests will be rejected in this mode! **This mode is not supported by every robot!**
        Use [getSupportedModes](getSupportedModes) to evaluate if the device support free drive.
      format: enum
    GetModeResponse:
      required:
        - robot_system_mode
      type: object
      properties:
        robot_system_mode:
          $ref: '#/components/schemas/RobotSystemMode'
    ModeChangeResponse:
      required:
        - current_robot_mode
        - previous_robot_mode
        - cause_of_change
      type: object
      properties:
        current_robot_mode:
          $ref: '#/components/schemas/RobotSystemMode'
        by_client_request:
          type: boolean
          description: True if mode change was requested by client.
        previous_robot_mode:
          $ref: '#/components/schemas/RobotSystemMode'
        cause_of_change:
          type: string
          description: Details about cause of mode change.
      description: |
        Mode change example:
        * Client sends [jointJogging](jointJogging)](cell="..",...)
        * Server responds with *current_robot_mode: ROBOT_SYSTEM_MODE_UNDEFINED, by_client_request: true* at the beginning of the transition.
        * Server responds with *current_robot_mode: ROBOT_SYSTEM_MODE_CONTROL, by_client_request: true* when transition is done.

        In case an error happens during execution, e.g. a path would lead to a joint limit violation:
        * Server responds with *current_robot_mode: ROBOT_SYSTEM_MODE_UNDEFINED, by_client_request: false*
        * Server responds with *current_robot_mode: ROBOT_SYSTEM_MODE_MONITOR, by_client_request: false*

        In case an error happens during connection, e.g. the robot is not reachable:
        * Client sends [setDefaultMode](setDefaultMode)(mode: MODE_CONTROL)
        * Server responds with *current_robot_mode:ROBOT_SYSTEM_MODE_UNDEFINED, by_client_request: true*
        * Server responds with *current_robot_mode:ROBOT_SYSTEM_MODE_DISCONNECT, by_client_request: false*
    VirtualRobotConfiguration:
      required:
        - name
        - content
      type: object
      properties:
        name:
          type: string
          description: |
            Name of the configuration file generated by the unique identifier of the controller and a time stamp.
        content:
          type: string
          description: |
            Content of the configuration file. Copy & paste to the [addRobotController](addRobotController) configuration.json parameter.
    RotationAngleTypes:
      enum:
        - QUATERNION
        - ROTATION_VECTOR
        - EULER_ANGLES_INTRINSIC_ZXZ
        - EULER_ANGLES_INTRINSIC_XYX
        - EULER_ANGLES_INTRINSIC_YZY
        - EULER_ANGLES_INTRINSIC_ZYZ
        - EULER_ANGLES_INTRINSIC_XZX
        - EULER_ANGLES_INTRINSIC_YXY
        - EULER_ANGLES_INTRINSIC_XYZ
        - EULER_ANGLES_INTRINSIC_YZX
        - EULER_ANGLES_INTRINSIC_ZXY
        - EULER_ANGLES_INTRINSIC_XZY
        - EULER_ANGLES_INTRINSIC_ZYX
        - EULER_ANGLES_INTRINSIC_YXZ
        - EULER_ANGLES_EXTRINSIC_ZXZ
        - EULER_ANGLES_EXTRINSIC_XYX
        - EULER_ANGLES_EXTRINSIC_YZY
        - EULER_ANGLES_EXTRINSIC_ZYZ
        - EULER_ANGLES_EXTRINSIC_XZX
        - EULER_ANGLES_EXTRINSIC_YXY
        - EULER_ANGLES_EXTRINSIC_ZYX
        - EULER_ANGLES_EXTRINSIC_XZY
        - EULER_ANGLES_EXTRINSIC_YXZ
        - EULER_ANGLES_EXTRINSIC_YZX
        - EULER_ANGLES_EXTRINSIC_XYZ
        - EULER_ANGLES_EXTRINSIC_ZXY
      type: string
      description: |
        The type of rotation description that is used to specify the rotation.

        **Quaternion notation**

        * The rotation is represented using a quaternion: [x, y, z, w].
        * The vector part [x, y, z] is the imaginary part of the quaternion, and the scalar part [w] is the real part.

        **Rotation Vector notation**

        * The rotation is represented using an axis-angle representation:
        > axis = Vector[0:2]
        > angle = |axis| in [rad]
        > axis.normalized * angle

        **Euler notation**

        * *extrinsic* fixed external reference system
        * *intrinsic* reference system fixed to rotation body
        > angles = Vector[0:2] in [rad].
        * ZYX, ZXZ,...
          - mapping of the given angles values to the (either intrinsic
            or extrinsic) axes in the stated order.
         > Example ZYX: Z = Vector[0], Y = Vector[1], X = Vector[2].
      format: enum
    RotationAngles:
      required:
        - angles
        - type
      type: object
      properties:
        angles:
          type: array
          minItems: 3
          maxItems: 4
          items:
            type: number
            format: double
          description: The values for the rotation notation.
        type:
          $ref: '#/components/schemas/RotationAngleTypes'
      description: |-
        Defines rotation angles and their interpretation.
        Rotation Vector order: X = Vector[0], Y = Vector[1], Z = Vector[2], W = Vector[3].
    CoordinateSystem:
      required:
        - coordinate_system
      type: object
      properties:
        coordinate_system:
          type: string
          description: Unique identifier of the coordinate system.
        name:
          type: string
          description: Human readable name of this coordinate system.
        reference_uid:
          type: string
          description: The identifier of the reference coordinate system. Empty if world is used.
        position:
          $ref: '#/components/schemas/Vector3d'
        rotation:
          $ref: '#/components/schemas/RotationAngles'
    ListResponse:
      type: object
      properties:
        coordinatesystems:
          type: array
          items:
            $ref: '#/components/schemas/CoordinateSystem'
    AddRequest:
      required:
        - offset
      type: object
      properties:
        offset:
          $ref: '#/components/schemas/Pose'
        name:
          type: string
          description: Human readable name of this coordinate system, e.g. to simplify recognition.
      description: |
        This message is used to add a coordinate system with a pose including a position offset in [mm] and a rotational offset in rotation vector notation.
    MotionGroupInstance:
      required:
        - motion_group
        - controller
        - name_from_controller
        - model_from_controller
      type: object
      properties:
        motion_group:
          type: string
          description: Identifier of the motion group.
        controller:
          type: string
          description: Identifier of the robot controller the motion group is attached to.
        name_from_controller:
          type: string
          description: The name of the motion group has on the robot controller.
        model_from_controller:
          type: string
          description: |
            The robot controller model if available. Usable for frontend 3D visualization.
      description: The data type describes the physically connected motion groups on a robot controller, e.g. a robot arm.
    MotionGroupInstanceList:
      required:
        - instances
      type: object
      properties:
        instances:
          type: array
          items:
            $ref: '#/components/schemas/MotionGroupInstance'
      description: A list of motion groups.
    InfoServiceCapabilities:
      required:
        - list_tcps
        - get_active_tcp
        - get_safety_setup
        - get_motion_group_specification
        - list_payloads
        - get_active_payload
        - get_mounting
        - get_blending_zones
      type: object
      properties:
        list_tcps:
          type: boolean
          description: Is this motion group able to provide a list of all available TCPs.
        get_active_tcp:
          type: boolean
          description: Is this motion group able to provide the currently active TCP.
        get_safety_setup:
          type: boolean
          description: Is this motion group able to get the safety setup.
        get_motion_group_specification:
          type: boolean
          description: Is this motion group able to provide a motion group specification.
        list_payloads:
          type: boolean
          description: Is this motion group able to provide a list of all available payloads.
        get_active_payload:
          type: boolean
          description: Is this motion group able to provide the currently active payload.
        get_mounting:
          type: boolean
          description: Is this motion group able to provide the mounting information.
    KinematicServiceCapabilities:
      required:
        - calculate_joint_position
        - calculate_all_joint_positions
        - calculate_tcp_pose
      type: object
      properties:
        calculate_joint_position:
          type: boolean
          description: Can this motion-group compute its nearest joint position from a TCP pose.
        calculate_all_joint_positions:
          type: boolean
          description: Can this motion-group compute all its possible joint positions from a TCP pose.
        calculate_tcp_pose:
          type: boolean
          description: Can this motion-group compute its TCP pose from joint positions.
    AllJointPositionsRequest:
      required:
        - motion_group
        - tcp_pose
      type: object
      properties:
        motion_group:
          type: string
          description: Identifier of the motion-group.
        tcp_pose:
          $ref: '#/components/schemas/TcpPose'
      description: Request to calculate the joint positions of a motion group in order to move its TCP to a specific pose (Inverse Kinematic Solutions).
    AllJointPositionsResponse:
      required:
        - joint_position
      type: object
      properties:
        joint_positions:
          type: array
          items:
            $ref: '#/components/schemas/Joints'
          description: Joint position in [rad].
      description: A list of Joint Positions. If any of them is applied to the motion-group, its TCP will be at the specified pose.
    JointPositionRequest:
      required:
        - motion_group
        - tcp_pose
        - reference_joint_position
      type: object
      properties:
        motion_group:
          type: string
          description: Identifier of the motion group.
        tcp_pose:
          $ref: '#/components/schemas/TcpPose'
        reference_joint_position:
          $ref: '#/components/schemas/Joints'
      description: Request to find the joint positions the motion-group needs to apply for its TCP to be in a specified pose (Inverse Kinematic Solution).
    TcpPoseRequest:
      required:
        - motion_group
        - joint_position
      type: object
      properties:
        motion_group:
          type: string
          description: Unique identifier of the motion-group.
        joint_position:
          $ref: '#/components/schemas/Joints'
        tcp:
          type: string
          description: |
            Specifies the TCP at which the pose is calculated via its unique identifier.
            Optional. If not provided, the currently active TCP is used.
        coordinate_system:
          type: string
          description: |
            Unique identifier of the base coordinate system of the calculated pose.
            Optional. If empty, world is used.
      description: Request to compute the TCP pose for a single joint position sample.
    Mounting:
      required:
        - coordinate_system
        - pose
      type: object
      properties:
        coordinate_system:
          type: string
          description: |
            Identifier of mounting coordinate system. The motion group is based on the origin of this coordinate system.
        pose:
          $ref: '#/components/schemas/Pose'
          description: The pose offset based on world coordinate system of the mounting.
      description: Mounting of a motion group.
    JoggingServiceCapabilities:
      required:
        - joint_jogging
        - cartesian_jogging
      type: object
      properties:
        joint_jogging:
          type: boolean
          description: Can this motion group be moved via joint jogging.
        cartesian_jogging:
          type: boolean
          description: Can this motion group be moved via cartesian jogging.
    Quaternion:
      required:
        - x
        - 'y'
        - z
        - w
      type: object
      properties:
        x:
          type: number
          format: double
        'y':
          type: number
          format: double
        z:
          type: number
          format: double
        w:
          type: number
          format: double
      description: 'A unit quaternion with double precision. The quaternion should be normalized: If interpreted as vector, its length has to be 1.'
    PlannerPose:
      type: object
      properties:
        position:
          $ref: '#/components/schemas/Vector3d'
        orientation:
          $ref: '#/components/schemas/Quaternion'
    PlanningLimits_LimitRange:
      required:
        - upper_limit
        - lower_limit
      type: object
      properties:
        lower_limit:
          type: number
          format: double
        upper_limit:
          type: number
          format: double
      description: The upper_limit must be greater then the lower_limit.
    PlanningLimits:
      type: object
      properties:
        joint_position_limits:
          type: array
          items:
            $ref: '#/components/schemas/PlanningLimits_LimitRange'
          description: |
            Joint position limits in [rad], configured in the safety setup, starting
            at base.
        joint_velocity_limits:
          type: array
          items:
            type: number
            format: double
          description: |
            Maximum allowed velocity for joints in [rad/s or mm/s] of the safety setup,
            starting at base.
        joint_acceleration_limits:
          type: array
          items:
            type: number
            format: double
          description: |
            Maximum allowed acceleration for joints in [rad/s^2 or mm/s^2] of the safety
            setup, starting at base.
        joint_torque_limits:
          type: array
          items:
            type: number
            format: double
          description: |
            Maximum allowed torque for joints in [Nm or N] of the safety setup, starting
            at base.
        tcp_velocity_limit:
          type: number
          description: |
            At maximum one dimensional velocity in [mm/s] at TCP allowed.
          format: double
        tcp_acceleration_limit:
          type: number
          description: |
            At maximum one dimensional acceleration in [mm/s^2] at TCP allowed.
          format: double
        tcp_orientation_velocity_limit:
          type: number
          description: |
            At maximum one dimensional orientation velocity in [rad/s] at TCP allowed.
          format: double
        tcp_orientation_acceleration_limit:
          type: number
          description: |
            At maximum one dimensional orientation acceleration in [rad/s^2] at TCP allowed.
          format: double
        tcp_force_limit:
          type: number
          description: |
            At maximum one dimensional force in [N] at TCP allowed.
          format: double
        elbow_velocity_limit:
          type: number
          description: |
            At maximum one dimensional velocity in [mm/s] at the elbow allowed.
          format: double
        elbow_acceleration_limit:
          type: number
          description: |
            At maximum one dimensional acceleration in [mm/s^2] at the elbow allowed.
          format: double
        elbow_force_limit:
          type: number
          description: |
            At maximum one dimensional force in [N] at the elbow allowed.
          format: double
      description: All known joint and cartesian limits of a motion-group. Used for motion planning.
    SafetyZoneLimits:
      required:
        - safety_zone
        - limits
      type: object
      properties:
        safety_zone:
          type: integer
          format: uint32
        limits:
          $ref: '#/components/schemas/PlanningLimits'
      description: All limits which apply within a single safety zone.
    Sphere:
      required:
        - radius
      type: object
      properties:
        radius:
          type: number
          description: The radius of the sphere in [mm].
          format: double
      description: Defines a spherical shape centered around an origin.
    Box:
      required:
        - size_x
        - size_y
        - size_z
        - type
      type: object
      properties:
        size_x:
          type: number
          description: The dimension in x direction in [mm].
          format: double
        size_y:
          type: number
          description: The dimension in y direction in [mm].
          format: double
        size_z:
          type: number
          description: The dimension in z direction in [mm].
          format: double
        type:
          enum:
            - TYPE_HOLLOW
            - TYPE_FULL
          type: string
          description: The type defines if the box is hollow or not.
          format: enum
      description: Defines a cuboid shape centered around an origin.
    Rectangle:
      required:
        - size_x
        - size_y
      type: object
      properties:
        size_x:
          type: number
          description: The dimension in x direction in [mm].
          format: double
        size_y:
          type: number
          description: The dimension in y direction in [mm].
          format: double
      description: Defines an x-y plane with finite size.
    Plane:
      type: object
      properties: {}
      description: Defines an x-y plane with infinite size.
    Cylinder:
      required:
        - radius
        - height
      type: object
      properties:
        radius:
          type: number
          description: The radius of the cylinder in [mm].
          format: double
        height:
          type: number
          description: The height of the cylinder in [mm].
          format: double
      description: Defines a cylindrical shape centered around the z-axis.
    ConvexHull:
      required:
        - vertices
      type: object
      properties:
        vertices:
          type: array
          items:
            $ref: '#/components/schemas/Vector3d'
          description: The list of encapsulated points.
      description: Defines a convex hull encapsulating a set of vertices.
    Capsule:
      required:
        - radius
        - cylinder_height
      type: object
      properties:
        radius:
          type: number
          description: The radius of the cylinder and semi-spheres in [mm].
          format: double
        cylinder_height:
          type: number
          description: The height of the inner cylinder in [mm].
          format: double
      description: Defines a cylinder like shape with 2 semi-spheres on top and bottom.
    RectangularCapsule:
      required:
        - radius
        - sphere_center_distance_x
        - sphere_center_distance_y
      type: object
      properties:
        radius:
          type: number
          description: The radius of the inner spheres in [mm].
          format: double
        sphere_center_distance_x:
          type: number
          description: The distance of the sphere center in x direction in [mm].
          format: double
        sphere_center_distance_y:
          type: number
          description: The distance of the sphere center in y direction in [mm].
          format: double
      description: 'A convex hull around four spheres. Sphere center points in x-y-plane, offset by either combination +-sizeX/+-sizeY. Alternative description: Rectangle in x-y-plane with a 3D padding.'
    Geometry:
      required:
        - init_pose
      type: object
      properties:
        sphere:
          $ref: '#/components/schemas/Sphere'
        box:
          $ref: '#/components/schemas/Box'
        rectangle:
          $ref: '#/components/schemas/Rectangle'
        plane:
          $ref: '#/components/schemas/Plane'
        cylinder:
          $ref: '#/components/schemas/Cylinder'
        convex_hull:
          $ref: '#/components/schemas/ConvexHull'
        capsule:
          $ref: '#/components/schemas/Capsule'
        rectangular_capsule:
          $ref: '#/components/schemas/RectangularCapsule'
        compound:
          $ref: '#/components/schemas/Compound'
        init_pose:
          $ref: '#/components/schemas/PlannerPose'
        id:
          type: string
          description: An identifier may be used to refer to this geometry, e.g. when giving feedback.
      description: A Geometry is defined by a shape and a pose.
    Compound:
      required:
        - child_geometries
      type: object
      properties:
        child_geometries:
          type: array
          items:
            $ref: '#/components/schemas/Geometry'
          description: A list of geometries sharing the same reference frame.
      description: Describes a collision shape compounded from multiple collision objects. All objects are described in the compounds reference frame.
    SafetyZone:
      required:
        - id
        - priority
        - geometry
      type: object
      properties:
        id:
          type: integer
          description: A unique identifier.
          format: uint32
        priority:
          type: integer
          description: The precedence if multiple zones overlap.
          format: uint32
        geometry:
          $ref: '#/components/schemas/Geometry'
      description: A zone where the MotionGroup cannot enter or certain limits apply.
    RobotLinkGeometry:
      required:
        - link_index
        - geometry
      type: object
      properties:
        link_index:
          type: integer
          description: Determines how many sets of DH-parameter are applied to get from robot base coordinate system to the link coordinate system in which the geometry is defined.
          format: uint32
        geometry:
          $ref: '#/components/schemas/Geometry'
      description: Describes a geometry encapsulating a given link from a robot.
    SafetyConfiguration:
      required:
        - global_limits
      type: object
      properties:
        global_limits:
          $ref: '#/components/schemas/PlanningLimits'
        safety_zone_limits:
          type: array
          items:
            $ref: '#/components/schemas/SafetyZoneLimits'
          description: All limits applied in certain SafetyZones.
        safety_zones:
          type: array
          items:
            $ref: '#/components/schemas/SafetyZone'
          description: SafetyZones are areas which cannot be entered or impose certain limits.
        robot_model_geometries:
          type: array
          items:
            $ref: '#/components/schemas/RobotLinkGeometry'
          description: The shape of the motion-group to validate against SafetyZones.
        tcp_geometries:
          type: array
          items:
            $ref: '#/components/schemas/Geometry'
          description: The shape of the TCP to validate against SafetyZones.
      description: The safety configuration of a motion-group. Used for motion planning.
    OptimizerSetup:
      required:
        - motion_group_type
        - mounting
        - tcp
        - safety_setup
      type: object
      properties:
        motion_group_type:
          type: string
        mounting:
          $ref: '#/components/schemas/PlannerPose'
        tcp:
          $ref: '#/components/schemas/PlannerPose'
        safety_setup:
          $ref: '#/components/schemas/SafetyConfiguration'
      description: The configuration of a motion-group used for motion planning.
    Payload:
      required:
        - name
        - payload
      type: object
      properties:
        name:
          type: string
          description: Unique identifier of the payload.
        payload:
          type: number
          description: Mass of payload in [kg].
          format: double
        center_of_mass:
          $ref: '#/components/schemas/Vector3d'
        moment_of_inertia:
          $ref: '#/components/schemas/Vector3d'
    ListPayloadsResponse:
      type: object
      properties:
        payloads:
          type: array
          items:
            $ref: '#/components/schemas/Payload'
    JointLimit:
      required:
        - joint
        - lower_limit
        - upper_limit
      type: object
      properties:
        joint:
          enum:
            - JOINTNAME_AXIS_INVALID
            - JOINTNAME_AXIS_1
            - JOINTNAME_AXIS_2
            - JOINTNAME_AXIS_3
            - JOINTNAME_AXIS_4
            - JOINTNAME_AXIS_5
            - JOINTNAME_AXIS_6
            - JOINTNAME_AXIS_7
            - JOINTNAME_AXIS_8
            - JOINTNAME_AXIS_9
            - JOINTNAME_AXIS_10
            - JOINTNAME_AXIS_11
            - JOINTNAME_AXIS_12
          type: string
          description: Definition of the joint where the limits are applied.
          format: enum
        lower_limit:
          type: number
          description: Lower joint limit which is smaller than the upper joint limit.
          format: double
        upper_limit:
          type: number
          description: Upper joint boundary which is bigger than the lower joint limit.
          format: double
        unlimited:
          type: boolean
          description: True, if joint limit is unlimited. Lower and upper limits are ignored.
      description: |
        A joint limit can contain a position (rad or mm), a velocity (rad/s or mm/s),
        an acceleration (rad/s² or mm/s²) or a jerk (rad/s³ or mm/s³).
    SingleJointLimit:
      required:
        - joint
        - limit
      type: object
      properties:
        joint:
          enum:
            - JOINTNAME_AXIS_INVALID
            - JOINTNAME_AXIS_1
            - JOINTNAME_AXIS_2
            - JOINTNAME_AXIS_3
            - JOINTNAME_AXIS_4
            - JOINTNAME_AXIS_5
            - JOINTNAME_AXIS_6
            - JOINTNAME_AXIS_7
            - JOINTNAME_AXIS_8
            - JOINTNAME_AXIS_9
            - JOINTNAME_AXIS_10
            - JOINTNAME_AXIS_11
            - JOINTNAME_AXIS_12
          type: string
          description: Definition of the joint where the limits are applied.
          format: enum
        limit:
          type: number
          description: Limit, unit depends on usage of this message structure.
          format: double
      description: A joint limit can contain a position (rad or mm), a velocity (rad/s or mm/s), an acceleration (rad/s² or mm/s²) or a jerk (rad/s³ or mm/s³).
    LimitSettings:
      type: object
      properties:
        joint_position_limits:
          type: array
          items:
            $ref: '#/components/schemas/JointLimit'
          description: Joint position limits in [rad or mm], configured in the safety setup, starting at base.
        joint_velocity_limits:
          type: array
          items:
            $ref: '#/components/schemas/SingleJointLimit'
          description: Max allowed velocity for joints in [rad/s or mm/s] of the safety setup, starting at base.
        joint_acceleration_limits:
          type: array
          items:
            $ref: '#/components/schemas/SingleJointLimit'
          description: Max allowed acceleration for joints in [rad/s^2 or mm/s^2] of the safety setup, starting at base.
        joint_torque_limits:
          type: array
          items:
            $ref: '#/components/schemas/SingleJointLimit'
          description: Max allowed torque for joints in [Nm or N] of the safety setup, starting at base.
        tcp_velocity_limit:
          type: number
          description: '[mm/s] max. allowed velocity at the TCP, 1-dimensional.'
          format: double
        tcp_acceleration_limit:
          type: number
          description: '[mm/s^2] max. allowed acceleration at the TCP, 1-dimensional.'
          format: double
        tcp_orientation_velocity_limit:
          type: number
          description: '[rad/s] max. allowed orientation velocity at the TCP, 1-dimensional.'
          format: double
        tcp_orientation_acceleration_limit:
          type: number
          description: '[rad/s^2] max. allowed orientation acceleration at the TCP, 1-dimensional.'
          format: double
        tcp_force_limit:
          type: number
          description: '[N] max. allowed force at the TCP, 1-dimensional.'
          format: double
        elbow_velocity_limit:
          type: number
          description: '[mm/s] max. allowed velocity at the elbow, 1-dimensional.'
          format: double
        elbow_acceleration_limit:
          type: number
          description: '[mm/s^2] max. allowed acceleration at the elbow, 1-dimensional.'
          format: double
        elbow_force_limit:
          type: number
          description: '[N] max. allowed force at the elbow, 1-dimensional.'
          format: double
      description: 'NOTE: if a joint or Cartesian limit is not set or present for the corresponding device, then the value is not present (in the list or the optional value is null). The unit depends on the kind of axis (rotational or linear).'
    SafetySetup_SafetySettings:
      type: object
      properties:
        safety_state:
          enum:
            - SAFETY_INVALID
            - SAFETY_NORMAL
            - SAFETY_REDUCED
          type: string
          description: The safety state that the settings are valid for.
          format: enum
        settings:
          $ref: '#/components/schemas/LimitSettings'
      description: Restricts the robot movements due to the safety configuration.
    SafetySetup_SafetyZone:
      type: object
      properties:
        id:
          type: integer
          description: A unique identifier.
          format: uint32
        priority:
          type: integer
          description: The precedence if two zones overlap.
          format: uint32
        geometry:
          $ref: '#/components/schemas/Geometry'
        motion_group_uid:
          type: integer
          description: |-
            Unique identifier of an specific motion-group if the safety zone only applies to it.
            If it is not set, then the safety zone applies to all motion-groups.
          format: uint32
      description: Describes the physical space in which the safety limitations will be applied.
    ToolGeometry:
      required:
        - tcp
        - geometry
      type: object
      properties:
        tcp:
          type: string
          description: Identifier of this tcp.
        geometries:
          type: array
          items:
            $ref: '#/components/schemas/Geometry'
          description: The shape of the tool to validate against SafetyZones.
      description: Describes a geometry encapsulating a given tool from a robot.
    SafetySetup:
      type: object
      properties:
        safety_settings:
          type: array
          items:
            $ref: '#/components/schemas/SafetySetup_SafetySettings'
        safety_zones:
          type: array
          items:
            $ref: '#/components/schemas/SafetySetup_SafetyZone'
        robot_model_geometries:
          type: array
          items:
            $ref: '#/components/schemas/RobotLinkGeometry'
        tool_geometries:
          type: array
          items:
            $ref: '#/components/schemas/ToolGeometry'
    DHParameter:
      type: object
      properties:
        alpha:
          type: number
          description: Angle about x-axis in [rad].
          format: double
        theta:
          type: number
          description: Angle about z-axis in [rad].
          format: double
        a:
          type: number
          description: Offset along x-axis in [mm].
          format: double
        d:
          type: number
          description: Offset along z-axis in [mm].
          format: double
        reverse_rotation_direction:
          type: boolean
          description: True, if rotation direction of joint is reversed.
      description: A single set of DH parameters.
    MotionGroupSpecification:
      type: object
      properties:
        dh_parameters:
          type: array
          items:
            $ref: '#/components/schemas/DHParameter'
          description: |
            A list of DH (Denavit-Hartenberg) parameters.
            An element in this list contains a set of DH parameters that describe the relation of two cartesian reference frames.
            Every joint of a serial motion group has an associated cartesian reference frame located in the rotation axis of the joint.
            A set of DH parameters is applied in the following order: theta, d, a, alpha.
        mechanical_joint_limits:
          type: array
          items:
            $ref: '#/components/schemas/JointLimit'
          description: |
            Mechanical joint limits in [rad/mm], starting with the first joint in the motion group base.
            For every joint there is a minimum and maximum value.
            Those are defined by the motion group manufacturer and can be found in its data sheet.
            If a mechanical joint limit is exceeded, the motion group stops immediately. The stop is triggered by the physical robot controller.
            This should be prevented by using proper soft joint limits.
      description: Holding static properties of the motion group.
    MotionGroupStateResponse:
      required:
        - state
      type: object
      properties:
        state:
          $ref: '#/components/schemas/MotionGroupState'
          description: |
            Current state of the motion group.
        tcp_pose:
          $ref: '#/components/schemas/TcpPose'
          description: |
            Current position of the TCP specified as `tcp` in the request.
            Attention: This TCP is not necessarily the same the one currently selected on the robot control panel.
            If you need the information for the currently selected TCP, use the state.tcp_pose in the response.
            If `tcp` is not specified in the request, this field will be omitted in the response.
            Position is in [mm].
            The position is relative to the response_coordinate_system specified in the request.
    RobotTcp:
      required:
        - id
        - position
      type: object
      properties:
        id:
          type: string
          description: Identifier of this tcp.
        readable_name:
          type: string
          description: A readable and changeable name for frontend visualization.
        position:
          $ref: '#/components/schemas/Vector3d'
        rotation:
          $ref: '#/components/schemas/RotationAngles'
    ListTcpsResponse:
      type: object
      properties:
        tcps:
          type: array
          items:
            $ref: '#/components/schemas/RobotTcp'
          description: Represents the tcp offset from the device flange (in other words the absolute transformation from flange to the tcp).
    JointJoggingRequest:
      required:
        - motion_group
        - joint_velocities
        - rotation_direction
        - position_velocity
        - rotation_velocity
      type: object
      properties:
        motion_group:
          type: string
          description: Identifier of the motion group.
        joint_velocities:
          type: array
          items:
            type: number
            format: double
          description: in [rad/s]
          example:
            - 0
            - 0
            - 0
            - 0
            - -0.1
            - 0.2
        tcp:
          format: string
          description: |
            The identifier of the tool center point (TCP) to be used for the jogging motion.
            If not specified, the TCP currently active on the robot controller will be used.
            At this TCP, it will be assured, that the allowed cartesian velocity limits are not exceeded.
        response_rate:
          type: integer
          format: uint32
          description: Update rate for the response message in ms. If not set 200ms are used.
        response_coordinate_system:
          type: string
          description: |
            Unique identifier addressing a coordinate system in which the responses should be converted.
            If not set, world coordinate system is used.
      description: A request to move the joints of a motion group.
    JoggingResponse:
      required:
        - motion_group
      type: object
      properties:
        motion_group:
          type: string
          description: Identifier of the motion group.
        state:
          $ref: '#/components/schemas/RobotControllerState'
        movement_state:
          enum:
            - MOVEMENT_STATE_UNKNOWN
            - MOVEMENT_STATE_ERROR
            - MOVEMENT_STATE_MOVING
            - MOVEMENT_STATE_STOP_BY_REQUEST
            - MOVEMENT_STATE_JOINT_LIMIT_REACHED
            - MOVEMENT_STATE_STOP_FOR_IO
            - MOVEMENT_STATE_STOP_FOR_FORCE_LIMIT
          type: string
          description: State of the current movement, e.g. ongoing or stopped due to a particular reason.
          format: enum
      description: A response for a Jogging Request, is streamed during an active Jogging Movement.
    DirectionJoggingRequest:
      required:
        - motion_group
        - position_direction
        - rotation_direction
        - position_velocity
        - rotation_velocity
      type: object
      properties:
        motion_group:
          type: string
          description: Identifier of the motion group.
        position_direction:
          $ref: '#/components/schemas/Vector3d'
        rotation_direction:
          $ref: '#/components/schemas/Vector3d'
        coordinate_system:
          type: string
          description: |
            Unique identifier addressing the base coordinate system of position_direction and rotation_direction.
            If not set, world coordinate system is used.
            Set coordinate_system to "tool" to select the current tool coordinate system as base.
        position_velocity:
          type: number
          description: in (mm/s)
          format: double
        rotation_velocity:
          type: number
          description: in (rad/s)
          format: double
        tcp:
          format: string
          description: |
            The identifier of the tool center point (TCP) used for the jogging motion.
            If not specified, the TCP currently active on the robot controller will be used.
            The maximum cartesian velocity limit set at the TCP will not be exceeded during movement.
        response_rate:
          type: integer
          format: uint32
          description: Update rate for the response message in ms. If not set 200ms are used.
        response_coordinate_system:
          type: string
          description: |
            Unique identifier addressing a coordinate system in which the responses should be converted.
            If not set, world coordinate system is used.
      description: A request to move a motion group in a cartesian direction.
    MotionIdsListResponse:
      type: object
      properties:
        motions:
          type: array
          items:
            type: string
          description: '-| Identifiers of all motions which are currently cached. Use [planMotion](planMotion) to add a new motion. Motions are deleted if corresponding motion group or controller is disconnected.'
    LimitsOverride:
      type: object
      properties:
        joint_velocity_limits:
          $ref: '#/components/schemas/Joints'
          description: |
            Maximum joint velocity in [rad/s] for each joint.
            Either leave this field empty or set a value for each joint.
        joint_acceleration_limits:
          $ref: '#/components/schemas/Joints'
          description: |
            Maximum joint acceleration in [rad/s^2] for each joint.
            Either leave this field empty or set a value for each joint.
        tcp_velocity_limit:
          type: number
          format: double
          description: |
            Maximum allowed TCP velocity in [mm/s].
        tcp_acceleration_limit:
          type: number
          format: double
          description: |
            Maximum allowed TCP acceleration in [mm/s^2].
        tcp_orientation_velocity_limit:
          type: number
          format: double
          description: |
            Maximum allowed TCP rotation velocity in [rad/s].
        tcp_orientation_acceleration_limit:
          type: number
          format: double
          description: |
            Maximum allowed TCP rotation acceleration in [rad/s^2].
      description: If a limit is not set, the default value will be used.
    CommandSettings:
      type: object
      properties:
        auto_blending:
          type: integer
          format: uint32
          description: |-
            Auto-blending is used to keep a constant velocity when blending between two motion commands.
            It changes the TCP path around the target point of a motion command.
            The value represents the percentage of the original velocity.

            What is blending?
            Blending alters the geometry of the TCP path at the target point of a motion command
            to ensure that the velocity does not drop to zero between two motion commands.
        position_blending:
          type: number
          format: double
          description: |-
            If auto-blending blends too much of the resulting trajectory, position-blending could be used between two motion commands.
            Specifies the maximum radius in [mm] around the motion command's target point
            where the geometry of the TCP path is allowed to be changed to blend the current motion command into the next one.
        limits_override:
          $ref: '#/components/schemas/LimitsOverride'
      description: Settings which can be used to modify the behavior in a command-wise manner.
    Circle:
      required:
        - via_pose
        - target_pose
      type: object
      properties:
        via_pose:
          $ref: '#/components/schemas/Pose'
        target_pose:
          $ref: '#/components/schemas/Pose'
    CubicSpline_CubicSplineParameter:
      required:
        - pose
        - path_parameter
      type: object
      properties:
        pose:
          $ref: '#/components/schemas/Pose'
        path_parameter:
          type: number
          format: double
    CubicSpline:
      required:
        - parameters
      type: object
      properties:
        parameters:
          type: array
          items:
            $ref: '#/components/schemas/CubicSpline_CubicSplineParameter'
    Command:
      required:
        - command
      type: object
      properties:
        settings:
          $ref: '#/components/schemas/CommandSettings'
          description: Command settings for a single motion command. Allow blending between two motion commands or override limits on a motion command level.
        line:
          $ref: '#/components/schemas/Pose'
          description: A line is representing a straight line from start position to provided target position. The orientation is calculated via a quaternion [slerp](https://en.wikipedia.org/wiki/Slerp) from start orienation to provided target orientation.
        circle:
          $ref: '#/components/schemas/Circle'
          description: A circular constructs a circle in translative space from start position, provided via position, and provided target position. The orientation is calculated via a [bezier spline](https://en.wikipedia.org/wiki/B%C3%A9zier_curve) from start orienation to provided target orientation. The via point defines the control point for the bezier spline. Therefore, the control point will not be hit directly.
        joint_ptp:
          $ref: '#/components/schemas/Joints'
          description: A joint point-to-point is representing a line in joint space. All joints will be moved synchronously.
        cartesian_ptp:
          $ref: '#/components/schemas/Pose'
          description: A cartesian point-to-point is representing a joint point-to-point motion from start point to provided target pose. This is a joint point-to-point as well, but the target is given in cartesian space. The target joint configuration will be calculated to be in the same kinematic configuration as the start point is. If that is not possible, planning will fail.
        cubic_spline:
          $ref: '#/components/schemas/CubicSpline'
          description: A [cubic spline](https://de.wikipedia.org/wiki/Spline-Interpolation) is representing a cartesian cubic spline in translative and orientational space from start point to provided target pose via control points.
      description: A command is a single motion command (line, circle, joint_ptp, cartesian_ptp, cubic_spline) with corresponding settings (limits, blending). The motion commands are a flattened union/oneof type. Only set one of the motion commands per command. A motion command always starts at the end of the previous motion command. Subsequently, a plan request must have start joint configuration to plan a well defined motion.
    PlanRequest:
      required:
        - motion_group
        - start_joint_position
        - commands
      type: object
      properties:
        motion_group:
          type: string
          description: Identifier of the motion group.
        start_joint_position:
          $ref: '#/components/schemas/Joints'
          description: '-| To define a motion the start joints have to be indicated. Cartesian movements will be in the same kinematic configuration as the start joint position until the first joint point to point motion. Motions can only be executed, if the start joint position is the current joint position of the motion group. To retrieve the current joint position use the endpoint [getCurrentMotionGroupState](getCurrentMotionGroupState). To move the robot to the start joint position, use the endpoint [streamMoveToTrajectoryViaJointP2P](streamMoveToTrajectoryViaJointP2P).'
        commands:
          type: array
          items:
            $ref: '#/components/schemas/Command'
          description: List of motion commands. A command consists of a motion command (line, circle, joint_ptp, cartesian_ptp, cubic_spline) and corresponding settings (blending, limits override).
        tcp:
          type: string
          description: Tool identifier. If not set the current tool is used.
        payload:
          type: string
          description: Payload identifier. If unset the currently set payload is used.
    PlanSuccessfulResponse:
      type: object
      properties:
        motion:
          type: string
          description: Unique identifier of the motion. Use as reference to execute the motion or to retrieve information on the motion.
        end_joint_position:
          $ref: '#/components/schemas/Joints'
          description: The final joint position. Use this position as a start joint position to concatenate motions.
      description: The motion can be executed entirely.
    JointLimitExceeded:
      type: object
      properties:
        joint_index:
          type: integer
          format: uint32
        joint_position:
          $ref: '#/components/schemas/Joints'
      description: |-
        This error is returned when a joint position limit is exceeded.
        The joint index denotes which joint is out of its limits, starting with 1 and the full joint position is returned.
    Singularity:
      type: object
      properties:
        singularity_type:
          enum:
            - SINGULARITY_TYPE_UNKNOWN
            - SINGULARITY_TYPE_WRIST
            - SINGULARITY_TYPE_ELBOW
            - SINGULARITY_TYPE_SHOULDER
          type: string
          format: enum
        singular_joint_position:
          $ref: '#/components/schemas/Joints'
      description: |-
        A Singularity is a point in the robot's workspace where the robot loses one or more degrees of freedom with regards to moving its TCP.
        This means the robot cannot move or rotate the TCP in a certain direction from this specific point.

        The singularity type is the type of singularity that the robot is in.
        The singular joint position is the joint position of the robot when it is in a singularity.
    SafetyZoneViolation:
      type: object
      properties:
        description:
          type: string
      description: |-
        Safety zone violations occur when a motion is planned within a safety zone set on the controller.
        The message description indicates which part of the motion group collides with which safety zone.
    OutOfWorkspace:
      type: object
      properties:
        invalid_tcp_pose:
          $ref: '#/components/schemas/Pose'
      description: Requested TCP pose is outside of motion group's workspace.
    PlanFailedOnTrajectoryResponse:
      type: object
      properties:
        motion:
          type: string
          description: Identifier of the motion until the error.
        description:
          type: string
        last_valid_joint_position:
          $ref: '#/components/schemas/Joints'
        last_valid_tcp_pose:
          $ref: '#/components/schemas/Pose'
        error_location_on_trajectory:
          type: number
          description: Location on the trajectory where the error occurred. The location is defined as a floating point range from 0 to n, where 0 is the start of the trajectory and n is the end of the trajectory. n is the number commands. The decimal places represent the percentage of the defective command.
          format: double
        joint_limit_exceeded:
          $ref: '#/components/schemas/JointLimitExceeded'
        singularity:
          $ref: '#/components/schemas/Singularity'
        safety_zone_violation:
          $ref: '#/components/schemas/SafetyZoneViolation'
        out_of_workspace:
          $ref: '#/components/schemas/OutOfWorkspace'
      description: The planning failed. The motion can be executed until the defected command part starts.
    StartJointsMissing:
      type: object
      properties: {}
      description: |-
        Error in case no start joint position was provided.
        Every motion needs to start with a joint position as reference to uniquely define the kinematic configuration of the motion-group at the start the motion.
    CommandsMissing:
      type: object
      properties: {}
      description: Error in case no motion commands were provided. Every planning needs to have at least one motion command to describe the path to be followed.
    PlanFailedResponse:
      type: object
      properties:
        description:
          type: string
        start_joints_missing:
          $ref: '#/components/schemas/StartJointsMissing'
        commands_missing:
          $ref: '#/components/schemas/CommandsMissing'
        joint_limit_exceeded:
          $ref: '#/components/schemas/JointLimitExceeded'
        singularity:
          $ref: '#/components/schemas/Singularity'
        safety_zone_violation:
          $ref: '#/components/schemas/SafetyZoneViolation'
        out_of_workspace:
          $ref: '#/components/schemas/OutOfWorkspace'
      description: Starting point of motion is invalid. Therefore, planning a motion is not possible.
    PlanResponse:
      type: object
      properties:
        plan_successful_response:
          $ref: '#/components/schemas/PlanSuccessfulResponse'
        plan_failed_on_trajectory_response:
          $ref: '#/components/schemas/PlanFailedOnTrajectoryResponse'
        plan_failed_response:
          $ref: '#/components/schemas/PlanFailedResponse'
      description: '-| The plan response signals if the planned motion is executable, partially executable or not executable. If the motion is executable or partially executable, the response contains an unique identifier for the motion and the end joint position. To execute the motion use the unique identifier for calling move endpoints [streamMoveForward](streamMoveForward) or [streamMoveBackward](streamMoveBackward). Use the unique identifier within the endpoints [getMotionTrajectory](getMotionTrajectory) and [getMotionTrajectorySample](getMotionTrajectorySample) to retrieve information about the motion. Use the end joint position to plan and concatenate the next motion. If an error occurred, the response contains feedback including the reason for failure and the location where the failure occurred.'
    MoveRequest:
      required:
        - playback_speed_in_percent
      type: object
      properties:
        playback_speed_in_percent:
          type: integer
          format: uint32
          description: |-
            Set the velocity for executed movements of the motion in percent. A percentage of 100% means that the robot moves as
            fast as possible without violating the limits. Setting this value does not affect the overall shape of the velocity profile.
            Everything is slowed down by the same factor. Therefore, this should only be used for teaching and trajectory
            evaluation purposes. If the process requires a certain velocity, the respective limits should be set when planning the motion.
            This will not change the velocity override of the controller. The controller velocity override value shall be 100% to ensure
            controllability of the motion group.
        response_rate:
          type: integer
          format: uint32
          description: |-
            Update rate for the response message in milliseconds (ms). Default is 200 ms.
            We recommend to use the step rate of the controller or a multiple of the step rate as Nova updates the state in the controller's step rate as well.
            Minimal response rate is the step rate of controller.
        response_coordinate_system:
          type: string
          description: |
            Unique identifier addressing a coordinate system to which the cartesian data of the responses should be converted.
            Default is the world coordinate system.
      description: A request to move the joints of a motion group.
    MoveResponse:
      type: object
      properties:
        time_to_end:
          type: integer
          description: Remaining time in milliseconds (ms) to reach the end of the motion.
          format: uint32
        current_location_on_trajectory:
          type: number
          description: Refers to the current location of motion group on the trajectory.
          format: double
    StopResponse:
      required:
        - stop_code
        - location_on_trajectory
      type: object
      properties:
        stop_code:
          enum:
            - STOP_CODE_UNKNOWN
            - STOP_CODE_USER_REQUEST
            - STOP_CODE_PATH_END
            - STOP_CODE_JOINT_LIMIT_REACHED
            - STOP_CODE_IO
            - STOP_CODE_FORCE_LIMIT
            - STOP_CODE_ERROR
          type: string
          format: enum
        message:
          type: string
          description: Will provide detailed information about the reason for stopping.
        location_on_trajectory:
          type: number
          format: double
      description: The response will be sent once at the end of every motion signalling that the motion group has stopped moving.
    StreamMoveResponse:
      required:
        - response
      type: object
      properties:
        move_response:
          $ref: '#/components/schemas/MoveResponse'
          description: This field is filled during the movement.
        stop_response:
          $ref: '#/components/schemas/StopResponse'
          description: This field is filled when the movement is finished. It is the final response
        state:
          $ref: '#/components/schemas/RobotControllerState'
          description: The current state of the robot controller and motion group in motion.
      description: |-
        The stream will return MoveResponse repeatedly as long as defined in `response_rate` until the movement is
        completed. Finally, a single StopResponse is returned and the stream is closed.
    ExecuteToTrajectoryRequest:
      required:
        - location_on_trajectory
      type: object
      properties:
        location_on_trajectory:
          type: number
          format: double
          description: |-
            Gets the target location the robot should move to via joint point-to-point (moveJ).
            The location is a scalar value that defines a position along a path, typically ranging from 0 to `n`,
            where `n` denotes the number of motion commands. Each integer value of the location corresponds to a specific motion command,
            while non-integer values interpolate positions within the segments.
            The location is calculated from the joint path.
        limit_override:
          $ref: '#/components/schemas/LimitsOverride'
          description: The limits for the p2p motion to a previously planned motion.
        responses_coordinate_system:
          type: string
          description: |
            Unique identifier of a coordinate system to which the responses should be converted to. Default is the world coordinate system.
            Default coordinate system is world.
      description: A request to move to one location on a previously planned motion via a p2p motion.
    TrajectorySample:
      type: object
      properties:
        tcp_pose:
          $ref: '#/components/schemas/Pose'
        tcp_velocity:
          type: number
          description: '[mm/s]'
          format: double
        tcp_acceleration:
          type: number
          description: '[mm/s^2]'
          format: double
        tcp_orientation_velocity:
          type: number
          description: '[rad/s]'
          format: double
        tcp_orientation_acceleration:
          type: number
          description: '[rad/s^2]'
          format: double
        joint_position:
          $ref: '#/components/schemas/Joints'
        joint_velocity:
          $ref: '#/components/schemas/Joints'
        joint_acceleration:
          $ref: '#/components/schemas/Joints'
        joint_torques:
          $ref: '#/components/schemas/Joints'
        time:
          type: number
          description: '[s]'
          format: double
        location_on_trajectory:
          type: number
          description: location on trajectory
          format: double
      description: A sample of a trajectory is a single point of the trajectory at a specific location.
    GetTrajectoryResponse:
      type: object
      properties:
        trajectory:
          type: array
          items:
            $ref: '#/components/schemas/TrajectorySample'
          description: A list of points representing the trajectory of a planned motion with defined `sample_time` in milliseconds (ms).
    GetTrajectorySampleResponse:
      type: object
      properties:
        sample:
          $ref: '#/components/schemas/TrajectorySample'
    ProgramRunState:
      type: string
      enum:
        - not started
        - running
        - completed
        - failed
        - stopped
      title: ProgramRunState
    ProgramRunnerReference:
      properties:
        id:
          type: string
          title: Id
        state:
          $ref: '#/components/schemas/ProgramRunState'
      type: object
      required:
        - id
        - state
      title: ProgramerRunnerReference
    pyjectory__datatypes__serializer__Pose:
      properties:
        pose:
          prefixItems:
            - type: number
            - type: number
            - type: number
            - type: number
            - type: number
            - type: number
          type: array
          maxItems: 6
          minItems: 6
          title: Pose
      type: object
      required:
        - pose
      title: Pose
      description: |-
        Object's position and orientaton, defined in [x, y, z, rx, ry, rz].
        x,y,z are defined in millimeters.
        rx,ry,rz are defined in radians.
    pyjectory__datatypes__serializer__Position:
      properties:
        position:
          prefixItems:
            - type: number
            - type: number
            - type: number
          type: array
          maxItems: 3
          minItems: 3
          title: Position
      type: object
      required:
        - position
      title: Position
      description: Single point, defined in [x, y, z] with floating numbers. Must be defined.
    pyjectory__datatypes__serializer__Orientation:
      properties:
        orientation:
          prefixItems:
            - type: number
            - type: number
            - type: number
          type: array
          maxItems: 3
          minItems: 3
          title: Orientation
      type: object
      required:
        - orientation
      title: Orientation
      description: |-
        Rotation vector, defined in [rx, ry, rz] with floating numbers.
        The rotation is represented in vector3 using an axis-angle representation: axis.normalized * angle (angle in radians).
        Must be defined for the first pose of a path. If not defined for the rest of the path,
        the previous orientation will be used.
    Capture:
      properties:
        image:
          type: string
          title: Image
      type: object
      required:
        - image
      title: Capture
    PointCloud:
      properties:
        pointcloud:
          type: string
          title: Pointcloud
      type: object
      required:
        - pointcloud
      title: PointCloud
    Array-Input:
      properties:
        array:
          items:
            anyOf:
              - type: number
              - type: integer
              - type: string
              - type: string
                format: binary
              - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Pose'
              - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Position'
              - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Orientation'
              - $ref: '#/components/schemas/Capture'
              - $ref: '#/components/schemas/PointCloud'
              - $ref: '#/components/schemas/Array-Input'
          type: array
          title: Array
      type: object
      required:
        - array
      title: Array
    CodeWithArguments:
      properties:
        code:
          type: string
          title: Code
          description: Wandelscript code string which describes a Wandelscript Program as content/json.
        initial_state:
          anyOf:
            - additionalProperties:
                anyOf:
                  - type: number
                  - type: integer
                  - type: string
                  - type: string
                    format: binary
                  - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Pose'
                  - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Position'
                  - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Orientation'
                  - $ref: '#/components/schemas/Capture'
                  - $ref: '#/components/schemas/PointCloud'
                  - $ref: '#/components/schemas/Array-Input'
              type: object
            - type: 'null'
          title: Initial State
          description: Initial arguments that are available within the Wandelscript program.
          default: {}
      type: object
      required:
        - code
      title: CodeWithArguments
    ValidationError:
      properties:
        loc:
          items:
            anyOf:
              - type: string
              - type: integer
          type: array
          title: Location
        msg:
          type: string
          title: Message
        type:
          type: string
          title: Error Type
      type: object
      required:
        - loc
        - msg
        - type
      title: ValidationError
    HTTPValidationError:
      properties:
        detail:
          items:
            $ref: '#/components/schemas/ValidationError'
          type: array
          title: Detail
      type: object
      title: HTTPValidationError
    pyjectory__datatypes__core__Position:
      prefixItems:
        - type: number
          title: X
        - type: number
          title: 'Y'
        - type: number
          title: Z
      type: array
      maxItems: 3
      minItems: 3
      title: Position
    pyjectory__datatypes__core__Orientation:
      prefixItems:
        - type: number
          title: X
        - type: number
          title: 'Y'
        - type: number
          title: Z
      type: array
      maxItems: 3
      minItems: 3
    pyjectory__datatypes__core__Pose:
      properties:
        position:
          $ref: '#/components/schemas/pyjectory__datatypes__core__Position'
        orientation:
          $ref: '#/components/schemas/pyjectory__datatypes__core__Orientation'
      type: object
      required:
        - position
        - orientation
      title: Pose
      description: A pose (position and orientation)
    RobotState:
      properties:
        pose:
          $ref: '#/components/schemas/pyjectory__datatypes__core__Pose'
        joints:
          anyOf:
            - items:
                type: number
              type: array
            - type: 'null'
          title: Joints
      type: object
      required:
        - pose
      title: RobotState
      description: Collection of information on the current state of the robot
    Path:
      properties:
        poses:
          items:
            $ref: '#/components/schemas/RobotState'
          type: array
          title: Poses
          default: []
      type: object
      title: Path
    Array-Output:
      properties:
        array:
          items:
            anyOf:
              - type: number
              - type: integer
              - type: string
              - type: string
                format: binary
              - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Pose'
              - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Position'
              - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Orientation'
              - $ref: '#/components/schemas/Capture'
              - $ref: '#/components/schemas/PointCloud'
              - $ref: '#/components/schemas/Array-Output'
          type: array
          title: Array
      type: object
      required:
        - array
      title: Array
    ProgramRun:
      properties:
        id:
          type: string
          title: Id
        state:
          $ref: '#/components/schemas/ProgramRunState'
        path:
          allOf:
            - $ref: '#/components/schemas/Path'
          default:
            poses: []
        logs:
          type: string
          title: Logs
          default: ''
        store:
          additionalProperties:
            anyOf:
              - type: number
              - type: integer
              - type: string
              - type: string
                format: binary
              - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Pose'
              - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Position'
              - $ref: '#/components/schemas/pyjectory__datatypes__serializer__Orientation'
              - $ref: '#/components/schemas/Capture'
              - $ref: '#/components/schemas/PointCloud'
              - $ref: '#/components/schemas/Array-Output'
          type: object
          title: Store
          default: {}
        error:
          anyOf:
            - type: string
            - type: 'null'
          title: Error
        traceback:
          anyOf:
            - type: string
            - type: 'null'
          title: Traceback
        start_time:
          anyOf:
            - type: number
            - type: 'null'
          title: Start Time
        execution_time:
          anyOf:
            - type: number
            - type: 'null'
          title: Execution Time
        execution_duration:
          anyOf:
            - type: number
            - type: 'null'
          title: Execution Duration
      type: object
      required:
        - id
        - state
      title: ProgramRun
    pyriphery__robotics__robotcell__Timer__Configuration:
      properties:
        type:
          type: string
          enum:
            - timer
            - simulated_timer
          title: Type
          default: timer
        identifier:
          type: string
          title: Identifier
          default: timer
      type: object
      title: Timer
    pyriphery__etcd__ETCD__Configuration:
      properties:
        type:
          const: etcd
          title: Type
          default: etcd
        identifier:
          type: string
          title: Identifier
          default: database
        host:
          type: string
          title: Host
          default: etcd
        port:
          type: integer
          title: Port
          default: 2379
      type: object
      title: etcd client
      description: |-
        Configuration of the etcd client

        This configuration is necessary to add an etcd server as device to the cell.
        The etcd server itself is running in the cell by default.

        [etcd](https://etcd.io/) is a distributed, reliable key-value store that can be used
        to store values which can be
        addressed by Wandelscript in advanced Wandelscript programs.

        Args:
            identifier: the identifier name for etcd
            host: The host name.  Default is 'etcd'.
            port : The port defined in the etcd manifest file. The default is 2379.
    pyriphery__hardware__isaac__Isaac__Configuration:
      properties:
        type:
          const: isaac
          title: Type
          default: isaac
        identifier:
          type: string
          title: Identifier
          default: isaac
        host:
          type: string
          title: Host
          default: 0.0.0.0
        prim_paths:
          additionalProperties:
            type: string
          type: object
          title: Prim Paths
          default: {}
      type: object
      title: Omniservice Configuration
      description: The configuration of the Omniservice
    pyriphery__pyrae__robot__Robot__Configuration:
      properties:
        type:
          type: string
          enum:
            - robot
            - robot_planner
          title: Type
          default: robot
        identifier:
          type: string
          title: Identifier
          default: robot
        host:
          type: string
          title: Robot Host
          default: virtual-ur10e
        controller_model_name:
          type: string
          title: Model Name
          default: UniversalRobots::Controller
        motion_group_id:
          anyOf:
            - type: string
            - type: 'null'
          title: Motion Group Id
        rae_host:
          type: string
          title: Rae Host
          default: rae
        rae_port:
          type: integer
          title: Rae Port
          default: 50051
      type: object
      title: Configuration
      description: |-
        Configuration of a RAE Robot

        Args:
            model_name: Type of the robot that is initialized on the RAE
            host: Host of the real robot. A virtual robot is used when "localhost" is given
            motion_group_id: Motion group id of the robot
            rae_host: Host of the RAEe
            rae_port: Port of the RAE
    pyriphery__pyrae__controller__Controller__Configuration:
      properties:
        type:
          title: Type
          default: controller
        identifier:
          type: string
          title: Identifier
          default: controller
        host:
          type: string
          title: Robot Host
          default: virtual-ur10e
        controller_model_name:
          type: string
          title: Model Name
          default: UniversalRobots::Controller
        rae_host:
          type: string
          title: Rae Host
          default: rae
        rae_port:
          type: integer
          title: Rae Port
          default: 50051
      type: object
      title: Robot Controller Configuration
      description: |-
        Configuration of a Robot Controller.

        This will configure the robot controller such that it is controllable through Wandelscript.

        This is for advanced users only: it should not be necessary to change this configuration in most use cases.
    pyriphery__opcua__OPCUA__Configuration:
      properties:
        type:
          const: opc_ua
          title: Type
          default: opc_ua
        identifier:
          type: string
          title: Identifier
          default: opc_ua
        url:
          type: string
          title: Url
          default: opc.tcp://localhost:4840/wandelbots
      type: object
      title: OPCUAConnector
      description: |-
        Configuration of the OPCUAConnector

        Args:
            url: The URL of the OPC UA service
    pyriphery__robotics__simulation__SimulatedOPCUA__Configuration:
      properties:
        type:
          const: simulated_opcua
          title: Type
          default: simulated_opcua
        identifier:
          type: string
          title: Identifier
          default: opcua
      type: object
      title: Virtual OPCUA
    pyriphery__robotics__simulation__RobotWithViewOpen3d__Configuration:
      properties:
        type:
          const: simulated_robot_with_view
          title: Type
          default: simulated_robot_with_view
        identifier:
          type: string
          title: Identifier
          default: robot
        initial_pose:
          items:
            type: number
          type: array
          title: Initial Pose
      type: object
      title: Simulated Robot with View
      description: |-
        The configuration of a simulated robot

        Args:
            initial_pose: The start pose of the robot, None means it is unknown
    pyriphery__robotics__simulation__SimulatedIO__Configuration:
      properties:
        type:
          const: simulated_io
          title: Type
          default: simulated_io
        identifier:
          type: string
          title: Identifier
          default: io
      type: object
      title: Virtual I/Os
    Sphere-2:
      title: Sphere
      type: object
      properties:
        shape_type:
          type: string
          enum:
            - sphere
          default: sphere
        radius:
          type: number
          format: float
      required:
        - shape_type
        - radius
      description: Centered around origin.
    Box-2:
      title: Box
      type: object
      properties:
        shape_type:
          type: string
          enum:
            - box
          default: box
        size_x:
          type: number
          format: float
        size_y:
          type: number
          format: float
        size_z:
          type: number
          format: float
        type:
          type: string
          enum:
            - HOLLOW
            - FULL
          default: FULL
      required:
        - shape_type
        - size_x
        - size_y
        - size_z
        - type
      description: |
        Centered around origin.

        If margin is applied to full box, it is added to all sizes (shape still has edges).
        Hollow box is represented by thin boxes that make up its walls.
        If margin is applied to hollow box, its sizes are reduced by the margin.
    Rectangle-2:
      title: Rectangle
      type: object
      properties:
        shape_type:
          type: string
          enum:
            - rectangle
          default: rectangle
        size_x:
          type: number
          format: float
        size_y:
          type: number
          format: float
      required:
        - shape_type
        - size_x
        - size_y
      description: Centered in XY-plane.
    Plane-2:
      title: Plane
      type: object
      properties:
        shape_type:
          type: string
          enum:
            - plane
          default: plane
      required:
        - shape_type
      description: XY-plane.
    Cylinder-2:
      title: Cylinder
      type: object
      properties:
        shape_type:
          type: string
          enum:
            - cylinder
          default: cylinder
        radius:
          type: number
          format: float
        height:
          type: number
          format: float
      required:
        - shape_type
        - radius
        - height
      description: |
        Centered around origin, symmetric around z-axis.

        If margin is applied, it is added to radius and height (shape still has edges).
    Capsule-2:
      title: Capsule
      type: object
      properties:
        shape_type:
          type: string
          enum:
            - capsule
          default: capsule
        radius:
          type: number
          format: float
        cylinder_height:
          type: number
          format: float
      required:
        - shape_type
        - radius
        - cylinder_height
      description: Centered around origin, symmetric around z-axis.
    RectangularCapsule-2:
      title: Rectangular Capsule
      type: object
      properties:
        shape_type:
          type: string
          enum:
            - rectangular_capsule
          default: rectangular_capsule
        radius:
          type: number
          format: float
        sphere_center_distance_x:
          type: number
          format: float
        sphere_center_distance_y:
          type: number
          format: float
      required:
        - shape_type
        - radius
        - sphere_center_distance_x
        - sphere_center_distance_y
      description: |
        Convex hull around four spheres. Sphere center points in XY-plane, offset by either combination "+/- sizeX" or "+/- sizeY".

        Alternative description: Rectangle in x-y-plane with a 3D padding.
    ConvexHull-2:
      title: Convex Hull
      type: object
      properties:
        shape_type:
          type: string
          enum:
            - convex_hull
          default: convex_hull
        vertices:
          type: array
          items:
            $ref: '#/components/schemas/pyjectory__datatypes__core__Position'
      required:
        - shape_type
        - vertices
      description: Convex hull around all vertices.
    Collider-Output:
      title: Collider
      description: |
        Defines a collider with a single shape.

        Pose describes where the shape of the collider is positioned.
      type: object
      properties:
        shape:
          oneOf:
            - $ref: '#/components/schemas/Sphere-2'
            - $ref: '#/components/schemas/Box-2'
            - $ref: '#/components/schemas/Rectangle-2'
            - $ref: '#/components/schemas/Plane-2'
            - $ref: '#/components/schemas/Cylinder-2'
            - $ref: '#/components/schemas/Capsule-2'
            - $ref: '#/components/schemas/RectangularCapsule-2'
            - $ref: '#/components/schemas/ConvexHull-2'
        pose:
          $ref: '#/components/schemas/pyjectory__datatypes__core__Pose'
        margin:
          type: number
          description: Increases the shape's size in all dimensions. Applied in [mm]. Can be used to keep a safe distance to the shape.
          format: float
          default: 0
      required:
        - shape
        - pose
    CollisionRobotConfiguration-Output:
      title: Collision Robot Configuration
      type: object
      description: |
        Configuration of a robot in the collision scene.

        Default link shapes are provided for all supported robots. Apply `use_default_link_shapes` with `true`.

        `link_attachements` are additional shapes that are attached to the link reference frames.
        The reference frame of the `link_attachements` is obtained after applying all sets of DH-parameters
        from base to (including) the specified index.
        Adjacent links in the kinematic chain of the robot are not checked for collision.

        The tool is treated like another link attached to the end (flange) of the chain.
        All tool shapes are described in the flange frame.
      properties:
        use_default_link_shapes:
          type: boolean
          description: If `true`, default shapes are used for all links.
          default: true
        link_attachements:
          type: object
          description: |
            Shapes to attach to link reference frames, additionally to default shapes. The keys are integers representing
            the link indices, and the values are objects mapping shape names to their collider definitions.
          additionalProperties:
            type: object
            additionalProperties:
              $ref: '#/components/schemas/Collider-Output'
        tool:
          type: object
          description: Shapes that make up the tool, attached to the flange frame.
          additionalProperties:
            $ref: '#/components/schemas/Collider-Output'
      required:
        - use_default_link_shapes
    pyriphery__robotics__configurable_collision_scene__ConfigurableCollisionScene__Configuration-Output:
      title: 'EXPERIMENTAL: Configurable Collision Scene'
      type: object
      properties:
        type:
          const: collision_scene
          title: Type
          default: collision_scene
          description: |
            This device is experimental and might experience functional changes in the future.

            The configuration of the collision scene. This configuration is used to create a collision scene for planning
            at the start of a program execution. The scene can then be modified by the program.

            Note that in a cell with multiple robots only sequential robot motions are correctly checked for
            collisions. Use simultaneous motions of multiple robots at your own risk.
        identifier:
          type: string
          description: A unique identifier for the collision scene.
          default: scene
        static_colliders:
          type: object
          description: A collection of static colliders within the scene, identified by their names.
          additionalProperties:
            $ref: '#/components/schemas/Collider-Output'
        robot_configurations:
          type: object
          description: |
            Configurations for robots within the scene. Allow for the specification of collision geometries and
            other robot-specific settings, identified by robot names.
          additionalProperties:
            $ref: '#/components/schemas/CollisionRobotConfiguration-Output'
    Collider-Input:
      title: Collider
      description: |
        Defines a collider with a single shape.

        Pose describes where the shape of the collider is positioned.
      type: object
      properties:
        shape:
          oneOf:
            - $ref: '#/components/schemas/Sphere-2'
            - $ref: '#/components/schemas/Box-2'
            - $ref: '#/components/schemas/Rectangle-2'
            - $ref: '#/components/schemas/Plane-2'
            - $ref: '#/components/schemas/Cylinder-2'
            - $ref: '#/components/schemas/Capsule-2'
            - $ref: '#/components/schemas/RectangularCapsule-2'
            - $ref: '#/components/schemas/ConvexHull-2'
        pose:
          $ref: '#/components/schemas/pyjectory__datatypes__core__Pose'
        margin:
          type: number
          description: Increases the shape's size in all dimensions. Applied in [mm]. Can be used to keep a safe distance to the shape.
          format: float
          default: 0
      required:
        - shape
        - pose
    CollisionRobotConfiguration-Input:
      title: Collision Robot Configuration
      type: object
      description: |
        Configuration of a robot in the collision scene.

        Default link shapes are provided for all supported robots. Apply `use_default_link_shapes` with `true`.

        `link_attachements` are additional shapes that are attached to the link reference frames.
        The reference frame of the `link_attachements` is obtained after applying all sets of DH-parameters
        from base to (including) the specified index.
        Adjacent links in the kinematic chain of the robot are not checked for collision.

        The tool is treated like another link attached to the end (flange) of the chain.
        All tool shapes are described in the flange frame.
      properties:
        use_default_link_shapes:
          type: boolean
          description: If `true`, default shapes are used for all links.
          default: true
        link_attachements:
          type: object
          description: |
            Shapes to attach to link reference frames, additionally to default shapes. The keys are integers representing
            the link indices, and the values are objects mapping shape names to their collider definitions.
          additionalProperties:
            type: object
            additionalProperties:
              $ref: '#/components/schemas/Collider-Input'
        tool:
          type: object
          description: Shapes that make up the tool, attached to the flange frame.
          additionalProperties:
            $ref: '#/components/schemas/Collider-Input'
      required:
        - use_default_link_shapes
    pyriphery__robotics__configurable_collision_scene__ConfigurableCollisionScene__Configuration-Input:
      title: 'EXPERIMENTAL: Configurable Collision Scene'
      type: object
      properties:
        type:
          const: collision_scene
          title: Type
          default: collision_scene
          description: |
            This device is experimental and might experience functional changes in the future.

            The configuration of the collision scene. This configuration is used to create a collision scene for planning
            at the start of a program execution. The scene can then be modified by the program.

            Note that in a cell with multiple robots only sequential robot motions are correctly checked for
            collisions. Use simultaneous motions of multiple robots at your own risk.
        identifier:
          type: string
          description: A unique identifier for the collision scene.
          default: scene
        static_colliders:
          type: object
          description: A collection of static colliders within the scene, identified by their names.
          additionalProperties:
            $ref: '#/components/schemas/Collider-Input'
        robot_configurations:
          type: object
          description: |
            Configurations for robots within the scene. Allow for the specification of collision geometries and
            other robot-specific settings, identified by robot names.
          additionalProperties:
            $ref: '#/components/schemas/CollisionRobotConfiguration-Input'
    MotionGroupInfo:
      required:
        - id
        - name
        - dof
      type: object
      properties:
        id:
          type: integer
          format: uint32
          description: |
            The unique identifier of the motion group. Use it to refer to the motion group in other calls.
        name:
          type: string
          description: |
            The name of the motion group for display purposes.
        dof:
          type: integer
          format: uint32
          description: |
            The number of joints aka degrees of freedom in the motion group.
    MotionGroupInfos:
      required:
        - motiongroups
      type: object
      properties:
        motiongroups:
          type: array
          items:
            $ref: '#/components/schemas/MotionGroupInfo'
    IO:
      required:
        - name
        - direction
        - value
      type: object
      example:
        name: giTC_ToolCode
        direction: ControllerIn
        integer: 0
      properties:
        name:
          type: string
        direction:
          enum:
            - ControllerIn
            - ControllerOut
          type: string
          format: enum
        bool:
          type: boolean
        integer:
          type: string
        double:
          type: number
          format: double
    IOs:
      required:
        - IOs
      type: object
      properties:
        IOs:
          type: array
          items:
            $ref: '#/components/schemas/IO'
          example:
            - name: giTC_ToolCode
              direction: ControllerIn
              integer: '0'
            - name: DeviceNet/d652/WBDO16
              direction: ControllerOut
              double: 3.14159265359
            - name: WB_STOP_PROGRAM
              direction: ControllerIn
              bool: false
    Empty:
      type: object
      properties: {}
    MotionGroupJoints:
      required:
        - positions
      type: object
      properties:
        positions:
          type: array
          items:
            type: number
            format: double
          description: |
            The joint positions of the motion group.
        velocities:
          type: array
          items:
            type: number
            format: double
          description: |
            The joint velocities of the motion group.
        accelerations:
          type: array
          items:
            type: number
            format: double
          description: |
            The joint accelerations of the motion group.
        torques:
          type: array
          items:
            type: number
            format: double
          description: |
            The joint torques of the motion group.
      description: |-
        Ensure to provide one value for each joint. See [getMotionGroups](getMotionGroups) for the number of joints.
        Everything but positions is optional.
    CoordinateSystems:
      required:
        - coordinate_systems
      type: object
      properties:
        coordinate_systems:
          type: array
          items:
            $ref: '#/components/schemas/CoordinateSystem'
    RobotTcps:
      required:
        - tcps
      type: object
      properties:
        tcps:
          type: array
          items:
            $ref: '#/components/schemas/RobotTcp'
          example:
            - id: BASE/schmalz_gripper
              readable_name: BASE/schmalz_gripper
              position:
                x: 0
                'y': 0
                z: 110
              rotation:
                angles:
                  - 1
                  - 0
                  - 0
                  - 0
                type: QUATERNION
            - id: WB_EGM/egm_tool
              readable_name: WB_EGM/egm_tool
              position:
                x: 400
                'y': 250
                z: 0
              rotation:
                angles:
                  - 1.57079632679
                  - 0
                  - 3.14159265359
                  - 0
                type: ROTATION_VECTOR
    Flag:
      required:
        - active
      type: object
      properties:
        active:
          type: boolean
    OpMode:
      required:
        - mode
      type: object
      description: |
        Controllers have two operating modes: AUTOMATIC and MANUAL.
        MANUAL mode is mainly used for teaching a robot application.
        To ensure safe operation the velocity of the robot is limited to 250 mm/s.
        Running the finished application is done in AUTOMATIC operating mode without the limited velocity of the MANUAL mode.
      properties:
        mode:
          enum:
            - OPERATION_MODE_MANUAL
            - OPERATION_MODE_AUTO
          type: string
          format: enum
    Behavior:
      enum:
        - BEHAVIOR_AUTOMATIC
        - BEHAVIOR_AUTOMATIC_NOT_COMPLY_WITH_CYCLETIME
        - BEHAVIOR_EXTERNAL_SOURCE
      description: |
        ## BEHAVIOR_AUTOMATIC
        This is the default behavior.
        The motion group instantly takes any commanded joint configuration as actual joint state.
        Configures the compliance of the virtual robot with the normal ControllerState cycle time. If set, the virtual robot will act like a physical one, e.g. with a cycle time of 8ms to respond to a new joint state command.
        ## BEHAVIOR_AUTOMATIC_NOT_COMPLY_WITH_CYCLETIME
        Configures the compliance of the virtual robot with the normal ControllerState cycle time. If set, the robot will respond as fast as possible, limited only by software execution speed. Because of that the execution of a movement requires less time than with BEHAVIOR_AUTOMATIC.
        ## BEHAVIOR_EXTERNAL_SOURCE
        The external client is the only source of actual joint state changes.
        This mode is used to enable third party software indicating the current joint state via [externalJointsStream](externalJointsStream).
      type: string
      format: enum
    MotionGroupBehaviorGetter:
      required:
        - behavior
      type: object
      properties:
        behavior:
          $ref: '#/components/schemas/Behavior'
    ExternalJointStreamDatapointValue:
      required:
        - positions
        - velocities
        - accelerations
        - torques
      type: object
      properties:
        positions:
          type: array
          items:
            type: number
            format: double
          description: The joint positions of the robot.
        velocities:
          type: array
          items:
            type: number
            format: double
          description: The joint velocities of the robot.
        accelerations:
          type: array
          items:
            type: number
            format: double
          description: The joint accelerations of the robot.
        torques:
          type: array
          items:
            type: number
            format: double
          description: The joint torques of the robot.
      description: The joint-values of the external joint stream datapoint.
    ExternalJointStreamDatapoint:
      required:
        - id
        - value
      type: object
      properties:
        id:
          type: integer
          format: uint32
          description: Unique identifier addressing a controller in the cell.
        value:
          $ref: '#/components/schemas/ExternalJointStreamDatapointValue'
      description: A datapoint inside external joint stream.
    ProgramMetadata:
      properties:
        id:
          type: string
          title: ID
          description: The unique identifier of the program.
        name:
          type: string
          title: Name
          description: The name of the program presented to the enduser.
        created_date:
          type: string
          title: Created date
          description: The date when the program was created.
        last_updated_date:
          type: string
          title: Last updated date
          description: The date when the program was last updated.
        is_hidden:
          type: boolean
          title: Is hidden to enduser
          description: |
            Whether the program is accessible for the enduser or only for the developer.
        image:
          type: string
          title: Image path
          description: The path to the image of the program
      type: object
      required:
        - id
        - name
        - created_date
        - last_updated_date
        - is_hidden
      title: ProgramMetadata
      description: The metadata of a program.
      examples:
        - id: 5517ecd8-728a-4958-9d86-65a5b38721b6
          name: Motiontracking
          created_date: '2024-05-15 19:23:41'
          last_updated_date: '2024-05-15 19:23:41'
          is_hidden: false
    ListProgramMetadataResponse:
      properties:
        programs:
          items:
            $ref: '#/components/schemas/ProgramMetadata'
          type: array
          title: Programs
      type: object
      required:
        - programs
      title: ListProgramMetadataResponse
      description: List of all the stored programs, represented by their metadata.
    HTTPExceptionResponse:
      properties:
        detail:
          type: string
          title: Error message
          description: A message describing the error.
      type: object
      required:
        - detail
      title: HTTPExceptionResponse
    UpdateProgramMetadataRequest:
      properties:
        name:
          type: string
          title: Name
        is_hidden:
          type: boolean
          title: Is Hidden
        image:
          type: string
          title: Image
      type: object
      title: UpdateProgramMetadataRequest
      description: |-
        This message is used to update the metadata of a program.
        Only the set fields get updated.
      examples:
        - name: Updated name
          is_hidden: true
          image: path/to/image
        - name: Just update the name
    Body_uploadProgramMetadataImage:
      properties:
        file:
          type: string
          format: binary
          title: File
      type: object
      required:
        - file
      title: Body_uploadProgramMetadataImage
    RecipeMetadata:
      properties:
        id:
          type: string
          title: ID
          description: The unique identifier of the recipe.
        name:
          type: string
          title: Name
        created_date:
          type: string
          title: Created Date
        last_updated_date:
          type: string
          title: Last Updated Date
        is_production:
          type: boolean
          title: Is Production
        program_id:
          type: string
          title: Program Id
        image:
          type: string
          title: Image
      type: object
      required:
        - name
        - created_date
        - last_updated_date
        - is_production
        - program_id
      title: RecipeMetadata
      description: The metadata of a recipe.
      examples:
        - id: 60eb9061-a5d8-4c17-9d42-174bec78da28
          name: Zigzag Log Cake
          created_date: '2024-05-15 19:23:41'
          last_updated_date: '2024-05-15 19:23:41'
          is_production: false
          program_id: motiontracking
    ListRecipeMetadataResponse:
      properties:
        recipes:
          items:
            $ref: '#/components/schemas/RecipeMetadata'
          type: array
          title: Recipes
      type: object
      required:
        - recipes
      title: ListRecipeMetadataResponse
      description: List of all the stored recipes, represented by their metadata.
    UpdateRecipeMetadataRequest:
      properties:
        name:
          type: string
          title: Name
        is_production:
          type: boolean
          title: Is Production
        program_id:
          type: string
          title: Program Id
      type: object
      title: UpdateRecipeMetadataRequest
      description: |-
        This message is used to update the metadata of a recipe.
        Only the set fields get updated.
      examples:
        - name: Updated name
          is_production: true
          program_id: different_program_id
        - name: Just update the name
    Body_uploadRecipeMetadataImage:
      properties:
        file:
          type: string
          format: binary
          title: File
      type: object
      required:
        - file
      title: Body_uploadRecipeMetadataImage
    Description:
      required:
        - uuid
        - version
        - supported_controllers
        - supported_motion_groups
      type: object
      properties:
        uuid:
          type: string
          description: |
            A unique (non persistent) identifier that identifies the service providing instance.
        installation:
          type: string
          description: Name of the installation, eg. 'Demonstrator', 'Cell12', .....
        version:
          $ref: '#/components/schemas/VersionNumber'
        supported_controllers:
          type: array
          items:
            type: string
          description: The list of supported robot controllers.
        supported_motion_groups:
          type: array
          items:
            type: string
          description: The list of supported motion groups.
      description: Describe the instance and the supported devices.
    ControllerRequest_LoginCredentials:
      required:
        - username
        - password
      type: object
      properties:
        username:
          type: string
        password:
          type: string
          description: |
            The password in plain text. NOTE: Prevent potential data leaks by limiting access to the password when Wandelbots Nova is used in open shop floor networks.
      description: |
        Credentials that will be used when interacting with the robot controller for
        installation of apps and programs.

        We know and use the common manufacturer defaults - so just set this up if your
        controller has something different configured.
    ControllerRequest:
      required:
        - model_name
        - host
      type: object
      properties:
        model_name:
          type: string
          description: |
            The requested robot controller model. Must be the correct controller_model
            string, use [getDescription](getDescription) to consult the complete list.
        host:
          type: string
          description: Resolvable host name or IP address that connects to the robot controller.
        allow_software_install_on_controller:
          type: boolean
          description: |
            Only set true if the user has actively confirmed that it is allowed
            to install required communication software onto the robot controller.
            It is expected that you ALWAYS request first without `software install`!

            Installing foreign software on a robot controller
            might create legal issues - regarding to the actual certified
            state of the robot system.
        controller_credentials:
          $ref: '#/components/schemas/ControllerRequest_LoginCredentials'
    Versions_Version:
      required:
        - name
        - string_version
      type: object
      properties:
        name:
          type: string
          description: The name of the Component.
        string_version:
          type: string
          description: The version of the Component.
    Versions:
      required:
        - versions
      type: object
      properties:
        versions:
          type: array
          items:
            $ref: '#/components/schemas/Versions_Version'
    NameList:
      description: A list of names
      type: array
      items:
        type: string
    DeveloperImage:
      type: object
      description: Override the default container image with a custom one.
      required:
        - tag
      properties:
        tag:
          type: string
        repository:
          type: string
    FoundationServiceRae:
      type: object
      description: The configuration overwrite for the RAE.
      properties:
        imageOverwrite:
          $ref: '#/components/schemas/DeveloperImage'
        realtimePort:
          type: integer
    FoundationServiceWandelengine:
      type: object
      description: The configuration overwrite for the Wandelengine.
      properties:
        imageOverwrite:
          $ref: '#/components/schemas/DeveloperImage'
        enableLanguageServer:
          description: Enable the Wandelscript language server shipped with the Wandelengine
          type: boolean
          default: false
    FoundationServiceApiGateway:
      type: object
      description: The configuration overwrite for the API gateway
      properties:
        imageOverwrite:
          $ref: '#/components/schemas/DeveloperImage'
    FoundationServiceProgramStore:
      type: object
      description: The configuration overwrite for the program store.
      properties:
        imageOverwrite:
          $ref: '#/components/schemas/DeveloperImage'
    FoundationServiceRobotPad:
      type: object
      description: The configuration overwrite for the RobotPad App.
      properties:
        imageOverwrite:
          $ref: '#/components/schemas/DeveloperImage'
    FoundationServices:
      type: object
      description: The configuration overwrite for all foundation services.
      properties:
        rae:
          $ref: '#/components/schemas/FoundationServiceRae'
        wandelengine:
          $ref: '#/components/schemas/FoundationServiceWandelengine'
        api-gateway:
          $ref: '#/components/schemas/FoundationServiceApiGateway'
        programstore:
          $ref: '#/components/schemas/FoundationServiceProgramStore'
        robot-pad:
          $ref: '#/components/schemas/FoundationServiceRobotPad'
    ControllerKind:
      type: string
      enum:
        - AbbController
        - FanucController
        - UniversalrobotsController
        - VirtualController
        - YaskawaController
    Controller:
      type: object
      required:
        - kind
      properties:
        kind:
          $ref: '#/components/schemas/ControllerKind'
    AbbController:
      title: Abb
      description: |
        The configuration of a physical ABB robot controller has to contain IP address.
        Additionally an EGM server configuration has to be specified in order to control the robot.
        Deploying the server is a functionality of this API.
      allOf:
        - $ref: '#/components/schemas/Controller'
        - type: object
          required:
            - controllerIp
            - egmServer
          properties:
            controllerIp:
              type: string
            egmServer:
              description: The EGM server runs inside of the cell, thus its IP must be in the same network as the 'controllerIp'
              type: object
              required:
                - ip
                - port
              properties:
                ip:
                  type: string
                port:
                  type: integer
                  default: 32112
            imageOverwrite:
              $ref: '#/components/schemas/DeveloperImage'
    FanucController:
      title: Fanuc
      description: The configuration of a physical FANUC robot controller has to contain IP address of the controller.
      allOf:
        - $ref: '#/components/schemas/Controller'
        - type: object
          required:
            - controllerIp
          properties:
            controllerIp:
              type: string
            imageOverwrite:
              $ref: '#/components/schemas/DeveloperImage'
    UniversalrobotsController:
      title: Universalrobots
      description: The configuration of a physical Universal Robots controller has to contain IP address of the controller.
      allOf:
        - $ref: '#/components/schemas/Controller'
        - type: object
          required:
            - controllerIp
          properties:
            controllerIp:
              type: string
    Manufacturer:
      type: string
      enum:
        - abb
        - fanuc
        - universalrobots
        - yaskawa
    VirtualControllerTypes:
      type: string
      enum:
        - abb-irb1200_7
        - fanuc-crx10ia
        - fanuc-crx25ia
        - fanuc-m10iD12
        - fanuc-m20iD25
        - fanuc-m20iD35
        - universalrobots-ur10e
        - universalrobots-ur3e
        - universalrobots-ur5e
        - universalrobots-ur5
        - yaskawa-ar1440
        - yaskawa-ar2010
        - yaskawa-gp7
    VirtualController:
      title: Virtual
      description: |
        The configuration of a virtual robot controller has to contain the manufacturer string,
        an optional joint position string array and either a type or the full JSON configuration.
        The JSON config of a physical controller can be obtained via `/cells/{cell}/controllers/{controller}/virtual-robot-configuration`
      allOf:
        - $ref: '#/components/schemas/Controller'
        - type: object
          required:
            - manufacturer
          properties:
            manufacturer:
              $ref: '#/components/schemas/Manufacturer'
            type:
              $ref: '#/components/schemas/VirtualControllerTypes'
            json:
              type: string
            position:
              type: string
            imageOverwrite:
              $ref: '#/components/schemas/DeveloperImage'
    YaskawaController:
      title: Yaskawa
      description: The configuration of a physical Yaskawa robot controller has to contain IP address of the controller.
      allOf:
        - $ref: '#/components/schemas/Controller'
        - type: object
          required:
            - controllerIp
          properties:
            controllerIp:
              type: string
    RobotController:
      type: object
      description: The configuration of a physical or virtual robot controller.
      required:
        - name
        - configuration
      properties:
        name:
          description: A unique name of the Controller inside the Cell.
          type: string
        configuration:
          oneOf:
            - $ref: '#/components/schemas/AbbController'
            - $ref: '#/components/schemas/FanucController'
            - $ref: '#/components/schemas/UniversalrobotsController'
            - $ref: '#/components/schemas/VirtualController'
            - $ref: '#/components/schemas/YaskawaController'
          discriminator:
            propertyName: kind
          x-go-type-name: ControllerConfig
    ImageCredentials:
      type: object
      description: |
        User provided credentials for creating a secret to pull an image from a registry.
      required:
        - registry
        - user
        - password
      properties:
        registry:
          type: string
        user:
          type: string
        password:
          type: string
    ContainerImage:
      type: object
      description: |
        A user provided, custom container image and the required credentials to pull it from a registry.
      required:
        - image
      properties:
        image:
          description: The location of a container image in the form of `<registry>/<image>:<tag>`.
          type: string
        credentials:
          $ref: '#/components/schemas/ImageCredentials'
        secrets:
          type: array
          description: Known secrets for authentication with the container registry.
          items:
            type: object
            required:
              - name
            properties:
              name:
                type: string
    ContainerEnvironment:
      type: array
      description: |
        A list of environment variables with name and their value.
        These can be used to configure the containerized application, and turn on or off features.
      items:
        type: object
        required:
          - name
          - value
        properties:
          name:
            type: string
          value:
            type: string
    App:
      type: object
      description: An App is defined by a webserver, packed inside a container, serving a web-application.
      required:
        - name
        - path
        - containerImage
      properties:
        name:
          description: |
            The name of the user provided application.
            The name must be unique within the cell and is used as a identifier for addressing the application in all API calls, e.g. when updating the application.
          type: string
        path:
          description: The url path the app is listening on.
          type: string
          default: /app
        containerImage:
          $ref: '#/components/schemas/ContainerImage'
        port:
          description: The port the containerized webserver is listening on.
          type: integer
          default: 8080
        environment:
          $ref: '#/components/schemas/ContainerEnvironment'
    Cell:
      type: object
      description: |
        To create a robot cell, only a valid name is required.
        Once created, a robot cell provides access to the Wandelbots Nova foundation services.
        The configuration can be customized, e.g. robot controllers, also within apps.
      required:
        - name
      properties:
        name:
          description: |
            A unique name for the cell used as a unique identifier for addressing the cell in all API calls.
            Since the cell identifier is used as Kubernetes namespace, the following rules apply:
            * Contain only lowercase alphanumeric characters or '-',
            * Start with an alphanumeric character,
            * End with an alphanumeric character,
            * A maximum length of 63 characters,
            * The identifiers "kube-system", "default", and "wandelbots" are reserved and cannot be used.
          type: string
          pattern: ^(?!kube-system$|default$|wandelbots$)[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$
          default: cell
        foundation-services:
          $ref: '#/components/schemas/FoundationServices'
        controllers:
          type: array
          items:
            $ref: '#/components/schemas/RobotController'
        apps:
          type: array
          items:
            $ref: '#/components/schemas/App'
    Error:
      type: object
      required:
        - code
        - message
      properties:
        code:
          type: string
        message:
          type: string
    UpdateRequest:
      type: object
      description: |
        An update is defined by the indicated Wandelbots Nova version.
        The version has to be a valid [semver](https://github.com/Masterminds/semver) string.
      required:
        - version
      properties:
        version:
          description: The indicated Wandelbots Nova version.
          type: string
  examples:
    Status_INVALID_ARGUMENT:
      value:
        code: 3
        message: Client specified an invalid argument. Check error message for more information.
    Status_FAILED_PRECONDITION:
      value:
        code: 9
        message: Request can not be executed with the robot controller. Check error message for more information.
    Status_PERMISSION_DENIED:
      value:
        code: 7
        message: Client does not have sufficient permission. Check error message for more information.
    Status_NOT_FOUND:
      value:
        code: 5
        message: A specified resource is not found. Use the available endpoints to verify that the desired resource has been created.
    Status_ABORTED:
      value:
        code: 10
        message: Concurrency conflict, such as read-modify-write conflict. Please try again later.
    Status_ALREADY_EXISTS:
      value:
        code: 6
        message: The resource that a client tried to create already exists.
    Status_RESOURCE_EXHAUSTED:
      value:
        code: 8
        message: Usually occurs when another movement is being executed, the I/O is being written or a mode change is taking place. Please try again later.
    Status_UNKNOWN:
      value:
        code: 2
        message: Unknown server error. Typically a server bug. Please open a support ticket and attach a diagnose package from [getDiagnosePackage](getDiagnosePackage).
    Status_INTERNAL:
      value:
        code: 13
        message: An internal error occurred. Please try again later. If this not work, please open a support ticket and attach a diagnose package from [getDiagnosePackage](getDiagnosePackage).
    Status_UNIMPLEMENTED:
      value:
        code: 12
        message: API method not implemented by the robot controller.
    DefaultCell:
      summary: A cell with the default configured Foundation Services
      value:
        name: cell
    CellWithFoundationSvc:
      summary: A cell with custom configured Foundation Services
      value:
        name: cell
        foundation-services:
          rae:
            realtimePort: 30651
            imageOverwrite:
              tag: 2.7.33
              repository: docker.io/wandelbotsgmbh/robotics-rae
          wandelengine:
            enableLanguageServer: false
            imageOverwrite:
              tag: 0.997.0-rc4
              repository: wandelbotsgmbh/wandelbrain-wandelengine
    CellForVirtualRobots:
      summary: A cell with configured realtimePort supporting only virtual Robots.
      value:
        name: cell
        foundation-services:
          rae:
            realtimePort: 0
    CellForPhysicalRobots:
      summary: A cell with configured realtimePort supporting physical and virtual Robots.
      value:
        name: cell
        foundation-services:
          rae:
            realtimePort: 30651
    FoundationServices:
      summary: Full Foundation Services configuration
      value:
        rae:
          realtimePort: 30651
          imageOverwrite:
            tag: 2.7.33
            repository: docker.io/wandelbotsgmbh/robotics-rae
        wandelengine:
          enableLanguageServer: true
          imageOverwrite:
            tag: 0.997.0-rc4
            repository: wandelbotsgmbh/wandelbrain-wandelengine
        api-gateway:
          imageOverwrite:
            tag: 0.35.2
            repository: docker.io/wandelbotsgmbh/api-gateway
    AbbController:
      value:
        name: abb-robot
        configuration:
          kind: AbbController
          controllerIp: 192.168.125.1
          egmServer:
            ip: 192.168.125.100
            port: 32112
    FanucController:
      value:
        name: fanuc-robot
        configuration:
          kind: FanucController
          controllerIp: 192.168.100.1
    UrController:
      value:
        name: ur-robot
        configuration:
          kind: UniversalrobotsController
          controllerIp: 192.168.1.1
    VirtualController:
      value:
        name: virtual-robot
        configuration:
          kind: VirtualController
          manufacturer: universalrobots
          type: universalrobots-ur5e
          position: '[0,0,0,0,0,0,0]'
    YaskawaController:
      value:
        name: yaskawa-robot
        configuration:
          kind: YaskawaController
          controllerIp: 192.168.255.1
    AppSwaggerUI:
      summary: SwaggerUI App example
      value:
        name: app-example
        containerImage:
          image: docker.io/swaggerapi/swagger-ui
        path: /swagger-ui
        environment:
          - name: BASE_URL
            value: /swagger-ui
    UpdateLatest:
      summary: Update to the latest Wandelbots Nova version.
      value:
        version: x.x.x
    UpdateSpecific:
      summary: Update to a specific Wandelbots Nova version.
      value:
        version: 24.1.4
  responses:
    DefaultErrorResponse:
      description: |
        Default error response. Please see the examples for possible error responses.
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Status'
          examples:
            INVALID_ARGUMENT:
              $ref: '#/components/examples/Status_INVALID_ARGUMENT'
            FAILED_PRECONDITION:
              $ref: '#/components/examples/Status_FAILED_PRECONDITION'
            PERMISSION_DENIED:
              $ref: '#/components/examples/Status_PERMISSION_DENIED'
            NOT_FOUND:
              $ref: '#/components/examples/Status_NOT_FOUND'
            ABORTED:
              $ref: '#/components/examples/Status_ABORTED'
            ALREADY_EXISTS:
              $ref: '#/components/examples/Status_ALREADY_EXISTS'
            RESOURCE_EXHAUSTED:
              $ref: '#/components/examples/Status_RESOURCE_EXHAUSTED'
            UNKNOWN:
              $ref: '#/components/examples/Status_UNKNOWN'
            INTERNAL:
              $ref: '#/components/examples/Status_INTERNAL'
            UNIMPLEMENTED:
              $ref: '#/components/examples/Status_UNIMPLEMENTED'
    NotFound:
      description: The specified resource was not found
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Error'
